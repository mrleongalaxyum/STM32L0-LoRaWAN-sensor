
STM32 LoRa node.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000d9a0  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001840  0800da60  0800da60  0001da60  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800f2a0  0800f2a0  00020058  2**0
                  CONTENTS
  4 .ARM          00000008  0800f2a0  0800f2a0  0001f2a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0800f2a8  0800f2a8  00020058  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800f2a8  0800f2a8  0001f2a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800f2ac  0800f2ac  0001f2ac  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000058  20000000  0800f2b0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000004c0  20000058  0800f308  00020058  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000518  0800f308  00020518  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00020058  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001f208  00000000  00000000  00020080  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000381e  00000000  00000000  0003f288  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001758  00000000  00000000  00042aa8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00001640  00000000  00000000  00044200  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0001755a  00000000  00000000  00045840  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0001aafb  00000000  00000000  0005cd9a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0008e1e9  00000000  00000000  00077895  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  00105a7e  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00005648  00000000  00000000  00105ad4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000058 	.word	0x20000058
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800da48 	.word	0x0800da48

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	2000005c 	.word	0x2000005c
 8000104:	0800da48 	.word	0x0800da48

08000108 <__udivsi3>:
 8000108:	2200      	movs	r2, #0
 800010a:	0843      	lsrs	r3, r0, #1
 800010c:	428b      	cmp	r3, r1
 800010e:	d374      	bcc.n	80001fa <__udivsi3+0xf2>
 8000110:	0903      	lsrs	r3, r0, #4
 8000112:	428b      	cmp	r3, r1
 8000114:	d35f      	bcc.n	80001d6 <__udivsi3+0xce>
 8000116:	0a03      	lsrs	r3, r0, #8
 8000118:	428b      	cmp	r3, r1
 800011a:	d344      	bcc.n	80001a6 <__udivsi3+0x9e>
 800011c:	0b03      	lsrs	r3, r0, #12
 800011e:	428b      	cmp	r3, r1
 8000120:	d328      	bcc.n	8000174 <__udivsi3+0x6c>
 8000122:	0c03      	lsrs	r3, r0, #16
 8000124:	428b      	cmp	r3, r1
 8000126:	d30d      	bcc.n	8000144 <__udivsi3+0x3c>
 8000128:	22ff      	movs	r2, #255	; 0xff
 800012a:	0209      	lsls	r1, r1, #8
 800012c:	ba12      	rev	r2, r2
 800012e:	0c03      	lsrs	r3, r0, #16
 8000130:	428b      	cmp	r3, r1
 8000132:	d302      	bcc.n	800013a <__udivsi3+0x32>
 8000134:	1212      	asrs	r2, r2, #8
 8000136:	0209      	lsls	r1, r1, #8
 8000138:	d065      	beq.n	8000206 <__udivsi3+0xfe>
 800013a:	0b03      	lsrs	r3, r0, #12
 800013c:	428b      	cmp	r3, r1
 800013e:	d319      	bcc.n	8000174 <__udivsi3+0x6c>
 8000140:	e000      	b.n	8000144 <__udivsi3+0x3c>
 8000142:	0a09      	lsrs	r1, r1, #8
 8000144:	0bc3      	lsrs	r3, r0, #15
 8000146:	428b      	cmp	r3, r1
 8000148:	d301      	bcc.n	800014e <__udivsi3+0x46>
 800014a:	03cb      	lsls	r3, r1, #15
 800014c:	1ac0      	subs	r0, r0, r3
 800014e:	4152      	adcs	r2, r2
 8000150:	0b83      	lsrs	r3, r0, #14
 8000152:	428b      	cmp	r3, r1
 8000154:	d301      	bcc.n	800015a <__udivsi3+0x52>
 8000156:	038b      	lsls	r3, r1, #14
 8000158:	1ac0      	subs	r0, r0, r3
 800015a:	4152      	adcs	r2, r2
 800015c:	0b43      	lsrs	r3, r0, #13
 800015e:	428b      	cmp	r3, r1
 8000160:	d301      	bcc.n	8000166 <__udivsi3+0x5e>
 8000162:	034b      	lsls	r3, r1, #13
 8000164:	1ac0      	subs	r0, r0, r3
 8000166:	4152      	adcs	r2, r2
 8000168:	0b03      	lsrs	r3, r0, #12
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x6a>
 800016e:	030b      	lsls	r3, r1, #12
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0ac3      	lsrs	r3, r0, #11
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x76>
 800017a:	02cb      	lsls	r3, r1, #11
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0a83      	lsrs	r3, r0, #10
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x82>
 8000186:	028b      	lsls	r3, r1, #10
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0a43      	lsrs	r3, r0, #9
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x8e>
 8000192:	024b      	lsls	r3, r1, #9
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0a03      	lsrs	r3, r0, #8
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x9a>
 800019e:	020b      	lsls	r3, r1, #8
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	d2cd      	bcs.n	8000142 <__udivsi3+0x3a>
 80001a6:	09c3      	lsrs	r3, r0, #7
 80001a8:	428b      	cmp	r3, r1
 80001aa:	d301      	bcc.n	80001b0 <__udivsi3+0xa8>
 80001ac:	01cb      	lsls	r3, r1, #7
 80001ae:	1ac0      	subs	r0, r0, r3
 80001b0:	4152      	adcs	r2, r2
 80001b2:	0983      	lsrs	r3, r0, #6
 80001b4:	428b      	cmp	r3, r1
 80001b6:	d301      	bcc.n	80001bc <__udivsi3+0xb4>
 80001b8:	018b      	lsls	r3, r1, #6
 80001ba:	1ac0      	subs	r0, r0, r3
 80001bc:	4152      	adcs	r2, r2
 80001be:	0943      	lsrs	r3, r0, #5
 80001c0:	428b      	cmp	r3, r1
 80001c2:	d301      	bcc.n	80001c8 <__udivsi3+0xc0>
 80001c4:	014b      	lsls	r3, r1, #5
 80001c6:	1ac0      	subs	r0, r0, r3
 80001c8:	4152      	adcs	r2, r2
 80001ca:	0903      	lsrs	r3, r0, #4
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xcc>
 80001d0:	010b      	lsls	r3, r1, #4
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	08c3      	lsrs	r3, r0, #3
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xd8>
 80001dc:	00cb      	lsls	r3, r1, #3
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0883      	lsrs	r3, r0, #2
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xe4>
 80001e8:	008b      	lsls	r3, r1, #2
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0843      	lsrs	r3, r0, #1
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xf0>
 80001f4:	004b      	lsls	r3, r1, #1
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	1a41      	subs	r1, r0, r1
 80001fc:	d200      	bcs.n	8000200 <__udivsi3+0xf8>
 80001fe:	4601      	mov	r1, r0
 8000200:	4152      	adcs	r2, r2
 8000202:	4610      	mov	r0, r2
 8000204:	4770      	bx	lr
 8000206:	e7ff      	b.n	8000208 <__udivsi3+0x100>
 8000208:	b501      	push	{r0, lr}
 800020a:	2000      	movs	r0, #0
 800020c:	f000 f8f0 	bl	80003f0 <__aeabi_idiv0>
 8000210:	bd02      	pop	{r1, pc}
 8000212:	46c0      	nop			; (mov r8, r8)

08000214 <__aeabi_uidivmod>:
 8000214:	2900      	cmp	r1, #0
 8000216:	d0f7      	beq.n	8000208 <__udivsi3+0x100>
 8000218:	e776      	b.n	8000108 <__udivsi3>
 800021a:	4770      	bx	lr

0800021c <__divsi3>:
 800021c:	4603      	mov	r3, r0
 800021e:	430b      	orrs	r3, r1
 8000220:	d47f      	bmi.n	8000322 <__divsi3+0x106>
 8000222:	2200      	movs	r2, #0
 8000224:	0843      	lsrs	r3, r0, #1
 8000226:	428b      	cmp	r3, r1
 8000228:	d374      	bcc.n	8000314 <__divsi3+0xf8>
 800022a:	0903      	lsrs	r3, r0, #4
 800022c:	428b      	cmp	r3, r1
 800022e:	d35f      	bcc.n	80002f0 <__divsi3+0xd4>
 8000230:	0a03      	lsrs	r3, r0, #8
 8000232:	428b      	cmp	r3, r1
 8000234:	d344      	bcc.n	80002c0 <__divsi3+0xa4>
 8000236:	0b03      	lsrs	r3, r0, #12
 8000238:	428b      	cmp	r3, r1
 800023a:	d328      	bcc.n	800028e <__divsi3+0x72>
 800023c:	0c03      	lsrs	r3, r0, #16
 800023e:	428b      	cmp	r3, r1
 8000240:	d30d      	bcc.n	800025e <__divsi3+0x42>
 8000242:	22ff      	movs	r2, #255	; 0xff
 8000244:	0209      	lsls	r1, r1, #8
 8000246:	ba12      	rev	r2, r2
 8000248:	0c03      	lsrs	r3, r0, #16
 800024a:	428b      	cmp	r3, r1
 800024c:	d302      	bcc.n	8000254 <__divsi3+0x38>
 800024e:	1212      	asrs	r2, r2, #8
 8000250:	0209      	lsls	r1, r1, #8
 8000252:	d065      	beq.n	8000320 <__divsi3+0x104>
 8000254:	0b03      	lsrs	r3, r0, #12
 8000256:	428b      	cmp	r3, r1
 8000258:	d319      	bcc.n	800028e <__divsi3+0x72>
 800025a:	e000      	b.n	800025e <__divsi3+0x42>
 800025c:	0a09      	lsrs	r1, r1, #8
 800025e:	0bc3      	lsrs	r3, r0, #15
 8000260:	428b      	cmp	r3, r1
 8000262:	d301      	bcc.n	8000268 <__divsi3+0x4c>
 8000264:	03cb      	lsls	r3, r1, #15
 8000266:	1ac0      	subs	r0, r0, r3
 8000268:	4152      	adcs	r2, r2
 800026a:	0b83      	lsrs	r3, r0, #14
 800026c:	428b      	cmp	r3, r1
 800026e:	d301      	bcc.n	8000274 <__divsi3+0x58>
 8000270:	038b      	lsls	r3, r1, #14
 8000272:	1ac0      	subs	r0, r0, r3
 8000274:	4152      	adcs	r2, r2
 8000276:	0b43      	lsrs	r3, r0, #13
 8000278:	428b      	cmp	r3, r1
 800027a:	d301      	bcc.n	8000280 <__divsi3+0x64>
 800027c:	034b      	lsls	r3, r1, #13
 800027e:	1ac0      	subs	r0, r0, r3
 8000280:	4152      	adcs	r2, r2
 8000282:	0b03      	lsrs	r3, r0, #12
 8000284:	428b      	cmp	r3, r1
 8000286:	d301      	bcc.n	800028c <__divsi3+0x70>
 8000288:	030b      	lsls	r3, r1, #12
 800028a:	1ac0      	subs	r0, r0, r3
 800028c:	4152      	adcs	r2, r2
 800028e:	0ac3      	lsrs	r3, r0, #11
 8000290:	428b      	cmp	r3, r1
 8000292:	d301      	bcc.n	8000298 <__divsi3+0x7c>
 8000294:	02cb      	lsls	r3, r1, #11
 8000296:	1ac0      	subs	r0, r0, r3
 8000298:	4152      	adcs	r2, r2
 800029a:	0a83      	lsrs	r3, r0, #10
 800029c:	428b      	cmp	r3, r1
 800029e:	d301      	bcc.n	80002a4 <__divsi3+0x88>
 80002a0:	028b      	lsls	r3, r1, #10
 80002a2:	1ac0      	subs	r0, r0, r3
 80002a4:	4152      	adcs	r2, r2
 80002a6:	0a43      	lsrs	r3, r0, #9
 80002a8:	428b      	cmp	r3, r1
 80002aa:	d301      	bcc.n	80002b0 <__divsi3+0x94>
 80002ac:	024b      	lsls	r3, r1, #9
 80002ae:	1ac0      	subs	r0, r0, r3
 80002b0:	4152      	adcs	r2, r2
 80002b2:	0a03      	lsrs	r3, r0, #8
 80002b4:	428b      	cmp	r3, r1
 80002b6:	d301      	bcc.n	80002bc <__divsi3+0xa0>
 80002b8:	020b      	lsls	r3, r1, #8
 80002ba:	1ac0      	subs	r0, r0, r3
 80002bc:	4152      	adcs	r2, r2
 80002be:	d2cd      	bcs.n	800025c <__divsi3+0x40>
 80002c0:	09c3      	lsrs	r3, r0, #7
 80002c2:	428b      	cmp	r3, r1
 80002c4:	d301      	bcc.n	80002ca <__divsi3+0xae>
 80002c6:	01cb      	lsls	r3, r1, #7
 80002c8:	1ac0      	subs	r0, r0, r3
 80002ca:	4152      	adcs	r2, r2
 80002cc:	0983      	lsrs	r3, r0, #6
 80002ce:	428b      	cmp	r3, r1
 80002d0:	d301      	bcc.n	80002d6 <__divsi3+0xba>
 80002d2:	018b      	lsls	r3, r1, #6
 80002d4:	1ac0      	subs	r0, r0, r3
 80002d6:	4152      	adcs	r2, r2
 80002d8:	0943      	lsrs	r3, r0, #5
 80002da:	428b      	cmp	r3, r1
 80002dc:	d301      	bcc.n	80002e2 <__divsi3+0xc6>
 80002de:	014b      	lsls	r3, r1, #5
 80002e0:	1ac0      	subs	r0, r0, r3
 80002e2:	4152      	adcs	r2, r2
 80002e4:	0903      	lsrs	r3, r0, #4
 80002e6:	428b      	cmp	r3, r1
 80002e8:	d301      	bcc.n	80002ee <__divsi3+0xd2>
 80002ea:	010b      	lsls	r3, r1, #4
 80002ec:	1ac0      	subs	r0, r0, r3
 80002ee:	4152      	adcs	r2, r2
 80002f0:	08c3      	lsrs	r3, r0, #3
 80002f2:	428b      	cmp	r3, r1
 80002f4:	d301      	bcc.n	80002fa <__divsi3+0xde>
 80002f6:	00cb      	lsls	r3, r1, #3
 80002f8:	1ac0      	subs	r0, r0, r3
 80002fa:	4152      	adcs	r2, r2
 80002fc:	0883      	lsrs	r3, r0, #2
 80002fe:	428b      	cmp	r3, r1
 8000300:	d301      	bcc.n	8000306 <__divsi3+0xea>
 8000302:	008b      	lsls	r3, r1, #2
 8000304:	1ac0      	subs	r0, r0, r3
 8000306:	4152      	adcs	r2, r2
 8000308:	0843      	lsrs	r3, r0, #1
 800030a:	428b      	cmp	r3, r1
 800030c:	d301      	bcc.n	8000312 <__divsi3+0xf6>
 800030e:	004b      	lsls	r3, r1, #1
 8000310:	1ac0      	subs	r0, r0, r3
 8000312:	4152      	adcs	r2, r2
 8000314:	1a41      	subs	r1, r0, r1
 8000316:	d200      	bcs.n	800031a <__divsi3+0xfe>
 8000318:	4601      	mov	r1, r0
 800031a:	4152      	adcs	r2, r2
 800031c:	4610      	mov	r0, r2
 800031e:	4770      	bx	lr
 8000320:	e05d      	b.n	80003de <__divsi3+0x1c2>
 8000322:	0fca      	lsrs	r2, r1, #31
 8000324:	d000      	beq.n	8000328 <__divsi3+0x10c>
 8000326:	4249      	negs	r1, r1
 8000328:	1003      	asrs	r3, r0, #32
 800032a:	d300      	bcc.n	800032e <__divsi3+0x112>
 800032c:	4240      	negs	r0, r0
 800032e:	4053      	eors	r3, r2
 8000330:	2200      	movs	r2, #0
 8000332:	469c      	mov	ip, r3
 8000334:	0903      	lsrs	r3, r0, #4
 8000336:	428b      	cmp	r3, r1
 8000338:	d32d      	bcc.n	8000396 <__divsi3+0x17a>
 800033a:	0a03      	lsrs	r3, r0, #8
 800033c:	428b      	cmp	r3, r1
 800033e:	d312      	bcc.n	8000366 <__divsi3+0x14a>
 8000340:	22fc      	movs	r2, #252	; 0xfc
 8000342:	0189      	lsls	r1, r1, #6
 8000344:	ba12      	rev	r2, r2
 8000346:	0a03      	lsrs	r3, r0, #8
 8000348:	428b      	cmp	r3, r1
 800034a:	d30c      	bcc.n	8000366 <__divsi3+0x14a>
 800034c:	0189      	lsls	r1, r1, #6
 800034e:	1192      	asrs	r2, r2, #6
 8000350:	428b      	cmp	r3, r1
 8000352:	d308      	bcc.n	8000366 <__divsi3+0x14a>
 8000354:	0189      	lsls	r1, r1, #6
 8000356:	1192      	asrs	r2, r2, #6
 8000358:	428b      	cmp	r3, r1
 800035a:	d304      	bcc.n	8000366 <__divsi3+0x14a>
 800035c:	0189      	lsls	r1, r1, #6
 800035e:	d03a      	beq.n	80003d6 <__divsi3+0x1ba>
 8000360:	1192      	asrs	r2, r2, #6
 8000362:	e000      	b.n	8000366 <__divsi3+0x14a>
 8000364:	0989      	lsrs	r1, r1, #6
 8000366:	09c3      	lsrs	r3, r0, #7
 8000368:	428b      	cmp	r3, r1
 800036a:	d301      	bcc.n	8000370 <__divsi3+0x154>
 800036c:	01cb      	lsls	r3, r1, #7
 800036e:	1ac0      	subs	r0, r0, r3
 8000370:	4152      	adcs	r2, r2
 8000372:	0983      	lsrs	r3, r0, #6
 8000374:	428b      	cmp	r3, r1
 8000376:	d301      	bcc.n	800037c <__divsi3+0x160>
 8000378:	018b      	lsls	r3, r1, #6
 800037a:	1ac0      	subs	r0, r0, r3
 800037c:	4152      	adcs	r2, r2
 800037e:	0943      	lsrs	r3, r0, #5
 8000380:	428b      	cmp	r3, r1
 8000382:	d301      	bcc.n	8000388 <__divsi3+0x16c>
 8000384:	014b      	lsls	r3, r1, #5
 8000386:	1ac0      	subs	r0, r0, r3
 8000388:	4152      	adcs	r2, r2
 800038a:	0903      	lsrs	r3, r0, #4
 800038c:	428b      	cmp	r3, r1
 800038e:	d301      	bcc.n	8000394 <__divsi3+0x178>
 8000390:	010b      	lsls	r3, r1, #4
 8000392:	1ac0      	subs	r0, r0, r3
 8000394:	4152      	adcs	r2, r2
 8000396:	08c3      	lsrs	r3, r0, #3
 8000398:	428b      	cmp	r3, r1
 800039a:	d301      	bcc.n	80003a0 <__divsi3+0x184>
 800039c:	00cb      	lsls	r3, r1, #3
 800039e:	1ac0      	subs	r0, r0, r3
 80003a0:	4152      	adcs	r2, r2
 80003a2:	0883      	lsrs	r3, r0, #2
 80003a4:	428b      	cmp	r3, r1
 80003a6:	d301      	bcc.n	80003ac <__divsi3+0x190>
 80003a8:	008b      	lsls	r3, r1, #2
 80003aa:	1ac0      	subs	r0, r0, r3
 80003ac:	4152      	adcs	r2, r2
 80003ae:	d2d9      	bcs.n	8000364 <__divsi3+0x148>
 80003b0:	0843      	lsrs	r3, r0, #1
 80003b2:	428b      	cmp	r3, r1
 80003b4:	d301      	bcc.n	80003ba <__divsi3+0x19e>
 80003b6:	004b      	lsls	r3, r1, #1
 80003b8:	1ac0      	subs	r0, r0, r3
 80003ba:	4152      	adcs	r2, r2
 80003bc:	1a41      	subs	r1, r0, r1
 80003be:	d200      	bcs.n	80003c2 <__divsi3+0x1a6>
 80003c0:	4601      	mov	r1, r0
 80003c2:	4663      	mov	r3, ip
 80003c4:	4152      	adcs	r2, r2
 80003c6:	105b      	asrs	r3, r3, #1
 80003c8:	4610      	mov	r0, r2
 80003ca:	d301      	bcc.n	80003d0 <__divsi3+0x1b4>
 80003cc:	4240      	negs	r0, r0
 80003ce:	2b00      	cmp	r3, #0
 80003d0:	d500      	bpl.n	80003d4 <__divsi3+0x1b8>
 80003d2:	4249      	negs	r1, r1
 80003d4:	4770      	bx	lr
 80003d6:	4663      	mov	r3, ip
 80003d8:	105b      	asrs	r3, r3, #1
 80003da:	d300      	bcc.n	80003de <__divsi3+0x1c2>
 80003dc:	4240      	negs	r0, r0
 80003de:	b501      	push	{r0, lr}
 80003e0:	2000      	movs	r0, #0
 80003e2:	f000 f805 	bl	80003f0 <__aeabi_idiv0>
 80003e6:	bd02      	pop	{r1, pc}

080003e8 <__aeabi_idivmod>:
 80003e8:	2900      	cmp	r1, #0
 80003ea:	d0f8      	beq.n	80003de <__divsi3+0x1c2>
 80003ec:	e716      	b.n	800021c <__divsi3>
 80003ee:	4770      	bx	lr

080003f0 <__aeabi_idiv0>:
 80003f0:	4770      	bx	lr
 80003f2:	46c0      	nop			; (mov r8, r8)

080003f4 <__aeabi_ldivmod>:
 80003f4:	2b00      	cmp	r3, #0
 80003f6:	d115      	bne.n	8000424 <__aeabi_ldivmod+0x30>
 80003f8:	2a00      	cmp	r2, #0
 80003fa:	d113      	bne.n	8000424 <__aeabi_ldivmod+0x30>
 80003fc:	2900      	cmp	r1, #0
 80003fe:	db06      	blt.n	800040e <__aeabi_ldivmod+0x1a>
 8000400:	dc01      	bgt.n	8000406 <__aeabi_ldivmod+0x12>
 8000402:	2800      	cmp	r0, #0
 8000404:	d006      	beq.n	8000414 <__aeabi_ldivmod+0x20>
 8000406:	2000      	movs	r0, #0
 8000408:	43c0      	mvns	r0, r0
 800040a:	0841      	lsrs	r1, r0, #1
 800040c:	e002      	b.n	8000414 <__aeabi_ldivmod+0x20>
 800040e:	2180      	movs	r1, #128	; 0x80
 8000410:	0609      	lsls	r1, r1, #24
 8000412:	2000      	movs	r0, #0
 8000414:	b407      	push	{r0, r1, r2}
 8000416:	4802      	ldr	r0, [pc, #8]	; (8000420 <__aeabi_ldivmod+0x2c>)
 8000418:	a101      	add	r1, pc, #4	; (adr r1, 8000420 <__aeabi_ldivmod+0x2c>)
 800041a:	1840      	adds	r0, r0, r1
 800041c:	9002      	str	r0, [sp, #8]
 800041e:	bd03      	pop	{r0, r1, pc}
 8000420:	ffffffd1 	.word	0xffffffd1
 8000424:	b403      	push	{r0, r1}
 8000426:	4668      	mov	r0, sp
 8000428:	b501      	push	{r0, lr}
 800042a:	9802      	ldr	r0, [sp, #8]
 800042c:	f000 f91a 	bl	8000664 <__gnu_ldivmod_helper>
 8000430:	9b01      	ldr	r3, [sp, #4]
 8000432:	469e      	mov	lr, r3
 8000434:	b002      	add	sp, #8
 8000436:	bc0c      	pop	{r2, r3}
 8000438:	4770      	bx	lr
 800043a:	46c0      	nop			; (mov r8, r8)

0800043c <__aeabi_uldivmod>:
 800043c:	2b00      	cmp	r3, #0
 800043e:	d111      	bne.n	8000464 <__aeabi_uldivmod+0x28>
 8000440:	2a00      	cmp	r2, #0
 8000442:	d10f      	bne.n	8000464 <__aeabi_uldivmod+0x28>
 8000444:	2900      	cmp	r1, #0
 8000446:	d100      	bne.n	800044a <__aeabi_uldivmod+0xe>
 8000448:	2800      	cmp	r0, #0
 800044a:	d002      	beq.n	8000452 <__aeabi_uldivmod+0x16>
 800044c:	2100      	movs	r1, #0
 800044e:	43c9      	mvns	r1, r1
 8000450:	1c08      	adds	r0, r1, #0
 8000452:	b407      	push	{r0, r1, r2}
 8000454:	4802      	ldr	r0, [pc, #8]	; (8000460 <__aeabi_uldivmod+0x24>)
 8000456:	a102      	add	r1, pc, #8	; (adr r1, 8000460 <__aeabi_uldivmod+0x24>)
 8000458:	1840      	adds	r0, r0, r1
 800045a:	9002      	str	r0, [sp, #8]
 800045c:	bd03      	pop	{r0, r1, pc}
 800045e:	46c0      	nop			; (mov r8, r8)
 8000460:	ffffff91 	.word	0xffffff91
 8000464:	b403      	push	{r0, r1}
 8000466:	4668      	mov	r0, sp
 8000468:	b501      	push	{r0, lr}
 800046a:	9802      	ldr	r0, [sp, #8]
 800046c:	f000 f82e 	bl	80004cc <__udivmoddi4>
 8000470:	9b01      	ldr	r3, [sp, #4]
 8000472:	469e      	mov	lr, r3
 8000474:	b002      	add	sp, #8
 8000476:	bc0c      	pop	{r2, r3}
 8000478:	4770      	bx	lr
 800047a:	46c0      	nop			; (mov r8, r8)

0800047c <__aeabi_lmul>:
 800047c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800047e:	0415      	lsls	r5, r2, #16
 8000480:	0c2d      	lsrs	r5, r5, #16
 8000482:	000f      	movs	r7, r1
 8000484:	0001      	movs	r1, r0
 8000486:	002e      	movs	r6, r5
 8000488:	46c6      	mov	lr, r8
 800048a:	4684      	mov	ip, r0
 800048c:	0400      	lsls	r0, r0, #16
 800048e:	0c14      	lsrs	r4, r2, #16
 8000490:	0c00      	lsrs	r0, r0, #16
 8000492:	0c09      	lsrs	r1, r1, #16
 8000494:	4346      	muls	r6, r0
 8000496:	434d      	muls	r5, r1
 8000498:	4360      	muls	r0, r4
 800049a:	4361      	muls	r1, r4
 800049c:	1940      	adds	r0, r0, r5
 800049e:	0c34      	lsrs	r4, r6, #16
 80004a0:	1824      	adds	r4, r4, r0
 80004a2:	b500      	push	{lr}
 80004a4:	42a5      	cmp	r5, r4
 80004a6:	d903      	bls.n	80004b0 <__aeabi_lmul+0x34>
 80004a8:	2080      	movs	r0, #128	; 0x80
 80004aa:	0240      	lsls	r0, r0, #9
 80004ac:	4680      	mov	r8, r0
 80004ae:	4441      	add	r1, r8
 80004b0:	0c25      	lsrs	r5, r4, #16
 80004b2:	186d      	adds	r5, r5, r1
 80004b4:	4661      	mov	r1, ip
 80004b6:	4359      	muls	r1, r3
 80004b8:	437a      	muls	r2, r7
 80004ba:	0430      	lsls	r0, r6, #16
 80004bc:	1949      	adds	r1, r1, r5
 80004be:	0424      	lsls	r4, r4, #16
 80004c0:	0c00      	lsrs	r0, r0, #16
 80004c2:	1820      	adds	r0, r4, r0
 80004c4:	1889      	adds	r1, r1, r2
 80004c6:	bc80      	pop	{r7}
 80004c8:	46b8      	mov	r8, r7
 80004ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

080004cc <__udivmoddi4>:
 80004cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80004ce:	4657      	mov	r7, sl
 80004d0:	464e      	mov	r6, r9
 80004d2:	4645      	mov	r5, r8
 80004d4:	46de      	mov	lr, fp
 80004d6:	b5e0      	push	{r5, r6, r7, lr}
 80004d8:	0004      	movs	r4, r0
 80004da:	000d      	movs	r5, r1
 80004dc:	4692      	mov	sl, r2
 80004de:	4699      	mov	r9, r3
 80004e0:	b083      	sub	sp, #12
 80004e2:	428b      	cmp	r3, r1
 80004e4:	d830      	bhi.n	8000548 <__udivmoddi4+0x7c>
 80004e6:	d02d      	beq.n	8000544 <__udivmoddi4+0x78>
 80004e8:	4649      	mov	r1, r9
 80004ea:	4650      	mov	r0, sl
 80004ec:	f000 f8f6 	bl	80006dc <__clzdi2>
 80004f0:	0029      	movs	r1, r5
 80004f2:	0006      	movs	r6, r0
 80004f4:	0020      	movs	r0, r4
 80004f6:	f000 f8f1 	bl	80006dc <__clzdi2>
 80004fa:	1a33      	subs	r3, r6, r0
 80004fc:	4698      	mov	r8, r3
 80004fe:	3b20      	subs	r3, #32
 8000500:	469b      	mov	fp, r3
 8000502:	d433      	bmi.n	800056c <__udivmoddi4+0xa0>
 8000504:	465a      	mov	r2, fp
 8000506:	4653      	mov	r3, sl
 8000508:	4093      	lsls	r3, r2
 800050a:	4642      	mov	r2, r8
 800050c:	001f      	movs	r7, r3
 800050e:	4653      	mov	r3, sl
 8000510:	4093      	lsls	r3, r2
 8000512:	001e      	movs	r6, r3
 8000514:	42af      	cmp	r7, r5
 8000516:	d83a      	bhi.n	800058e <__udivmoddi4+0xc2>
 8000518:	42af      	cmp	r7, r5
 800051a:	d100      	bne.n	800051e <__udivmoddi4+0x52>
 800051c:	e078      	b.n	8000610 <__udivmoddi4+0x144>
 800051e:	465b      	mov	r3, fp
 8000520:	1ba4      	subs	r4, r4, r6
 8000522:	41bd      	sbcs	r5, r7
 8000524:	2b00      	cmp	r3, #0
 8000526:	da00      	bge.n	800052a <__udivmoddi4+0x5e>
 8000528:	e075      	b.n	8000616 <__udivmoddi4+0x14a>
 800052a:	2200      	movs	r2, #0
 800052c:	2300      	movs	r3, #0
 800052e:	9200      	str	r2, [sp, #0]
 8000530:	9301      	str	r3, [sp, #4]
 8000532:	2301      	movs	r3, #1
 8000534:	465a      	mov	r2, fp
 8000536:	4093      	lsls	r3, r2
 8000538:	9301      	str	r3, [sp, #4]
 800053a:	2301      	movs	r3, #1
 800053c:	4642      	mov	r2, r8
 800053e:	4093      	lsls	r3, r2
 8000540:	9300      	str	r3, [sp, #0]
 8000542:	e028      	b.n	8000596 <__udivmoddi4+0xca>
 8000544:	4282      	cmp	r2, r0
 8000546:	d9cf      	bls.n	80004e8 <__udivmoddi4+0x1c>
 8000548:	2200      	movs	r2, #0
 800054a:	2300      	movs	r3, #0
 800054c:	9200      	str	r2, [sp, #0]
 800054e:	9301      	str	r3, [sp, #4]
 8000550:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000552:	2b00      	cmp	r3, #0
 8000554:	d001      	beq.n	800055a <__udivmoddi4+0x8e>
 8000556:	601c      	str	r4, [r3, #0]
 8000558:	605d      	str	r5, [r3, #4]
 800055a:	9800      	ldr	r0, [sp, #0]
 800055c:	9901      	ldr	r1, [sp, #4]
 800055e:	b003      	add	sp, #12
 8000560:	bcf0      	pop	{r4, r5, r6, r7}
 8000562:	46bb      	mov	fp, r7
 8000564:	46b2      	mov	sl, r6
 8000566:	46a9      	mov	r9, r5
 8000568:	46a0      	mov	r8, r4
 800056a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800056c:	4642      	mov	r2, r8
 800056e:	2320      	movs	r3, #32
 8000570:	1a9b      	subs	r3, r3, r2
 8000572:	4652      	mov	r2, sl
 8000574:	40da      	lsrs	r2, r3
 8000576:	4641      	mov	r1, r8
 8000578:	0013      	movs	r3, r2
 800057a:	464a      	mov	r2, r9
 800057c:	408a      	lsls	r2, r1
 800057e:	0017      	movs	r7, r2
 8000580:	4642      	mov	r2, r8
 8000582:	431f      	orrs	r7, r3
 8000584:	4653      	mov	r3, sl
 8000586:	4093      	lsls	r3, r2
 8000588:	001e      	movs	r6, r3
 800058a:	42af      	cmp	r7, r5
 800058c:	d9c4      	bls.n	8000518 <__udivmoddi4+0x4c>
 800058e:	2200      	movs	r2, #0
 8000590:	2300      	movs	r3, #0
 8000592:	9200      	str	r2, [sp, #0]
 8000594:	9301      	str	r3, [sp, #4]
 8000596:	4643      	mov	r3, r8
 8000598:	2b00      	cmp	r3, #0
 800059a:	d0d9      	beq.n	8000550 <__udivmoddi4+0x84>
 800059c:	07fb      	lsls	r3, r7, #31
 800059e:	0872      	lsrs	r2, r6, #1
 80005a0:	431a      	orrs	r2, r3
 80005a2:	4646      	mov	r6, r8
 80005a4:	087b      	lsrs	r3, r7, #1
 80005a6:	e00e      	b.n	80005c6 <__udivmoddi4+0xfa>
 80005a8:	42ab      	cmp	r3, r5
 80005aa:	d101      	bne.n	80005b0 <__udivmoddi4+0xe4>
 80005ac:	42a2      	cmp	r2, r4
 80005ae:	d80c      	bhi.n	80005ca <__udivmoddi4+0xfe>
 80005b0:	1aa4      	subs	r4, r4, r2
 80005b2:	419d      	sbcs	r5, r3
 80005b4:	2001      	movs	r0, #1
 80005b6:	1924      	adds	r4, r4, r4
 80005b8:	416d      	adcs	r5, r5
 80005ba:	2100      	movs	r1, #0
 80005bc:	3e01      	subs	r6, #1
 80005be:	1824      	adds	r4, r4, r0
 80005c0:	414d      	adcs	r5, r1
 80005c2:	2e00      	cmp	r6, #0
 80005c4:	d006      	beq.n	80005d4 <__udivmoddi4+0x108>
 80005c6:	42ab      	cmp	r3, r5
 80005c8:	d9ee      	bls.n	80005a8 <__udivmoddi4+0xdc>
 80005ca:	3e01      	subs	r6, #1
 80005cc:	1924      	adds	r4, r4, r4
 80005ce:	416d      	adcs	r5, r5
 80005d0:	2e00      	cmp	r6, #0
 80005d2:	d1f8      	bne.n	80005c6 <__udivmoddi4+0xfa>
 80005d4:	9800      	ldr	r0, [sp, #0]
 80005d6:	9901      	ldr	r1, [sp, #4]
 80005d8:	465b      	mov	r3, fp
 80005da:	1900      	adds	r0, r0, r4
 80005dc:	4169      	adcs	r1, r5
 80005de:	2b00      	cmp	r3, #0
 80005e0:	db24      	blt.n	800062c <__udivmoddi4+0x160>
 80005e2:	002b      	movs	r3, r5
 80005e4:	465a      	mov	r2, fp
 80005e6:	4644      	mov	r4, r8
 80005e8:	40d3      	lsrs	r3, r2
 80005ea:	002a      	movs	r2, r5
 80005ec:	40e2      	lsrs	r2, r4
 80005ee:	001c      	movs	r4, r3
 80005f0:	465b      	mov	r3, fp
 80005f2:	0015      	movs	r5, r2
 80005f4:	2b00      	cmp	r3, #0
 80005f6:	db2a      	blt.n	800064e <__udivmoddi4+0x182>
 80005f8:	0026      	movs	r6, r4
 80005fa:	409e      	lsls	r6, r3
 80005fc:	0033      	movs	r3, r6
 80005fe:	0026      	movs	r6, r4
 8000600:	4647      	mov	r7, r8
 8000602:	40be      	lsls	r6, r7
 8000604:	0032      	movs	r2, r6
 8000606:	1a80      	subs	r0, r0, r2
 8000608:	4199      	sbcs	r1, r3
 800060a:	9000      	str	r0, [sp, #0]
 800060c:	9101      	str	r1, [sp, #4]
 800060e:	e79f      	b.n	8000550 <__udivmoddi4+0x84>
 8000610:	42a3      	cmp	r3, r4
 8000612:	d8bc      	bhi.n	800058e <__udivmoddi4+0xc2>
 8000614:	e783      	b.n	800051e <__udivmoddi4+0x52>
 8000616:	4642      	mov	r2, r8
 8000618:	2320      	movs	r3, #32
 800061a:	2100      	movs	r1, #0
 800061c:	1a9b      	subs	r3, r3, r2
 800061e:	2200      	movs	r2, #0
 8000620:	9100      	str	r1, [sp, #0]
 8000622:	9201      	str	r2, [sp, #4]
 8000624:	2201      	movs	r2, #1
 8000626:	40da      	lsrs	r2, r3
 8000628:	9201      	str	r2, [sp, #4]
 800062a:	e786      	b.n	800053a <__udivmoddi4+0x6e>
 800062c:	4642      	mov	r2, r8
 800062e:	2320      	movs	r3, #32
 8000630:	1a9b      	subs	r3, r3, r2
 8000632:	002a      	movs	r2, r5
 8000634:	4646      	mov	r6, r8
 8000636:	409a      	lsls	r2, r3
 8000638:	0023      	movs	r3, r4
 800063a:	40f3      	lsrs	r3, r6
 800063c:	4644      	mov	r4, r8
 800063e:	4313      	orrs	r3, r2
 8000640:	002a      	movs	r2, r5
 8000642:	40e2      	lsrs	r2, r4
 8000644:	001c      	movs	r4, r3
 8000646:	465b      	mov	r3, fp
 8000648:	0015      	movs	r5, r2
 800064a:	2b00      	cmp	r3, #0
 800064c:	dad4      	bge.n	80005f8 <__udivmoddi4+0x12c>
 800064e:	4642      	mov	r2, r8
 8000650:	002f      	movs	r7, r5
 8000652:	2320      	movs	r3, #32
 8000654:	0026      	movs	r6, r4
 8000656:	4097      	lsls	r7, r2
 8000658:	1a9b      	subs	r3, r3, r2
 800065a:	40de      	lsrs	r6, r3
 800065c:	003b      	movs	r3, r7
 800065e:	4333      	orrs	r3, r6
 8000660:	e7cd      	b.n	80005fe <__udivmoddi4+0x132>
 8000662:	46c0      	nop			; (mov r8, r8)

08000664 <__gnu_ldivmod_helper>:
 8000664:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000666:	46ce      	mov	lr, r9
 8000668:	4647      	mov	r7, r8
 800066a:	b580      	push	{r7, lr}
 800066c:	4691      	mov	r9, r2
 800066e:	4698      	mov	r8, r3
 8000670:	0004      	movs	r4, r0
 8000672:	000d      	movs	r5, r1
 8000674:	f000 f83e 	bl	80006f4 <__divdi3>
 8000678:	0007      	movs	r7, r0
 800067a:	000e      	movs	r6, r1
 800067c:	0002      	movs	r2, r0
 800067e:	000b      	movs	r3, r1
 8000680:	4648      	mov	r0, r9
 8000682:	4641      	mov	r1, r8
 8000684:	f7ff fefa 	bl	800047c <__aeabi_lmul>
 8000688:	1a24      	subs	r4, r4, r0
 800068a:	418d      	sbcs	r5, r1
 800068c:	9b08      	ldr	r3, [sp, #32]
 800068e:	0038      	movs	r0, r7
 8000690:	0031      	movs	r1, r6
 8000692:	601c      	str	r4, [r3, #0]
 8000694:	605d      	str	r5, [r3, #4]
 8000696:	bcc0      	pop	{r6, r7}
 8000698:	46b9      	mov	r9, r7
 800069a:	46b0      	mov	r8, r6
 800069c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800069e:	46c0      	nop			; (mov r8, r8)

080006a0 <__clzsi2>:
 80006a0:	211c      	movs	r1, #28
 80006a2:	2301      	movs	r3, #1
 80006a4:	041b      	lsls	r3, r3, #16
 80006a6:	4298      	cmp	r0, r3
 80006a8:	d301      	bcc.n	80006ae <__clzsi2+0xe>
 80006aa:	0c00      	lsrs	r0, r0, #16
 80006ac:	3910      	subs	r1, #16
 80006ae:	0a1b      	lsrs	r3, r3, #8
 80006b0:	4298      	cmp	r0, r3
 80006b2:	d301      	bcc.n	80006b8 <__clzsi2+0x18>
 80006b4:	0a00      	lsrs	r0, r0, #8
 80006b6:	3908      	subs	r1, #8
 80006b8:	091b      	lsrs	r3, r3, #4
 80006ba:	4298      	cmp	r0, r3
 80006bc:	d301      	bcc.n	80006c2 <__clzsi2+0x22>
 80006be:	0900      	lsrs	r0, r0, #4
 80006c0:	3904      	subs	r1, #4
 80006c2:	a202      	add	r2, pc, #8	; (adr r2, 80006cc <__clzsi2+0x2c>)
 80006c4:	5c10      	ldrb	r0, [r2, r0]
 80006c6:	1840      	adds	r0, r0, r1
 80006c8:	4770      	bx	lr
 80006ca:	46c0      	nop			; (mov r8, r8)
 80006cc:	02020304 	.word	0x02020304
 80006d0:	01010101 	.word	0x01010101
	...

080006dc <__clzdi2>:
 80006dc:	b510      	push	{r4, lr}
 80006de:	2900      	cmp	r1, #0
 80006e0:	d103      	bne.n	80006ea <__clzdi2+0xe>
 80006e2:	f7ff ffdd 	bl	80006a0 <__clzsi2>
 80006e6:	3020      	adds	r0, #32
 80006e8:	e002      	b.n	80006f0 <__clzdi2+0x14>
 80006ea:	1c08      	adds	r0, r1, #0
 80006ec:	f7ff ffd8 	bl	80006a0 <__clzsi2>
 80006f0:	bd10      	pop	{r4, pc}
 80006f2:	46c0      	nop			; (mov r8, r8)

080006f4 <__divdi3>:
 80006f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80006f6:	4657      	mov	r7, sl
 80006f8:	464e      	mov	r6, r9
 80006fa:	4645      	mov	r5, r8
 80006fc:	46de      	mov	lr, fp
 80006fe:	b5e0      	push	{r5, r6, r7, lr}
 8000700:	000f      	movs	r7, r1
 8000702:	0019      	movs	r1, r3
 8000704:	2300      	movs	r3, #0
 8000706:	0006      	movs	r6, r0
 8000708:	4698      	mov	r8, r3
 800070a:	0010      	movs	r0, r2
 800070c:	b083      	sub	sp, #12
 800070e:	2f00      	cmp	r7, #0
 8000710:	da07      	bge.n	8000722 <__divdi3+0x2e>
 8000712:	0033      	movs	r3, r6
 8000714:	003c      	movs	r4, r7
 8000716:	2700      	movs	r7, #0
 8000718:	425e      	negs	r6, r3
 800071a:	41a7      	sbcs	r7, r4
 800071c:	2301      	movs	r3, #1
 800071e:	425b      	negs	r3, r3
 8000720:	4698      	mov	r8, r3
 8000722:	2900      	cmp	r1, #0
 8000724:	da07      	bge.n	8000736 <__divdi3+0x42>
 8000726:	4643      	mov	r3, r8
 8000728:	43db      	mvns	r3, r3
 800072a:	000c      	movs	r4, r1
 800072c:	4698      	mov	r8, r3
 800072e:	0003      	movs	r3, r0
 8000730:	2100      	movs	r1, #0
 8000732:	4258      	negs	r0, r3
 8000734:	41a1      	sbcs	r1, r4
 8000736:	0034      	movs	r4, r6
 8000738:	003d      	movs	r5, r7
 800073a:	4682      	mov	sl, r0
 800073c:	4689      	mov	r9, r1
 800073e:	42b9      	cmp	r1, r7
 8000740:	d86a      	bhi.n	8000818 <__divdi3+0x124>
 8000742:	d067      	beq.n	8000814 <__divdi3+0x120>
 8000744:	4649      	mov	r1, r9
 8000746:	4650      	mov	r0, sl
 8000748:	f7ff ffc8 	bl	80006dc <__clzdi2>
 800074c:	4683      	mov	fp, r0
 800074e:	0039      	movs	r1, r7
 8000750:	0030      	movs	r0, r6
 8000752:	f7ff ffc3 	bl	80006dc <__clzdi2>
 8000756:	465b      	mov	r3, fp
 8000758:	1a1b      	subs	r3, r3, r0
 800075a:	469c      	mov	ip, r3
 800075c:	3b20      	subs	r3, #32
 800075e:	469b      	mov	fp, r3
 8000760:	d46b      	bmi.n	800083a <__divdi3+0x146>
 8000762:	4658      	mov	r0, fp
 8000764:	4651      	mov	r1, sl
 8000766:	4081      	lsls	r1, r0
 8000768:	4660      	mov	r0, ip
 800076a:	000b      	movs	r3, r1
 800076c:	4651      	mov	r1, sl
 800076e:	4081      	lsls	r1, r0
 8000770:	000a      	movs	r2, r1
 8000772:	42bb      	cmp	r3, r7
 8000774:	d900      	bls.n	8000778 <__divdi3+0x84>
 8000776:	e072      	b.n	800085e <__divdi3+0x16a>
 8000778:	42bb      	cmp	r3, r7
 800077a:	d100      	bne.n	800077e <__divdi3+0x8a>
 800077c:	e079      	b.n	8000872 <__divdi3+0x17e>
 800077e:	0034      	movs	r4, r6
 8000780:	003d      	movs	r5, r7
 8000782:	4659      	mov	r1, fp
 8000784:	1aa4      	subs	r4, r4, r2
 8000786:	419d      	sbcs	r5, r3
 8000788:	2900      	cmp	r1, #0
 800078a:	da00      	bge.n	800078e <__divdi3+0x9a>
 800078c:	e074      	b.n	8000878 <__divdi3+0x184>
 800078e:	2100      	movs	r1, #0
 8000790:	2000      	movs	r0, #0
 8000792:	2601      	movs	r6, #1
 8000794:	9000      	str	r0, [sp, #0]
 8000796:	9101      	str	r1, [sp, #4]
 8000798:	4659      	mov	r1, fp
 800079a:	408e      	lsls	r6, r1
 800079c:	9601      	str	r6, [sp, #4]
 800079e:	4661      	mov	r1, ip
 80007a0:	2601      	movs	r6, #1
 80007a2:	408e      	lsls	r6, r1
 80007a4:	4661      	mov	r1, ip
 80007a6:	9600      	str	r6, [sp, #0]
 80007a8:	2900      	cmp	r1, #0
 80007aa:	d05f      	beq.n	800086c <__divdi3+0x178>
 80007ac:	07d9      	lsls	r1, r3, #31
 80007ae:	0856      	lsrs	r6, r2, #1
 80007b0:	430e      	orrs	r6, r1
 80007b2:	085f      	lsrs	r7, r3, #1
 80007b4:	4661      	mov	r1, ip
 80007b6:	2201      	movs	r2, #1
 80007b8:	2300      	movs	r3, #0
 80007ba:	e00c      	b.n	80007d6 <__divdi3+0xe2>
 80007bc:	42af      	cmp	r7, r5
 80007be:	d101      	bne.n	80007c4 <__divdi3+0xd0>
 80007c0:	42a6      	cmp	r6, r4
 80007c2:	d80a      	bhi.n	80007da <__divdi3+0xe6>
 80007c4:	1ba4      	subs	r4, r4, r6
 80007c6:	41bd      	sbcs	r5, r7
 80007c8:	1924      	adds	r4, r4, r4
 80007ca:	416d      	adcs	r5, r5
 80007cc:	3901      	subs	r1, #1
 80007ce:	18a4      	adds	r4, r4, r2
 80007d0:	415d      	adcs	r5, r3
 80007d2:	2900      	cmp	r1, #0
 80007d4:	d006      	beq.n	80007e4 <__divdi3+0xf0>
 80007d6:	42af      	cmp	r7, r5
 80007d8:	d9f0      	bls.n	80007bc <__divdi3+0xc8>
 80007da:	3901      	subs	r1, #1
 80007dc:	1924      	adds	r4, r4, r4
 80007de:	416d      	adcs	r5, r5
 80007e0:	2900      	cmp	r1, #0
 80007e2:	d1f8      	bne.n	80007d6 <__divdi3+0xe2>
 80007e4:	9800      	ldr	r0, [sp, #0]
 80007e6:	9901      	ldr	r1, [sp, #4]
 80007e8:	465b      	mov	r3, fp
 80007ea:	1900      	adds	r0, r0, r4
 80007ec:	4169      	adcs	r1, r5
 80007ee:	2b00      	cmp	r3, #0
 80007f0:	db4d      	blt.n	800088e <__divdi3+0x19a>
 80007f2:	002e      	movs	r6, r5
 80007f4:	002c      	movs	r4, r5
 80007f6:	40de      	lsrs	r6, r3
 80007f8:	4663      	mov	r3, ip
 80007fa:	40dc      	lsrs	r4, r3
 80007fc:	465b      	mov	r3, fp
 80007fe:	2b00      	cmp	r3, #0
 8000800:	db55      	blt.n	80008ae <__divdi3+0x1ba>
 8000802:	0034      	movs	r4, r6
 8000804:	409c      	lsls	r4, r3
 8000806:	0023      	movs	r3, r4
 8000808:	4664      	mov	r4, ip
 800080a:	40a6      	lsls	r6, r4
 800080c:	0032      	movs	r2, r6
 800080e:	1a80      	subs	r0, r0, r2
 8000810:	4199      	sbcs	r1, r3
 8000812:	e003      	b.n	800081c <__divdi3+0x128>
 8000814:	42b0      	cmp	r0, r6
 8000816:	d995      	bls.n	8000744 <__divdi3+0x50>
 8000818:	2000      	movs	r0, #0
 800081a:	2100      	movs	r1, #0
 800081c:	4643      	mov	r3, r8
 800081e:	2b00      	cmp	r3, #0
 8000820:	d004      	beq.n	800082c <__divdi3+0x138>
 8000822:	0003      	movs	r3, r0
 8000824:	000c      	movs	r4, r1
 8000826:	2100      	movs	r1, #0
 8000828:	4258      	negs	r0, r3
 800082a:	41a1      	sbcs	r1, r4
 800082c:	b003      	add	sp, #12
 800082e:	bcf0      	pop	{r4, r5, r6, r7}
 8000830:	46bb      	mov	fp, r7
 8000832:	46b2      	mov	sl, r6
 8000834:	46a9      	mov	r9, r5
 8000836:	46a0      	mov	r8, r4
 8000838:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800083a:	4662      	mov	r2, ip
 800083c:	4648      	mov	r0, r9
 800083e:	2320      	movs	r3, #32
 8000840:	4651      	mov	r1, sl
 8000842:	4090      	lsls	r0, r2
 8000844:	1a9b      	subs	r3, r3, r2
 8000846:	40d9      	lsrs	r1, r3
 8000848:	0003      	movs	r3, r0
 800084a:	9100      	str	r1, [sp, #0]
 800084c:	9900      	ldr	r1, [sp, #0]
 800084e:	4660      	mov	r0, ip
 8000850:	430b      	orrs	r3, r1
 8000852:	4651      	mov	r1, sl
 8000854:	4081      	lsls	r1, r0
 8000856:	000a      	movs	r2, r1
 8000858:	42bb      	cmp	r3, r7
 800085a:	d800      	bhi.n	800085e <__divdi3+0x16a>
 800085c:	e78c      	b.n	8000778 <__divdi3+0x84>
 800085e:	2100      	movs	r1, #0
 8000860:	2000      	movs	r0, #0
 8000862:	9000      	str	r0, [sp, #0]
 8000864:	9101      	str	r1, [sp, #4]
 8000866:	4661      	mov	r1, ip
 8000868:	2900      	cmp	r1, #0
 800086a:	d19f      	bne.n	80007ac <__divdi3+0xb8>
 800086c:	9800      	ldr	r0, [sp, #0]
 800086e:	9901      	ldr	r1, [sp, #4]
 8000870:	e7d4      	b.n	800081c <__divdi3+0x128>
 8000872:	42b1      	cmp	r1, r6
 8000874:	d8f3      	bhi.n	800085e <__divdi3+0x16a>
 8000876:	e782      	b.n	800077e <__divdi3+0x8a>
 8000878:	4661      	mov	r1, ip
 800087a:	2620      	movs	r6, #32
 800087c:	2701      	movs	r7, #1
 800087e:	1a76      	subs	r6, r6, r1
 8000880:	2000      	movs	r0, #0
 8000882:	2100      	movs	r1, #0
 8000884:	40f7      	lsrs	r7, r6
 8000886:	9000      	str	r0, [sp, #0]
 8000888:	9101      	str	r1, [sp, #4]
 800088a:	9701      	str	r7, [sp, #4]
 800088c:	e787      	b.n	800079e <__divdi3+0xaa>
 800088e:	4662      	mov	r2, ip
 8000890:	2320      	movs	r3, #32
 8000892:	1a9b      	subs	r3, r3, r2
 8000894:	002a      	movs	r2, r5
 8000896:	409a      	lsls	r2, r3
 8000898:	0026      	movs	r6, r4
 800089a:	0013      	movs	r3, r2
 800089c:	4662      	mov	r2, ip
 800089e:	40d6      	lsrs	r6, r2
 80008a0:	002c      	movs	r4, r5
 80008a2:	431e      	orrs	r6, r3
 80008a4:	4663      	mov	r3, ip
 80008a6:	40dc      	lsrs	r4, r3
 80008a8:	465b      	mov	r3, fp
 80008aa:	2b00      	cmp	r3, #0
 80008ac:	daa9      	bge.n	8000802 <__divdi3+0x10e>
 80008ae:	4662      	mov	r2, ip
 80008b0:	2320      	movs	r3, #32
 80008b2:	0035      	movs	r5, r6
 80008b4:	4094      	lsls	r4, r2
 80008b6:	1a9b      	subs	r3, r3, r2
 80008b8:	40dd      	lsrs	r5, r3
 80008ba:	0023      	movs	r3, r4
 80008bc:	432b      	orrs	r3, r5
 80008be:	e7a3      	b.n	8000808 <__divdi3+0x114>

080008c0 <bmp280_init_default_params>:

#define BMP280_RESET_VALUE     0xB6



void bmp280_init_default_params(bmp280_params_t *params) {
 80008c0:	b580      	push	{r7, lr}
 80008c2:	b082      	sub	sp, #8
 80008c4:	af00      	add	r7, sp, #0
 80008c6:	6078      	str	r0, [r7, #4]
	params->mode = BMP280_MODE_NORMAL;
 80008c8:	687b      	ldr	r3, [r7, #4]
 80008ca:	2203      	movs	r2, #3
 80008cc:	701a      	strb	r2, [r3, #0]
	params->filter = BMP280_FILTER_OFF;
 80008ce:	687b      	ldr	r3, [r7, #4]
 80008d0:	2200      	movs	r2, #0
 80008d2:	705a      	strb	r2, [r3, #1]
	params->oversampling_pressure = BMP280_STANDARD;
 80008d4:	687b      	ldr	r3, [r7, #4]
 80008d6:	2203      	movs	r2, #3
 80008d8:	709a      	strb	r2, [r3, #2]
	params->oversampling_temperature = BMP280_STANDARD;
 80008da:	687b      	ldr	r3, [r7, #4]
 80008dc:	2203      	movs	r2, #3
 80008de:	70da      	strb	r2, [r3, #3]
	params->oversampling_humidity = BMP280_STANDARD;
 80008e0:	687b      	ldr	r3, [r7, #4]
 80008e2:	2203      	movs	r2, #3
 80008e4:	711a      	strb	r2, [r3, #4]
	params->standby = BMP280_STANDBY_250;
 80008e6:	687b      	ldr	r3, [r7, #4]
 80008e8:	2203      	movs	r2, #3
 80008ea:	715a      	strb	r2, [r3, #5]
}
 80008ec:	46c0      	nop			; (mov r8, r8)
 80008ee:	46bd      	mov	sp, r7
 80008f0:	b002      	add	sp, #8
 80008f2:	bd80      	pop	{r7, pc}

080008f4 <read_register16>:

static bool read_register16(BMP280_HandleTypedef *dev, uint8_t addr, uint16_t *value) {
 80008f4:	b590      	push	{r4, r7, lr}
 80008f6:	b08b      	sub	sp, #44	; 0x2c
 80008f8:	af04      	add	r7, sp, #16
 80008fa:	60f8      	str	r0, [r7, #12]
 80008fc:	607a      	str	r2, [r7, #4]
 80008fe:	240b      	movs	r4, #11
 8000900:	193b      	adds	r3, r7, r4
 8000902:	1c0a      	adds	r2, r1, #0
 8000904:	701a      	strb	r2, [r3, #0]
	uint16_t tx_buff;
	uint8_t rx_buff[2];
	tx_buff = (dev->addr << 1);
 8000906:	68fb      	ldr	r3, [r7, #12]
 8000908:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800090a:	2116      	movs	r1, #22
 800090c:	187a      	adds	r2, r7, r1
 800090e:	18db      	adds	r3, r3, r3
 8000910:	8013      	strh	r3, [r2, #0]

	if (HAL_I2C_Mem_Read(dev->i2c, tx_buff, addr, 1, rx_buff, 2, 5000)
 8000912:	68fb      	ldr	r3, [r7, #12]
 8000914:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8000916:	193b      	adds	r3, r7, r4
 8000918:	781b      	ldrb	r3, [r3, #0]
 800091a:	b29a      	uxth	r2, r3
 800091c:	187b      	adds	r3, r7, r1
 800091e:	8819      	ldrh	r1, [r3, #0]
 8000920:	4b0f      	ldr	r3, [pc, #60]	; (8000960 <read_register16+0x6c>)
 8000922:	9302      	str	r3, [sp, #8]
 8000924:	2302      	movs	r3, #2
 8000926:	9301      	str	r3, [sp, #4]
 8000928:	2414      	movs	r4, #20
 800092a:	193b      	adds	r3, r7, r4
 800092c:	9300      	str	r3, [sp, #0]
 800092e:	2301      	movs	r3, #1
 8000930:	f008 fb36 	bl	8008fa0 <HAL_I2C_Mem_Read>
 8000934:	1e03      	subs	r3, r0, #0
 8000936:	d10e      	bne.n	8000956 <read_register16+0x62>
			== HAL_OK) {
		*value = (uint16_t) ((rx_buff[1] << 8) | rx_buff[0]);
 8000938:	0021      	movs	r1, r4
 800093a:	187b      	adds	r3, r7, r1
 800093c:	785b      	ldrb	r3, [r3, #1]
 800093e:	021b      	lsls	r3, r3, #8
 8000940:	b21a      	sxth	r2, r3
 8000942:	187b      	adds	r3, r7, r1
 8000944:	781b      	ldrb	r3, [r3, #0]
 8000946:	b21b      	sxth	r3, r3
 8000948:	4313      	orrs	r3, r2
 800094a:	b21b      	sxth	r3, r3
 800094c:	b29a      	uxth	r2, r3
 800094e:	687b      	ldr	r3, [r7, #4]
 8000950:	801a      	strh	r2, [r3, #0]
		return true;
 8000952:	2301      	movs	r3, #1
 8000954:	e000      	b.n	8000958 <read_register16+0x64>
	} else
		return false;
 8000956:	2300      	movs	r3, #0

}
 8000958:	0018      	movs	r0, r3
 800095a:	46bd      	mov	sp, r7
 800095c:	b007      	add	sp, #28
 800095e:	bd90      	pop	{r4, r7, pc}
 8000960:	00001388 	.word	0x00001388

08000964 <read_data>:

static inline int read_data(BMP280_HandleTypedef *dev, uint8_t addr, uint8_t *value, uint8_t len) {
 8000964:	b5b0      	push	{r4, r5, r7, lr}
 8000966:	b08a      	sub	sp, #40	; 0x28
 8000968:	af04      	add	r7, sp, #16
 800096a:	60f8      	str	r0, [r7, #12]
 800096c:	0008      	movs	r0, r1
 800096e:	607a      	str	r2, [r7, #4]
 8000970:	0019      	movs	r1, r3
 8000972:	240b      	movs	r4, #11
 8000974:	193b      	adds	r3, r7, r4
 8000976:	1c02      	adds	r2, r0, #0
 8000978:	701a      	strb	r2, [r3, #0]
 800097a:	250a      	movs	r5, #10
 800097c:	197b      	adds	r3, r7, r5
 800097e:	1c0a      	adds	r2, r1, #0
 8000980:	701a      	strb	r2, [r3, #0]
	uint16_t tx_buff;
	tx_buff = (dev->addr << 1);
 8000982:	68fb      	ldr	r3, [r7, #12]
 8000984:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000986:	2116      	movs	r1, #22
 8000988:	187a      	adds	r2, r7, r1
 800098a:	18db      	adds	r3, r3, r3
 800098c:	8013      	strh	r3, [r2, #0]
	if (HAL_I2C_Mem_Read(dev->i2c, tx_buff, addr, 1, value, len, 5000) == HAL_OK)
 800098e:	68fb      	ldr	r3, [r7, #12]
 8000990:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8000992:	193b      	adds	r3, r7, r4
 8000994:	781b      	ldrb	r3, [r3, #0]
 8000996:	b29c      	uxth	r4, r3
 8000998:	197b      	adds	r3, r7, r5
 800099a:	781b      	ldrb	r3, [r3, #0]
 800099c:	b29b      	uxth	r3, r3
 800099e:	187a      	adds	r2, r7, r1
 80009a0:	8811      	ldrh	r1, [r2, #0]
 80009a2:	4a09      	ldr	r2, [pc, #36]	; (80009c8 <read_data+0x64>)
 80009a4:	9202      	str	r2, [sp, #8]
 80009a6:	9301      	str	r3, [sp, #4]
 80009a8:	687b      	ldr	r3, [r7, #4]
 80009aa:	9300      	str	r3, [sp, #0]
 80009ac:	2301      	movs	r3, #1
 80009ae:	0022      	movs	r2, r4
 80009b0:	f008 faf6 	bl	8008fa0 <HAL_I2C_Mem_Read>
 80009b4:	1e03      	subs	r3, r0, #0
 80009b6:	d101      	bne.n	80009bc <read_data+0x58>
		return 0;
 80009b8:	2300      	movs	r3, #0
 80009ba:	e000      	b.n	80009be <read_data+0x5a>
	else
		return 1;
 80009bc:	2301      	movs	r3, #1

}
 80009be:	0018      	movs	r0, r3
 80009c0:	46bd      	mov	sp, r7
 80009c2:	b006      	add	sp, #24
 80009c4:	bdb0      	pop	{r4, r5, r7, pc}
 80009c6:	46c0      	nop			; (mov r8, r8)
 80009c8:	00001388 	.word	0x00001388

080009cc <read_calibration_data>:

static bool read_calibration_data(BMP280_HandleTypedef *dev) {
 80009cc:	b580      	push	{r7, lr}
 80009ce:	b082      	sub	sp, #8
 80009d0:	af00      	add	r7, sp, #0
 80009d2:	6078      	str	r0, [r7, #4]

	if (read_register16(dev, 0x88, &dev->dig_T1)
 80009d4:	687a      	ldr	r2, [r7, #4]
 80009d6:	687b      	ldr	r3, [r7, #4]
 80009d8:	2188      	movs	r1, #136	; 0x88
 80009da:	0018      	movs	r0, r3
 80009dc:	f7ff ff8a 	bl	80008f4 <read_register16>
 80009e0:	1e03      	subs	r3, r0, #0
 80009e2:	d100      	bne.n	80009e6 <read_calibration_data+0x1a>
 80009e4:	e06d      	b.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x8a, (uint16_t *) &dev->dig_T2)
 80009e6:	687b      	ldr	r3, [r7, #4]
 80009e8:	1c9a      	adds	r2, r3, #2
 80009ea:	687b      	ldr	r3, [r7, #4]
 80009ec:	218a      	movs	r1, #138	; 0x8a
 80009ee:	0018      	movs	r0, r3
 80009f0:	f7ff ff80 	bl	80008f4 <read_register16>
 80009f4:	1e03      	subs	r3, r0, #0
 80009f6:	d100      	bne.n	80009fa <read_calibration_data+0x2e>
 80009f8:	e063      	b.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x8c, (uint16_t *) &dev->dig_T3)
 80009fa:	687b      	ldr	r3, [r7, #4]
 80009fc:	1d1a      	adds	r2, r3, #4
 80009fe:	687b      	ldr	r3, [r7, #4]
 8000a00:	218c      	movs	r1, #140	; 0x8c
 8000a02:	0018      	movs	r0, r3
 8000a04:	f7ff ff76 	bl	80008f4 <read_register16>
 8000a08:	1e03      	subs	r3, r0, #0
 8000a0a:	d05a      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x8e, &dev->dig_P1)
 8000a0c:	687b      	ldr	r3, [r7, #4]
 8000a0e:	1d9a      	adds	r2, r3, #6
 8000a10:	687b      	ldr	r3, [r7, #4]
 8000a12:	218e      	movs	r1, #142	; 0x8e
 8000a14:	0018      	movs	r0, r3
 8000a16:	f7ff ff6d 	bl	80008f4 <read_register16>
 8000a1a:	1e03      	subs	r3, r0, #0
 8000a1c:	d051      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x90, (uint16_t *) &dev->dig_P2)
 8000a1e:	687b      	ldr	r3, [r7, #4]
 8000a20:	3308      	adds	r3, #8
 8000a22:	001a      	movs	r2, r3
 8000a24:	687b      	ldr	r3, [r7, #4]
 8000a26:	2190      	movs	r1, #144	; 0x90
 8000a28:	0018      	movs	r0, r3
 8000a2a:	f7ff ff63 	bl	80008f4 <read_register16>
 8000a2e:	1e03      	subs	r3, r0, #0
 8000a30:	d047      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x92, (uint16_t *) &dev->dig_P3)
 8000a32:	687b      	ldr	r3, [r7, #4]
 8000a34:	330a      	adds	r3, #10
 8000a36:	001a      	movs	r2, r3
 8000a38:	687b      	ldr	r3, [r7, #4]
 8000a3a:	2192      	movs	r1, #146	; 0x92
 8000a3c:	0018      	movs	r0, r3
 8000a3e:	f7ff ff59 	bl	80008f4 <read_register16>
 8000a42:	1e03      	subs	r3, r0, #0
 8000a44:	d03d      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x94, (uint16_t *) &dev->dig_P4)
 8000a46:	687b      	ldr	r3, [r7, #4]
 8000a48:	330c      	adds	r3, #12
 8000a4a:	001a      	movs	r2, r3
 8000a4c:	687b      	ldr	r3, [r7, #4]
 8000a4e:	2194      	movs	r1, #148	; 0x94
 8000a50:	0018      	movs	r0, r3
 8000a52:	f7ff ff4f 	bl	80008f4 <read_register16>
 8000a56:	1e03      	subs	r3, r0, #0
 8000a58:	d033      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x96, (uint16_t *) &dev->dig_P5)
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	330e      	adds	r3, #14
 8000a5e:	001a      	movs	r2, r3
 8000a60:	687b      	ldr	r3, [r7, #4]
 8000a62:	2196      	movs	r1, #150	; 0x96
 8000a64:	0018      	movs	r0, r3
 8000a66:	f7ff ff45 	bl	80008f4 <read_register16>
 8000a6a:	1e03      	subs	r3, r0, #0
 8000a6c:	d029      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x98, (uint16_t *) &dev->dig_P6)
 8000a6e:	687b      	ldr	r3, [r7, #4]
 8000a70:	3310      	adds	r3, #16
 8000a72:	001a      	movs	r2, r3
 8000a74:	687b      	ldr	r3, [r7, #4]
 8000a76:	2198      	movs	r1, #152	; 0x98
 8000a78:	0018      	movs	r0, r3
 8000a7a:	f7ff ff3b 	bl	80008f4 <read_register16>
 8000a7e:	1e03      	subs	r3, r0, #0
 8000a80:	d01f      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x9a, (uint16_t *) &dev->dig_P7)
 8000a82:	687b      	ldr	r3, [r7, #4]
 8000a84:	3312      	adds	r3, #18
 8000a86:	001a      	movs	r2, r3
 8000a88:	687b      	ldr	r3, [r7, #4]
 8000a8a:	219a      	movs	r1, #154	; 0x9a
 8000a8c:	0018      	movs	r0, r3
 8000a8e:	f7ff ff31 	bl	80008f4 <read_register16>
 8000a92:	1e03      	subs	r3, r0, #0
 8000a94:	d015      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x9c, (uint16_t *) &dev->dig_P8)
 8000a96:	687b      	ldr	r3, [r7, #4]
 8000a98:	3314      	adds	r3, #20
 8000a9a:	001a      	movs	r2, r3
 8000a9c:	687b      	ldr	r3, [r7, #4]
 8000a9e:	219c      	movs	r1, #156	; 0x9c
 8000aa0:	0018      	movs	r0, r3
 8000aa2:	f7ff ff27 	bl	80008f4 <read_register16>
 8000aa6:	1e03      	subs	r3, r0, #0
 8000aa8:	d00b      	beq.n	8000ac2 <read_calibration_data+0xf6>
			&& read_register16(dev, 0x9e,
					(uint16_t *) &dev->dig_P9)) {
 8000aaa:	687b      	ldr	r3, [r7, #4]
 8000aac:	3316      	adds	r3, #22
 8000aae:	001a      	movs	r2, r3
			&& read_register16(dev, 0x9e,
 8000ab0:	687b      	ldr	r3, [r7, #4]
 8000ab2:	219e      	movs	r1, #158	; 0x9e
 8000ab4:	0018      	movs	r0, r3
 8000ab6:	f7ff ff1d 	bl	80008f4 <read_register16>
 8000aba:	1e03      	subs	r3, r0, #0
 8000abc:	d001      	beq.n	8000ac2 <read_calibration_data+0xf6>

		return true;
 8000abe:	2301      	movs	r3, #1
 8000ac0:	e000      	b.n	8000ac4 <read_calibration_data+0xf8>
	}

	return false;
 8000ac2:	2300      	movs	r3, #0
}
 8000ac4:	0018      	movs	r0, r3
 8000ac6:	46bd      	mov	sp, r7
 8000ac8:	b002      	add	sp, #8
 8000aca:	bd80      	pop	{r7, pc}

08000acc <read_hum_calibration_data>:

static bool read_hum_calibration_data(BMP280_HandleTypedef *dev) {
 8000acc:	b5b0      	push	{r4, r5, r7, lr}
 8000ace:	b084      	sub	sp, #16
 8000ad0:	af00      	add	r7, sp, #0
 8000ad2:	6078      	str	r0, [r7, #4]
	uint16_t h4, h5;

	if (!read_data(dev, 0xa1, &dev->dig_H1, 1)
 8000ad4:	687b      	ldr	r3, [r7, #4]
 8000ad6:	3318      	adds	r3, #24
 8000ad8:	001a      	movs	r2, r3
 8000ada:	6878      	ldr	r0, [r7, #4]
 8000adc:	2301      	movs	r3, #1
 8000ade:	21a1      	movs	r1, #161	; 0xa1
 8000ae0:	f7ff ff40 	bl	8000964 <read_data>
 8000ae4:	1e03      	subs	r3, r0, #0
 8000ae6:	d14b      	bne.n	8000b80 <read_hum_calibration_data+0xb4>
			&& read_register16(dev, 0xe1, (uint16_t *) &dev->dig_H2)
 8000ae8:	687b      	ldr	r3, [r7, #4]
 8000aea:	331a      	adds	r3, #26
 8000aec:	001a      	movs	r2, r3
 8000aee:	687b      	ldr	r3, [r7, #4]
 8000af0:	21e1      	movs	r1, #225	; 0xe1
 8000af2:	0018      	movs	r0, r3
 8000af4:	f7ff fefe 	bl	80008f4 <read_register16>
 8000af8:	1e03      	subs	r3, r0, #0
 8000afa:	d041      	beq.n	8000b80 <read_hum_calibration_data+0xb4>
			&& !read_data(dev, 0xe3, &dev->dig_H3, 1)
 8000afc:	687b      	ldr	r3, [r7, #4]
 8000afe:	331c      	adds	r3, #28
 8000b00:	001a      	movs	r2, r3
 8000b02:	6878      	ldr	r0, [r7, #4]
 8000b04:	2301      	movs	r3, #1
 8000b06:	21e3      	movs	r1, #227	; 0xe3
 8000b08:	f7ff ff2c 	bl	8000964 <read_data>
 8000b0c:	1e03      	subs	r3, r0, #0
 8000b0e:	d137      	bne.n	8000b80 <read_hum_calibration_data+0xb4>
			&& read_register16(dev, 0xe4, &h4)
 8000b10:	240e      	movs	r4, #14
 8000b12:	193a      	adds	r2, r7, r4
 8000b14:	687b      	ldr	r3, [r7, #4]
 8000b16:	21e4      	movs	r1, #228	; 0xe4
 8000b18:	0018      	movs	r0, r3
 8000b1a:	f7ff feeb 	bl	80008f4 <read_register16>
 8000b1e:	1e03      	subs	r3, r0, #0
 8000b20:	d02e      	beq.n	8000b80 <read_hum_calibration_data+0xb4>
			&& read_register16(dev, 0xe5, &h5)
 8000b22:	250c      	movs	r5, #12
 8000b24:	197a      	adds	r2, r7, r5
 8000b26:	687b      	ldr	r3, [r7, #4]
 8000b28:	21e5      	movs	r1, #229	; 0xe5
 8000b2a:	0018      	movs	r0, r3
 8000b2c:	f7ff fee2 	bl	80008f4 <read_register16>
 8000b30:	1e03      	subs	r3, r0, #0
 8000b32:	d025      	beq.n	8000b80 <read_hum_calibration_data+0xb4>
			&& !read_data(dev, 0xe7, (uint8_t *) &dev->dig_H6, 1)) {
 8000b34:	687b      	ldr	r3, [r7, #4]
 8000b36:	3322      	adds	r3, #34	; 0x22
 8000b38:	001a      	movs	r2, r3
 8000b3a:	6878      	ldr	r0, [r7, #4]
 8000b3c:	2301      	movs	r3, #1
 8000b3e:	21e7      	movs	r1, #231	; 0xe7
 8000b40:	f7ff ff10 	bl	8000964 <read_data>
 8000b44:	1e03      	subs	r3, r0, #0
 8000b46:	d11b      	bne.n	8000b80 <read_hum_calibration_data+0xb4>
		dev->dig_H4 = (h4 & 0x00ff) << 4 | (h4 & 0x0f00) >> 8;
 8000b48:	193b      	adds	r3, r7, r4
 8000b4a:	881b      	ldrh	r3, [r3, #0]
 8000b4c:	011b      	lsls	r3, r3, #4
 8000b4e:	b21a      	sxth	r2, r3
 8000b50:	23ff      	movs	r3, #255	; 0xff
 8000b52:	011b      	lsls	r3, r3, #4
 8000b54:	4013      	ands	r3, r2
 8000b56:	b21a      	sxth	r2, r3
 8000b58:	193b      	adds	r3, r7, r4
 8000b5a:	881b      	ldrh	r3, [r3, #0]
 8000b5c:	121b      	asrs	r3, r3, #8
 8000b5e:	b21b      	sxth	r3, r3
 8000b60:	210f      	movs	r1, #15
 8000b62:	400b      	ands	r3, r1
 8000b64:	b21b      	sxth	r3, r3
 8000b66:	4313      	orrs	r3, r2
 8000b68:	b21a      	sxth	r2, r3
 8000b6a:	687b      	ldr	r3, [r7, #4]
 8000b6c:	83da      	strh	r2, [r3, #30]
		dev->dig_H5 = h5 >> 4;
 8000b6e:	197b      	adds	r3, r7, r5
 8000b70:	881b      	ldrh	r3, [r3, #0]
 8000b72:	091b      	lsrs	r3, r3, #4
 8000b74:	b29b      	uxth	r3, r3
 8000b76:	b21a      	sxth	r2, r3
 8000b78:	687b      	ldr	r3, [r7, #4]
 8000b7a:	841a      	strh	r2, [r3, #32]

		return true;
 8000b7c:	2301      	movs	r3, #1
 8000b7e:	e000      	b.n	8000b82 <read_hum_calibration_data+0xb6>
	}

	return false;
 8000b80:	2300      	movs	r3, #0
}
 8000b82:	0018      	movs	r0, r3
 8000b84:	46bd      	mov	sp, r7
 8000b86:	b004      	add	sp, #16
 8000b88:	bdb0      	pop	{r4, r5, r7, pc}
	...

08000b8c <write_register8>:

static int write_register8(BMP280_HandleTypedef *dev, uint8_t addr, uint8_t value) {
 8000b8c:	b580      	push	{r7, lr}
 8000b8e:	b088      	sub	sp, #32
 8000b90:	af04      	add	r7, sp, #16
 8000b92:	6078      	str	r0, [r7, #4]
 8000b94:	0008      	movs	r0, r1
 8000b96:	0011      	movs	r1, r2
 8000b98:	1cfb      	adds	r3, r7, #3
 8000b9a:	1c02      	adds	r2, r0, #0
 8000b9c:	701a      	strb	r2, [r3, #0]
 8000b9e:	1cbb      	adds	r3, r7, #2
 8000ba0:	1c0a      	adds	r2, r1, #0
 8000ba2:	701a      	strb	r2, [r3, #0]
	uint16_t tx_buff;

	tx_buff = (dev->addr << 1);
 8000ba4:	687b      	ldr	r3, [r7, #4]
 8000ba6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000ba8:	210e      	movs	r1, #14
 8000baa:	187a      	adds	r2, r7, r1
 8000bac:	18db      	adds	r3, r3, r3
 8000bae:	8013      	strh	r3, [r2, #0]

	if (HAL_I2C_Mem_Write(dev->i2c, tx_buff, addr, 1, &value, 1, 10000) == HAL_OK)
 8000bb0:	687b      	ldr	r3, [r7, #4]
 8000bb2:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8000bb4:	1cfb      	adds	r3, r7, #3
 8000bb6:	781b      	ldrb	r3, [r3, #0]
 8000bb8:	b29a      	uxth	r2, r3
 8000bba:	187b      	adds	r3, r7, r1
 8000bbc:	8819      	ldrh	r1, [r3, #0]
 8000bbe:	4b09      	ldr	r3, [pc, #36]	; (8000be4 <write_register8+0x58>)
 8000bc0:	9302      	str	r3, [sp, #8]
 8000bc2:	2301      	movs	r3, #1
 8000bc4:	9301      	str	r3, [sp, #4]
 8000bc6:	1cbb      	adds	r3, r7, #2
 8000bc8:	9300      	str	r3, [sp, #0]
 8000bca:	2301      	movs	r3, #1
 8000bcc:	f008 f8a8 	bl	8008d20 <HAL_I2C_Mem_Write>
 8000bd0:	1e03      	subs	r3, r0, #0
 8000bd2:	d101      	bne.n	8000bd8 <write_register8+0x4c>
		return false;
 8000bd4:	2300      	movs	r3, #0
 8000bd6:	e000      	b.n	8000bda <write_register8+0x4e>
	else
		return true;
 8000bd8:	2301      	movs	r3, #1
}
 8000bda:	0018      	movs	r0, r3
 8000bdc:	46bd      	mov	sp, r7
 8000bde:	b004      	add	sp, #16
 8000be0:	bd80      	pop	{r7, pc}
 8000be2:	46c0      	nop			; (mov r8, r8)
 8000be4:	00002710 	.word	0x00002710

08000be8 <bmp280_init>:

bool bmp280_init(BMP280_HandleTypedef *dev, bmp280_params_t *params) {
 8000be8:	b590      	push	{r4, r7, lr}
 8000bea:	b085      	sub	sp, #20
 8000bec:	af00      	add	r7, sp, #0
 8000bee:	6078      	str	r0, [r7, #4]
 8000bf0:	6039      	str	r1, [r7, #0]

	if (dev->addr != BMP280_I2C_ADDRESS_0
 8000bf2:	687b      	ldr	r3, [r7, #4]
 8000bf4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000bf6:	2b76      	cmp	r3, #118	; 0x76
 8000bf8:	d005      	beq.n	8000c06 <bmp280_init+0x1e>
			&& dev->addr != BMP280_I2C_ADDRESS_1) {
 8000bfa:	687b      	ldr	r3, [r7, #4]
 8000bfc:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000bfe:	2b77      	cmp	r3, #119	; 0x77
 8000c00:	d001      	beq.n	8000c06 <bmp280_init+0x1e>

		return false;
 8000c02:	2300      	movs	r3, #0
 8000c04:	e0a3      	b.n	8000d4e <bmp280_init+0x166>
	}

	if (read_data(dev, BMP280_REG_ID, &dev->id, 1)) {
 8000c06:	687b      	ldr	r3, [r7, #4]
 8000c08:	3332      	adds	r3, #50	; 0x32
 8000c0a:	001a      	movs	r2, r3
 8000c0c:	6878      	ldr	r0, [r7, #4]
 8000c0e:	2301      	movs	r3, #1
 8000c10:	21d0      	movs	r1, #208	; 0xd0
 8000c12:	f7ff fea7 	bl	8000964 <read_data>
 8000c16:	1e03      	subs	r3, r0, #0
 8000c18:	d001      	beq.n	8000c1e <bmp280_init+0x36>
		return false;
 8000c1a:	2300      	movs	r3, #0
 8000c1c:	e097      	b.n	8000d4e <bmp280_init+0x166>
	}

	if (dev->id != BMP280_CHIP_ID && dev->id != BME280_CHIP_ID) {
 8000c1e:	687b      	ldr	r3, [r7, #4]
 8000c20:	2232      	movs	r2, #50	; 0x32
 8000c22:	5c9b      	ldrb	r3, [r3, r2]
 8000c24:	2b58      	cmp	r3, #88	; 0x58
 8000c26:	d006      	beq.n	8000c36 <bmp280_init+0x4e>
 8000c28:	687b      	ldr	r3, [r7, #4]
 8000c2a:	2232      	movs	r2, #50	; 0x32
 8000c2c:	5c9b      	ldrb	r3, [r3, r2]
 8000c2e:	2b60      	cmp	r3, #96	; 0x60
 8000c30:	d001      	beq.n	8000c36 <bmp280_init+0x4e>

		return false;
 8000c32:	2300      	movs	r3, #0
 8000c34:	e08b      	b.n	8000d4e <bmp280_init+0x166>
	}

	// Soft reset.
	if (write_register8(dev, BMP280_REG_RESET, BMP280_RESET_VALUE)) {
 8000c36:	687b      	ldr	r3, [r7, #4]
 8000c38:	22b6      	movs	r2, #182	; 0xb6
 8000c3a:	21e0      	movs	r1, #224	; 0xe0
 8000c3c:	0018      	movs	r0, r3
 8000c3e:	f7ff ffa5 	bl	8000b8c <write_register8>
 8000c42:	1e03      	subs	r3, r0, #0
 8000c44:	d001      	beq.n	8000c4a <bmp280_init+0x62>
		return false;
 8000c46:	2300      	movs	r3, #0
 8000c48:	e081      	b.n	8000d4e <bmp280_init+0x166>
	}

	// Wait until finished copying over the NVP data.
	while (1) {
		uint8_t status;
		if (!read_data(dev, BMP280_REG_STATUS, &status, 1)
 8000c4a:	240c      	movs	r4, #12
 8000c4c:	193a      	adds	r2, r7, r4
 8000c4e:	6878      	ldr	r0, [r7, #4]
 8000c50:	2301      	movs	r3, #1
 8000c52:	21f3      	movs	r1, #243	; 0xf3
 8000c54:	f7ff fe86 	bl	8000964 <read_data>
 8000c58:	1e03      	subs	r3, r0, #0
 8000c5a:	d1f6      	bne.n	8000c4a <bmp280_init+0x62>
				&& (status & 1) == 0)
 8000c5c:	193b      	adds	r3, r7, r4
 8000c5e:	781b      	ldrb	r3, [r3, #0]
 8000c60:	001a      	movs	r2, r3
 8000c62:	2301      	movs	r3, #1
 8000c64:	4013      	ands	r3, r2
 8000c66:	d1f0      	bne.n	8000c4a <bmp280_init+0x62>
			break;
	}

	if (!read_calibration_data(dev)) {
 8000c68:	687b      	ldr	r3, [r7, #4]
 8000c6a:	0018      	movs	r0, r3
 8000c6c:	f7ff feae 	bl	80009cc <read_calibration_data>
 8000c70:	0003      	movs	r3, r0
 8000c72:	001a      	movs	r2, r3
 8000c74:	2301      	movs	r3, #1
 8000c76:	4053      	eors	r3, r2
 8000c78:	b2db      	uxtb	r3, r3
 8000c7a:	2b00      	cmp	r3, #0
 8000c7c:	d100      	bne.n	8000c80 <bmp280_init+0x98>
 8000c7e:	e001      	b.n	8000c84 <bmp280_init+0x9c>
		return false;
 8000c80:	2300      	movs	r3, #0
 8000c82:	e064      	b.n	8000d4e <bmp280_init+0x166>
	}

	if (dev->id == BME280_CHIP_ID && !read_hum_calibration_data(dev)) {
 8000c84:	687b      	ldr	r3, [r7, #4]
 8000c86:	2232      	movs	r2, #50	; 0x32
 8000c88:	5c9b      	ldrb	r3, [r3, r2]
 8000c8a:	2b60      	cmp	r3, #96	; 0x60
 8000c8c:	d10c      	bne.n	8000ca8 <bmp280_init+0xc0>
 8000c8e:	687b      	ldr	r3, [r7, #4]
 8000c90:	0018      	movs	r0, r3
 8000c92:	f7ff ff1b 	bl	8000acc <read_hum_calibration_data>
 8000c96:	0003      	movs	r3, r0
 8000c98:	001a      	movs	r2, r3
 8000c9a:	2301      	movs	r3, #1
 8000c9c:	4053      	eors	r3, r2
 8000c9e:	b2db      	uxtb	r3, r3
 8000ca0:	2b00      	cmp	r3, #0
 8000ca2:	d001      	beq.n	8000ca8 <bmp280_init+0xc0>
		return false;
 8000ca4:	2300      	movs	r3, #0
 8000ca6:	e052      	b.n	8000d4e <bmp280_init+0x166>
	}

	uint8_t config = (params->standby << 5) | (params->filter << 2);
 8000ca8:	683b      	ldr	r3, [r7, #0]
 8000caa:	795b      	ldrb	r3, [r3, #5]
 8000cac:	015b      	lsls	r3, r3, #5
 8000cae:	b25a      	sxtb	r2, r3
 8000cb0:	683b      	ldr	r3, [r7, #0]
 8000cb2:	785b      	ldrb	r3, [r3, #1]
 8000cb4:	009b      	lsls	r3, r3, #2
 8000cb6:	b25b      	sxtb	r3, r3
 8000cb8:	4313      	orrs	r3, r2
 8000cba:	b25a      	sxtb	r2, r3
 8000cbc:	210f      	movs	r1, #15
 8000cbe:	187b      	adds	r3, r7, r1
 8000cc0:	701a      	strb	r2, [r3, #0]
	if (write_register8(dev, BMP280_REG_CONFIG, config)) {
 8000cc2:	187b      	adds	r3, r7, r1
 8000cc4:	781a      	ldrb	r2, [r3, #0]
 8000cc6:	687b      	ldr	r3, [r7, #4]
 8000cc8:	21f5      	movs	r1, #245	; 0xf5
 8000cca:	0018      	movs	r0, r3
 8000ccc:	f7ff ff5e 	bl	8000b8c <write_register8>
 8000cd0:	1e03      	subs	r3, r0, #0
 8000cd2:	d001      	beq.n	8000cd8 <bmp280_init+0xf0>
		return false;
 8000cd4:	2300      	movs	r3, #0
 8000cd6:	e03a      	b.n	8000d4e <bmp280_init+0x166>
	}

	if (params->mode == BMP280_MODE_FORCED) {
 8000cd8:	683b      	ldr	r3, [r7, #0]
 8000cda:	781b      	ldrb	r3, [r3, #0]
 8000cdc:	2b01      	cmp	r3, #1
 8000cde:	d102      	bne.n	8000ce6 <bmp280_init+0xfe>
		params->mode = BMP280_MODE_SLEEP;  // initial mode for forced is sleep
 8000ce0:	683b      	ldr	r3, [r7, #0]
 8000ce2:	2200      	movs	r2, #0
 8000ce4:	701a      	strb	r2, [r3, #0]
	}

	uint8_t ctrl = (params->oversampling_temperature << 5)
 8000ce6:	683b      	ldr	r3, [r7, #0]
 8000ce8:	78db      	ldrb	r3, [r3, #3]
 8000cea:	015b      	lsls	r3, r3, #5
			| (params->oversampling_pressure << 2) | (params->mode);
 8000cec:	b25a      	sxtb	r2, r3
 8000cee:	683b      	ldr	r3, [r7, #0]
 8000cf0:	789b      	ldrb	r3, [r3, #2]
 8000cf2:	009b      	lsls	r3, r3, #2
 8000cf4:	b25b      	sxtb	r3, r3
 8000cf6:	4313      	orrs	r3, r2
 8000cf8:	b25a      	sxtb	r2, r3
 8000cfa:	683b      	ldr	r3, [r7, #0]
 8000cfc:	781b      	ldrb	r3, [r3, #0]
 8000cfe:	b25b      	sxtb	r3, r3
 8000d00:	4313      	orrs	r3, r2
 8000d02:	b25a      	sxtb	r2, r3
	uint8_t ctrl = (params->oversampling_temperature << 5)
 8000d04:	230e      	movs	r3, #14
 8000d06:	18fb      	adds	r3, r7, r3
 8000d08:	701a      	strb	r2, [r3, #0]

	if (dev->id == BME280_CHIP_ID) {
 8000d0a:	687b      	ldr	r3, [r7, #4]
 8000d0c:	2232      	movs	r2, #50	; 0x32
 8000d0e:	5c9b      	ldrb	r3, [r3, r2]
 8000d10:	2b60      	cmp	r3, #96	; 0x60
 8000d12:	d10f      	bne.n	8000d34 <bmp280_init+0x14c>
		// Write crtl hum reg first, only active after write to BMP280_REG_CTRL.
		uint8_t ctrl_hum = params->oversampling_humidity;
 8000d14:	210d      	movs	r1, #13
 8000d16:	187b      	adds	r3, r7, r1
 8000d18:	683a      	ldr	r2, [r7, #0]
 8000d1a:	7912      	ldrb	r2, [r2, #4]
 8000d1c:	701a      	strb	r2, [r3, #0]
		if (write_register8(dev, BMP280_REG_CTRL_HUM, ctrl_hum)) {
 8000d1e:	187b      	adds	r3, r7, r1
 8000d20:	781a      	ldrb	r2, [r3, #0]
 8000d22:	687b      	ldr	r3, [r7, #4]
 8000d24:	21f2      	movs	r1, #242	; 0xf2
 8000d26:	0018      	movs	r0, r3
 8000d28:	f7ff ff30 	bl	8000b8c <write_register8>
 8000d2c:	1e03      	subs	r3, r0, #0
 8000d2e:	d001      	beq.n	8000d34 <bmp280_init+0x14c>
			return false;
 8000d30:	2300      	movs	r3, #0
 8000d32:	e00c      	b.n	8000d4e <bmp280_init+0x166>
		}
	}

	if (write_register8(dev, BMP280_REG_CTRL, ctrl)) {
 8000d34:	230e      	movs	r3, #14
 8000d36:	18fb      	adds	r3, r7, r3
 8000d38:	781a      	ldrb	r2, [r3, #0]
 8000d3a:	687b      	ldr	r3, [r7, #4]
 8000d3c:	21f4      	movs	r1, #244	; 0xf4
 8000d3e:	0018      	movs	r0, r3
 8000d40:	f7ff ff24 	bl	8000b8c <write_register8>
 8000d44:	1e03      	subs	r3, r0, #0
 8000d46:	d001      	beq.n	8000d4c <bmp280_init+0x164>
		return false;
 8000d48:	2300      	movs	r3, #0
 8000d4a:	e000      	b.n	8000d4e <bmp280_init+0x166>
	}

	return true;
 8000d4c:	2301      	movs	r3, #1
}
 8000d4e:	0018      	movs	r0, r3
 8000d50:	46bd      	mov	sp, r7
 8000d52:	b005      	add	sp, #20
 8000d54:	bd90      	pop	{r4, r7, pc}

08000d56 <compensate_temperature>:
 * Compensation algorithm is taken from BMP280 datasheet.
 *
 * Return value is in degrees Celsius.
 */
static inline int32_t compensate_temperature(BMP280_HandleTypedef *dev, int32_t adc_temp,
		int32_t *fine_temp) {
 8000d56:	b580      	push	{r7, lr}
 8000d58:	b086      	sub	sp, #24
 8000d5a:	af00      	add	r7, sp, #0
 8000d5c:	60f8      	str	r0, [r7, #12]
 8000d5e:	60b9      	str	r1, [r7, #8]
 8000d60:	607a      	str	r2, [r7, #4]
	int32_t var1, var2;

	var1 = ((((adc_temp >> 3) - ((int32_t) dev->dig_T1 << 1)))
 8000d62:	68bb      	ldr	r3, [r7, #8]
 8000d64:	10da      	asrs	r2, r3, #3
 8000d66:	68fb      	ldr	r3, [r7, #12]
 8000d68:	881b      	ldrh	r3, [r3, #0]
 8000d6a:	005b      	lsls	r3, r3, #1
 8000d6c:	1ad3      	subs	r3, r2, r3
			* (int32_t) dev->dig_T2) >> 11;
 8000d6e:	68fa      	ldr	r2, [r7, #12]
 8000d70:	2102      	movs	r1, #2
 8000d72:	5e52      	ldrsh	r2, [r2, r1]
 8000d74:	4353      	muls	r3, r2
	var1 = ((((adc_temp >> 3) - ((int32_t) dev->dig_T1 << 1)))
 8000d76:	12db      	asrs	r3, r3, #11
 8000d78:	617b      	str	r3, [r7, #20]
	var2 = (((((adc_temp >> 4) - (int32_t) dev->dig_T1)
 8000d7a:	68bb      	ldr	r3, [r7, #8]
 8000d7c:	111b      	asrs	r3, r3, #4
 8000d7e:	68fa      	ldr	r2, [r7, #12]
 8000d80:	8812      	ldrh	r2, [r2, #0]
 8000d82:	1a9b      	subs	r3, r3, r2
			* ((adc_temp >> 4) - (int32_t) dev->dig_T1)) >> 12)
 8000d84:	68ba      	ldr	r2, [r7, #8]
 8000d86:	1112      	asrs	r2, r2, #4
 8000d88:	68f9      	ldr	r1, [r7, #12]
 8000d8a:	8809      	ldrh	r1, [r1, #0]
 8000d8c:	1a52      	subs	r2, r2, r1
 8000d8e:	4353      	muls	r3, r2
 8000d90:	131b      	asrs	r3, r3, #12
			* (int32_t) dev->dig_T3) >> 14;
 8000d92:	68fa      	ldr	r2, [r7, #12]
 8000d94:	2104      	movs	r1, #4
 8000d96:	5e52      	ldrsh	r2, [r2, r1]
 8000d98:	4353      	muls	r3, r2
	var2 = (((((adc_temp >> 4) - (int32_t) dev->dig_T1)
 8000d9a:	139b      	asrs	r3, r3, #14
 8000d9c:	613b      	str	r3, [r7, #16]

	*fine_temp = var1 + var2;
 8000d9e:	697a      	ldr	r2, [r7, #20]
 8000da0:	693b      	ldr	r3, [r7, #16]
 8000da2:	18d2      	adds	r2, r2, r3
 8000da4:	687b      	ldr	r3, [r7, #4]
 8000da6:	601a      	str	r2, [r3, #0]
	return (*fine_temp * 5 + 128) >> 8;
 8000da8:	687b      	ldr	r3, [r7, #4]
 8000daa:	681a      	ldr	r2, [r3, #0]
 8000dac:	0013      	movs	r3, r2
 8000dae:	009b      	lsls	r3, r3, #2
 8000db0:	189b      	adds	r3, r3, r2
 8000db2:	3380      	adds	r3, #128	; 0x80
 8000db4:	121b      	asrs	r3, r3, #8
}
 8000db6:	0018      	movs	r0, r3
 8000db8:	46bd      	mov	sp, r7
 8000dba:	b006      	add	sp, #24
 8000dbc:	bd80      	pop	{r7, pc}
	...

08000dc0 <compensate_pressure>:
 * Compensation algorithm is taken from BMP280 datasheet.
 *
 * Return value is in Pa, 24 integer bits and 8 fractional bits.
 */
static inline uint32_t compensate_pressure(BMP280_HandleTypedef *dev, int32_t adc_press,
		int32_t fine_temp) {
 8000dc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000dc2:	b0af      	sub	sp, #188	; 0xbc
 8000dc4:	af00      	add	r7, sp, #0
 8000dc6:	239c      	movs	r3, #156	; 0x9c
 8000dc8:	18fe      	adds	r6, r7, r3
 8000dca:	6030      	str	r0, [r6, #0]
 8000dcc:	2098      	movs	r0, #152	; 0x98
 8000dce:	1838      	adds	r0, r7, r0
 8000dd0:	6001      	str	r1, [r0, #0]
 8000dd2:	2194      	movs	r1, #148	; 0x94
 8000dd4:	1878      	adds	r0, r7, r1
 8000dd6:	6002      	str	r2, [r0, #0]
	int64_t var1, var2, p;

	var1 = (int64_t) fine_temp - 128000;
 8000dd8:	187a      	adds	r2, r7, r1
 8000dda:	6813      	ldr	r3, [r2, #0]
 8000ddc:	65bb      	str	r3, [r7, #88]	; 0x58
 8000dde:	17db      	asrs	r3, r3, #31
 8000de0:	65fb      	str	r3, [r7, #92]	; 0x5c
 8000de2:	4ace      	ldr	r2, [pc, #824]	; (800111c <compensate_pressure+0x35c>)
 8000de4:	2301      	movs	r3, #1
 8000de6:	425b      	negs	r3, r3
 8000de8:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8000dea:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8000dec:	1880      	adds	r0, r0, r2
 8000dee:	4159      	adcs	r1, r3
 8000df0:	0002      	movs	r2, r0
 8000df2:	000b      	movs	r3, r1
 8000df4:	26b0      	movs	r6, #176	; 0xb0
 8000df6:	19b9      	adds	r1, r7, r6
 8000df8:	600a      	str	r2, [r1, #0]
 8000dfa:	604b      	str	r3, [r1, #4]
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 8000dfc:	19ba      	adds	r2, r7, r6
 8000dfe:	6853      	ldr	r3, [r2, #4]
 8000e00:	6812      	ldr	r2, [r2, #0]
 8000e02:	19b9      	adds	r1, r7, r6
 8000e04:	6808      	ldr	r0, [r1, #0]
 8000e06:	6849      	ldr	r1, [r1, #4]
 8000e08:	f7ff fb38 	bl	800047c <__aeabi_lmul>
 8000e0c:	0002      	movs	r2, r0
 8000e0e:	000b      	movs	r3, r1
 8000e10:	0010      	movs	r0, r2
 8000e12:	0019      	movs	r1, r3
 8000e14:	239c      	movs	r3, #156	; 0x9c
 8000e16:	18fa      	adds	r2, r7, r3
 8000e18:	6813      	ldr	r3, [r2, #0]
 8000e1a:	2210      	movs	r2, #16
 8000e1c:	5e9b      	ldrsh	r3, [r3, r2]
 8000e1e:	653b      	str	r3, [r7, #80]	; 0x50
 8000e20:	17db      	asrs	r3, r3, #31
 8000e22:	657b      	str	r3, [r7, #84]	; 0x54
 8000e24:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8000e26:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8000e28:	f7ff fb28 	bl	800047c <__aeabi_lmul>
 8000e2c:	0002      	movs	r2, r0
 8000e2e:	000b      	movs	r3, r1
 8000e30:	21a8      	movs	r1, #168	; 0xa8
 8000e32:	1878      	adds	r0, r7, r1
 8000e34:	6002      	str	r2, [r0, #0]
 8000e36:	6043      	str	r3, [r0, #4]
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 8000e38:	239c      	movs	r3, #156	; 0x9c
 8000e3a:	18fa      	adds	r2, r7, r3
 8000e3c:	6813      	ldr	r3, [r2, #0]
 8000e3e:	220e      	movs	r2, #14
 8000e40:	5e9b      	ldrsh	r3, [r3, r2]
 8000e42:	64bb      	str	r3, [r7, #72]	; 0x48
 8000e44:	17db      	asrs	r3, r3, #31
 8000e46:	64fb      	str	r3, [r7, #76]	; 0x4c
 8000e48:	19ba      	adds	r2, r7, r6
 8000e4a:	6853      	ldr	r3, [r2, #4]
 8000e4c:	6812      	ldr	r2, [r2, #0]
 8000e4e:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8000e50:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8000e52:	f7ff fb13 	bl	800047c <__aeabi_lmul>
 8000e56:	0002      	movs	r2, r0
 8000e58:	000b      	movs	r3, r1
 8000e5a:	0bd1      	lsrs	r1, r2, #15
 8000e5c:	045d      	lsls	r5, r3, #17
 8000e5e:	430d      	orrs	r5, r1
 8000e60:	0454      	lsls	r4, r2, #17
 8000e62:	21a8      	movs	r1, #168	; 0xa8
 8000e64:	187a      	adds	r2, r7, r1
 8000e66:	6853      	ldr	r3, [r2, #4]
 8000e68:	6812      	ldr	r2, [r2, #0]
 8000e6a:	1912      	adds	r2, r2, r4
 8000e6c:	416b      	adcs	r3, r5
 8000e6e:	1878      	adds	r0, r7, r1
 8000e70:	6002      	str	r2, [r0, #0]
 8000e72:	6043      	str	r3, [r0, #4]
	var2 = var2 + (((int64_t) dev->dig_P4) << 35);
 8000e74:	259c      	movs	r5, #156	; 0x9c
 8000e76:	197b      	adds	r3, r7, r5
 8000e78:	681b      	ldr	r3, [r3, #0]
 8000e7a:	220c      	movs	r2, #12
 8000e7c:	5e9b      	ldrsh	r3, [r3, r2]
 8000e7e:	643b      	str	r3, [r7, #64]	; 0x40
 8000e80:	17db      	asrs	r3, r3, #31
 8000e82:	647b      	str	r3, [r7, #68]	; 0x44
 8000e84:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8000e86:	00db      	lsls	r3, r3, #3
 8000e88:	63fb      	str	r3, [r7, #60]	; 0x3c
 8000e8a:	2300      	movs	r3, #0
 8000e8c:	63bb      	str	r3, [r7, #56]	; 0x38
 8000e8e:	000c      	movs	r4, r1
 8000e90:	187b      	adds	r3, r7, r1
 8000e92:	681a      	ldr	r2, [r3, #0]
 8000e94:	685b      	ldr	r3, [r3, #4]
 8000e96:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8000e98:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8000e9a:	1812      	adds	r2, r2, r0
 8000e9c:	414b      	adcs	r3, r1
 8000e9e:	1939      	adds	r1, r7, r4
 8000ea0:	600a      	str	r2, [r1, #0]
 8000ea2:	604b      	str	r3, [r1, #4]
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 8000ea4:	0034      	movs	r4, r6
 8000ea6:	193b      	adds	r3, r7, r4
 8000ea8:	681a      	ldr	r2, [r3, #0]
 8000eaa:	685b      	ldr	r3, [r3, #4]
 8000eac:	1939      	adds	r1, r7, r4
 8000eae:	6808      	ldr	r0, [r1, #0]
 8000eb0:	6849      	ldr	r1, [r1, #4]
 8000eb2:	f7ff fae3 	bl	800047c <__aeabi_lmul>
 8000eb6:	0002      	movs	r2, r0
 8000eb8:	000b      	movs	r3, r1
 8000eba:	0010      	movs	r0, r2
 8000ebc:	0019      	movs	r1, r3
 8000ebe:	197b      	adds	r3, r7, r5
 8000ec0:	681b      	ldr	r3, [r3, #0]
 8000ec2:	220a      	movs	r2, #10
 8000ec4:	5e9b      	ldrsh	r3, [r3, r2]
 8000ec6:	633b      	str	r3, [r7, #48]	; 0x30
 8000ec8:	17db      	asrs	r3, r3, #31
 8000eca:	637b      	str	r3, [r7, #52]	; 0x34
 8000ecc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8000ece:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000ed0:	f7ff fad4 	bl	800047c <__aeabi_lmul>
 8000ed4:	0002      	movs	r2, r0
 8000ed6:	000b      	movs	r3, r1
 8000ed8:	0619      	lsls	r1, r3, #24
 8000eda:	468c      	mov	ip, r1
 8000edc:	0a10      	lsrs	r0, r2, #8
 8000ede:	2688      	movs	r6, #136	; 0x88
 8000ee0:	19b9      	adds	r1, r7, r6
 8000ee2:	6008      	str	r0, [r1, #0]
 8000ee4:	19b8      	adds	r0, r7, r6
 8000ee6:	6800      	ldr	r0, [r0, #0]
 8000ee8:	4661      	mov	r1, ip
 8000eea:	4308      	orrs	r0, r1
 8000eec:	19b9      	adds	r1, r7, r6
 8000eee:	6008      	str	r0, [r1, #0]
 8000ef0:	121b      	asrs	r3, r3, #8
 8000ef2:	228c      	movs	r2, #140	; 0x8c
 8000ef4:	18ba      	adds	r2, r7, r2
 8000ef6:	6013      	str	r3, [r2, #0]
			+ ((var1 * (int64_t) dev->dig_P2) << 12);
 8000ef8:	197b      	adds	r3, r7, r5
 8000efa:	681b      	ldr	r3, [r3, #0]
 8000efc:	2208      	movs	r2, #8
 8000efe:	5e9b      	ldrsh	r3, [r3, r2]
 8000f00:	62bb      	str	r3, [r7, #40]	; 0x28
 8000f02:	17db      	asrs	r3, r3, #31
 8000f04:	62fb      	str	r3, [r7, #44]	; 0x2c
 8000f06:	193b      	adds	r3, r7, r4
 8000f08:	681a      	ldr	r2, [r3, #0]
 8000f0a:	685b      	ldr	r3, [r3, #4]
 8000f0c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8000f0e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8000f10:	f7ff fab4 	bl	800047c <__aeabi_lmul>
 8000f14:	0002      	movs	r2, r0
 8000f16:	000b      	movs	r3, r1
 8000f18:	0d11      	lsrs	r1, r2, #20
 8000f1a:	468c      	mov	ip, r1
 8000f1c:	0318      	lsls	r0, r3, #12
 8000f1e:	2184      	movs	r1, #132	; 0x84
 8000f20:	1879      	adds	r1, r7, r1
 8000f22:	6008      	str	r0, [r1, #0]
 8000f24:	2084      	movs	r0, #132	; 0x84
 8000f26:	1839      	adds	r1, r7, r0
 8000f28:	6808      	ldr	r0, [r1, #0]
 8000f2a:	4661      	mov	r1, ip
 8000f2c:	4308      	orrs	r0, r1
 8000f2e:	2184      	movs	r1, #132	; 0x84
 8000f30:	1879      	adds	r1, r7, r1
 8000f32:	6008      	str	r0, [r1, #0]
 8000f34:	0313      	lsls	r3, r2, #12
 8000f36:	2180      	movs	r1, #128	; 0x80
 8000f38:	187a      	adds	r2, r7, r1
 8000f3a:	6013      	str	r3, [r2, #0]
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 8000f3c:	19bb      	adds	r3, r7, r6
 8000f3e:	681a      	ldr	r2, [r3, #0]
 8000f40:	685b      	ldr	r3, [r3, #4]
 8000f42:	1879      	adds	r1, r7, r1
 8000f44:	6808      	ldr	r0, [r1, #0]
 8000f46:	6849      	ldr	r1, [r1, #4]
 8000f48:	1812      	adds	r2, r2, r0
 8000f4a:	414b      	adcs	r3, r1
 8000f4c:	1939      	adds	r1, r7, r4
 8000f4e:	600a      	str	r2, [r1, #0]
 8000f50:	604b      	str	r3, [r1, #4]
	var1 = (((int64_t) 1 << 47) + var1) * ((int64_t) dev->dig_P1) >> 33;
 8000f52:	193b      	adds	r3, r7, r4
 8000f54:	6818      	ldr	r0, [r3, #0]
 8000f56:	6859      	ldr	r1, [r3, #4]
 8000f58:	2200      	movs	r2, #0
 8000f5a:	2380      	movs	r3, #128	; 0x80
 8000f5c:	021b      	lsls	r3, r3, #8
 8000f5e:	1880      	adds	r0, r0, r2
 8000f60:	4159      	adcs	r1, r3
 8000f62:	197b      	adds	r3, r7, r5
 8000f64:	681b      	ldr	r3, [r3, #0]
 8000f66:	88db      	ldrh	r3, [r3, #6]
 8000f68:	623b      	str	r3, [r7, #32]
 8000f6a:	2300      	movs	r3, #0
 8000f6c:	627b      	str	r3, [r7, #36]	; 0x24
 8000f6e:	6a3a      	ldr	r2, [r7, #32]
 8000f70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f72:	f7ff fa83 	bl	800047c <__aeabi_lmul>
 8000f76:	0002      	movs	r2, r0
 8000f78:	000b      	movs	r3, r1
 8000f7a:	1059      	asrs	r1, r3, #1
 8000f7c:	1938      	adds	r0, r7, r4
 8000f7e:	6001      	str	r1, [r0, #0]
 8000f80:	17db      	asrs	r3, r3, #31
 8000f82:	21b4      	movs	r1, #180	; 0xb4
 8000f84:	187a      	adds	r2, r7, r1
 8000f86:	6013      	str	r3, [r2, #0]

	if (var1 == 0) {
 8000f88:	193b      	adds	r3, r7, r4
 8000f8a:	681a      	ldr	r2, [r3, #0]
 8000f8c:	187b      	adds	r3, r7, r1
 8000f8e:	681b      	ldr	r3, [r3, #0]
 8000f90:	431a      	orrs	r2, r3
 8000f92:	d101      	bne.n	8000f98 <compensate_pressure+0x1d8>
		return 0;  // avoid exception caused by division by zero
 8000f94:	2300      	movs	r3, #0
 8000f96:	e0bc      	b.n	8001112 <compensate_pressure+0x352>
	}

	p = 1048576 - adc_press;
 8000f98:	2398      	movs	r3, #152	; 0x98
 8000f9a:	18fb      	adds	r3, r7, r3
 8000f9c:	681a      	ldr	r2, [r3, #0]
 8000f9e:	2380      	movs	r3, #128	; 0x80
 8000fa0:	035b      	lsls	r3, r3, #13
 8000fa2:	1a9b      	subs	r3, r3, r2
 8000fa4:	24a0      	movs	r4, #160	; 0xa0
 8000fa6:	193a      	adds	r2, r7, r4
 8000fa8:	6013      	str	r3, [r2, #0]
 8000faa:	17db      	asrs	r3, r3, #31
 8000fac:	25a4      	movs	r5, #164	; 0xa4
 8000fae:	197a      	adds	r2, r7, r5
 8000fb0:	6013      	str	r3, [r2, #0]
	p = (((p << 31) - var2) * 3125) / var1;
 8000fb2:	193b      	adds	r3, r7, r4
 8000fb4:	681b      	ldr	r3, [r3, #0]
 8000fb6:	105b      	asrs	r3, r3, #1
 8000fb8:	61fb      	str	r3, [r7, #28]
 8000fba:	193b      	adds	r3, r7, r4
 8000fbc:	681b      	ldr	r3, [r3, #0]
 8000fbe:	07db      	lsls	r3, r3, #31
 8000fc0:	61bb      	str	r3, [r7, #24]
 8000fc2:	20a8      	movs	r0, #168	; 0xa8
 8000fc4:	183a      	adds	r2, r7, r0
 8000fc6:	6853      	ldr	r3, [r2, #4]
 8000fc8:	6812      	ldr	r2, [r2, #0]
 8000fca:	69b8      	ldr	r0, [r7, #24]
 8000fcc:	69f9      	ldr	r1, [r7, #28]
 8000fce:	1a80      	subs	r0, r0, r2
 8000fd0:	4199      	sbcs	r1, r3
 8000fd2:	4a53      	ldr	r2, [pc, #332]	; (8001120 <compensate_pressure+0x360>)
 8000fd4:	2300      	movs	r3, #0
 8000fd6:	f7ff fa51 	bl	800047c <__aeabi_lmul>
 8000fda:	0002      	movs	r2, r0
 8000fdc:	000b      	movs	r3, r1
 8000fde:	0010      	movs	r0, r2
 8000fe0:	0019      	movs	r1, r3
 8000fe2:	23b0      	movs	r3, #176	; 0xb0
 8000fe4:	18fa      	adds	r2, r7, r3
 8000fe6:	6853      	ldr	r3, [r2, #4]
 8000fe8:	6812      	ldr	r2, [r2, #0]
 8000fea:	f7ff fa03 	bl	80003f4 <__aeabi_ldivmod>
 8000fee:	0002      	movs	r2, r0
 8000ff0:	000b      	movs	r3, r1
 8000ff2:	1939      	adds	r1, r7, r4
 8000ff4:	600a      	str	r2, [r1, #0]
 8000ff6:	604b      	str	r3, [r1, #4]
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8000ff8:	269c      	movs	r6, #156	; 0x9c
 8000ffa:	19ba      	adds	r2, r7, r6
 8000ffc:	6813      	ldr	r3, [r2, #0]
 8000ffe:	2216      	movs	r2, #22
 8001000:	5e9b      	ldrsh	r3, [r3, r2]
 8001002:	613b      	str	r3, [r7, #16]
 8001004:	17db      	asrs	r3, r3, #31
 8001006:	617b      	str	r3, [r7, #20]
 8001008:	197a      	adds	r2, r7, r5
 800100a:	6813      	ldr	r3, [r2, #0]
 800100c:	04da      	lsls	r2, r3, #19
 800100e:	1939      	adds	r1, r7, r4
 8001010:	680b      	ldr	r3, [r1, #0]
 8001012:	0b5b      	lsrs	r3, r3, #13
 8001014:	67bb      	str	r3, [r7, #120]	; 0x78
 8001016:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8001018:	4313      	orrs	r3, r2
 800101a:	67bb      	str	r3, [r7, #120]	; 0x78
 800101c:	197a      	adds	r2, r7, r5
 800101e:	6813      	ldr	r3, [r2, #0]
 8001020:	135b      	asrs	r3, r3, #13
 8001022:	67fb      	str	r3, [r7, #124]	; 0x7c
 8001024:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8001026:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8001028:	6938      	ldr	r0, [r7, #16]
 800102a:	6979      	ldr	r1, [r7, #20]
 800102c:	f7ff fa26 	bl	800047c <__aeabi_lmul>
 8001030:	0002      	movs	r2, r0
 8001032:	000b      	movs	r3, r1
 8001034:	0010      	movs	r0, r2
 8001036:	0019      	movs	r1, r3
 8001038:	197a      	adds	r2, r7, r5
 800103a:	6813      	ldr	r3, [r2, #0]
 800103c:	04da      	lsls	r2, r3, #19
 800103e:	193b      	adds	r3, r7, r4
 8001040:	681b      	ldr	r3, [r3, #0]
 8001042:	0b5b      	lsrs	r3, r3, #13
 8001044:	673b      	str	r3, [r7, #112]	; 0x70
 8001046:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001048:	4313      	orrs	r3, r2
 800104a:	673b      	str	r3, [r7, #112]	; 0x70
 800104c:	197a      	adds	r2, r7, r5
 800104e:	6813      	ldr	r3, [r2, #0]
 8001050:	135b      	asrs	r3, r3, #13
 8001052:	677b      	str	r3, [r7, #116]	; 0x74
 8001054:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8001056:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8001058:	f7ff fa10 	bl	800047c <__aeabi_lmul>
 800105c:	0002      	movs	r2, r0
 800105e:	000b      	movs	r3, r1
 8001060:	01d9      	lsls	r1, r3, #7
 8001062:	0e50      	lsrs	r0, r2, #25
 8001064:	4301      	orrs	r1, r0
 8001066:	25b0      	movs	r5, #176	; 0xb0
 8001068:	1978      	adds	r0, r7, r5
 800106a:	6001      	str	r1, [r0, #0]
 800106c:	165b      	asrs	r3, r3, #25
 800106e:	22b4      	movs	r2, #180	; 0xb4
 8001070:	18ba      	adds	r2, r7, r2
 8001072:	6013      	str	r3, [r2, #0]
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8001074:	19ba      	adds	r2, r7, r6
 8001076:	6813      	ldr	r3, [r2, #0]
 8001078:	2214      	movs	r2, #20
 800107a:	5e9b      	ldrsh	r3, [r3, r2]
 800107c:	60bb      	str	r3, [r7, #8]
 800107e:	17db      	asrs	r3, r3, #31
 8001080:	60fb      	str	r3, [r7, #12]
 8001082:	193a      	adds	r2, r7, r4
 8001084:	6853      	ldr	r3, [r2, #4]
 8001086:	6812      	ldr	r2, [r2, #0]
 8001088:	68b8      	ldr	r0, [r7, #8]
 800108a:	68f9      	ldr	r1, [r7, #12]
 800108c:	f7ff f9f6 	bl	800047c <__aeabi_lmul>
 8001090:	0002      	movs	r2, r0
 8001092:	000b      	movs	r3, r1
 8001094:	0359      	lsls	r1, r3, #13
 8001096:	0cd0      	lsrs	r0, r2, #19
 8001098:	4301      	orrs	r1, r0
 800109a:	20a8      	movs	r0, #168	; 0xa8
 800109c:	1838      	adds	r0, r7, r0
 800109e:	6001      	str	r1, [r0, #0]
 80010a0:	14db      	asrs	r3, r3, #19
 80010a2:	22ac      	movs	r2, #172	; 0xac
 80010a4:	18ba      	adds	r2, r7, r2
 80010a6:	6013      	str	r3, [r2, #0]

	p = ((p + var1 + var2) >> 8) + ((int64_t) dev->dig_P7 << 4);
 80010a8:	193a      	adds	r2, r7, r4
 80010aa:	6810      	ldr	r0, [r2, #0]
 80010ac:	6851      	ldr	r1, [r2, #4]
 80010ae:	197a      	adds	r2, r7, r5
 80010b0:	6853      	ldr	r3, [r2, #4]
 80010b2:	6812      	ldr	r2, [r2, #0]
 80010b4:	1880      	adds	r0, r0, r2
 80010b6:	4159      	adcs	r1, r3
 80010b8:	23a8      	movs	r3, #168	; 0xa8
 80010ba:	18fb      	adds	r3, r7, r3
 80010bc:	681a      	ldr	r2, [r3, #0]
 80010be:	685b      	ldr	r3, [r3, #4]
 80010c0:	1812      	adds	r2, r2, r0
 80010c2:	414b      	adcs	r3, r1
 80010c4:	0619      	lsls	r1, r3, #24
 80010c6:	0a10      	lsrs	r0, r2, #8
 80010c8:	66b8      	str	r0, [r7, #104]	; 0x68
 80010ca:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 80010cc:	4308      	orrs	r0, r1
 80010ce:	66b8      	str	r0, [r7, #104]	; 0x68
 80010d0:	121b      	asrs	r3, r3, #8
 80010d2:	66fb      	str	r3, [r7, #108]	; 0x6c
 80010d4:	19bb      	adds	r3, r7, r6
 80010d6:	681b      	ldr	r3, [r3, #0]
 80010d8:	2212      	movs	r2, #18
 80010da:	5e9b      	ldrsh	r3, [r3, r2]
 80010dc:	603b      	str	r3, [r7, #0]
 80010de:	17db      	asrs	r3, r3, #31
 80010e0:	607b      	str	r3, [r7, #4]
 80010e2:	6839      	ldr	r1, [r7, #0]
 80010e4:	687a      	ldr	r2, [r7, #4]
 80010e6:	000b      	movs	r3, r1
 80010e8:	0f1b      	lsrs	r3, r3, #28
 80010ea:	0010      	movs	r0, r2
 80010ec:	0100      	lsls	r0, r0, #4
 80010ee:	6678      	str	r0, [r7, #100]	; 0x64
 80010f0:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80010f2:	4318      	orrs	r0, r3
 80010f4:	6678      	str	r0, [r7, #100]	; 0x64
 80010f6:	000b      	movs	r3, r1
 80010f8:	011b      	lsls	r3, r3, #4
 80010fa:	663b      	str	r3, [r7, #96]	; 0x60
 80010fc:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80010fe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8001100:	6e38      	ldr	r0, [r7, #96]	; 0x60
 8001102:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8001104:	1812      	adds	r2, r2, r0
 8001106:	414b      	adcs	r3, r1
 8001108:	1939      	adds	r1, r7, r4
 800110a:	600a      	str	r2, [r1, #0]
 800110c:	604b      	str	r3, [r1, #4]
	return p;
 800110e:	193b      	adds	r3, r7, r4
 8001110:	681b      	ldr	r3, [r3, #0]
}
 8001112:	0018      	movs	r0, r3
 8001114:	46bd      	mov	sp, r7
 8001116:	b02f      	add	sp, #188	; 0xbc
 8001118:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800111a:	46c0      	nop			; (mov r8, r8)
 800111c:	fffe0c00 	.word	0xfffe0c00
 8001120:	00000c35 	.word	0x00000c35

08001124 <compensate_humidity>:
 * Compensation algorithm is taken from BME280 datasheet.
 *
 * Return value is in Pa, 24 integer bits and 8 fractional bits.
 */
static inline uint32_t compensate_humidity(BMP280_HandleTypedef *dev, int32_t adc_hum,
		int32_t fine_temp) {
 8001124:	b580      	push	{r7, lr}
 8001126:	b086      	sub	sp, #24
 8001128:	af00      	add	r7, sp, #0
 800112a:	60f8      	str	r0, [r7, #12]
 800112c:	60b9      	str	r1, [r7, #8]
 800112e:	607a      	str	r2, [r7, #4]
	int32_t v_x1_u32r;

	v_x1_u32r = fine_temp - (int32_t) 76800;
 8001130:	687b      	ldr	r3, [r7, #4]
 8001132:	4a2c      	ldr	r2, [pc, #176]	; (80011e4 <compensate_humidity+0xc0>)
 8001134:	4694      	mov	ip, r2
 8001136:	4463      	add	r3, ip
 8001138:	617b      	str	r3, [r7, #20]
	v_x1_u32r = ((((adc_hum << 14) - ((int32_t) dev->dig_H4 << 20)
 800113a:	68bb      	ldr	r3, [r7, #8]
 800113c:	039a      	lsls	r2, r3, #14
 800113e:	68fb      	ldr	r3, [r7, #12]
 8001140:	211e      	movs	r1, #30
 8001142:	5e5b      	ldrsh	r3, [r3, r1]
 8001144:	051b      	lsls	r3, r3, #20
 8001146:	1ad2      	subs	r2, r2, r3
			- ((int32_t) dev->dig_H5 * v_x1_u32r)) + (int32_t) 16384) >> 15)
 8001148:	68fb      	ldr	r3, [r7, #12]
 800114a:	2120      	movs	r1, #32
 800114c:	5e5b      	ldrsh	r3, [r3, r1]
 800114e:	0019      	movs	r1, r3
 8001150:	697b      	ldr	r3, [r7, #20]
 8001152:	434b      	muls	r3, r1
 8001154:	1ad3      	subs	r3, r2, r3
 8001156:	2280      	movs	r2, #128	; 0x80
 8001158:	01d2      	lsls	r2, r2, #7
 800115a:	4694      	mov	ip, r2
 800115c:	4463      	add	r3, ip
 800115e:	13db      	asrs	r3, r3, #15
			* (((((((v_x1_u32r * (int32_t) dev->dig_H6) >> 10)
 8001160:	68fa      	ldr	r2, [r7, #12]
 8001162:	2122      	movs	r1, #34	; 0x22
 8001164:	5652      	ldrsb	r2, [r2, r1]
 8001166:	0011      	movs	r1, r2
 8001168:	697a      	ldr	r2, [r7, #20]
 800116a:	434a      	muls	r2, r1
 800116c:	1292      	asrs	r2, r2, #10
					* (((v_x1_u32r * (int32_t) dev->dig_H3) >> 11)
 800116e:	68f9      	ldr	r1, [r7, #12]
 8001170:	7f09      	ldrb	r1, [r1, #28]
 8001172:	0008      	movs	r0, r1
 8001174:	6979      	ldr	r1, [r7, #20]
 8001176:	4341      	muls	r1, r0
 8001178:	12c9      	asrs	r1, r1, #11
							+ (int32_t) 32768)) >> 10) + (int32_t) 2097152)
 800117a:	2080      	movs	r0, #128	; 0x80
 800117c:	0200      	lsls	r0, r0, #8
 800117e:	4684      	mov	ip, r0
 8001180:	4461      	add	r1, ip
					* (((v_x1_u32r * (int32_t) dev->dig_H3) >> 11)
 8001182:	434a      	muls	r2, r1
							+ (int32_t) 32768)) >> 10) + (int32_t) 2097152)
 8001184:	1292      	asrs	r2, r2, #10
 8001186:	2180      	movs	r1, #128	; 0x80
 8001188:	0389      	lsls	r1, r1, #14
 800118a:	468c      	mov	ip, r1
 800118c:	4462      	add	r2, ip
					* (int32_t) dev->dig_H2 + 8192) >> 14);
 800118e:	68f9      	ldr	r1, [r7, #12]
 8001190:	201a      	movs	r0, #26
 8001192:	5e09      	ldrsh	r1, [r1, r0]
 8001194:	434a      	muls	r2, r1
 8001196:	2180      	movs	r1, #128	; 0x80
 8001198:	0189      	lsls	r1, r1, #6
 800119a:	468c      	mov	ip, r1
 800119c:	4462      	add	r2, ip
 800119e:	1392      	asrs	r2, r2, #14
	v_x1_u32r = ((((adc_hum << 14) - ((int32_t) dev->dig_H4 << 20)
 80011a0:	4353      	muls	r3, r2
 80011a2:	617b      	str	r3, [r7, #20]
	v_x1_u32r = v_x1_u32r
			- (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7)
 80011a4:	697b      	ldr	r3, [r7, #20]
 80011a6:	13db      	asrs	r3, r3, #15
 80011a8:	697a      	ldr	r2, [r7, #20]
 80011aa:	13d2      	asrs	r2, r2, #15
 80011ac:	4353      	muls	r3, r2
 80011ae:	11db      	asrs	r3, r3, #7
					* (int32_t) dev->dig_H1) >> 4);
 80011b0:	68fa      	ldr	r2, [r7, #12]
 80011b2:	7e12      	ldrb	r2, [r2, #24]
 80011b4:	4353      	muls	r3, r2
 80011b6:	111b      	asrs	r3, r3, #4
	v_x1_u32r = v_x1_u32r
 80011b8:	697a      	ldr	r2, [r7, #20]
 80011ba:	1ad3      	subs	r3, r2, r3
 80011bc:	617b      	str	r3, [r7, #20]
	v_x1_u32r = v_x1_u32r < 0 ? 0 : v_x1_u32r;
 80011be:	697b      	ldr	r3, [r7, #20]
 80011c0:	2b00      	cmp	r3, #0
 80011c2:	da00      	bge.n	80011c6 <compensate_humidity+0xa2>
 80011c4:	2300      	movs	r3, #0
 80011c6:	617b      	str	r3, [r7, #20]
	v_x1_u32r = v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r;
 80011c8:	697b      	ldr	r3, [r7, #20]
 80011ca:	22c8      	movs	r2, #200	; 0xc8
 80011cc:	0552      	lsls	r2, r2, #21
 80011ce:	4293      	cmp	r3, r2
 80011d0:	dd01      	ble.n	80011d6 <compensate_humidity+0xb2>
 80011d2:	23c8      	movs	r3, #200	; 0xc8
 80011d4:	055b      	lsls	r3, r3, #21
 80011d6:	617b      	str	r3, [r7, #20]
	return v_x1_u32r >> 12;
 80011d8:	697b      	ldr	r3, [r7, #20]
 80011da:	131b      	asrs	r3, r3, #12
}
 80011dc:	0018      	movs	r0, r3
 80011de:	46bd      	mov	sp, r7
 80011e0:	b006      	add	sp, #24
 80011e2:	bd80      	pop	{r7, pc}
 80011e4:	fffed400 	.word	0xfffed400

080011e8 <bmp280_read_fixed>:

bool bmp280_read_fixed(BMP280_HandleTypedef *dev, int32_t *temperature, uint32_t *pressure, uint32_t *humidity) {
 80011e8:	b580      	push	{r7, lr}
 80011ea:	b08c      	sub	sp, #48	; 0x30
 80011ec:	af00      	add	r7, sp, #0
 80011ee:	60f8      	str	r0, [r7, #12]
 80011f0:	60b9      	str	r1, [r7, #8]
 80011f2:	607a      	str	r2, [r7, #4]
 80011f4:	603b      	str	r3, [r7, #0]
	int32_t adc_temp;
	int32_t adc_humidity;
	uint8_t data[8];

	// Need to read in one sequence to ensure they match.
	size_t size = 8;
 80011f6:	2308      	movs	r3, #8
 80011f8:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (read_data(dev, 0xf7, data, size)) {
 80011fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80011fc:	b2db      	uxtb	r3, r3
 80011fe:	2218      	movs	r2, #24
 8001200:	18ba      	adds	r2, r7, r2
 8001202:	68f8      	ldr	r0, [r7, #12]
 8001204:	21f7      	movs	r1, #247	; 0xf7
 8001206:	f7ff fbad 	bl	8000964 <read_data>
 800120a:	1e03      	subs	r3, r0, #0
 800120c:	d001      	beq.n	8001212 <bmp280_read_fixed+0x2a>
		return false;
 800120e:	2300      	movs	r3, #0
 8001210:	e03e      	b.n	8001290 <bmp280_read_fixed+0xa8>
	}

	adc_pressure = data[0] << 12 | data[1] << 4 | data[2] >> 4;
 8001212:	2118      	movs	r1, #24
 8001214:	187b      	adds	r3, r7, r1
 8001216:	781b      	ldrb	r3, [r3, #0]
 8001218:	031a      	lsls	r2, r3, #12
 800121a:	187b      	adds	r3, r7, r1
 800121c:	785b      	ldrb	r3, [r3, #1]
 800121e:	011b      	lsls	r3, r3, #4
 8001220:	4313      	orrs	r3, r2
 8001222:	187a      	adds	r2, r7, r1
 8001224:	7892      	ldrb	r2, [r2, #2]
 8001226:	0912      	lsrs	r2, r2, #4
 8001228:	b2d2      	uxtb	r2, r2
 800122a:	4313      	orrs	r3, r2
 800122c:	62bb      	str	r3, [r7, #40]	; 0x28
	adc_temp = data[3] << 12 | data[4] << 4 | data[5] >> 4;
 800122e:	187b      	adds	r3, r7, r1
 8001230:	78db      	ldrb	r3, [r3, #3]
 8001232:	031a      	lsls	r2, r3, #12
 8001234:	187b      	adds	r3, r7, r1
 8001236:	791b      	ldrb	r3, [r3, #4]
 8001238:	011b      	lsls	r3, r3, #4
 800123a:	4313      	orrs	r3, r2
 800123c:	187a      	adds	r2, r7, r1
 800123e:	7952      	ldrb	r2, [r2, #5]
 8001240:	0912      	lsrs	r2, r2, #4
 8001242:	b2d2      	uxtb	r2, r2
 8001244:	4313      	orrs	r3, r2
 8001246:	627b      	str	r3, [r7, #36]	; 0x24
	adc_humidity = data[6] << 8 | data[7];
 8001248:	187b      	adds	r3, r7, r1
 800124a:	799b      	ldrb	r3, [r3, #6]
 800124c:	021b      	lsls	r3, r3, #8
 800124e:	187a      	adds	r2, r7, r1
 8001250:	79d2      	ldrb	r2, [r2, #7]
 8001252:	4313      	orrs	r3, r2
 8001254:	623b      	str	r3, [r7, #32]

	int32_t fine_temp;
	*temperature = compensate_temperature(dev, adc_temp, &fine_temp);
 8001256:	2314      	movs	r3, #20
 8001258:	18fa      	adds	r2, r7, r3
 800125a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800125c:	68fb      	ldr	r3, [r7, #12]
 800125e:	0018      	movs	r0, r3
 8001260:	f7ff fd79 	bl	8000d56 <compensate_temperature>
 8001264:	0002      	movs	r2, r0
 8001266:	68bb      	ldr	r3, [r7, #8]
 8001268:	601a      	str	r2, [r3, #0]
	*pressure = compensate_pressure(dev, adc_pressure, fine_temp);
 800126a:	697a      	ldr	r2, [r7, #20]
 800126c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800126e:	68fb      	ldr	r3, [r7, #12]
 8001270:	0018      	movs	r0, r3
 8001272:	f7ff fda5 	bl	8000dc0 <compensate_pressure>
 8001276:	0002      	movs	r2, r0
 8001278:	687b      	ldr	r3, [r7, #4]
 800127a:	601a      	str	r2, [r3, #0]
	*humidity = compensate_humidity(dev, adc_humidity, fine_temp);
 800127c:	697a      	ldr	r2, [r7, #20]
 800127e:	6a39      	ldr	r1, [r7, #32]
 8001280:	68fb      	ldr	r3, [r7, #12]
 8001282:	0018      	movs	r0, r3
 8001284:	f7ff ff4e 	bl	8001124 <compensate_humidity>
 8001288:	0002      	movs	r2, r0
 800128a:	683b      	ldr	r3, [r7, #0]
 800128c:	601a      	str	r2, [r3, #0]

	return true;
 800128e:	2301      	movs	r3, #1
}
 8001290:	0018      	movs	r0, r3
 8001292:	46bd      	mov	sp, r7
 8001294:	b00c      	add	sp, #48	; 0x30
 8001296:	bd80      	pop	{r7, pc}

08001298 <aesroundkeys>:
u4_t AESAUX[16/sizeof(u4_t)];
u4_t AESKEY[11*16/sizeof(u4_t)];

// generate 1+10 roundkeys for encryption with 128-bit key
// read 128-bit key from AESKEY in MSBF, generate roundkey words in place
static void aesroundkeys () {
 8001298:	b580      	push	{r7, lr}
 800129a:	b082      	sub	sp, #8
 800129c:	af00      	add	r7, sp, #0
    int i;
    u4_t b;

    for( i=0; i<4; i++) {
 800129e:	2300      	movs	r3, #0
 80012a0:	607b      	str	r3, [r7, #4]
 80012a2:	e024      	b.n	80012ee <aesroundkeys+0x56>
        AESKEY[i] = swapmsbf(AESKEY[i]);
 80012a4:	4b37      	ldr	r3, [pc, #220]	; (8001384 <aesroundkeys+0xec>)
 80012a6:	687a      	ldr	r2, [r7, #4]
 80012a8:	0092      	lsls	r2, r2, #2
 80012aa:	58d3      	ldr	r3, [r2, r3]
 80012ac:	061a      	lsls	r2, r3, #24
 80012ae:	4b35      	ldr	r3, [pc, #212]	; (8001384 <aesroundkeys+0xec>)
 80012b0:	6879      	ldr	r1, [r7, #4]
 80012b2:	0089      	lsls	r1, r1, #2
 80012b4:	58cb      	ldr	r3, [r1, r3]
 80012b6:	0219      	lsls	r1, r3, #8
 80012b8:	23ff      	movs	r3, #255	; 0xff
 80012ba:	041b      	lsls	r3, r3, #16
 80012bc:	400b      	ands	r3, r1
 80012be:	431a      	orrs	r2, r3
 80012c0:	4b30      	ldr	r3, [pc, #192]	; (8001384 <aesroundkeys+0xec>)
 80012c2:	6879      	ldr	r1, [r7, #4]
 80012c4:	0089      	lsls	r1, r1, #2
 80012c6:	58cb      	ldr	r3, [r1, r3]
 80012c8:	0a19      	lsrs	r1, r3, #8
 80012ca:	23ff      	movs	r3, #255	; 0xff
 80012cc:	021b      	lsls	r3, r3, #8
 80012ce:	400b      	ands	r3, r1
 80012d0:	431a      	orrs	r2, r3
 80012d2:	4b2c      	ldr	r3, [pc, #176]	; (8001384 <aesroundkeys+0xec>)
 80012d4:	6879      	ldr	r1, [r7, #4]
 80012d6:	0089      	lsls	r1, r1, #2
 80012d8:	58cb      	ldr	r3, [r1, r3]
 80012da:	0e1b      	lsrs	r3, r3, #24
 80012dc:	431a      	orrs	r2, r3
 80012de:	0011      	movs	r1, r2
 80012e0:	4b28      	ldr	r3, [pc, #160]	; (8001384 <aesroundkeys+0xec>)
 80012e2:	687a      	ldr	r2, [r7, #4]
 80012e4:	0092      	lsls	r2, r2, #2
 80012e6:	50d1      	str	r1, [r2, r3]
    for( i=0; i<4; i++) {
 80012e8:	687b      	ldr	r3, [r7, #4]
 80012ea:	3301      	adds	r3, #1
 80012ec:	607b      	str	r3, [r7, #4]
 80012ee:	687b      	ldr	r3, [r7, #4]
 80012f0:	2b03      	cmp	r3, #3
 80012f2:	ddd7      	ble.n	80012a4 <aesroundkeys+0xc>
    }
    
    b = AESKEY[3];
 80012f4:	4b23      	ldr	r3, [pc, #140]	; (8001384 <aesroundkeys+0xec>)
 80012f6:	68db      	ldr	r3, [r3, #12]
 80012f8:	603b      	str	r3, [r7, #0]
    for( ; i<44; i++ ) {
 80012fa:	e03b      	b.n	8001374 <aesroundkeys+0xdc>
        if( i%4==0 ) {
 80012fc:	687b      	ldr	r3, [r7, #4]
 80012fe:	2203      	movs	r2, #3
 8001300:	4013      	ands	r3, r2
 8001302:	d127      	bne.n	8001354 <aesroundkeys+0xbc>
            // b = SubWord(RotWord(b)) xor Rcon[i/4]
            b = (AES_S[u1(b >> 16)] << 24) ^
 8001304:	683b      	ldr	r3, [r7, #0]
 8001306:	0c1b      	lsrs	r3, r3, #16
 8001308:	b2db      	uxtb	r3, r3
 800130a:	001a      	movs	r2, r3
 800130c:	4b1e      	ldr	r3, [pc, #120]	; (8001388 <aesroundkeys+0xf0>)
 800130e:	5c9b      	ldrb	r3, [r3, r2]
 8001310:	061a      	lsls	r2, r3, #24
                (AES_S[u1(b >>  8)] << 16) ^
 8001312:	683b      	ldr	r3, [r7, #0]
 8001314:	0a1b      	lsrs	r3, r3, #8
 8001316:	b2db      	uxtb	r3, r3
 8001318:	0019      	movs	r1, r3
 800131a:	4b1b      	ldr	r3, [pc, #108]	; (8001388 <aesroundkeys+0xf0>)
 800131c:	5c5b      	ldrb	r3, [r3, r1]
 800131e:	041b      	lsls	r3, r3, #16
            b = (AES_S[u1(b >> 16)] << 24) ^
 8001320:	405a      	eors	r2, r3
                (AES_S[u1(b)      ] <<  8) ^
 8001322:	683b      	ldr	r3, [r7, #0]
 8001324:	b2db      	uxtb	r3, r3
 8001326:	0019      	movs	r1, r3
 8001328:	4b17      	ldr	r3, [pc, #92]	; (8001388 <aesroundkeys+0xf0>)
 800132a:	5c5b      	ldrb	r3, [r3, r1]
 800132c:	021b      	lsls	r3, r3, #8
                (AES_S[u1(b >>  8)] << 16) ^
 800132e:	4053      	eors	r3, r2
                (AES_S[   b >> 24 ]      ) ^
 8001330:	683a      	ldr	r2, [r7, #0]
 8001332:	0e12      	lsrs	r2, r2, #24
 8001334:	4914      	ldr	r1, [pc, #80]	; (8001388 <aesroundkeys+0xf0>)
 8001336:	5c8a      	ldrb	r2, [r1, r2]
                (AES_S[u1(b)      ] <<  8) ^
 8001338:	4053      	eors	r3, r2
 800133a:	0019      	movs	r1, r3
                 AES_RCON[(i-4)/4];
 800133c:	687b      	ldr	r3, [r7, #4]
 800133e:	3b04      	subs	r3, #4
 8001340:	2b00      	cmp	r3, #0
 8001342:	da00      	bge.n	8001346 <aesroundkeys+0xae>
 8001344:	3303      	adds	r3, #3
 8001346:	109b      	asrs	r3, r3, #2
 8001348:	001a      	movs	r2, r3
 800134a:	4b10      	ldr	r3, [pc, #64]	; (800138c <aesroundkeys+0xf4>)
 800134c:	0092      	lsls	r2, r2, #2
 800134e:	58d3      	ldr	r3, [r2, r3]
            b = (AES_S[u1(b >> 16)] << 24) ^
 8001350:	404b      	eors	r3, r1
 8001352:	603b      	str	r3, [r7, #0]
        }
        AESKEY[i] = b ^= AESKEY[i-4];
 8001354:	687b      	ldr	r3, [r7, #4]
 8001356:	1f1a      	subs	r2, r3, #4
 8001358:	4b0a      	ldr	r3, [pc, #40]	; (8001384 <aesroundkeys+0xec>)
 800135a:	0092      	lsls	r2, r2, #2
 800135c:	58d3      	ldr	r3, [r2, r3]
 800135e:	683a      	ldr	r2, [r7, #0]
 8001360:	4053      	eors	r3, r2
 8001362:	603b      	str	r3, [r7, #0]
 8001364:	4b07      	ldr	r3, [pc, #28]	; (8001384 <aesroundkeys+0xec>)
 8001366:	687a      	ldr	r2, [r7, #4]
 8001368:	0092      	lsls	r2, r2, #2
 800136a:	6839      	ldr	r1, [r7, #0]
 800136c:	50d1      	str	r1, [r2, r3]
    for( ; i<44; i++ ) {
 800136e:	687b      	ldr	r3, [r7, #4]
 8001370:	3301      	adds	r3, #1
 8001372:	607b      	str	r3, [r7, #4]
 8001374:	687b      	ldr	r3, [r7, #4]
 8001376:	2b2b      	cmp	r3, #43	; 0x2b
 8001378:	ddc0      	ble.n	80012fc <aesroundkeys+0x64>
    }
}
 800137a:	46c0      	nop			; (mov r8, r8)
 800137c:	46c0      	nop			; (mov r8, r8)
 800137e:	46bd      	mov	sp, r7
 8001380:	b002      	add	sp, #8
 8001382:	bd80      	pop	{r7, pc}
 8001384:	200000a0 	.word	0x200000a0
 8001388:	0800dfe4 	.word	0x0800dfe4
 800138c:	0800dfbc 	.word	0x0800dfbc

08001390 <os_aes>:

u4_t os_aes (u1_t mode, xref2u1_t buf, u2_t len) {
 8001390:	b580      	push	{r7, lr}
 8001392:	b08c      	sub	sp, #48	; 0x30
 8001394:	af00      	add	r7, sp, #0
 8001396:	6039      	str	r1, [r7, #0]
 8001398:	0011      	movs	r1, r2
 800139a:	1dfb      	adds	r3, r7, #7
 800139c:	1c02      	adds	r2, r0, #0
 800139e:	701a      	strb	r2, [r3, #0]
 80013a0:	1d3b      	adds	r3, r7, #4
 80013a2:	1c0a      	adds	r2, r1, #0
 80013a4:	801a      	strh	r2, [r3, #0]
        
        aesroundkeys();
 80013a6:	f7ff ff77 	bl	8001298 <aesroundkeys>

        if( mode & AES_MICNOAUX ) {
 80013aa:	1dfb      	adds	r3, r7, #7
 80013ac:	781b      	ldrb	r3, [r3, #0]
 80013ae:	2208      	movs	r2, #8
 80013b0:	4013      	ands	r3, r2
 80013b2:	d010      	beq.n	80013d6 <os_aes+0x46>
            AESAUX[0] = AESAUX[1] = AESAUX[2] = AESAUX[3] = 0;
 80013b4:	4b60      	ldr	r3, [pc, #384]	; (8001538 <os_aes+0x1a8>)
 80013b6:	2200      	movs	r2, #0
 80013b8:	60da      	str	r2, [r3, #12]
 80013ba:	4b5f      	ldr	r3, [pc, #380]	; (8001538 <os_aes+0x1a8>)
 80013bc:	68da      	ldr	r2, [r3, #12]
 80013be:	4b5e      	ldr	r3, [pc, #376]	; (8001538 <os_aes+0x1a8>)
 80013c0:	609a      	str	r2, [r3, #8]
 80013c2:	4b5d      	ldr	r3, [pc, #372]	; (8001538 <os_aes+0x1a8>)
 80013c4:	689a      	ldr	r2, [r3, #8]
 80013c6:	4b5c      	ldr	r3, [pc, #368]	; (8001538 <os_aes+0x1a8>)
 80013c8:	605a      	str	r2, [r3, #4]
 80013ca:	4b5b      	ldr	r3, [pc, #364]	; (8001538 <os_aes+0x1a8>)
 80013cc:	685a      	ldr	r2, [r3, #4]
 80013ce:	4b5a      	ldr	r3, [pc, #360]	; (8001538 <os_aes+0x1a8>)
 80013d0:	601a      	str	r2, [r3, #0]
 80013d2:	f000 fcb6 	bl	8001d42 <os_aes+0x9b2>
        } else {
            AESAUX[0] = swapmsbf(AESAUX[0]);
 80013d6:	4b58      	ldr	r3, [pc, #352]	; (8001538 <os_aes+0x1a8>)
 80013d8:	681b      	ldr	r3, [r3, #0]
 80013da:	061a      	lsls	r2, r3, #24
 80013dc:	4b56      	ldr	r3, [pc, #344]	; (8001538 <os_aes+0x1a8>)
 80013de:	681b      	ldr	r3, [r3, #0]
 80013e0:	0219      	lsls	r1, r3, #8
 80013e2:	23ff      	movs	r3, #255	; 0xff
 80013e4:	041b      	lsls	r3, r3, #16
 80013e6:	400b      	ands	r3, r1
 80013e8:	431a      	orrs	r2, r3
 80013ea:	4b53      	ldr	r3, [pc, #332]	; (8001538 <os_aes+0x1a8>)
 80013ec:	681b      	ldr	r3, [r3, #0]
 80013ee:	0a19      	lsrs	r1, r3, #8
 80013f0:	23ff      	movs	r3, #255	; 0xff
 80013f2:	021b      	lsls	r3, r3, #8
 80013f4:	400b      	ands	r3, r1
 80013f6:	431a      	orrs	r2, r3
 80013f8:	4b4f      	ldr	r3, [pc, #316]	; (8001538 <os_aes+0x1a8>)
 80013fa:	681b      	ldr	r3, [r3, #0]
 80013fc:	0e1b      	lsrs	r3, r3, #24
 80013fe:	431a      	orrs	r2, r3
 8001400:	4b4d      	ldr	r3, [pc, #308]	; (8001538 <os_aes+0x1a8>)
 8001402:	601a      	str	r2, [r3, #0]
            AESAUX[1] = swapmsbf(AESAUX[1]);
 8001404:	4b4c      	ldr	r3, [pc, #304]	; (8001538 <os_aes+0x1a8>)
 8001406:	685b      	ldr	r3, [r3, #4]
 8001408:	061a      	lsls	r2, r3, #24
 800140a:	4b4b      	ldr	r3, [pc, #300]	; (8001538 <os_aes+0x1a8>)
 800140c:	685b      	ldr	r3, [r3, #4]
 800140e:	0219      	lsls	r1, r3, #8
 8001410:	23ff      	movs	r3, #255	; 0xff
 8001412:	041b      	lsls	r3, r3, #16
 8001414:	400b      	ands	r3, r1
 8001416:	431a      	orrs	r2, r3
 8001418:	4b47      	ldr	r3, [pc, #284]	; (8001538 <os_aes+0x1a8>)
 800141a:	685b      	ldr	r3, [r3, #4]
 800141c:	0a19      	lsrs	r1, r3, #8
 800141e:	23ff      	movs	r3, #255	; 0xff
 8001420:	021b      	lsls	r3, r3, #8
 8001422:	400b      	ands	r3, r1
 8001424:	431a      	orrs	r2, r3
 8001426:	4b44      	ldr	r3, [pc, #272]	; (8001538 <os_aes+0x1a8>)
 8001428:	685b      	ldr	r3, [r3, #4]
 800142a:	0e1b      	lsrs	r3, r3, #24
 800142c:	431a      	orrs	r2, r3
 800142e:	4b42      	ldr	r3, [pc, #264]	; (8001538 <os_aes+0x1a8>)
 8001430:	605a      	str	r2, [r3, #4]
            AESAUX[2] = swapmsbf(AESAUX[2]);
 8001432:	4b41      	ldr	r3, [pc, #260]	; (8001538 <os_aes+0x1a8>)
 8001434:	689b      	ldr	r3, [r3, #8]
 8001436:	061a      	lsls	r2, r3, #24
 8001438:	4b3f      	ldr	r3, [pc, #252]	; (8001538 <os_aes+0x1a8>)
 800143a:	689b      	ldr	r3, [r3, #8]
 800143c:	0219      	lsls	r1, r3, #8
 800143e:	23ff      	movs	r3, #255	; 0xff
 8001440:	041b      	lsls	r3, r3, #16
 8001442:	400b      	ands	r3, r1
 8001444:	431a      	orrs	r2, r3
 8001446:	4b3c      	ldr	r3, [pc, #240]	; (8001538 <os_aes+0x1a8>)
 8001448:	689b      	ldr	r3, [r3, #8]
 800144a:	0a19      	lsrs	r1, r3, #8
 800144c:	23ff      	movs	r3, #255	; 0xff
 800144e:	021b      	lsls	r3, r3, #8
 8001450:	400b      	ands	r3, r1
 8001452:	431a      	orrs	r2, r3
 8001454:	4b38      	ldr	r3, [pc, #224]	; (8001538 <os_aes+0x1a8>)
 8001456:	689b      	ldr	r3, [r3, #8]
 8001458:	0e1b      	lsrs	r3, r3, #24
 800145a:	431a      	orrs	r2, r3
 800145c:	4b36      	ldr	r3, [pc, #216]	; (8001538 <os_aes+0x1a8>)
 800145e:	609a      	str	r2, [r3, #8]
            AESAUX[3] = swapmsbf(AESAUX[3]);
 8001460:	4b35      	ldr	r3, [pc, #212]	; (8001538 <os_aes+0x1a8>)
 8001462:	68db      	ldr	r3, [r3, #12]
 8001464:	061a      	lsls	r2, r3, #24
 8001466:	4b34      	ldr	r3, [pc, #208]	; (8001538 <os_aes+0x1a8>)
 8001468:	68db      	ldr	r3, [r3, #12]
 800146a:	0219      	lsls	r1, r3, #8
 800146c:	23ff      	movs	r3, #255	; 0xff
 800146e:	041b      	lsls	r3, r3, #16
 8001470:	400b      	ands	r3, r1
 8001472:	431a      	orrs	r2, r3
 8001474:	4b30      	ldr	r3, [pc, #192]	; (8001538 <os_aes+0x1a8>)
 8001476:	68db      	ldr	r3, [r3, #12]
 8001478:	0a19      	lsrs	r1, r3, #8
 800147a:	23ff      	movs	r3, #255	; 0xff
 800147c:	021b      	lsls	r3, r3, #8
 800147e:	400b      	ands	r3, r1
 8001480:	431a      	orrs	r2, r3
 8001482:	4b2d      	ldr	r3, [pc, #180]	; (8001538 <os_aes+0x1a8>)
 8001484:	68db      	ldr	r3, [r3, #12]
 8001486:	0e1b      	lsrs	r3, r3, #24
 8001488:	431a      	orrs	r2, r3
 800148a:	4b2b      	ldr	r3, [pc, #172]	; (8001538 <os_aes+0x1a8>)
 800148c:	60da      	str	r2, [r3, #12]
        }

        while( (signed char)len > 0 ) {
 800148e:	f000 fc58 	bl	8001d42 <os_aes+0x9b2>
            u4_t a0, a1, a2, a3;
            u4_t t0, t1, t2, t3;
            u4_t *ki, *ke;

            // load input block
            if( (mode & AES_CTR) || ((mode & AES_MIC) && (mode & AES_MICNOAUX)==0) ) { // load CTR block or first MIC block
 8001492:	1dfb      	adds	r3, r7, #7
 8001494:	781b      	ldrb	r3, [r3, #0]
 8001496:	2204      	movs	r2, #4
 8001498:	4013      	ands	r3, r2
 800149a:	d109      	bne.n	80014b0 <os_aes+0x120>
 800149c:	1dfb      	adds	r3, r7, #7
 800149e:	781b      	ldrb	r3, [r3, #0]
 80014a0:	2202      	movs	r2, #2
 80014a2:	4013      	ands	r3, r2
 80014a4:	d011      	beq.n	80014ca <os_aes+0x13a>
 80014a6:	1dfb      	adds	r3, r7, #7
 80014a8:	781b      	ldrb	r3, [r3, #0]
 80014aa:	2208      	movs	r2, #8
 80014ac:	4013      	ands	r3, r2
 80014ae:	d10c      	bne.n	80014ca <os_aes+0x13a>
                a0 = AESAUX[0];
 80014b0:	4b21      	ldr	r3, [pc, #132]	; (8001538 <os_aes+0x1a8>)
 80014b2:	681b      	ldr	r3, [r3, #0]
 80014b4:	62fb      	str	r3, [r7, #44]	; 0x2c
                a1 = AESAUX[1];
 80014b6:	4b20      	ldr	r3, [pc, #128]	; (8001538 <os_aes+0x1a8>)
 80014b8:	685b      	ldr	r3, [r3, #4]
 80014ba:	62bb      	str	r3, [r7, #40]	; 0x28
                a2 = AESAUX[2];
 80014bc:	4b1e      	ldr	r3, [pc, #120]	; (8001538 <os_aes+0x1a8>)
 80014be:	689b      	ldr	r3, [r3, #8]
 80014c0:	627b      	str	r3, [r7, #36]	; 0x24
                a3 = AESAUX[3];
 80014c2:	4b1d      	ldr	r3, [pc, #116]	; (8001538 <os_aes+0x1a8>)
 80014c4:	68db      	ldr	r3, [r3, #12]
 80014c6:	623b      	str	r3, [r7, #32]
 80014c8:	e067      	b.n	800159a <os_aes+0x20a>
            }
            else if( (mode & AES_MIC) && len <= 16 ) { // last MIC block
 80014ca:	1dfb      	adds	r3, r7, #7
 80014cc:	781b      	ldrb	r3, [r3, #0]
 80014ce:	2202      	movs	r2, #2
 80014d0:	4013      	ands	r3, r2
 80014d2:	d01a      	beq.n	800150a <os_aes+0x17a>
 80014d4:	1d3b      	adds	r3, r7, #4
 80014d6:	881b      	ldrh	r3, [r3, #0]
 80014d8:	2b10      	cmp	r3, #16
 80014da:	d816      	bhi.n	800150a <os_aes+0x17a>
                a0 = a1 = a2 = a3 = 0; // load null block
 80014dc:	2300      	movs	r3, #0
 80014de:	623b      	str	r3, [r7, #32]
 80014e0:	6a3b      	ldr	r3, [r7, #32]
 80014e2:	627b      	str	r3, [r7, #36]	; 0x24
 80014e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80014e6:	62bb      	str	r3, [r7, #40]	; 0x28
 80014e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80014ea:	62fb      	str	r3, [r7, #44]	; 0x2c
                mode |= ((len == 16) ? 1 : 2) << 4; // set MICSUB: CMAC subkey K1 or K2
 80014ec:	1d3b      	adds	r3, r7, #4
 80014ee:	881b      	ldrh	r3, [r3, #0]
 80014f0:	2b10      	cmp	r3, #16
 80014f2:	d101      	bne.n	80014f8 <os_aes+0x168>
 80014f4:	2310      	movs	r3, #16
 80014f6:	e000      	b.n	80014fa <os_aes+0x16a>
 80014f8:	2320      	movs	r3, #32
 80014fa:	1dfa      	adds	r2, r7, #7
 80014fc:	7812      	ldrb	r2, [r2, #0]
 80014fe:	b252      	sxtb	r2, r2
 8001500:	4313      	orrs	r3, r2
 8001502:	b25a      	sxtb	r2, r3
 8001504:	1dfb      	adds	r3, r7, #7
 8001506:	701a      	strb	r2, [r3, #0]
 8001508:	e047      	b.n	800159a <os_aes+0x20a>
            } else
        LOADDATA: { // load data block (partially)
 800150a:	46c0      	nop			; (mov r8, r8)
                for(t0=0; t0<16; t0++) {
 800150c:	2300      	movs	r3, #0
 800150e:	61fb      	str	r3, [r7, #28]
 8001510:	e027      	b.n	8001562 <os_aes+0x1d2>
                    t1 = (t1<<8) | ((t0<len) ? buf[t0] : (t0==len) ? 0x80 : 0x00);
 8001512:	69bb      	ldr	r3, [r7, #24]
 8001514:	021a      	lsls	r2, r3, #8
 8001516:	1d3b      	adds	r3, r7, #4
 8001518:	881b      	ldrh	r3, [r3, #0]
 800151a:	69f9      	ldr	r1, [r7, #28]
 800151c:	4299      	cmp	r1, r3
 800151e:	d204      	bcs.n	800152a <os_aes+0x19a>
 8001520:	6839      	ldr	r1, [r7, #0]
 8001522:	69fb      	ldr	r3, [r7, #28]
 8001524:	18cb      	adds	r3, r1, r3
 8001526:	781b      	ldrb	r3, [r3, #0]
 8001528:	e009      	b.n	800153e <os_aes+0x1ae>
 800152a:	1d3b      	adds	r3, r7, #4
 800152c:	881b      	ldrh	r3, [r3, #0]
 800152e:	69f9      	ldr	r1, [r7, #28]
 8001530:	4299      	cmp	r1, r3
 8001532:	d103      	bne.n	800153c <os_aes+0x1ac>
 8001534:	2380      	movs	r3, #128	; 0x80
 8001536:	e002      	b.n	800153e <os_aes+0x1ae>
 8001538:	20000150 	.word	0x20000150
 800153c:	2300      	movs	r3, #0
 800153e:	4313      	orrs	r3, r2
 8001540:	61bb      	str	r3, [r7, #24]
                    if((t0&3)==3) {
 8001542:	69fb      	ldr	r3, [r7, #28]
 8001544:	2203      	movs	r2, #3
 8001546:	4013      	ands	r3, r2
 8001548:	2b03      	cmp	r3, #3
 800154a:	d107      	bne.n	800155c <os_aes+0x1cc>
                        a0 = a1;
 800154c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800154e:	62fb      	str	r3, [r7, #44]	; 0x2c
                        a1 = a2;
 8001550:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001552:	62bb      	str	r3, [r7, #40]	; 0x28
                        a2 = a3;
 8001554:	6a3b      	ldr	r3, [r7, #32]
 8001556:	627b      	str	r3, [r7, #36]	; 0x24
                        a3 = t1;
 8001558:	69bb      	ldr	r3, [r7, #24]
 800155a:	623b      	str	r3, [r7, #32]
                for(t0=0; t0<16; t0++) {
 800155c:	69fb      	ldr	r3, [r7, #28]
 800155e:	3301      	adds	r3, #1
 8001560:	61fb      	str	r3, [r7, #28]
 8001562:	69fb      	ldr	r3, [r7, #28]
 8001564:	2b0f      	cmp	r3, #15
 8001566:	d9d4      	bls.n	8001512 <os_aes+0x182>
                    }
                } 
                if( mode & AES_MIC ) {
 8001568:	1dfb      	adds	r3, r7, #7
 800156a:	781b      	ldrb	r3, [r3, #0]
 800156c:	2202      	movs	r2, #2
 800156e:	4013      	ands	r3, r2
 8001570:	d013      	beq.n	800159a <os_aes+0x20a>
                    a0 ^= AESAUX[0];
 8001572:	4bfe      	ldr	r3, [pc, #1016]	; (800196c <os_aes+0x5dc>)
 8001574:	681b      	ldr	r3, [r3, #0]
 8001576:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001578:	4053      	eors	r3, r2
 800157a:	62fb      	str	r3, [r7, #44]	; 0x2c
                    a1 ^= AESAUX[1];
 800157c:	4bfb      	ldr	r3, [pc, #1004]	; (800196c <os_aes+0x5dc>)
 800157e:	685b      	ldr	r3, [r3, #4]
 8001580:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001582:	4053      	eors	r3, r2
 8001584:	62bb      	str	r3, [r7, #40]	; 0x28
                    a2 ^= AESAUX[2];
 8001586:	4bf9      	ldr	r3, [pc, #996]	; (800196c <os_aes+0x5dc>)
 8001588:	689b      	ldr	r3, [r3, #8]
 800158a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800158c:	4053      	eors	r3, r2
 800158e:	627b      	str	r3, [r7, #36]	; 0x24
                    a3 ^= AESAUX[3];
 8001590:	4bf6      	ldr	r3, [pc, #984]	; (800196c <os_aes+0x5dc>)
 8001592:	68db      	ldr	r3, [r3, #12]
 8001594:	6a3a      	ldr	r2, [r7, #32]
 8001596:	4053      	eors	r3, r2
 8001598:	623b      	str	r3, [r7, #32]
                }
            }

            // perform AES encryption on block in a0-a3
            ki = AESKEY;
 800159a:	4bf5      	ldr	r3, [pc, #980]	; (8001970 <os_aes+0x5e0>)
 800159c:	617b      	str	r3, [r7, #20]
            ke = ki + 8*4;
 800159e:	697b      	ldr	r3, [r7, #20]
 80015a0:	3380      	adds	r3, #128	; 0x80
 80015a2:	613b      	str	r3, [r7, #16]
            a0 ^= ki[0];
 80015a4:	697b      	ldr	r3, [r7, #20]
 80015a6:	681b      	ldr	r3, [r3, #0]
 80015a8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80015aa:	4053      	eors	r3, r2
 80015ac:	62fb      	str	r3, [r7, #44]	; 0x2c
            a1 ^= ki[1];
 80015ae:	697b      	ldr	r3, [r7, #20]
 80015b0:	3304      	adds	r3, #4
 80015b2:	681b      	ldr	r3, [r3, #0]
 80015b4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80015b6:	4053      	eors	r3, r2
 80015b8:	62bb      	str	r3, [r7, #40]	; 0x28
            a2 ^= ki[2];
 80015ba:	697b      	ldr	r3, [r7, #20]
 80015bc:	3308      	adds	r3, #8
 80015be:	681b      	ldr	r3, [r3, #0]
 80015c0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80015c2:	4053      	eors	r3, r2
 80015c4:	627b      	str	r3, [r7, #36]	; 0x24
            a3 ^= ki[3];
 80015c6:	697b      	ldr	r3, [r7, #20]
 80015c8:	330c      	adds	r3, #12
 80015ca:	681b      	ldr	r3, [r3, #0]
 80015cc:	6a3a      	ldr	r2, [r7, #32]
 80015ce:	4053      	eors	r3, r2
 80015d0:	623b      	str	r3, [r7, #32]
            do {
                AES_key4 (t1,t2,t3,t0,4);
 80015d2:	697b      	ldr	r3, [r7, #20]
 80015d4:	695b      	ldr	r3, [r3, #20]
 80015d6:	61bb      	str	r3, [r7, #24]
 80015d8:	697b      	ldr	r3, [r7, #20]
 80015da:	699b      	ldr	r3, [r3, #24]
 80015dc:	60fb      	str	r3, [r7, #12]
 80015de:	697b      	ldr	r3, [r7, #20]
 80015e0:	69db      	ldr	r3, [r3, #28]
 80015e2:	60bb      	str	r3, [r7, #8]
 80015e4:	697b      	ldr	r3, [r7, #20]
 80015e6:	691b      	ldr	r3, [r3, #16]
 80015e8:	61fb      	str	r3, [r7, #28]
                AES_expr4(t1,t2,t3,t0,a0);
 80015ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80015ec:	b2db      	uxtb	r3, r3
 80015ee:	001a      	movs	r2, r3
 80015f0:	4be0      	ldr	r3, [pc, #896]	; (8001974 <os_aes+0x5e4>)
 80015f2:	0092      	lsls	r2, r2, #2
 80015f4:	58d3      	ldr	r3, [r2, r3]
 80015f6:	69ba      	ldr	r2, [r7, #24]
 80015f8:	4053      	eors	r3, r2
 80015fa:	61bb      	str	r3, [r7, #24]
 80015fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80015fe:	0a1b      	lsrs	r3, r3, #8
 8001600:	b2db      	uxtb	r3, r3
 8001602:	001a      	movs	r2, r3
 8001604:	4bdc      	ldr	r3, [pc, #880]	; (8001978 <os_aes+0x5e8>)
 8001606:	0092      	lsls	r2, r2, #2
 8001608:	58d3      	ldr	r3, [r2, r3]
 800160a:	68fa      	ldr	r2, [r7, #12]
 800160c:	4053      	eors	r3, r2
 800160e:	60fb      	str	r3, [r7, #12]
 8001610:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001612:	0c1b      	lsrs	r3, r3, #16
 8001614:	b2db      	uxtb	r3, r3
 8001616:	001a      	movs	r2, r3
 8001618:	4bd8      	ldr	r3, [pc, #864]	; (800197c <os_aes+0x5ec>)
 800161a:	0092      	lsls	r2, r2, #2
 800161c:	58d3      	ldr	r3, [r2, r3]
 800161e:	68ba      	ldr	r2, [r7, #8]
 8001620:	4053      	eors	r3, r2
 8001622:	60bb      	str	r3, [r7, #8]
 8001624:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001626:	0e1a      	lsrs	r2, r3, #24
 8001628:	4bd5      	ldr	r3, [pc, #852]	; (8001980 <os_aes+0x5f0>)
 800162a:	0092      	lsls	r2, r2, #2
 800162c:	58d3      	ldr	r3, [r2, r3]
 800162e:	69fa      	ldr	r2, [r7, #28]
 8001630:	4053      	eors	r3, r2
 8001632:	61fb      	str	r3, [r7, #28]
                AES_expr4(t2,t3,t0,t1,a1);
 8001634:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001636:	b2db      	uxtb	r3, r3
 8001638:	001a      	movs	r2, r3
 800163a:	4bce      	ldr	r3, [pc, #824]	; (8001974 <os_aes+0x5e4>)
 800163c:	0092      	lsls	r2, r2, #2
 800163e:	58d3      	ldr	r3, [r2, r3]
 8001640:	68fa      	ldr	r2, [r7, #12]
 8001642:	4053      	eors	r3, r2
 8001644:	60fb      	str	r3, [r7, #12]
 8001646:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001648:	0a1b      	lsrs	r3, r3, #8
 800164a:	b2db      	uxtb	r3, r3
 800164c:	001a      	movs	r2, r3
 800164e:	4bca      	ldr	r3, [pc, #808]	; (8001978 <os_aes+0x5e8>)
 8001650:	0092      	lsls	r2, r2, #2
 8001652:	58d3      	ldr	r3, [r2, r3]
 8001654:	68ba      	ldr	r2, [r7, #8]
 8001656:	4053      	eors	r3, r2
 8001658:	60bb      	str	r3, [r7, #8]
 800165a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800165c:	0c1b      	lsrs	r3, r3, #16
 800165e:	b2db      	uxtb	r3, r3
 8001660:	001a      	movs	r2, r3
 8001662:	4bc6      	ldr	r3, [pc, #792]	; (800197c <os_aes+0x5ec>)
 8001664:	0092      	lsls	r2, r2, #2
 8001666:	58d3      	ldr	r3, [r2, r3]
 8001668:	69fa      	ldr	r2, [r7, #28]
 800166a:	4053      	eors	r3, r2
 800166c:	61fb      	str	r3, [r7, #28]
 800166e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001670:	0e1a      	lsrs	r2, r3, #24
 8001672:	4bc3      	ldr	r3, [pc, #780]	; (8001980 <os_aes+0x5f0>)
 8001674:	0092      	lsls	r2, r2, #2
 8001676:	58d3      	ldr	r3, [r2, r3]
 8001678:	69ba      	ldr	r2, [r7, #24]
 800167a:	4053      	eors	r3, r2
 800167c:	61bb      	str	r3, [r7, #24]
                AES_expr4(t3,t0,t1,t2,a2);
 800167e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001680:	b2db      	uxtb	r3, r3
 8001682:	001a      	movs	r2, r3
 8001684:	4bbb      	ldr	r3, [pc, #748]	; (8001974 <os_aes+0x5e4>)
 8001686:	0092      	lsls	r2, r2, #2
 8001688:	58d3      	ldr	r3, [r2, r3]
 800168a:	68ba      	ldr	r2, [r7, #8]
 800168c:	4053      	eors	r3, r2
 800168e:	60bb      	str	r3, [r7, #8]
 8001690:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001692:	0a1b      	lsrs	r3, r3, #8
 8001694:	b2db      	uxtb	r3, r3
 8001696:	001a      	movs	r2, r3
 8001698:	4bb7      	ldr	r3, [pc, #732]	; (8001978 <os_aes+0x5e8>)
 800169a:	0092      	lsls	r2, r2, #2
 800169c:	58d3      	ldr	r3, [r2, r3]
 800169e:	69fa      	ldr	r2, [r7, #28]
 80016a0:	4053      	eors	r3, r2
 80016a2:	61fb      	str	r3, [r7, #28]
 80016a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80016a6:	0c1b      	lsrs	r3, r3, #16
 80016a8:	b2db      	uxtb	r3, r3
 80016aa:	001a      	movs	r2, r3
 80016ac:	4bb3      	ldr	r3, [pc, #716]	; (800197c <os_aes+0x5ec>)
 80016ae:	0092      	lsls	r2, r2, #2
 80016b0:	58d3      	ldr	r3, [r2, r3]
 80016b2:	69ba      	ldr	r2, [r7, #24]
 80016b4:	4053      	eors	r3, r2
 80016b6:	61bb      	str	r3, [r7, #24]
 80016b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80016ba:	0e1a      	lsrs	r2, r3, #24
 80016bc:	4bb0      	ldr	r3, [pc, #704]	; (8001980 <os_aes+0x5f0>)
 80016be:	0092      	lsls	r2, r2, #2
 80016c0:	58d3      	ldr	r3, [r2, r3]
 80016c2:	68fa      	ldr	r2, [r7, #12]
 80016c4:	4053      	eors	r3, r2
 80016c6:	60fb      	str	r3, [r7, #12]
                AES_expr4(t0,t1,t2,t3,a3);
 80016c8:	6a3b      	ldr	r3, [r7, #32]
 80016ca:	b2db      	uxtb	r3, r3
 80016cc:	001a      	movs	r2, r3
 80016ce:	4ba9      	ldr	r3, [pc, #676]	; (8001974 <os_aes+0x5e4>)
 80016d0:	0092      	lsls	r2, r2, #2
 80016d2:	58d3      	ldr	r3, [r2, r3]
 80016d4:	69fa      	ldr	r2, [r7, #28]
 80016d6:	4053      	eors	r3, r2
 80016d8:	61fb      	str	r3, [r7, #28]
 80016da:	6a3b      	ldr	r3, [r7, #32]
 80016dc:	0a1b      	lsrs	r3, r3, #8
 80016de:	b2db      	uxtb	r3, r3
 80016e0:	001a      	movs	r2, r3
 80016e2:	4ba5      	ldr	r3, [pc, #660]	; (8001978 <os_aes+0x5e8>)
 80016e4:	0092      	lsls	r2, r2, #2
 80016e6:	58d3      	ldr	r3, [r2, r3]
 80016e8:	69ba      	ldr	r2, [r7, #24]
 80016ea:	4053      	eors	r3, r2
 80016ec:	61bb      	str	r3, [r7, #24]
 80016ee:	6a3b      	ldr	r3, [r7, #32]
 80016f0:	0c1b      	lsrs	r3, r3, #16
 80016f2:	b2db      	uxtb	r3, r3
 80016f4:	001a      	movs	r2, r3
 80016f6:	4ba1      	ldr	r3, [pc, #644]	; (800197c <os_aes+0x5ec>)
 80016f8:	0092      	lsls	r2, r2, #2
 80016fa:	58d3      	ldr	r3, [r2, r3]
 80016fc:	68fa      	ldr	r2, [r7, #12]
 80016fe:	4053      	eors	r3, r2
 8001700:	60fb      	str	r3, [r7, #12]
 8001702:	6a3b      	ldr	r3, [r7, #32]
 8001704:	0e1a      	lsrs	r2, r3, #24
 8001706:	4b9e      	ldr	r3, [pc, #632]	; (8001980 <os_aes+0x5f0>)
 8001708:	0092      	lsls	r2, r2, #2
 800170a:	58d3      	ldr	r3, [r2, r3]
 800170c:	68ba      	ldr	r2, [r7, #8]
 800170e:	4053      	eors	r3, r2
 8001710:	60bb      	str	r3, [r7, #8]

                AES_key4 (a1,a2,a3,a0,8);
 8001712:	697b      	ldr	r3, [r7, #20]
 8001714:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001716:	62bb      	str	r3, [r7, #40]	; 0x28
 8001718:	697b      	ldr	r3, [r7, #20]
 800171a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800171c:	627b      	str	r3, [r7, #36]	; 0x24
 800171e:	697b      	ldr	r3, [r7, #20]
 8001720:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001722:	623b      	str	r3, [r7, #32]
 8001724:	697b      	ldr	r3, [r7, #20]
 8001726:	6a1b      	ldr	r3, [r3, #32]
 8001728:	62fb      	str	r3, [r7, #44]	; 0x2c
                AES_expr4(a1,a2,a3,a0,t0);
 800172a:	69fb      	ldr	r3, [r7, #28]
 800172c:	b2db      	uxtb	r3, r3
 800172e:	001a      	movs	r2, r3
 8001730:	4b90      	ldr	r3, [pc, #576]	; (8001974 <os_aes+0x5e4>)
 8001732:	0092      	lsls	r2, r2, #2
 8001734:	58d3      	ldr	r3, [r2, r3]
 8001736:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001738:	4053      	eors	r3, r2
 800173a:	62bb      	str	r3, [r7, #40]	; 0x28
 800173c:	69fb      	ldr	r3, [r7, #28]
 800173e:	0a1b      	lsrs	r3, r3, #8
 8001740:	b2db      	uxtb	r3, r3
 8001742:	001a      	movs	r2, r3
 8001744:	4b8c      	ldr	r3, [pc, #560]	; (8001978 <os_aes+0x5e8>)
 8001746:	0092      	lsls	r2, r2, #2
 8001748:	58d3      	ldr	r3, [r2, r3]
 800174a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800174c:	4053      	eors	r3, r2
 800174e:	627b      	str	r3, [r7, #36]	; 0x24
 8001750:	69fb      	ldr	r3, [r7, #28]
 8001752:	0c1b      	lsrs	r3, r3, #16
 8001754:	b2db      	uxtb	r3, r3
 8001756:	001a      	movs	r2, r3
 8001758:	4b88      	ldr	r3, [pc, #544]	; (800197c <os_aes+0x5ec>)
 800175a:	0092      	lsls	r2, r2, #2
 800175c:	58d3      	ldr	r3, [r2, r3]
 800175e:	6a3a      	ldr	r2, [r7, #32]
 8001760:	4053      	eors	r3, r2
 8001762:	623b      	str	r3, [r7, #32]
 8001764:	69fb      	ldr	r3, [r7, #28]
 8001766:	0e1a      	lsrs	r2, r3, #24
 8001768:	4b85      	ldr	r3, [pc, #532]	; (8001980 <os_aes+0x5f0>)
 800176a:	0092      	lsls	r2, r2, #2
 800176c:	58d3      	ldr	r3, [r2, r3]
 800176e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001770:	4053      	eors	r3, r2
 8001772:	62fb      	str	r3, [r7, #44]	; 0x2c
                AES_expr4(a2,a3,a0,a1,t1);
 8001774:	69bb      	ldr	r3, [r7, #24]
 8001776:	b2db      	uxtb	r3, r3
 8001778:	001a      	movs	r2, r3
 800177a:	4b7e      	ldr	r3, [pc, #504]	; (8001974 <os_aes+0x5e4>)
 800177c:	0092      	lsls	r2, r2, #2
 800177e:	58d3      	ldr	r3, [r2, r3]
 8001780:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001782:	4053      	eors	r3, r2
 8001784:	627b      	str	r3, [r7, #36]	; 0x24
 8001786:	69bb      	ldr	r3, [r7, #24]
 8001788:	0a1b      	lsrs	r3, r3, #8
 800178a:	b2db      	uxtb	r3, r3
 800178c:	001a      	movs	r2, r3
 800178e:	4b7a      	ldr	r3, [pc, #488]	; (8001978 <os_aes+0x5e8>)
 8001790:	0092      	lsls	r2, r2, #2
 8001792:	58d3      	ldr	r3, [r2, r3]
 8001794:	6a3a      	ldr	r2, [r7, #32]
 8001796:	4053      	eors	r3, r2
 8001798:	623b      	str	r3, [r7, #32]
 800179a:	69bb      	ldr	r3, [r7, #24]
 800179c:	0c1b      	lsrs	r3, r3, #16
 800179e:	b2db      	uxtb	r3, r3
 80017a0:	001a      	movs	r2, r3
 80017a2:	4b76      	ldr	r3, [pc, #472]	; (800197c <os_aes+0x5ec>)
 80017a4:	0092      	lsls	r2, r2, #2
 80017a6:	58d3      	ldr	r3, [r2, r3]
 80017a8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80017aa:	4053      	eors	r3, r2
 80017ac:	62fb      	str	r3, [r7, #44]	; 0x2c
 80017ae:	69bb      	ldr	r3, [r7, #24]
 80017b0:	0e1a      	lsrs	r2, r3, #24
 80017b2:	4b73      	ldr	r3, [pc, #460]	; (8001980 <os_aes+0x5f0>)
 80017b4:	0092      	lsls	r2, r2, #2
 80017b6:	58d3      	ldr	r3, [r2, r3]
 80017b8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80017ba:	4053      	eors	r3, r2
 80017bc:	62bb      	str	r3, [r7, #40]	; 0x28
                AES_expr4(a3,a0,a1,a2,t2);
 80017be:	68fb      	ldr	r3, [r7, #12]
 80017c0:	b2db      	uxtb	r3, r3
 80017c2:	001a      	movs	r2, r3
 80017c4:	4b6b      	ldr	r3, [pc, #428]	; (8001974 <os_aes+0x5e4>)
 80017c6:	0092      	lsls	r2, r2, #2
 80017c8:	58d3      	ldr	r3, [r2, r3]
 80017ca:	6a3a      	ldr	r2, [r7, #32]
 80017cc:	4053      	eors	r3, r2
 80017ce:	623b      	str	r3, [r7, #32]
 80017d0:	68fb      	ldr	r3, [r7, #12]
 80017d2:	0a1b      	lsrs	r3, r3, #8
 80017d4:	b2db      	uxtb	r3, r3
 80017d6:	001a      	movs	r2, r3
 80017d8:	4b67      	ldr	r3, [pc, #412]	; (8001978 <os_aes+0x5e8>)
 80017da:	0092      	lsls	r2, r2, #2
 80017dc:	58d3      	ldr	r3, [r2, r3]
 80017de:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80017e0:	4053      	eors	r3, r2
 80017e2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80017e4:	68fb      	ldr	r3, [r7, #12]
 80017e6:	0c1b      	lsrs	r3, r3, #16
 80017e8:	b2db      	uxtb	r3, r3
 80017ea:	001a      	movs	r2, r3
 80017ec:	4b63      	ldr	r3, [pc, #396]	; (800197c <os_aes+0x5ec>)
 80017ee:	0092      	lsls	r2, r2, #2
 80017f0:	58d3      	ldr	r3, [r2, r3]
 80017f2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80017f4:	4053      	eors	r3, r2
 80017f6:	62bb      	str	r3, [r7, #40]	; 0x28
 80017f8:	68fb      	ldr	r3, [r7, #12]
 80017fa:	0e1a      	lsrs	r2, r3, #24
 80017fc:	4b60      	ldr	r3, [pc, #384]	; (8001980 <os_aes+0x5f0>)
 80017fe:	0092      	lsls	r2, r2, #2
 8001800:	58d3      	ldr	r3, [r2, r3]
 8001802:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001804:	4053      	eors	r3, r2
 8001806:	627b      	str	r3, [r7, #36]	; 0x24
                AES_expr4(a0,a1,a2,a3,t3);
 8001808:	68bb      	ldr	r3, [r7, #8]
 800180a:	b2db      	uxtb	r3, r3
 800180c:	001a      	movs	r2, r3
 800180e:	4b59      	ldr	r3, [pc, #356]	; (8001974 <os_aes+0x5e4>)
 8001810:	0092      	lsls	r2, r2, #2
 8001812:	58d3      	ldr	r3, [r2, r3]
 8001814:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001816:	4053      	eors	r3, r2
 8001818:	62fb      	str	r3, [r7, #44]	; 0x2c
 800181a:	68bb      	ldr	r3, [r7, #8]
 800181c:	0a1b      	lsrs	r3, r3, #8
 800181e:	b2db      	uxtb	r3, r3
 8001820:	001a      	movs	r2, r3
 8001822:	4b55      	ldr	r3, [pc, #340]	; (8001978 <os_aes+0x5e8>)
 8001824:	0092      	lsls	r2, r2, #2
 8001826:	58d3      	ldr	r3, [r2, r3]
 8001828:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800182a:	4053      	eors	r3, r2
 800182c:	62bb      	str	r3, [r7, #40]	; 0x28
 800182e:	68bb      	ldr	r3, [r7, #8]
 8001830:	0c1b      	lsrs	r3, r3, #16
 8001832:	b2db      	uxtb	r3, r3
 8001834:	001a      	movs	r2, r3
 8001836:	4b51      	ldr	r3, [pc, #324]	; (800197c <os_aes+0x5ec>)
 8001838:	0092      	lsls	r2, r2, #2
 800183a:	58d3      	ldr	r3, [r2, r3]
 800183c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800183e:	4053      	eors	r3, r2
 8001840:	627b      	str	r3, [r7, #36]	; 0x24
 8001842:	68bb      	ldr	r3, [r7, #8]
 8001844:	0e1a      	lsrs	r2, r3, #24
 8001846:	4b4e      	ldr	r3, [pc, #312]	; (8001980 <os_aes+0x5f0>)
 8001848:	0092      	lsls	r2, r2, #2
 800184a:	58d3      	ldr	r3, [r2, r3]
 800184c:	6a3a      	ldr	r2, [r7, #32]
 800184e:	4053      	eors	r3, r2
 8001850:	623b      	str	r3, [r7, #32]
            } while( (ki+=8) < ke );
 8001852:	697b      	ldr	r3, [r7, #20]
 8001854:	3320      	adds	r3, #32
 8001856:	617b      	str	r3, [r7, #20]
 8001858:	697a      	ldr	r2, [r7, #20]
 800185a:	693b      	ldr	r3, [r7, #16]
 800185c:	429a      	cmp	r2, r3
 800185e:	d200      	bcs.n	8001862 <os_aes+0x4d2>
 8001860:	e6b7      	b.n	80015d2 <os_aes+0x242>

            AES_key4 (t1,t2,t3,t0,4);
 8001862:	697b      	ldr	r3, [r7, #20]
 8001864:	695b      	ldr	r3, [r3, #20]
 8001866:	61bb      	str	r3, [r7, #24]
 8001868:	697b      	ldr	r3, [r7, #20]
 800186a:	699b      	ldr	r3, [r3, #24]
 800186c:	60fb      	str	r3, [r7, #12]
 800186e:	697b      	ldr	r3, [r7, #20]
 8001870:	69db      	ldr	r3, [r3, #28]
 8001872:	60bb      	str	r3, [r7, #8]
 8001874:	697b      	ldr	r3, [r7, #20]
 8001876:	691b      	ldr	r3, [r3, #16]
 8001878:	61fb      	str	r3, [r7, #28]
            AES_expr4(t1,t2,t3,t0,a0);
 800187a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800187c:	b2db      	uxtb	r3, r3
 800187e:	001a      	movs	r2, r3
 8001880:	4b3c      	ldr	r3, [pc, #240]	; (8001974 <os_aes+0x5e4>)
 8001882:	0092      	lsls	r2, r2, #2
 8001884:	58d3      	ldr	r3, [r2, r3]
 8001886:	69ba      	ldr	r2, [r7, #24]
 8001888:	4053      	eors	r3, r2
 800188a:	61bb      	str	r3, [r7, #24]
 800188c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800188e:	0a1b      	lsrs	r3, r3, #8
 8001890:	b2db      	uxtb	r3, r3
 8001892:	001a      	movs	r2, r3
 8001894:	4b38      	ldr	r3, [pc, #224]	; (8001978 <os_aes+0x5e8>)
 8001896:	0092      	lsls	r2, r2, #2
 8001898:	58d3      	ldr	r3, [r2, r3]
 800189a:	68fa      	ldr	r2, [r7, #12]
 800189c:	4053      	eors	r3, r2
 800189e:	60fb      	str	r3, [r7, #12]
 80018a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80018a2:	0c1b      	lsrs	r3, r3, #16
 80018a4:	b2db      	uxtb	r3, r3
 80018a6:	001a      	movs	r2, r3
 80018a8:	4b34      	ldr	r3, [pc, #208]	; (800197c <os_aes+0x5ec>)
 80018aa:	0092      	lsls	r2, r2, #2
 80018ac:	58d3      	ldr	r3, [r2, r3]
 80018ae:	68ba      	ldr	r2, [r7, #8]
 80018b0:	4053      	eors	r3, r2
 80018b2:	60bb      	str	r3, [r7, #8]
 80018b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80018b6:	0e1a      	lsrs	r2, r3, #24
 80018b8:	4b31      	ldr	r3, [pc, #196]	; (8001980 <os_aes+0x5f0>)
 80018ba:	0092      	lsls	r2, r2, #2
 80018bc:	58d3      	ldr	r3, [r2, r3]
 80018be:	69fa      	ldr	r2, [r7, #28]
 80018c0:	4053      	eors	r3, r2
 80018c2:	61fb      	str	r3, [r7, #28]
            AES_expr4(t2,t3,t0,t1,a1);
 80018c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80018c6:	b2db      	uxtb	r3, r3
 80018c8:	001a      	movs	r2, r3
 80018ca:	4b2a      	ldr	r3, [pc, #168]	; (8001974 <os_aes+0x5e4>)
 80018cc:	0092      	lsls	r2, r2, #2
 80018ce:	58d3      	ldr	r3, [r2, r3]
 80018d0:	68fa      	ldr	r2, [r7, #12]
 80018d2:	4053      	eors	r3, r2
 80018d4:	60fb      	str	r3, [r7, #12]
 80018d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80018d8:	0a1b      	lsrs	r3, r3, #8
 80018da:	b2db      	uxtb	r3, r3
 80018dc:	001a      	movs	r2, r3
 80018de:	4b26      	ldr	r3, [pc, #152]	; (8001978 <os_aes+0x5e8>)
 80018e0:	0092      	lsls	r2, r2, #2
 80018e2:	58d3      	ldr	r3, [r2, r3]
 80018e4:	68ba      	ldr	r2, [r7, #8]
 80018e6:	4053      	eors	r3, r2
 80018e8:	60bb      	str	r3, [r7, #8]
 80018ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80018ec:	0c1b      	lsrs	r3, r3, #16
 80018ee:	b2db      	uxtb	r3, r3
 80018f0:	001a      	movs	r2, r3
 80018f2:	4b22      	ldr	r3, [pc, #136]	; (800197c <os_aes+0x5ec>)
 80018f4:	0092      	lsls	r2, r2, #2
 80018f6:	58d3      	ldr	r3, [r2, r3]
 80018f8:	69fa      	ldr	r2, [r7, #28]
 80018fa:	4053      	eors	r3, r2
 80018fc:	61fb      	str	r3, [r7, #28]
 80018fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001900:	0e1a      	lsrs	r2, r3, #24
 8001902:	4b1f      	ldr	r3, [pc, #124]	; (8001980 <os_aes+0x5f0>)
 8001904:	0092      	lsls	r2, r2, #2
 8001906:	58d3      	ldr	r3, [r2, r3]
 8001908:	69ba      	ldr	r2, [r7, #24]
 800190a:	4053      	eors	r3, r2
 800190c:	61bb      	str	r3, [r7, #24]
            AES_expr4(t3,t0,t1,t2,a2);
 800190e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001910:	b2db      	uxtb	r3, r3
 8001912:	001a      	movs	r2, r3
 8001914:	4b17      	ldr	r3, [pc, #92]	; (8001974 <os_aes+0x5e4>)
 8001916:	0092      	lsls	r2, r2, #2
 8001918:	58d3      	ldr	r3, [r2, r3]
 800191a:	68ba      	ldr	r2, [r7, #8]
 800191c:	4053      	eors	r3, r2
 800191e:	60bb      	str	r3, [r7, #8]
 8001920:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001922:	0a1b      	lsrs	r3, r3, #8
 8001924:	b2db      	uxtb	r3, r3
 8001926:	001a      	movs	r2, r3
 8001928:	4b13      	ldr	r3, [pc, #76]	; (8001978 <os_aes+0x5e8>)
 800192a:	0092      	lsls	r2, r2, #2
 800192c:	58d3      	ldr	r3, [r2, r3]
 800192e:	69fa      	ldr	r2, [r7, #28]
 8001930:	4053      	eors	r3, r2
 8001932:	61fb      	str	r3, [r7, #28]
 8001934:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001936:	0c1b      	lsrs	r3, r3, #16
 8001938:	b2db      	uxtb	r3, r3
 800193a:	001a      	movs	r2, r3
 800193c:	4b0f      	ldr	r3, [pc, #60]	; (800197c <os_aes+0x5ec>)
 800193e:	0092      	lsls	r2, r2, #2
 8001940:	58d3      	ldr	r3, [r2, r3]
 8001942:	69ba      	ldr	r2, [r7, #24]
 8001944:	4053      	eors	r3, r2
 8001946:	61bb      	str	r3, [r7, #24]
 8001948:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800194a:	0e1a      	lsrs	r2, r3, #24
 800194c:	4b0c      	ldr	r3, [pc, #48]	; (8001980 <os_aes+0x5f0>)
 800194e:	0092      	lsls	r2, r2, #2
 8001950:	58d3      	ldr	r3, [r2, r3]
 8001952:	68fa      	ldr	r2, [r7, #12]
 8001954:	4053      	eors	r3, r2
 8001956:	60fb      	str	r3, [r7, #12]
            AES_expr4(t0,t1,t2,t3,a3);
 8001958:	6a3b      	ldr	r3, [r7, #32]
 800195a:	b2db      	uxtb	r3, r3
 800195c:	001a      	movs	r2, r3
 800195e:	4b05      	ldr	r3, [pc, #20]	; (8001974 <os_aes+0x5e4>)
 8001960:	0092      	lsls	r2, r2, #2
 8001962:	58d3      	ldr	r3, [r2, r3]
 8001964:	69fa      	ldr	r2, [r7, #28]
 8001966:	4053      	eors	r3, r2
 8001968:	e00c      	b.n	8001984 <os_aes+0x5f4>
 800196a:	46c0      	nop			; (mov r8, r8)
 800196c:	20000150 	.word	0x20000150
 8001970:	200000a0 	.word	0x200000a0
 8001974:	0800ece4 	.word	0x0800ece4
 8001978:	0800e8e4 	.word	0x0800e8e4
 800197c:	0800e4e4 	.word	0x0800e4e4
 8001980:	0800e0e4 	.word	0x0800e0e4
 8001984:	61fb      	str	r3, [r7, #28]
 8001986:	6a3b      	ldr	r3, [r7, #32]
 8001988:	0a1b      	lsrs	r3, r3, #8
 800198a:	b2db      	uxtb	r3, r3
 800198c:	001a      	movs	r2, r3
 800198e:	4bae      	ldr	r3, [pc, #696]	; (8001c48 <os_aes+0x8b8>)
 8001990:	0092      	lsls	r2, r2, #2
 8001992:	58d3      	ldr	r3, [r2, r3]
 8001994:	69ba      	ldr	r2, [r7, #24]
 8001996:	4053      	eors	r3, r2
 8001998:	61bb      	str	r3, [r7, #24]
 800199a:	6a3b      	ldr	r3, [r7, #32]
 800199c:	0c1b      	lsrs	r3, r3, #16
 800199e:	b2db      	uxtb	r3, r3
 80019a0:	001a      	movs	r2, r3
 80019a2:	4baa      	ldr	r3, [pc, #680]	; (8001c4c <os_aes+0x8bc>)
 80019a4:	0092      	lsls	r2, r2, #2
 80019a6:	58d3      	ldr	r3, [r2, r3]
 80019a8:	68fa      	ldr	r2, [r7, #12]
 80019aa:	4053      	eors	r3, r2
 80019ac:	60fb      	str	r3, [r7, #12]
 80019ae:	6a3b      	ldr	r3, [r7, #32]
 80019b0:	0e1a      	lsrs	r2, r3, #24
 80019b2:	4ba7      	ldr	r3, [pc, #668]	; (8001c50 <os_aes+0x8c0>)
 80019b4:	0092      	lsls	r2, r2, #2
 80019b6:	58d3      	ldr	r3, [r2, r3]
 80019b8:	68ba      	ldr	r2, [r7, #8]
 80019ba:	4053      	eors	r3, r2
 80019bc:	60bb      	str	r3, [r7, #8]

            AES_expr(a0,t0,t1,t2,t3,8);
 80019be:	697b      	ldr	r3, [r7, #20]
 80019c0:	6a1b      	ldr	r3, [r3, #32]
 80019c2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80019c4:	69fb      	ldr	r3, [r7, #28]
 80019c6:	0e1b      	lsrs	r3, r3, #24
 80019c8:	4aa2      	ldr	r2, [pc, #648]	; (8001c54 <os_aes+0x8c4>)
 80019ca:	5cd3      	ldrb	r3, [r2, r3]
 80019cc:	061b      	lsls	r3, r3, #24
 80019ce:	001a      	movs	r2, r3
 80019d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80019d2:	4053      	eors	r3, r2
 80019d4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80019d6:	69bb      	ldr	r3, [r7, #24]
 80019d8:	0c1b      	lsrs	r3, r3, #16
 80019da:	b2db      	uxtb	r3, r3
 80019dc:	001a      	movs	r2, r3
 80019de:	4b9d      	ldr	r3, [pc, #628]	; (8001c54 <os_aes+0x8c4>)
 80019e0:	5c9b      	ldrb	r3, [r3, r2]
 80019e2:	041b      	lsls	r3, r3, #16
 80019e4:	001a      	movs	r2, r3
 80019e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80019e8:	4053      	eors	r3, r2
 80019ea:	62fb      	str	r3, [r7, #44]	; 0x2c
 80019ec:	68fb      	ldr	r3, [r7, #12]
 80019ee:	0a1b      	lsrs	r3, r3, #8
 80019f0:	b2db      	uxtb	r3, r3
 80019f2:	001a      	movs	r2, r3
 80019f4:	4b97      	ldr	r3, [pc, #604]	; (8001c54 <os_aes+0x8c4>)
 80019f6:	5c9b      	ldrb	r3, [r3, r2]
 80019f8:	021b      	lsls	r3, r3, #8
 80019fa:	001a      	movs	r2, r3
 80019fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80019fe:	4053      	eors	r3, r2
 8001a00:	62fb      	str	r3, [r7, #44]	; 0x2c
 8001a02:	68bb      	ldr	r3, [r7, #8]
 8001a04:	b2db      	uxtb	r3, r3
 8001a06:	001a      	movs	r2, r3
 8001a08:	4b92      	ldr	r3, [pc, #584]	; (8001c54 <os_aes+0x8c4>)
 8001a0a:	5c9b      	ldrb	r3, [r3, r2]
 8001a0c:	001a      	movs	r2, r3
 8001a0e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001a10:	4053      	eors	r3, r2
 8001a12:	62fb      	str	r3, [r7, #44]	; 0x2c
            AES_expr(a1,t1,t2,t3,t0,9);
 8001a14:	697b      	ldr	r3, [r7, #20]
 8001a16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001a18:	62bb      	str	r3, [r7, #40]	; 0x28
 8001a1a:	69bb      	ldr	r3, [r7, #24]
 8001a1c:	0e1b      	lsrs	r3, r3, #24
 8001a1e:	4a8d      	ldr	r2, [pc, #564]	; (8001c54 <os_aes+0x8c4>)
 8001a20:	5cd3      	ldrb	r3, [r2, r3]
 8001a22:	061b      	lsls	r3, r3, #24
 8001a24:	001a      	movs	r2, r3
 8001a26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001a28:	4053      	eors	r3, r2
 8001a2a:	62bb      	str	r3, [r7, #40]	; 0x28
 8001a2c:	68fb      	ldr	r3, [r7, #12]
 8001a2e:	0c1b      	lsrs	r3, r3, #16
 8001a30:	b2db      	uxtb	r3, r3
 8001a32:	001a      	movs	r2, r3
 8001a34:	4b87      	ldr	r3, [pc, #540]	; (8001c54 <os_aes+0x8c4>)
 8001a36:	5c9b      	ldrb	r3, [r3, r2]
 8001a38:	041b      	lsls	r3, r3, #16
 8001a3a:	001a      	movs	r2, r3
 8001a3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001a3e:	4053      	eors	r3, r2
 8001a40:	62bb      	str	r3, [r7, #40]	; 0x28
 8001a42:	68bb      	ldr	r3, [r7, #8]
 8001a44:	0a1b      	lsrs	r3, r3, #8
 8001a46:	b2db      	uxtb	r3, r3
 8001a48:	001a      	movs	r2, r3
 8001a4a:	4b82      	ldr	r3, [pc, #520]	; (8001c54 <os_aes+0x8c4>)
 8001a4c:	5c9b      	ldrb	r3, [r3, r2]
 8001a4e:	021b      	lsls	r3, r3, #8
 8001a50:	001a      	movs	r2, r3
 8001a52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001a54:	4053      	eors	r3, r2
 8001a56:	62bb      	str	r3, [r7, #40]	; 0x28
 8001a58:	69fb      	ldr	r3, [r7, #28]
 8001a5a:	b2db      	uxtb	r3, r3
 8001a5c:	001a      	movs	r2, r3
 8001a5e:	4b7d      	ldr	r3, [pc, #500]	; (8001c54 <os_aes+0x8c4>)
 8001a60:	5c9b      	ldrb	r3, [r3, r2]
 8001a62:	001a      	movs	r2, r3
 8001a64:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001a66:	4053      	eors	r3, r2
 8001a68:	62bb      	str	r3, [r7, #40]	; 0x28
            AES_expr(a2,t2,t3,t0,t1,10);
 8001a6a:	697b      	ldr	r3, [r7, #20]
 8001a6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001a6e:	627b      	str	r3, [r7, #36]	; 0x24
 8001a70:	68fb      	ldr	r3, [r7, #12]
 8001a72:	0e1b      	lsrs	r3, r3, #24
 8001a74:	4a77      	ldr	r2, [pc, #476]	; (8001c54 <os_aes+0x8c4>)
 8001a76:	5cd3      	ldrb	r3, [r2, r3]
 8001a78:	061b      	lsls	r3, r3, #24
 8001a7a:	001a      	movs	r2, r3
 8001a7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001a7e:	4053      	eors	r3, r2
 8001a80:	627b      	str	r3, [r7, #36]	; 0x24
 8001a82:	68bb      	ldr	r3, [r7, #8]
 8001a84:	0c1b      	lsrs	r3, r3, #16
 8001a86:	b2db      	uxtb	r3, r3
 8001a88:	001a      	movs	r2, r3
 8001a8a:	4b72      	ldr	r3, [pc, #456]	; (8001c54 <os_aes+0x8c4>)
 8001a8c:	5c9b      	ldrb	r3, [r3, r2]
 8001a8e:	041b      	lsls	r3, r3, #16
 8001a90:	001a      	movs	r2, r3
 8001a92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001a94:	4053      	eors	r3, r2
 8001a96:	627b      	str	r3, [r7, #36]	; 0x24
 8001a98:	69fb      	ldr	r3, [r7, #28]
 8001a9a:	0a1b      	lsrs	r3, r3, #8
 8001a9c:	b2db      	uxtb	r3, r3
 8001a9e:	001a      	movs	r2, r3
 8001aa0:	4b6c      	ldr	r3, [pc, #432]	; (8001c54 <os_aes+0x8c4>)
 8001aa2:	5c9b      	ldrb	r3, [r3, r2]
 8001aa4:	021b      	lsls	r3, r3, #8
 8001aa6:	001a      	movs	r2, r3
 8001aa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001aaa:	4053      	eors	r3, r2
 8001aac:	627b      	str	r3, [r7, #36]	; 0x24
 8001aae:	69bb      	ldr	r3, [r7, #24]
 8001ab0:	b2db      	uxtb	r3, r3
 8001ab2:	001a      	movs	r2, r3
 8001ab4:	4b67      	ldr	r3, [pc, #412]	; (8001c54 <os_aes+0x8c4>)
 8001ab6:	5c9b      	ldrb	r3, [r3, r2]
 8001ab8:	001a      	movs	r2, r3
 8001aba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001abc:	4053      	eors	r3, r2
 8001abe:	627b      	str	r3, [r7, #36]	; 0x24
            AES_expr(a3,t3,t0,t1,t2,11);
 8001ac0:	697b      	ldr	r3, [r7, #20]
 8001ac2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001ac4:	623b      	str	r3, [r7, #32]
 8001ac6:	68bb      	ldr	r3, [r7, #8]
 8001ac8:	0e1b      	lsrs	r3, r3, #24
 8001aca:	4a62      	ldr	r2, [pc, #392]	; (8001c54 <os_aes+0x8c4>)
 8001acc:	5cd3      	ldrb	r3, [r2, r3]
 8001ace:	061b      	lsls	r3, r3, #24
 8001ad0:	001a      	movs	r2, r3
 8001ad2:	6a3b      	ldr	r3, [r7, #32]
 8001ad4:	4053      	eors	r3, r2
 8001ad6:	623b      	str	r3, [r7, #32]
 8001ad8:	69fb      	ldr	r3, [r7, #28]
 8001ada:	0c1b      	lsrs	r3, r3, #16
 8001adc:	b2db      	uxtb	r3, r3
 8001ade:	001a      	movs	r2, r3
 8001ae0:	4b5c      	ldr	r3, [pc, #368]	; (8001c54 <os_aes+0x8c4>)
 8001ae2:	5c9b      	ldrb	r3, [r3, r2]
 8001ae4:	041b      	lsls	r3, r3, #16
 8001ae6:	001a      	movs	r2, r3
 8001ae8:	6a3b      	ldr	r3, [r7, #32]
 8001aea:	4053      	eors	r3, r2
 8001aec:	623b      	str	r3, [r7, #32]
 8001aee:	69bb      	ldr	r3, [r7, #24]
 8001af0:	0a1b      	lsrs	r3, r3, #8
 8001af2:	b2db      	uxtb	r3, r3
 8001af4:	001a      	movs	r2, r3
 8001af6:	4b57      	ldr	r3, [pc, #348]	; (8001c54 <os_aes+0x8c4>)
 8001af8:	5c9b      	ldrb	r3, [r3, r2]
 8001afa:	021b      	lsls	r3, r3, #8
 8001afc:	001a      	movs	r2, r3
 8001afe:	6a3b      	ldr	r3, [r7, #32]
 8001b00:	4053      	eors	r3, r2
 8001b02:	623b      	str	r3, [r7, #32]
 8001b04:	68fb      	ldr	r3, [r7, #12]
 8001b06:	b2db      	uxtb	r3, r3
 8001b08:	001a      	movs	r2, r3
 8001b0a:	4b52      	ldr	r3, [pc, #328]	; (8001c54 <os_aes+0x8c4>)
 8001b0c:	5c9b      	ldrb	r3, [r3, r2]
 8001b0e:	001a      	movs	r2, r3
 8001b10:	6a3b      	ldr	r3, [r7, #32]
 8001b12:	4053      	eors	r3, r2
 8001b14:	623b      	str	r3, [r7, #32]
            // result of AES encryption in a0-a3

            if( mode & AES_MIC ) {
 8001b16:	1dfb      	adds	r3, r7, #7
 8001b18:	781b      	ldrb	r3, [r3, #0]
 8001b1a:	2202      	movs	r2, #2
 8001b1c:	4013      	ands	r3, r2
 8001b1e:	d05a      	beq.n	8001bd6 <os_aes+0x846>
                if( (t1 = (mode & AES_MICSUB) >> 4) != 0 ) { // last block
 8001b20:	1dfb      	adds	r3, r7, #7
 8001b22:	781b      	ldrb	r3, [r3, #0]
 8001b24:	111b      	asrs	r3, r3, #4
 8001b26:	001a      	movs	r2, r3
 8001b28:	2303      	movs	r3, #3
 8001b2a:	4013      	ands	r3, r2
 8001b2c:	61bb      	str	r3, [r7, #24]
 8001b2e:	69bb      	ldr	r3, [r7, #24]
 8001b30:	2b00      	cmp	r3, #0
 8001b32:	d043      	beq.n	8001bbc <os_aes+0x82c>
                    do {
                        // compute CMAC subkey K1 and K2
                        t0 = a0 >> 31; // save MSB
 8001b34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001b36:	0fdb      	lsrs	r3, r3, #31
 8001b38:	61fb      	str	r3, [r7, #28]
                        a0 = (a0 << 1) | (a1 >> 31);
 8001b3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001b3c:	005a      	lsls	r2, r3, #1
 8001b3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001b40:	0fdb      	lsrs	r3, r3, #31
 8001b42:	4313      	orrs	r3, r2
 8001b44:	62fb      	str	r3, [r7, #44]	; 0x2c
                        a1 = (a1 << 1) | (a2 >> 31);
 8001b46:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001b48:	005a      	lsls	r2, r3, #1
 8001b4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001b4c:	0fdb      	lsrs	r3, r3, #31
 8001b4e:	4313      	orrs	r3, r2
 8001b50:	62bb      	str	r3, [r7, #40]	; 0x28
                        a2 = (a2 << 1) | (a3 >> 31);
 8001b52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001b54:	005a      	lsls	r2, r3, #1
 8001b56:	6a3b      	ldr	r3, [r7, #32]
 8001b58:	0fdb      	lsrs	r3, r3, #31
 8001b5a:	4313      	orrs	r3, r2
 8001b5c:	627b      	str	r3, [r7, #36]	; 0x24
                        a3 = (a3 << 1);
 8001b5e:	6a3b      	ldr	r3, [r7, #32]
 8001b60:	005b      	lsls	r3, r3, #1
 8001b62:	623b      	str	r3, [r7, #32]
                        if( t0 ) a3 ^= 0x87;
 8001b64:	69fb      	ldr	r3, [r7, #28]
 8001b66:	2b00      	cmp	r3, #0
 8001b68:	d003      	beq.n	8001b72 <os_aes+0x7e2>
 8001b6a:	6a3b      	ldr	r3, [r7, #32]
 8001b6c:	2287      	movs	r2, #135	; 0x87
 8001b6e:	4053      	eors	r3, r2
 8001b70:	623b      	str	r3, [r7, #32]
                    } while( --t1 );
 8001b72:	69bb      	ldr	r3, [r7, #24]
 8001b74:	3b01      	subs	r3, #1
 8001b76:	61bb      	str	r3, [r7, #24]
 8001b78:	69bb      	ldr	r3, [r7, #24]
 8001b7a:	2b00      	cmp	r3, #0
 8001b7c:	d1da      	bne.n	8001b34 <os_aes+0x7a4>

                    AESAUX[0] ^= a0;
 8001b7e:	4b36      	ldr	r3, [pc, #216]	; (8001c58 <os_aes+0x8c8>)
 8001b80:	681a      	ldr	r2, [r3, #0]
 8001b82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001b84:	405a      	eors	r2, r3
 8001b86:	4b34      	ldr	r3, [pc, #208]	; (8001c58 <os_aes+0x8c8>)
 8001b88:	601a      	str	r2, [r3, #0]
                    AESAUX[1] ^= a1;
 8001b8a:	4b33      	ldr	r3, [pc, #204]	; (8001c58 <os_aes+0x8c8>)
 8001b8c:	685a      	ldr	r2, [r3, #4]
 8001b8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001b90:	405a      	eors	r2, r3
 8001b92:	4b31      	ldr	r3, [pc, #196]	; (8001c58 <os_aes+0x8c8>)
 8001b94:	605a      	str	r2, [r3, #4]
                    AESAUX[2] ^= a2;
 8001b96:	4b30      	ldr	r3, [pc, #192]	; (8001c58 <os_aes+0x8c8>)
 8001b98:	689a      	ldr	r2, [r3, #8]
 8001b9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001b9c:	405a      	eors	r2, r3
 8001b9e:	4b2e      	ldr	r3, [pc, #184]	; (8001c58 <os_aes+0x8c8>)
 8001ba0:	609a      	str	r2, [r3, #8]
                    AESAUX[3] ^= a3;
 8001ba2:	4b2d      	ldr	r3, [pc, #180]	; (8001c58 <os_aes+0x8c8>)
 8001ba4:	68da      	ldr	r2, [r3, #12]
 8001ba6:	6a3b      	ldr	r3, [r7, #32]
 8001ba8:	405a      	eors	r2, r3
 8001baa:	4b2b      	ldr	r3, [pc, #172]	; (8001c58 <os_aes+0x8c8>)
 8001bac:	60da      	str	r2, [r3, #12]
                    mode &= ~AES_MICSUB;
 8001bae:	1dfb      	adds	r3, r7, #7
 8001bb0:	1dfa      	adds	r2, r7, #7
 8001bb2:	7812      	ldrb	r2, [r2, #0]
 8001bb4:	2130      	movs	r1, #48	; 0x30
 8001bb6:	438a      	bics	r2, r1
 8001bb8:	701a      	strb	r2, [r3, #0]
                    goto LOADDATA;
 8001bba:	e4a7      	b.n	800150c <os_aes+0x17c>
                } else {
                    // save cipher block as new iv
                    AESAUX[0] = a0;
 8001bbc:	4b26      	ldr	r3, [pc, #152]	; (8001c58 <os_aes+0x8c8>)
 8001bbe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001bc0:	601a      	str	r2, [r3, #0]
                    AESAUX[1] = a1;
 8001bc2:	4b25      	ldr	r3, [pc, #148]	; (8001c58 <os_aes+0x8c8>)
 8001bc4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001bc6:	605a      	str	r2, [r3, #4]
                    AESAUX[2] = a2;
 8001bc8:	4b23      	ldr	r3, [pc, #140]	; (8001c58 <os_aes+0x8c8>)
 8001bca:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001bcc:	609a      	str	r2, [r3, #8]
                    AESAUX[3] = a3;
 8001bce:	4b22      	ldr	r3, [pc, #136]	; (8001c58 <os_aes+0x8c8>)
 8001bd0:	6a3a      	ldr	r2, [r7, #32]
 8001bd2:	60da      	str	r2, [r3, #12]
 8001bd4:	e09d      	b.n	8001d12 <os_aes+0x982>
                }
            } else { // CIPHER
                if( mode & AES_CTR ) { // xor block (partially)
 8001bd6:	1dfb      	adds	r3, r7, #7
 8001bd8:	781b      	ldrb	r3, [r3, #0]
 8001bda:	2204      	movs	r2, #4
 8001bdc:	4013      	ands	r3, r2
 8001bde:	d03d      	beq.n	8001c5c <os_aes+0x8cc>
                    t0 = (len > 16) ? 16: len;
 8001be0:	1d3b      	adds	r3, r7, #4
 8001be2:	881b      	ldrh	r3, [r3, #0]
 8001be4:	b29a      	uxth	r2, r3
 8001be6:	2a10      	cmp	r2, #16
 8001be8:	d900      	bls.n	8001bec <os_aes+0x85c>
 8001bea:	2310      	movs	r3, #16
 8001bec:	b29b      	uxth	r3, r3
 8001bee:	61fb      	str	r3, [r7, #28]
                    for(t1=0; t1<t0; t1++) {
 8001bf0:	2300      	movs	r3, #0
 8001bf2:	61bb      	str	r3, [r7, #24]
 8001bf4:	e01d      	b.n	8001c32 <os_aes+0x8a2>
                        buf[t1] ^= (a0>>24);
 8001bf6:	683a      	ldr	r2, [r7, #0]
 8001bf8:	69bb      	ldr	r3, [r7, #24]
 8001bfa:	18d3      	adds	r3, r2, r3
 8001bfc:	7819      	ldrb	r1, [r3, #0]
 8001bfe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c00:	0e1b      	lsrs	r3, r3, #24
 8001c02:	b2da      	uxtb	r2, r3
 8001c04:	6838      	ldr	r0, [r7, #0]
 8001c06:	69bb      	ldr	r3, [r7, #24]
 8001c08:	18c3      	adds	r3, r0, r3
 8001c0a:	404a      	eors	r2, r1
 8001c0c:	b2d2      	uxtb	r2, r2
 8001c0e:	701a      	strb	r2, [r3, #0]
                        a0 <<= 8;
 8001c10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c12:	021b      	lsls	r3, r3, #8
 8001c14:	62fb      	str	r3, [r7, #44]	; 0x2c
                        if((t1&3)==3) {
 8001c16:	69bb      	ldr	r3, [r7, #24]
 8001c18:	2203      	movs	r2, #3
 8001c1a:	4013      	ands	r3, r2
 8001c1c:	2b03      	cmp	r3, #3
 8001c1e:	d105      	bne.n	8001c2c <os_aes+0x89c>
                            a0 = a1;
 8001c20:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001c22:	62fb      	str	r3, [r7, #44]	; 0x2c
                            a1 = a2;
 8001c24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001c26:	62bb      	str	r3, [r7, #40]	; 0x28
                            a2 = a3;
 8001c28:	6a3b      	ldr	r3, [r7, #32]
 8001c2a:	627b      	str	r3, [r7, #36]	; 0x24
                    for(t1=0; t1<t0; t1++) {
 8001c2c:	69bb      	ldr	r3, [r7, #24]
 8001c2e:	3301      	adds	r3, #1
 8001c30:	61bb      	str	r3, [r7, #24]
 8001c32:	69ba      	ldr	r2, [r7, #24]
 8001c34:	69fb      	ldr	r3, [r7, #28]
 8001c36:	429a      	cmp	r2, r3
 8001c38:	d3dd      	bcc.n	8001bf6 <os_aes+0x866>
                        }
                    }
                    // update counter
                    AESAUX[3]++;
 8001c3a:	4b07      	ldr	r3, [pc, #28]	; (8001c58 <os_aes+0x8c8>)
 8001c3c:	68db      	ldr	r3, [r3, #12]
 8001c3e:	1c5a      	adds	r2, r3, #1
 8001c40:	4b05      	ldr	r3, [pc, #20]	; (8001c58 <os_aes+0x8c8>)
 8001c42:	60da      	str	r2, [r3, #12]
 8001c44:	e065      	b.n	8001d12 <os_aes+0x982>
 8001c46:	46c0      	nop			; (mov r8, r8)
 8001c48:	0800e8e4 	.word	0x0800e8e4
 8001c4c:	0800e4e4 	.word	0x0800e4e4
 8001c50:	0800e0e4 	.word	0x0800e0e4
 8001c54:	0800dfe4 	.word	0x0800dfe4
 8001c58:	20000150 	.word	0x20000150
                } else { // ECB
                    // store block
                    msbf4_write(buf+0,  a0);
 8001c5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c5e:	0e1b      	lsrs	r3, r3, #24
 8001c60:	b2da      	uxtb	r2, r3
 8001c62:	683b      	ldr	r3, [r7, #0]
 8001c64:	701a      	strb	r2, [r3, #0]
 8001c66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c68:	0c1a      	lsrs	r2, r3, #16
 8001c6a:	683b      	ldr	r3, [r7, #0]
 8001c6c:	3301      	adds	r3, #1
 8001c6e:	b2d2      	uxtb	r2, r2
 8001c70:	701a      	strb	r2, [r3, #0]
 8001c72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c74:	0a1a      	lsrs	r2, r3, #8
 8001c76:	683b      	ldr	r3, [r7, #0]
 8001c78:	3302      	adds	r3, #2
 8001c7a:	b2d2      	uxtb	r2, r2
 8001c7c:	701a      	strb	r2, [r3, #0]
 8001c7e:	683b      	ldr	r3, [r7, #0]
 8001c80:	3303      	adds	r3, #3
 8001c82:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001c84:	b2d2      	uxtb	r2, r2
 8001c86:	701a      	strb	r2, [r3, #0]
                    msbf4_write(buf+4,  a1);
 8001c88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001c8a:	0e1a      	lsrs	r2, r3, #24
 8001c8c:	683b      	ldr	r3, [r7, #0]
 8001c8e:	3304      	adds	r3, #4
 8001c90:	b2d2      	uxtb	r2, r2
 8001c92:	701a      	strb	r2, [r3, #0]
 8001c94:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001c96:	0c1a      	lsrs	r2, r3, #16
 8001c98:	683b      	ldr	r3, [r7, #0]
 8001c9a:	3305      	adds	r3, #5
 8001c9c:	b2d2      	uxtb	r2, r2
 8001c9e:	701a      	strb	r2, [r3, #0]
 8001ca0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001ca2:	0a1a      	lsrs	r2, r3, #8
 8001ca4:	683b      	ldr	r3, [r7, #0]
 8001ca6:	3306      	adds	r3, #6
 8001ca8:	b2d2      	uxtb	r2, r2
 8001caa:	701a      	strb	r2, [r3, #0]
 8001cac:	683b      	ldr	r3, [r7, #0]
 8001cae:	3307      	adds	r3, #7
 8001cb0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001cb2:	b2d2      	uxtb	r2, r2
 8001cb4:	701a      	strb	r2, [r3, #0]
                    msbf4_write(buf+8,  a2);
 8001cb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001cb8:	0e1a      	lsrs	r2, r3, #24
 8001cba:	683b      	ldr	r3, [r7, #0]
 8001cbc:	3308      	adds	r3, #8
 8001cbe:	b2d2      	uxtb	r2, r2
 8001cc0:	701a      	strb	r2, [r3, #0]
 8001cc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001cc4:	0c1a      	lsrs	r2, r3, #16
 8001cc6:	683b      	ldr	r3, [r7, #0]
 8001cc8:	3309      	adds	r3, #9
 8001cca:	b2d2      	uxtb	r2, r2
 8001ccc:	701a      	strb	r2, [r3, #0]
 8001cce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001cd0:	0a1a      	lsrs	r2, r3, #8
 8001cd2:	683b      	ldr	r3, [r7, #0]
 8001cd4:	330a      	adds	r3, #10
 8001cd6:	b2d2      	uxtb	r2, r2
 8001cd8:	701a      	strb	r2, [r3, #0]
 8001cda:	683b      	ldr	r3, [r7, #0]
 8001cdc:	330b      	adds	r3, #11
 8001cde:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001ce0:	b2d2      	uxtb	r2, r2
 8001ce2:	701a      	strb	r2, [r3, #0]
                    msbf4_write(buf+12, a3);
 8001ce4:	6a3b      	ldr	r3, [r7, #32]
 8001ce6:	0e1a      	lsrs	r2, r3, #24
 8001ce8:	683b      	ldr	r3, [r7, #0]
 8001cea:	330c      	adds	r3, #12
 8001cec:	b2d2      	uxtb	r2, r2
 8001cee:	701a      	strb	r2, [r3, #0]
 8001cf0:	6a3b      	ldr	r3, [r7, #32]
 8001cf2:	0c1a      	lsrs	r2, r3, #16
 8001cf4:	683b      	ldr	r3, [r7, #0]
 8001cf6:	330d      	adds	r3, #13
 8001cf8:	b2d2      	uxtb	r2, r2
 8001cfa:	701a      	strb	r2, [r3, #0]
 8001cfc:	6a3b      	ldr	r3, [r7, #32]
 8001cfe:	0a1a      	lsrs	r2, r3, #8
 8001d00:	683b      	ldr	r3, [r7, #0]
 8001d02:	330e      	adds	r3, #14
 8001d04:	b2d2      	uxtb	r2, r2
 8001d06:	701a      	strb	r2, [r3, #0]
 8001d08:	683b      	ldr	r3, [r7, #0]
 8001d0a:	330f      	adds	r3, #15
 8001d0c:	6a3a      	ldr	r2, [r7, #32]
 8001d0e:	b2d2      	uxtb	r2, r2
 8001d10:	701a      	strb	r2, [r3, #0]
                }
            }

            // update block state
            if( (mode & AES_MIC)==0 || (mode & AES_MICNOAUX) ) {
 8001d12:	1dfb      	adds	r3, r7, #7
 8001d14:	781b      	ldrb	r3, [r3, #0]
 8001d16:	2202      	movs	r2, #2
 8001d18:	4013      	ands	r3, r2
 8001d1a:	d004      	beq.n	8001d26 <os_aes+0x996>
 8001d1c:	1dfb      	adds	r3, r7, #7
 8001d1e:	781b      	ldrb	r3, [r3, #0]
 8001d20:	2208      	movs	r2, #8
 8001d22:	4013      	ands	r3, r2
 8001d24:	d007      	beq.n	8001d36 <os_aes+0x9a6>
                buf += 16;
 8001d26:	683b      	ldr	r3, [r7, #0]
 8001d28:	3310      	adds	r3, #16
 8001d2a:	603b      	str	r3, [r7, #0]
                len -= 16;
 8001d2c:	1d3b      	adds	r3, r7, #4
 8001d2e:	1d3a      	adds	r2, r7, #4
 8001d30:	8812      	ldrh	r2, [r2, #0]
 8001d32:	3a10      	subs	r2, #16
 8001d34:	801a      	strh	r2, [r3, #0]
            }
            mode |= AES_MICNOAUX;
 8001d36:	1dfb      	adds	r3, r7, #7
 8001d38:	1dfa      	adds	r2, r7, #7
 8001d3a:	7812      	ldrb	r2, [r2, #0]
 8001d3c:	2108      	movs	r1, #8
 8001d3e:	430a      	orrs	r2, r1
 8001d40:	701a      	strb	r2, [r3, #0]
        while( (signed char)len > 0 ) {
 8001d42:	1d3b      	adds	r3, r7, #4
 8001d44:	881b      	ldrh	r3, [r3, #0]
 8001d46:	b25b      	sxtb	r3, r3
 8001d48:	2b00      	cmp	r3, #0
 8001d4a:	dd01      	ble.n	8001d50 <os_aes+0x9c0>
 8001d4c:	f7ff fba1 	bl	8001492 <os_aes+0x102>
        }
        return AESAUX[0];
 8001d50:	4b02      	ldr	r3, [pc, #8]	; (8001d5c <os_aes+0x9cc>)
 8001d52:	681b      	ldr	r3, [r3, #0]
}
 8001d54:	0018      	movs	r0, r3
 8001d56:	46bd      	mov	sp, r7
 8001d58:	b00c      	add	sp, #48	; 0x30
 8001d5a:	bd80      	pop	{r7, pc}
 8001d5c:	20000150 	.word	0x20000150

08001d60 <debug_init>:

/*  ************************************** */
/*    DO NOT CHANGE BELOW THIS LINE        */
/*  ************************************** */

void debug_init () {
 8001d60:	b580      	push	{r7, lr}
 8001d62:	af00      	add	r7, sp, #0
    // configure LED pin as output
    debug_led(0);
 8001d64:	2000      	movs	r0, #0
 8001d66:	f000 f809 	bl	8001d7c <debug_led>

    // configure USART1 (115200/8N1, tx-only)

    // print banner
    debug_str("\r\n============== DEBUG STARTED ==============\r\n");
 8001d6a:	4b03      	ldr	r3, [pc, #12]	; (8001d78 <debug_init+0x18>)
 8001d6c:	0018      	movs	r0, r3
 8001d6e:	f000 f877 	bl	8001e60 <debug_str>
}
 8001d72:	46c0      	nop			; (mov r8, r8)
 8001d74:	46bd      	mov	sp, r7
 8001d76:	bd80      	pop	{r7, pc}
 8001d78:	0800da60 	.word	0x0800da60

08001d7c <debug_led>:

void debug_led (int val) {
 8001d7c:	b580      	push	{r7, lr}
 8001d7e:	b082      	sub	sp, #8
 8001d80:	af00      	add	r7, sp, #0
 8001d82:	6078      	str	r0, [r7, #4]
    HAL_GPIO_WritePin(LED_GPIO_Port,LED_Pin,val);
 8001d84:	687b      	ldr	r3, [r7, #4]
 8001d86:	b2da      	uxtb	r2, r3
 8001d88:	23a0      	movs	r3, #160	; 0xa0
 8001d8a:	05db      	lsls	r3, r3, #23
 8001d8c:	2120      	movs	r1, #32
 8001d8e:	0018      	movs	r0, r3
 8001d90:	f006 fdf4 	bl	800897c <HAL_GPIO_WritePin>
}
 8001d94:	46c0      	nop			; (mov r8, r8)
 8001d96:	46bd      	mov	sp, r7
 8001d98:	b002      	add	sp, #8
 8001d9a:	bd80      	pop	{r7, pc}

08001d9c <debug_char>:

void debug_char (char c) {
 8001d9c:	b580      	push	{r7, lr}
 8001d9e:	b084      	sub	sp, #16
 8001da0:	af00      	add	r7, sp, #0
 8001da2:	0002      	movs	r2, r0
 8001da4:	1dfb      	adds	r3, r7, #7
 8001da6:	701a      	strb	r2, [r3, #0]
  char buffer[] = "";
 8001da8:	210c      	movs	r1, #12
 8001daa:	187b      	adds	r3, r7, r1
 8001dac:	4a08      	ldr	r2, [pc, #32]	; (8001dd0 <debug_char+0x34>)
 8001dae:	7812      	ldrb	r2, [r2, #0]
 8001db0:	701a      	strb	r2, [r3, #0]
  buffer[0]= c;
 8001db2:	187b      	adds	r3, r7, r1
 8001db4:	1dfa      	adds	r2, r7, #7
 8001db6:	7812      	ldrb	r2, [r2, #0]
 8001db8:	701a      	strb	r2, [r3, #0]
  HAL_UART_Transmit(&myUART,buffer,sizeof(buffer),HAL_MAX_DELAY);
 8001dba:	2301      	movs	r3, #1
 8001dbc:	425b      	negs	r3, r3
 8001dbe:	1879      	adds	r1, r7, r1
 8001dc0:	4804      	ldr	r0, [pc, #16]	; (8001dd4 <debug_char+0x38>)
 8001dc2:	2201      	movs	r2, #1
 8001dc4:	f00a ff90 	bl	800cce8 <HAL_UART_Transmit>
}
 8001dc8:	46c0      	nop			; (mov r8, r8)
 8001dca:	46bd      	mov	sp, r7
 8001dcc:	b004      	add	sp, #16
 8001dce:	bd80      	pop	{r7, pc}
 8001dd0:	0800da90 	.word	0x0800da90
 8001dd4:	20000204 	.word	0x20000204

08001dd8 <debug_hex>:

void debug_hex (u1_t b) {
 8001dd8:	b580      	push	{r7, lr}
 8001dda:	b082      	sub	sp, #8
 8001ddc:	af00      	add	r7, sp, #0
 8001dde:	0002      	movs	r2, r0
 8001de0:	1dfb      	adds	r3, r7, #7
 8001de2:	701a      	strb	r2, [r3, #0]
    debug_char("0123456789ABCDEF"[b>>4]);
 8001de4:	1dfb      	adds	r3, r7, #7
 8001de6:	781b      	ldrb	r3, [r3, #0]
 8001de8:	091b      	lsrs	r3, r3, #4
 8001dea:	b2db      	uxtb	r3, r3
 8001dec:	001a      	movs	r2, r3
 8001dee:	4b09      	ldr	r3, [pc, #36]	; (8001e14 <debug_hex+0x3c>)
 8001df0:	5c9b      	ldrb	r3, [r3, r2]
 8001df2:	0018      	movs	r0, r3
 8001df4:	f7ff ffd2 	bl	8001d9c <debug_char>
    debug_char("0123456789ABCDEF"[b&0xF]);
 8001df8:	1dfb      	adds	r3, r7, #7
 8001dfa:	781b      	ldrb	r3, [r3, #0]
 8001dfc:	220f      	movs	r2, #15
 8001dfe:	4013      	ands	r3, r2
 8001e00:	4a04      	ldr	r2, [pc, #16]	; (8001e14 <debug_hex+0x3c>)
 8001e02:	5cd3      	ldrb	r3, [r2, r3]
 8001e04:	0018      	movs	r0, r3
 8001e06:	f7ff ffc9 	bl	8001d9c <debug_char>
}
 8001e0a:	46c0      	nop			; (mov r8, r8)
 8001e0c:	46bd      	mov	sp, r7
 8001e0e:	b002      	add	sp, #8
 8001e10:	bd80      	pop	{r7, pc}
 8001e12:	46c0      	nop			; (mov r8, r8)
 8001e14:	0800da94 	.word	0x0800da94

08001e18 <debug_uint>:
    }
    debug_char('\r');
    debug_char('\n');
}

void debug_uint (u4_t v) {
 8001e18:	b590      	push	{r4, r7, lr}
 8001e1a:	b085      	sub	sp, #20
 8001e1c:	af00      	add	r7, sp, #0
 8001e1e:	6078      	str	r0, [r7, #4]
    for(s1_t n=24; n>=0; n-=8) {
 8001e20:	230f      	movs	r3, #15
 8001e22:	18fb      	adds	r3, r7, r3
 8001e24:	2218      	movs	r2, #24
 8001e26:	701a      	strb	r2, [r3, #0]
 8001e28:	e010      	b.n	8001e4c <debug_uint+0x34>
        debug_hex(v>>n);
 8001e2a:	240f      	movs	r4, #15
 8001e2c:	193b      	adds	r3, r7, r4
 8001e2e:	781b      	ldrb	r3, [r3, #0]
 8001e30:	b25b      	sxtb	r3, r3
 8001e32:	687a      	ldr	r2, [r7, #4]
 8001e34:	40da      	lsrs	r2, r3
 8001e36:	0013      	movs	r3, r2
 8001e38:	b2db      	uxtb	r3, r3
 8001e3a:	0018      	movs	r0, r3
 8001e3c:	f7ff ffcc 	bl	8001dd8 <debug_hex>
    for(s1_t n=24; n>=0; n-=8) {
 8001e40:	193b      	adds	r3, r7, r4
 8001e42:	781b      	ldrb	r3, [r3, #0]
 8001e44:	3b08      	subs	r3, #8
 8001e46:	b2da      	uxtb	r2, r3
 8001e48:	193b      	adds	r3, r7, r4
 8001e4a:	701a      	strb	r2, [r3, #0]
 8001e4c:	230f      	movs	r3, #15
 8001e4e:	18fb      	adds	r3, r7, r3
 8001e50:	781b      	ldrb	r3, [r3, #0]
 8001e52:	2b7f      	cmp	r3, #127	; 0x7f
 8001e54:	d9e9      	bls.n	8001e2a <debug_uint+0x12>
    }
}
 8001e56:	46c0      	nop			; (mov r8, r8)
 8001e58:	46c0      	nop			; (mov r8, r8)
 8001e5a:	46bd      	mov	sp, r7
 8001e5c:	b005      	add	sp, #20
 8001e5e:	bd90      	pop	{r4, r7, pc}

08001e60 <debug_str>:
    int n = debug_fmt(buf, sizeof(buf), v, 10, 0, 0);
    while(n--)
        debug_char(*p++);
}

void debug_str (const char* str) {
 8001e60:	b580      	push	{r7, lr}
 8001e62:	b082      	sub	sp, #8
 8001e64:	af00      	add	r7, sp, #0
 8001e66:	6078      	str	r0, [r7, #4]
    while(*str) {
 8001e68:	e006      	b.n	8001e78 <debug_str+0x18>
        debug_char(*str++);
 8001e6a:	687b      	ldr	r3, [r7, #4]
 8001e6c:	1c5a      	adds	r2, r3, #1
 8001e6e:	607a      	str	r2, [r7, #4]
 8001e70:	781b      	ldrb	r3, [r3, #0]
 8001e72:	0018      	movs	r0, r3
 8001e74:	f7ff ff92 	bl	8001d9c <debug_char>
    while(*str) {
 8001e78:	687b      	ldr	r3, [r7, #4]
 8001e7a:	781b      	ldrb	r3, [r3, #0]
 8001e7c:	2b00      	cmp	r3, #0
 8001e7e:	d1f4      	bne.n	8001e6a <debug_str+0xa>
    }
}
 8001e80:	46c0      	nop			; (mov r8, r8)
 8001e82:	46c0      	nop			; (mov r8, r8)
 8001e84:	46bd      	mov	sp, r7
 8001e86:	b002      	add	sp, #8
 8001e88:	bd80      	pop	{r7, pc}

08001e8a <debug_val>:

void debug_val (const char* label, u4_t val) {
 8001e8a:	b580      	push	{r7, lr}
 8001e8c:	b082      	sub	sp, #8
 8001e8e:	af00      	add	r7, sp, #0
 8001e90:	6078      	str	r0, [r7, #4]
 8001e92:	6039      	str	r1, [r7, #0]
    debug_str(label);
 8001e94:	687b      	ldr	r3, [r7, #4]
 8001e96:	0018      	movs	r0, r3
 8001e98:	f7ff ffe2 	bl	8001e60 <debug_str>
    debug_uint(val);
 8001e9c:	683b      	ldr	r3, [r7, #0]
 8001e9e:	0018      	movs	r0, r3
 8001ea0:	f7ff ffba 	bl	8001e18 <debug_uint>
    debug_char('\r');
 8001ea4:	200d      	movs	r0, #13
 8001ea6:	f7ff ff79 	bl	8001d9c <debug_char>
    debug_char('\n');
 8001eaa:	200a      	movs	r0, #10
 8001eac:	f7ff ff76 	bl	8001d9c <debug_char>
}
 8001eb0:	46c0      	nop			; (mov r8, r8)
 8001eb2:	46bd      	mov	sp, r7
 8001eb4:	b002      	add	sp, #8
 8001eb6:	bd80      	pop	{r7, pc}

08001eb8 <debug_event>:
    while( b-buf < max && p > num );
    // return number of characters written
    return b - buf;
}

void debug_event (int ev) {
 8001eb8:	b580      	push	{r7, lr}
 8001eba:	b082      	sub	sp, #8
 8001ebc:	af00      	add	r7, sp, #0
 8001ebe:	6078      	str	r0, [r7, #4]
        [EV_LINK_DEAD]      = "LINK_DEAD",
        [EV_LINK_ALIVE]     = "LINK_ALIVE",
        [EV_SCAN_FOUND]     = "SCAN_FOUND",
        [EV_TXSTART]        = "EV_TXSTART",
    };
    debug_str((ev < sizeof(evnames)/sizeof(evnames[0])) ? evnames[ev] : "EV_UNKNOWN" );
 8001ec0:	687b      	ldr	r3, [r7, #4]
 8001ec2:	2b11      	cmp	r3, #17
 8001ec4:	d804      	bhi.n	8001ed0 <debug_event+0x18>
 8001ec6:	4b09      	ldr	r3, [pc, #36]	; (8001eec <debug_event+0x34>)
 8001ec8:	687a      	ldr	r2, [r7, #4]
 8001eca:	0092      	lsls	r2, r2, #2
 8001ecc:	58d3      	ldr	r3, [r2, r3]
 8001ece:	e000      	b.n	8001ed2 <debug_event+0x1a>
 8001ed0:	4b07      	ldr	r3, [pc, #28]	; (8001ef0 <debug_event+0x38>)
 8001ed2:	0018      	movs	r0, r3
 8001ed4:	f7ff ffc4 	bl	8001e60 <debug_str>
    debug_char('\r');
 8001ed8:	200d      	movs	r0, #13
 8001eda:	f7ff ff5f 	bl	8001d9c <debug_char>
    debug_char('\n');
 8001ede:	200a      	movs	r0, #10
 8001ee0:	f7ff ff5c 	bl	8001d9c <debug_char>
}
 8001ee4:	46c0      	nop			; (mov r8, r8)
 8001ee6:	46bd      	mov	sp, r7
 8001ee8:	b002      	add	sp, #8
 8001eea:	bd80      	pop	{r7, pc}
 8001eec:	20000000 	.word	0x20000000
 8001ef0:	0800daa8 	.word	0x0800daa8

08001ef4 <hal_io_init>:
} HAL;

// -----------------------------------------------------------------------------
// I/O

static void hal_io_init () {
 8001ef4:	b580      	push	{r7, lr}
 8001ef6:	af00      	add	r7, sp, #0
	//already done by cubemx
}
 8001ef8:	46c0      	nop			; (mov r8, r8)
 8001efa:	46bd      	mov	sp, r7
 8001efc:	bd80      	pop	{r7, pc}

08001efe <hal_pin_rxtx>:

// val ==1  => tx 1, rx 0 ; val == 0 => tx 0, rx 1
void hal_pin_rxtx (u1_t val) {
 8001efe:	b580      	push	{r7, lr}
 8001f00:	b082      	sub	sp, #8
 8001f02:	af00      	add	r7, sp, #0
 8001f04:	0002      	movs	r2, r0
 8001f06:	1dfb      	adds	r3, r7, #7
 8001f08:	701a      	strb	r2, [r3, #0]
  #ifdef TX_GPIO_Port
    HAL_GPIO_WritePin(RX_GPIO_Port,RX_Pin,~val);
    HAL_GPIO_WritePin(TX_GPIO_Port,TX_Pin,val);
  #endif
#endif
}
 8001f0a:	46c0      	nop			; (mov r8, r8)
 8001f0c:	46bd      	mov	sp, r7
 8001f0e:	b002      	add	sp, #8
 8001f10:	bd80      	pop	{r7, pc}

08001f12 <hal_pin_nss>:

// set radio NSS pin to given value
void hal_pin_nss (u1_t val) {
 8001f12:	b580      	push	{r7, lr}
 8001f14:	b082      	sub	sp, #8
 8001f16:	af00      	add	r7, sp, #0
 8001f18:	0002      	movs	r2, r0
 8001f1a:	1dfb      	adds	r3, r7, #7
 8001f1c:	701a      	strb	r2, [r3, #0]
    HAL_GPIO_WritePin(NSS_GPIO_Port,NSS_Pin,val);
 8001f1e:	1dfb      	adds	r3, r7, #7
 8001f20:	781a      	ldrb	r2, [r3, #0]
 8001f22:	2380      	movs	r3, #128	; 0x80
 8001f24:	0219      	lsls	r1, r3, #8
 8001f26:	23a0      	movs	r3, #160	; 0xa0
 8001f28:	05db      	lsls	r3, r3, #23
 8001f2a:	0018      	movs	r0, r3
 8001f2c:	f006 fd26 	bl	800897c <HAL_GPIO_WritePin>
}
 8001f30:	46c0      	nop			; (mov r8, r8)
 8001f32:	46bd      	mov	sp, r7
 8001f34:	b002      	add	sp, #8
 8001f36:	bd80      	pop	{r7, pc}

08001f38 <hal_pin_rst>:

// set radio RST pin to given value (or keep floating!)
void hal_pin_rst (u1_t val) {
 8001f38:	b580      	push	{r7, lr}
 8001f3a:	b08c      	sub	sp, #48	; 0x30
 8001f3c:	af00      	add	r7, sp, #0
 8001f3e:	0002      	movs	r2, r0
 8001f40:	1dfb      	adds	r3, r7, #7
 8001f42:	701a      	strb	r2, [r3, #0]
    if(val == 0 || val == 1) { // drive pin
 8001f44:	1dfb      	adds	r3, r7, #7
 8001f46:	781b      	ldrb	r3, [r3, #0]
 8001f48:	2b00      	cmp	r3, #0
 8001f4a:	d003      	beq.n	8001f54 <hal_pin_rst+0x1c>
 8001f4c:	1dfb      	adds	r3, r7, #7
 8001f4e:	781b      	ldrb	r3, [r3, #0]
 8001f50:	2b01      	cmp	r3, #1
 8001f52:	d117      	bne.n	8001f84 <hal_pin_rst+0x4c>
    	GPIO_InitTypeDef GPIO_InitStruct;
    	GPIO_InitStruct.Pin = RST_Pin;
 8001f54:	211c      	movs	r1, #28
 8001f56:	187b      	adds	r3, r7, r1
 8001f58:	2201      	movs	r2, #1
 8001f5a:	601a      	str	r2, [r3, #0]
    	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001f5c:	187b      	adds	r3, r7, r1
 8001f5e:	2201      	movs	r2, #1
 8001f60:	605a      	str	r2, [r3, #4]
    	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001f62:	187b      	adds	r3, r7, r1
 8001f64:	2200      	movs	r2, #0
 8001f66:	60da      	str	r2, [r3, #12]
    	HAL_GPIO_Init(RST_GPIO_Port, &GPIO_InitStruct);
 8001f68:	187b      	adds	r3, r7, r1
 8001f6a:	4a11      	ldr	r2, [pc, #68]	; (8001fb0 <hal_pin_rst+0x78>)
 8001f6c:	0019      	movs	r1, r3
 8001f6e:	0010      	movs	r0, r2
 8001f70:	f006 fa74 	bl	800845c <HAL_GPIO_Init>

    	HAL_GPIO_WritePin(RST_GPIO_Port,RST_Pin,val);
 8001f74:	1dfb      	adds	r3, r7, #7
 8001f76:	781b      	ldrb	r3, [r3, #0]
 8001f78:	480d      	ldr	r0, [pc, #52]	; (8001fb0 <hal_pin_rst+0x78>)
 8001f7a:	001a      	movs	r2, r3
 8001f7c:	2101      	movs	r1, #1
 8001f7e:	f006 fcfd 	bl	800897c <HAL_GPIO_WritePin>
    if(val == 0 || val == 1) { // drive pin
 8001f82:	e010      	b.n	8001fa6 <hal_pin_rst+0x6e>

    } else { // keep pin floating
        GPIO_InitTypeDef GPIO_InitStruct;
    	GPIO_InitStruct.Pin = RST_Pin;
 8001f84:	2108      	movs	r1, #8
 8001f86:	187b      	adds	r3, r7, r1
 8001f88:	2201      	movs	r2, #1
 8001f8a:	601a      	str	r2, [r3, #0]
    	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8001f8c:	187b      	adds	r3, r7, r1
 8001f8e:	2200      	movs	r2, #0
 8001f90:	605a      	str	r2, [r3, #4]
    	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001f92:	187b      	adds	r3, r7, r1
 8001f94:	2200      	movs	r2, #0
 8001f96:	609a      	str	r2, [r3, #8]
    	HAL_GPIO_Init(RST_GPIO_Port, &GPIO_InitStruct);
 8001f98:	187b      	adds	r3, r7, r1
 8001f9a:	4a05      	ldr	r2, [pc, #20]	; (8001fb0 <hal_pin_rst+0x78>)
 8001f9c:	0019      	movs	r1, r3
 8001f9e:	0010      	movs	r0, r2
 8001fa0:	f006 fa5c 	bl	800845c <HAL_GPIO_Init>
    }
}
 8001fa4:	46c0      	nop			; (mov r8, r8)
 8001fa6:	46c0      	nop			; (mov r8, r8)
 8001fa8:	46bd      	mov	sp, r7
 8001faa:	b00c      	add	sp, #48	; 0x30
 8001fac:	bd80      	pop	{r7, pc}
 8001fae:	46c0      	nop			; (mov r8, r8)
 8001fb0:	50000800 	.word	0x50000800

08001fb4 <HAL_GPIO_EXTI_Callback>:

extern void radio_irq_handler(u1_t dio);

// generic EXTI IRQ handler for all channels
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin_int){
 8001fb4:	b580      	push	{r7, lr}
 8001fb6:	b082      	sub	sp, #8
 8001fb8:	af00      	add	r7, sp, #0
 8001fba:	0002      	movs	r2, r0
 8001fbc:	1dbb      	adds	r3, r7, #6
 8001fbe:	801a      	strh	r2, [r3, #0]
	// DIO 0
	if(GPIO_Pin_int == DIO0_Pin) {
 8001fc0:	1dbb      	adds	r3, r7, #6
 8001fc2:	881b      	ldrh	r3, [r3, #0]
 8001fc4:	2b10      	cmp	r3, #16
 8001fc6:	d102      	bne.n	8001fce <HAL_GPIO_EXTI_Callback+0x1a>
		// invoke radio handler (on IRQ!)
		radio_irq_handler(0);
 8001fc8:	2000      	movs	r0, #0
 8001fca:	f004 ff4b 	bl	8006e64 <radio_irq_handler>
	}
	// DIO 1
	if(GPIO_Pin_int == DIO1_Pin) {
 8001fce:	1dbb      	adds	r3, r7, #6
 8001fd0:	881b      	ldrh	r3, [r3, #0]
 8001fd2:	2b02      	cmp	r3, #2
 8001fd4:	d102      	bne.n	8001fdc <HAL_GPIO_EXTI_Callback+0x28>
	    // invoke radio handler (on IRQ!)
		radio_irq_handler(1);
 8001fd6:	2001      	movs	r0, #1
 8001fd8:	f004 ff44 	bl	8006e64 <radio_irq_handler>
	}
	// DIO 2
	if(GPIO_Pin_int == DIO2_Pin) {
 8001fdc:	1dbb      	adds	r3, r7, #6
 8001fde:	881b      	ldrh	r3, [r3, #0]
 8001fe0:	2b01      	cmp	r3, #1
 8001fe2:	d102      	bne.n	8001fea <HAL_GPIO_EXTI_Callback+0x36>
	    // invoke radio handler (on IRQ!)
	    radio_irq_handler(2);
 8001fe4:	2002      	movs	r0, #2
 8001fe6:	f004 ff3d 	bl	8006e64 <radio_irq_handler>
	}
}
 8001fea:	46c0      	nop			; (mov r8, r8)
 8001fec:	46bd      	mov	sp, r7
 8001fee:	b002      	add	sp, #8
 8001ff0:	bd80      	pop	{r7, pc}

08001ff2 <hal_spi_init>:

// -----------------------------------------------------------------------------
// SPI
void hal_spi_init () {
 8001ff2:	b580      	push	{r7, lr}
 8001ff4:	af00      	add	r7, sp, #0
	// already done by cube mx
}
 8001ff6:	46c0      	nop			; (mov r8, r8)
 8001ff8:	46bd      	mov	sp, r7
 8001ffa:	bd80      	pop	{r7, pc}

08001ffc <hal_spi>:

// perform SPI transaction with radio
u1_t hal_spi (u1_t out) {
 8001ffc:	b590      	push	{r4, r7, lr}
 8001ffe:	b087      	sub	sp, #28
 8002000:	af02      	add	r7, sp, #8
 8002002:	0002      	movs	r2, r0
 8002004:	1dfb      	adds	r3, r7, #7
 8002006:	701a      	strb	r2, [r3, #0]
	char outbuffer[] ="";
 8002008:	210c      	movs	r1, #12
 800200a:	187b      	adds	r3, r7, r1
 800200c:	4a0d      	ldr	r2, [pc, #52]	; (8002044 <hal_spi+0x48>)
 800200e:	7812      	ldrb	r2, [r2, #0]
 8002010:	701a      	strb	r2, [r3, #0]
	char inbuffer[] ="";
 8002012:	2008      	movs	r0, #8
 8002014:	183b      	adds	r3, r7, r0
 8002016:	4a0b      	ldr	r2, [pc, #44]	; (8002044 <hal_spi+0x48>)
 8002018:	7812      	ldrb	r2, [r2, #0]
 800201a:	701a      	strb	r2, [r3, #0]
	outbuffer[0] = out;
 800201c:	187b      	adds	r3, r7, r1
 800201e:	1dfa      	adds	r2, r7, #7
 8002020:	7812      	ldrb	r2, [r2, #0]
 8002022:	701a      	strb	r2, [r3, #0]
	HAL_SPI_TransmitReceive(&mySPI,outbuffer,inbuffer,sizeof(outbuffer),HAL_MAX_DELAY);
 8002024:	0004      	movs	r4, r0
 8002026:	183a      	adds	r2, r7, r0
 8002028:	1879      	adds	r1, r7, r1
 800202a:	4807      	ldr	r0, [pc, #28]	; (8002048 <hal_spi+0x4c>)
 800202c:	2301      	movs	r3, #1
 800202e:	425b      	negs	r3, r3
 8002030:	9300      	str	r3, [sp, #0]
 8002032:	2301      	movs	r3, #1
 8002034:	f009 f922 	bl	800b27c <HAL_SPI_TransmitReceive>
	return inbuffer[0];
 8002038:	193b      	adds	r3, r7, r4
 800203a:	781b      	ldrb	r3, [r3, #0]
}
 800203c:	0018      	movs	r0, r3
 800203e:	46bd      	mov	sp, r7
 8002040:	b005      	add	sp, #20
 8002042:	bd90      	pop	{r4, r7, pc}
 8002044:	0800db84 	.word	0x0800db84
 8002048:	200001ac 	.word	0x200001ac

0800204c <hal_time_init>:


// -----------------------------------------------------------------------------
// TIME
static void hal_time_init () {
 800204c:	b580      	push	{r7, lr}
 800204e:	af00      	add	r7, sp, #0
	// already done by cubemx
}
 8002050:	46c0      	nop			; (mov r8, r8)
 8002052:	46bd      	mov	sp, r7
 8002054:	bd80      	pop	{r7, pc}
	...

08002058 <hal_ticks>:

u4_t hal_ticks () {
 8002058:	b580      	push	{r7, lr}
 800205a:	b082      	sub	sp, #8
 800205c:	af00      	add	r7, sp, #0
    hal_disableIRQs();
 800205e:	f000 f8b7 	bl	80021d0 <hal_disableIRQs>
    u4_t t = HAL.ticks;
 8002062:	4b14      	ldr	r3, [pc, #80]	; (80020b4 <hal_ticks+0x5c>)
 8002064:	685b      	ldr	r3, [r3, #4]
 8002066:	607b      	str	r3, [r7, #4]
    u2_t cnt = __HAL_TIM_GET_COUNTER(&myTIMER);
 8002068:	4b13      	ldr	r3, [pc, #76]	; (80020b8 <hal_ticks+0x60>)
 800206a:	681b      	ldr	r3, [r3, #0]
 800206c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800206e:	1cbb      	adds	r3, r7, #2
 8002070:	801a      	strh	r2, [r3, #0]
    if(__HAL_TIM_GET_FLAG(&myTIMER, TIM_FLAG_CC1) != RESET){
 8002072:	4b11      	ldr	r3, [pc, #68]	; (80020b8 <hal_ticks+0x60>)
 8002074:	681b      	ldr	r3, [r3, #0]
 8002076:	691b      	ldr	r3, [r3, #16]
 8002078:	2202      	movs	r2, #2
 800207a:	4013      	ands	r3, r2
 800207c:	2b02      	cmp	r3, #2
 800207e:	d10e      	bne.n	800209e <hal_ticks+0x46>
    	if(__HAL_TIM_GET_IT_SOURCE(&myTIMER, TIM_IT_CC1) !=RESET){
 8002080:	4b0d      	ldr	r3, [pc, #52]	; (80020b8 <hal_ticks+0x60>)
 8002082:	681b      	ldr	r3, [r3, #0]
 8002084:	68db      	ldr	r3, [r3, #12]
 8002086:	2202      	movs	r2, #2
 8002088:	4013      	ands	r3, r2
 800208a:	2b02      	cmp	r3, #2
 800208c:	d107      	bne.n	800209e <hal_ticks+0x46>
    		cnt = __HAL_TIM_GET_COUNTER(&myTIMER);
 800208e:	4b0a      	ldr	r3, [pc, #40]	; (80020b8 <hal_ticks+0x60>)
 8002090:	681b      	ldr	r3, [r3, #0]
 8002092:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002094:	1cbb      	adds	r3, r7, #2
 8002096:	801a      	strh	r2, [r3, #0]
    		t++;
 8002098:	687b      	ldr	r3, [r7, #4]
 800209a:	3301      	adds	r3, #1
 800209c:	607b      	str	r3, [r7, #4]
        }
     }
    hal_enableIRQs();
 800209e:	f000 f8a5 	bl	80021ec <hal_enableIRQs>
    return (t<<16)|cnt;
 80020a2:	687b      	ldr	r3, [r7, #4]
 80020a4:	041a      	lsls	r2, r3, #16
 80020a6:	1cbb      	adds	r3, r7, #2
 80020a8:	881b      	ldrh	r3, [r3, #0]
 80020aa:	4313      	orrs	r3, r2
}
 80020ac:	0018      	movs	r0, r3
 80020ae:	46bd      	mov	sp, r7
 80020b0:	b002      	add	sp, #8
 80020b2:	bd80      	pop	{r7, pc}
 80020b4:	20000074 	.word	0x20000074
 80020b8:	200002e4 	.word	0x200002e4

080020bc <deltaticks>:

// return modified delta ticks from now to specified ticktime (0 for past, FFFF for far future)
static u2_t deltaticks (u4_t time) {
 80020bc:	b580      	push	{r7, lr}
 80020be:	b084      	sub	sp, #16
 80020c0:	af00      	add	r7, sp, #0
 80020c2:	6078      	str	r0, [r7, #4]
    u4_t t = hal_ticks();
 80020c4:	f7ff ffc8 	bl	8002058 <hal_ticks>
 80020c8:	0003      	movs	r3, r0
 80020ca:	60fb      	str	r3, [r7, #12]
    s4_t d = time - t;
 80020cc:	687a      	ldr	r2, [r7, #4]
 80020ce:	68fb      	ldr	r3, [r7, #12]
 80020d0:	1ad3      	subs	r3, r2, r3
 80020d2:	60bb      	str	r3, [r7, #8]
    if( d<=0 ) return 0;    // in the past
 80020d4:	68bb      	ldr	r3, [r7, #8]
 80020d6:	2b00      	cmp	r3, #0
 80020d8:	dc01      	bgt.n	80020de <deltaticks+0x22>
 80020da:	2300      	movs	r3, #0
 80020dc:	e006      	b.n	80020ec <deltaticks+0x30>
    if( (d>>16)!=0 ) return 0xFFFF; // far ahead
 80020de:	68bb      	ldr	r3, [r7, #8]
 80020e0:	141b      	asrs	r3, r3, #16
 80020e2:	d001      	beq.n	80020e8 <deltaticks+0x2c>
 80020e4:	4b03      	ldr	r3, [pc, #12]	; (80020f4 <deltaticks+0x38>)
 80020e6:	e001      	b.n	80020ec <deltaticks+0x30>
    return (u2_t)d;
 80020e8:	68bb      	ldr	r3, [r7, #8]
 80020ea:	b29b      	uxth	r3, r3
}
 80020ec:	0018      	movs	r0, r3
 80020ee:	46bd      	mov	sp, r7
 80020f0:	b004      	add	sp, #16
 80020f2:	bd80      	pop	{r7, pc}
 80020f4:	0000ffff 	.word	0x0000ffff

080020f8 <hal_waitUntil>:

void hal_waitUntil (u4_t time) {
 80020f8:	b580      	push	{r7, lr}
 80020fa:	b082      	sub	sp, #8
 80020fc:	af00      	add	r7, sp, #0
 80020fe:	6078      	str	r0, [r7, #4]
    while( deltaticks(time) != 0 ); // busy wait until timestamp is reached
 8002100:	46c0      	nop			; (mov r8, r8)
 8002102:	687b      	ldr	r3, [r7, #4]
 8002104:	0018      	movs	r0, r3
 8002106:	f7ff ffd9 	bl	80020bc <deltaticks>
 800210a:	1e03      	subs	r3, r0, #0
 800210c:	d1f9      	bne.n	8002102 <hal_waitUntil+0xa>
}
 800210e:	46c0      	nop			; (mov r8, r8)
 8002110:	46c0      	nop			; (mov r8, r8)
 8002112:	46bd      	mov	sp, r7
 8002114:	b002      	add	sp, #8
 8002116:	bd80      	pop	{r7, pc}

08002118 <hal_checkTimer>:

// check and rewind for target time
u1_t hal_checkTimer (u4_t time) {
 8002118:	b5b0      	push	{r4, r5, r7, lr}
 800211a:	b084      	sub	sp, #16
 800211c:	af00      	add	r7, sp, #0
 800211e:	6078      	str	r0, [r7, #4]
    u2_t dt;
    myTIMER.Instance->SR &= ~TIM_SR_CC1IF; // clear any pending interrupts
 8002120:	4b1e      	ldr	r3, [pc, #120]	; (800219c <hal_checkTimer+0x84>)
 8002122:	681b      	ldr	r3, [r3, #0]
 8002124:	691a      	ldr	r2, [r3, #16]
 8002126:	4b1d      	ldr	r3, [pc, #116]	; (800219c <hal_checkTimer+0x84>)
 8002128:	681b      	ldr	r3, [r3, #0]
 800212a:	2102      	movs	r1, #2
 800212c:	438a      	bics	r2, r1
 800212e:	611a      	str	r2, [r3, #16]
    if((dt = deltaticks(time)) < 5) { // event is now (a few ticks ahead)
 8002130:	250e      	movs	r5, #14
 8002132:	197c      	adds	r4, r7, r5
 8002134:	687b      	ldr	r3, [r7, #4]
 8002136:	0018      	movs	r0, r3
 8002138:	f7ff ffc0 	bl	80020bc <deltaticks>
 800213c:	0003      	movs	r3, r0
 800213e:	8023      	strh	r3, [r4, #0]
 8002140:	197b      	adds	r3, r7, r5
 8002142:	881b      	ldrh	r3, [r3, #0]
 8002144:	2b04      	cmp	r3, #4
 8002146:	d809      	bhi.n	800215c <hal_checkTimer+0x44>
    	myTIMER.Instance->DIER &= ~TIM_DIER_CC1IE; // disable IE
 8002148:	4b14      	ldr	r3, [pc, #80]	; (800219c <hal_checkTimer+0x84>)
 800214a:	681b      	ldr	r3, [r3, #0]
 800214c:	68da      	ldr	r2, [r3, #12]
 800214e:	4b13      	ldr	r3, [pc, #76]	; (800219c <hal_checkTimer+0x84>)
 8002150:	681b      	ldr	r3, [r3, #0]
 8002152:	2102      	movs	r1, #2
 8002154:	438a      	bics	r2, r1
 8002156:	60da      	str	r2, [r3, #12]
        return 1;
 8002158:	2301      	movs	r3, #1
 800215a:	e01a      	b.n	8002192 <hal_checkTimer+0x7a>
    } else { // rewind timer (fully or to exact time))
    	myTIMER.Instance->CCR1 = myTIMER.Instance->CNT + dt;   // set comparator
 800215c:	4b0f      	ldr	r3, [pc, #60]	; (800219c <hal_checkTimer+0x84>)
 800215e:	681b      	ldr	r3, [r3, #0]
 8002160:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8002162:	230e      	movs	r3, #14
 8002164:	18fb      	adds	r3, r7, r3
 8002166:	881a      	ldrh	r2, [r3, #0]
 8002168:	4b0c      	ldr	r3, [pc, #48]	; (800219c <hal_checkTimer+0x84>)
 800216a:	681b      	ldr	r3, [r3, #0]
 800216c:	188a      	adds	r2, r1, r2
 800216e:	635a      	str	r2, [r3, #52]	; 0x34
    	myTIMER.Instance->DIER |= TIM_DIER_CC1IE;  // enable IE
 8002170:	4b0a      	ldr	r3, [pc, #40]	; (800219c <hal_checkTimer+0x84>)
 8002172:	681b      	ldr	r3, [r3, #0]
 8002174:	68da      	ldr	r2, [r3, #12]
 8002176:	4b09      	ldr	r3, [pc, #36]	; (800219c <hal_checkTimer+0x84>)
 8002178:	681b      	ldr	r3, [r3, #0]
 800217a:	2102      	movs	r1, #2
 800217c:	430a      	orrs	r2, r1
 800217e:	60da      	str	r2, [r3, #12]
    	myTIMER.Instance->CCER |= TIM_CCER_CC1E;   // enable capture/compare uint 2
 8002180:	4b06      	ldr	r3, [pc, #24]	; (800219c <hal_checkTimer+0x84>)
 8002182:	681b      	ldr	r3, [r3, #0]
 8002184:	6a1a      	ldr	r2, [r3, #32]
 8002186:	4b05      	ldr	r3, [pc, #20]	; (800219c <hal_checkTimer+0x84>)
 8002188:	681b      	ldr	r3, [r3, #0]
 800218a:	2101      	movs	r1, #1
 800218c:	430a      	orrs	r2, r1
 800218e:	621a      	str	r2, [r3, #32]
        return 0;
 8002190:	2300      	movs	r3, #0
    }
}
 8002192:	0018      	movs	r0, r3
 8002194:	46bd      	mov	sp, r7
 8002196:	b004      	add	sp, #16
 8002198:	bdb0      	pop	{r4, r5, r7, pc}
 800219a:	46c0      	nop			; (mov r8, r8)
 800219c:	200002e4 	.word	0x200002e4

080021a0 <HAL_TIM_PeriodElapsedCallback>:

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
 80021a0:	b580      	push	{r7, lr}
 80021a2:	b082      	sub	sp, #8
 80021a4:	af00      	add	r7, sp, #0
 80021a6:	6078      	str	r0, [r7, #4]
	if(htim->Instance == myTIMER.Instance){
 80021a8:	687b      	ldr	r3, [r7, #4]
 80021aa:	681a      	ldr	r2, [r3, #0]
 80021ac:	4b06      	ldr	r3, [pc, #24]	; (80021c8 <HAL_TIM_PeriodElapsedCallback+0x28>)
 80021ae:	681b      	ldr	r3, [r3, #0]
 80021b0:	429a      	cmp	r2, r3
 80021b2:	d104      	bne.n	80021be <HAL_TIM_PeriodElapsedCallback+0x1e>
		HAL.ticks++;
 80021b4:	4b05      	ldr	r3, [pc, #20]	; (80021cc <HAL_TIM_PeriodElapsedCallback+0x2c>)
 80021b6:	685b      	ldr	r3, [r3, #4]
 80021b8:	1c5a      	adds	r2, r3, #1
 80021ba:	4b04      	ldr	r3, [pc, #16]	; (80021cc <HAL_TIM_PeriodElapsedCallback+0x2c>)
 80021bc:	605a      	str	r2, [r3, #4]
    }
}
 80021be:	46c0      	nop			; (mov r8, r8)
 80021c0:	46bd      	mov	sp, r7
 80021c2:	b002      	add	sp, #8
 80021c4:	bd80      	pop	{r7, pc}
 80021c6:	46c0      	nop			; (mov r8, r8)
 80021c8:	200002e4 	.word	0x200002e4
 80021cc:	20000074 	.word	0x20000074

080021d0 <hal_disableIRQs>:

// -----------------------------------------------------------------------------
// IRQ
void hal_disableIRQs () {
 80021d0:	b580      	push	{r7, lr}
 80021d2:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80021d4:	b672      	cpsid	i
}
 80021d6:	46c0      	nop			; (mov r8, r8)
	__disable_irq();
	//__set_BASEPRI(1 << 4);
    HAL.irqlevel++;
 80021d8:	4b03      	ldr	r3, [pc, #12]	; (80021e8 <hal_disableIRQs+0x18>)
 80021da:	681b      	ldr	r3, [r3, #0]
 80021dc:	1c5a      	adds	r2, r3, #1
 80021de:	4b02      	ldr	r3, [pc, #8]	; (80021e8 <hal_disableIRQs+0x18>)
 80021e0:	601a      	str	r2, [r3, #0]
}
 80021e2:	46c0      	nop			; (mov r8, r8)
 80021e4:	46bd      	mov	sp, r7
 80021e6:	bd80      	pop	{r7, pc}
 80021e8:	20000074 	.word	0x20000074

080021ec <hal_enableIRQs>:

void hal_enableIRQs () {
 80021ec:	b580      	push	{r7, lr}
 80021ee:	af00      	add	r7, sp, #0
    if(--HAL.irqlevel == 0) {
 80021f0:	4b06      	ldr	r3, [pc, #24]	; (800220c <hal_enableIRQs+0x20>)
 80021f2:	681b      	ldr	r3, [r3, #0]
 80021f4:	1e5a      	subs	r2, r3, #1
 80021f6:	4b05      	ldr	r3, [pc, #20]	; (800220c <hal_enableIRQs+0x20>)
 80021f8:	601a      	str	r2, [r3, #0]
 80021fa:	4b04      	ldr	r3, [pc, #16]	; (800220c <hal_enableIRQs+0x20>)
 80021fc:	681b      	ldr	r3, [r3, #0]
 80021fe:	2b00      	cmp	r3, #0
 8002200:	d101      	bne.n	8002206 <hal_enableIRQs+0x1a>
  __ASM volatile ("cpsie i" : : : "memory");
 8002202:	b662      	cpsie	i
}
 8002204:	46c0      	nop			; (mov r8, r8)
		__enable_irq();
    	//__set_BASEPRI(0);
    }
}
 8002206:	46c0      	nop			; (mov r8, r8)
 8002208:	46bd      	mov	sp, r7
 800220a:	bd80      	pop	{r7, pc}
 800220c:	20000074 	.word	0x20000074

08002210 <hal_sleep>:

void hal_sleep () {
 8002210:	b580      	push	{r7, lr}
 8002212:	af00      	add	r7, sp, #0
	// low power sleep mode
#ifndef CFG_no_low_power_sleep_mode
	// PWR->CR |= PWR_CR_LPSDSR;
#endif
    // suspend execution until IRQ, regardless of the CPSR I-bit
    __WFI();
 8002214:	bf30      	wfi
}
 8002216:	46c0      	nop			; (mov r8, r8)
 8002218:	46bd      	mov	sp, r7
 800221a:	bd80      	pop	{r7, pc}

0800221c <hal_init>:

// -----------------------------------------------------------------------------

void hal_init () {
 800221c:	b580      	push	{r7, lr}
 800221e:	af00      	add	r7, sp, #0
    memset(&HAL, 0x00, sizeof(HAL));
 8002220:	4b09      	ldr	r3, [pc, #36]	; (8002248 <hal_init+0x2c>)
 8002222:	2208      	movs	r2, #8
 8002224:	2100      	movs	r1, #0
 8002226:	0018      	movs	r0, r3
 8002228:	f00b fc05 	bl	800da36 <memset>
    hal_disableIRQs();
 800222c:	f7ff ffd0 	bl	80021d0 <hal_disableIRQs>
    // configure radio I/O and interrupt handler
    hal_io_init();
 8002230:	f7ff fe60 	bl	8001ef4 <hal_io_init>
    // configure radio SPI
    hal_spi_init();
 8002234:	f7ff fedd 	bl	8001ff2 <hal_spi_init>
    // configure timer and interrupt handler
    hal_time_init();
 8002238:	f7ff ff08 	bl	800204c <hal_time_init>
    hal_enableIRQs();
 800223c:	f7ff ffd6 	bl	80021ec <hal_enableIRQs>
}
 8002240:	46c0      	nop			; (mov r8, r8)
 8002242:	46bd      	mov	sp, r7
 8002244:	bd80      	pop	{r7, pc}
 8002246:	46c0      	nop			; (mov r8, r8)
 8002248:	20000074 	.word	0x20000074

0800224c <hal_failed>:

void hal_failed () {
 800224c:	b580      	push	{r7, lr}
 800224e:	af00      	add	r7, sp, #0
    // HALT...
    hal_disableIRQs();
 8002250:	f7ff ffbe 	bl	80021d0 <hal_disableIRQs>
    hal_sleep();
 8002254:	f7ff ffdc 	bl	8002210 <hal_sleep>
    while(1);
 8002258:	e7fe      	b.n	8002258 <hal_failed+0xc>

0800225a <getSf>:
typedef u4_t devaddr_t;

// RX quality (device)
enum { RSSI_OFF=64, SNR_SCALEUP=4 };

inline sf_t  getSf   (rps_t params)            { return   (sf_t)(params &  0x7); }
 800225a:	b580      	push	{r7, lr}
 800225c:	b082      	sub	sp, #8
 800225e:	af00      	add	r7, sp, #0
 8002260:	0002      	movs	r2, r0
 8002262:	1dbb      	adds	r3, r7, #6
 8002264:	801a      	strh	r2, [r3, #0]
 8002266:	1dbb      	adds	r3, r7, #6
 8002268:	881b      	ldrh	r3, [r3, #0]
 800226a:	b2db      	uxtb	r3, r3
 800226c:	2207      	movs	r2, #7
 800226e:	4013      	ands	r3, r2
 8002270:	b2db      	uxtb	r3, r3
 8002272:	0018      	movs	r0, r3
 8002274:	46bd      	mov	sp, r7
 8002276:	b002      	add	sp, #8
 8002278:	bd80      	pop	{r7, pc}

0800227a <getBw>:
inline rps_t setSf   (rps_t params, sf_t sf)   { return (rps_t)((params & ~0x7) | sf); }
inline bw_t  getBw   (rps_t params)            { return  (bw_t)((params >> 3) & 0x3); }
 800227a:	b580      	push	{r7, lr}
 800227c:	b082      	sub	sp, #8
 800227e:	af00      	add	r7, sp, #0
 8002280:	0002      	movs	r2, r0
 8002282:	1dbb      	adds	r3, r7, #6
 8002284:	801a      	strh	r2, [r3, #0]
 8002286:	1dbb      	adds	r3, r7, #6
 8002288:	881b      	ldrh	r3, [r3, #0]
 800228a:	08db      	lsrs	r3, r3, #3
 800228c:	b29b      	uxth	r3, r3
 800228e:	b2db      	uxtb	r3, r3
 8002290:	2203      	movs	r2, #3
 8002292:	4013      	ands	r3, r2
 8002294:	b2db      	uxtb	r3, r3
 8002296:	0018      	movs	r0, r3
 8002298:	46bd      	mov	sp, r7
 800229a:	b002      	add	sp, #8
 800229c:	bd80      	pop	{r7, pc}

0800229e <getCr>:
inline rps_t setBw   (rps_t params, bw_t cr)   { return (rps_t)((params & ~0x18) | (cr<<3)); }
inline cr_t  getCr   (rps_t params)            { return  (cr_t)((params >> 5) & 0x3); }
 800229e:	b580      	push	{r7, lr}
 80022a0:	b082      	sub	sp, #8
 80022a2:	af00      	add	r7, sp, #0
 80022a4:	0002      	movs	r2, r0
 80022a6:	1dbb      	adds	r3, r7, #6
 80022a8:	801a      	strh	r2, [r3, #0]
 80022aa:	1dbb      	adds	r3, r7, #6
 80022ac:	881b      	ldrh	r3, [r3, #0]
 80022ae:	095b      	lsrs	r3, r3, #5
 80022b0:	b29b      	uxth	r3, r3
 80022b2:	b2db      	uxtb	r3, r3
 80022b4:	2203      	movs	r2, #3
 80022b6:	4013      	ands	r3, r2
 80022b8:	b2db      	uxtb	r3, r3
 80022ba:	0018      	movs	r0, r3
 80022bc:	46bd      	mov	sp, r7
 80022be:	b002      	add	sp, #8
 80022c0:	bd80      	pop	{r7, pc}

080022c2 <setCr>:
inline rps_t setCr   (rps_t params, cr_t cr)   { return (rps_t)((params & ~0x60) | (cr<<5)); }
 80022c2:	b580      	push	{r7, lr}
 80022c4:	b082      	sub	sp, #8
 80022c6:	af00      	add	r7, sp, #0
 80022c8:	0002      	movs	r2, r0
 80022ca:	1dbb      	adds	r3, r7, #6
 80022cc:	801a      	strh	r2, [r3, #0]
 80022ce:	1d7b      	adds	r3, r7, #5
 80022d0:	1c0a      	adds	r2, r1, #0
 80022d2:	701a      	strb	r2, [r3, #0]
 80022d4:	1dbb      	adds	r3, r7, #6
 80022d6:	2200      	movs	r2, #0
 80022d8:	5e9b      	ldrsh	r3, [r3, r2]
 80022da:	2260      	movs	r2, #96	; 0x60
 80022dc:	4393      	bics	r3, r2
 80022de:	b21a      	sxth	r2, r3
 80022e0:	1d7b      	adds	r3, r7, #5
 80022e2:	781b      	ldrb	r3, [r3, #0]
 80022e4:	015b      	lsls	r3, r3, #5
 80022e6:	b21b      	sxth	r3, r3
 80022e8:	4313      	orrs	r3, r2
 80022ea:	b21b      	sxth	r3, r3
 80022ec:	b29b      	uxth	r3, r3
 80022ee:	0018      	movs	r0, r3
 80022f0:	46bd      	mov	sp, r7
 80022f2:	b002      	add	sp, #8
 80022f4:	bd80      	pop	{r7, pc}

080022f6 <getNocrc>:
inline int   getNocrc(rps_t params)            { return        ((params >> 7) & 0x1); }
 80022f6:	b580      	push	{r7, lr}
 80022f8:	b082      	sub	sp, #8
 80022fa:	af00      	add	r7, sp, #0
 80022fc:	0002      	movs	r2, r0
 80022fe:	1dbb      	adds	r3, r7, #6
 8002300:	801a      	strh	r2, [r3, #0]
 8002302:	1dbb      	adds	r3, r7, #6
 8002304:	881b      	ldrh	r3, [r3, #0]
 8002306:	09db      	lsrs	r3, r3, #7
 8002308:	b29b      	uxth	r3, r3
 800230a:	001a      	movs	r2, r3
 800230c:	2301      	movs	r3, #1
 800230e:	4013      	ands	r3, r2
 8002310:	0018      	movs	r0, r3
 8002312:	46bd      	mov	sp, r7
 8002314:	b002      	add	sp, #8
 8002316:	bd80      	pop	{r7, pc}

08002318 <setNocrc>:
inline rps_t setNocrc(rps_t params, int nocrc) { return (rps_t)((params & ~0x80) | (nocrc<<7)); }
 8002318:	b580      	push	{r7, lr}
 800231a:	b082      	sub	sp, #8
 800231c:	af00      	add	r7, sp, #0
 800231e:	0002      	movs	r2, r0
 8002320:	6039      	str	r1, [r7, #0]
 8002322:	1dbb      	adds	r3, r7, #6
 8002324:	801a      	strh	r2, [r3, #0]
 8002326:	1dbb      	adds	r3, r7, #6
 8002328:	2200      	movs	r2, #0
 800232a:	5e9b      	ldrsh	r3, [r3, r2]
 800232c:	2280      	movs	r2, #128	; 0x80
 800232e:	4393      	bics	r3, r2
 8002330:	b21a      	sxth	r2, r3
 8002332:	683b      	ldr	r3, [r7, #0]
 8002334:	01db      	lsls	r3, r3, #7
 8002336:	b21b      	sxth	r3, r3
 8002338:	4313      	orrs	r3, r2
 800233a:	b21b      	sxth	r3, r3
 800233c:	b29b      	uxth	r3, r3
 800233e:	0018      	movs	r0, r3
 8002340:	46bd      	mov	sp, r7
 8002342:	b002      	add	sp, #8
 8002344:	bd80      	pop	{r7, pc}

08002346 <getIh>:
inline int   getIh   (rps_t params)            { return        ((params >> 8) & 0xFF); }
 8002346:	b580      	push	{r7, lr}
 8002348:	b082      	sub	sp, #8
 800234a:	af00      	add	r7, sp, #0
 800234c:	0002      	movs	r2, r0
 800234e:	1dbb      	adds	r3, r7, #6
 8002350:	801a      	strh	r2, [r3, #0]
 8002352:	1dbb      	adds	r3, r7, #6
 8002354:	881b      	ldrh	r3, [r3, #0]
 8002356:	0a1b      	lsrs	r3, r3, #8
 8002358:	b29b      	uxth	r3, r3
 800235a:	001a      	movs	r2, r3
 800235c:	23ff      	movs	r3, #255	; 0xff
 800235e:	4013      	ands	r3, r2
 8002360:	0018      	movs	r0, r3
 8002362:	46bd      	mov	sp, r7
 8002364:	b002      	add	sp, #8
 8002366:	bd80      	pop	{r7, pc}

08002368 <setIh>:
inline rps_t setIh   (rps_t params, int ih)    { return (rps_t)((params & ~0xFF00) | (ih<<8)); }
 8002368:	b580      	push	{r7, lr}
 800236a:	b082      	sub	sp, #8
 800236c:	af00      	add	r7, sp, #0
 800236e:	0002      	movs	r2, r0
 8002370:	6039      	str	r1, [r7, #0]
 8002372:	1dbb      	adds	r3, r7, #6
 8002374:	801a      	strh	r2, [r3, #0]
 8002376:	1dbb      	adds	r3, r7, #6
 8002378:	2200      	movs	r2, #0
 800237a:	5e9b      	ldrsh	r3, [r3, r2]
 800237c:	22ff      	movs	r2, #255	; 0xff
 800237e:	4013      	ands	r3, r2
 8002380:	b21a      	sxth	r2, r3
 8002382:	683b      	ldr	r3, [r7, #0]
 8002384:	021b      	lsls	r3, r3, #8
 8002386:	b21b      	sxth	r3, r3
 8002388:	4313      	orrs	r3, r2
 800238a:	b21b      	sxth	r3, r3
 800238c:	b29b      	uxth	r3, r3
 800238e:	0018      	movs	r0, r3
 8002390:	46bd      	mov	sp, r7
 8002392:	b002      	add	sp, #8
 8002394:	bd80      	pop	{r7, pc}
	...

08002398 <updr2rps>:
#define MAKERPS(sf,bw,cr,ih,nocrc) ((rps_t)((sf) | ((bw)<<3) | ((cr)<<5) | ((nocrc)?(1<<7):0) | ((ih&0xFF)<<8)))
// Two frames with params r1/r2 would interfere on air: same SFx + BWx 
inline int sameSfBw(rps_t r1, rps_t r2) { return ((r1^r2)&0x1F) == 0; }

extern const u1_t _DR2RPS_CRC[];
inline rps_t updr2rps (dr_t dr) { return (rps_t)_DR2RPS_CRC[dr+1]; }
 8002398:	b580      	push	{r7, lr}
 800239a:	b082      	sub	sp, #8
 800239c:	af00      	add	r7, sp, #0
 800239e:	0002      	movs	r2, r0
 80023a0:	1dfb      	adds	r3, r7, #7
 80023a2:	701a      	strb	r2, [r3, #0]
 80023a4:	1dfb      	adds	r3, r7, #7
 80023a6:	781b      	ldrb	r3, [r3, #0]
 80023a8:	3301      	adds	r3, #1
 80023aa:	4a03      	ldr	r2, [pc, #12]	; (80023b8 <updr2rps+0x20>)
 80023ac:	5cd3      	ldrb	r3, [r2, r3]
 80023ae:	b29b      	uxth	r3, r3
 80023b0:	0018      	movs	r0, r3
 80023b2:	46bd      	mov	sp, r7
 80023b4:	b002      	add	sp, #8
 80023b6:	bd80      	pop	{r7, pc}
 80023b8:	0800f0e4 	.word	0x0800f0e4

080023bc <dndr2rps>:
inline rps_t dndr2rps (dr_t dr) { return setNocrc(updr2rps(dr),1); }
 80023bc:	b580      	push	{r7, lr}
 80023be:	b082      	sub	sp, #8
 80023c0:	af00      	add	r7, sp, #0
 80023c2:	0002      	movs	r2, r0
 80023c4:	1dfb      	adds	r3, r7, #7
 80023c6:	701a      	strb	r2, [r3, #0]
 80023c8:	1dfb      	adds	r3, r7, #7
 80023ca:	781b      	ldrb	r3, [r3, #0]
 80023cc:	0018      	movs	r0, r3
 80023ce:	f7ff ffe3 	bl	8002398 <updr2rps>
 80023d2:	0003      	movs	r3, r0
 80023d4:	2101      	movs	r1, #1
 80023d6:	0018      	movs	r0, r3
 80023d8:	f7ff ff9e 	bl	8002318 <setNocrc>
 80023dc:	0003      	movs	r3, r0
 80023de:	0018      	movs	r0, r3
 80023e0:	46bd      	mov	sp, r7
 80023e2:	b002      	add	sp, #8
 80023e4:	bd80      	pop	{r7, pc}
	...

080023e8 <decDR>:
inline int isFasterDR (dr_t dr1, dr_t dr2) { return dr1 > dr2; }
inline int isSlowerDR (dr_t dr1, dr_t dr2) { return dr1 < dr2; }
inline dr_t  incDR    (dr_t dr) { return _DR2RPS_CRC[dr+2]==ILLEGAL_RPS ? dr : (dr_t)(dr+1); } // increase data rate
inline dr_t  decDR    (dr_t dr) { return _DR2RPS_CRC[dr  ]==ILLEGAL_RPS ? dr : (dr_t)(dr-1); } // decrease data rate
 80023e8:	b580      	push	{r7, lr}
 80023ea:	b082      	sub	sp, #8
 80023ec:	af00      	add	r7, sp, #0
 80023ee:	0002      	movs	r2, r0
 80023f0:	1dfb      	adds	r3, r7, #7
 80023f2:	701a      	strb	r2, [r3, #0]
 80023f4:	1dfb      	adds	r3, r7, #7
 80023f6:	781b      	ldrb	r3, [r3, #0]
 80023f8:	4a07      	ldr	r2, [pc, #28]	; (8002418 <decDR+0x30>)
 80023fa:	5cd3      	ldrb	r3, [r2, r3]
 80023fc:	2bff      	cmp	r3, #255	; 0xff
 80023fe:	d004      	beq.n	800240a <decDR+0x22>
 8002400:	1dfb      	adds	r3, r7, #7
 8002402:	781b      	ldrb	r3, [r3, #0]
 8002404:	3b01      	subs	r3, #1
 8002406:	b2db      	uxtb	r3, r3
 8002408:	e001      	b.n	800240e <decDR+0x26>
 800240a:	1dfb      	adds	r3, r7, #7
 800240c:	781b      	ldrb	r3, [r3, #0]
 800240e:	0018      	movs	r0, r3
 8002410:	46bd      	mov	sp, r7
 8002412:	b002      	add	sp, #8
 8002414:	bd80      	pop	{r7, pc}
 8002416:	46c0      	nop			; (mov r8, r8)
 8002418:	0800f0e4 	.word	0x0800f0e4

0800241c <validDR>:
inline dr_t  assertDR (dr_t dr) { return _DR2RPS_CRC[dr+1]==ILLEGAL_RPS ? DR_DFLTMIN : dr; }   // force into a valid DR
inline bit_t validDR  (dr_t dr) { return _DR2RPS_CRC[dr+1]!=ILLEGAL_RPS; } // in range
 800241c:	b580      	push	{r7, lr}
 800241e:	b082      	sub	sp, #8
 8002420:	af00      	add	r7, sp, #0
 8002422:	0002      	movs	r2, r0
 8002424:	1dfb      	adds	r3, r7, #7
 8002426:	701a      	strb	r2, [r3, #0]
 8002428:	1dfb      	adds	r3, r7, #7
 800242a:	781b      	ldrb	r3, [r3, #0]
 800242c:	3301      	adds	r3, #1
 800242e:	4a05      	ldr	r2, [pc, #20]	; (8002444 <validDR+0x28>)
 8002430:	5cd3      	ldrb	r3, [r2, r3]
 8002432:	3bff      	subs	r3, #255	; 0xff
 8002434:	1e5a      	subs	r2, r3, #1
 8002436:	4193      	sbcs	r3, r2
 8002438:	b2db      	uxtb	r3, r3
 800243a:	0018      	movs	r0, r3
 800243c:	46bd      	mov	sp, r7
 800243e:	b002      	add	sp, #8
 8002440:	bd80      	pop	{r7, pc}
 8002442:	46c0      	nop			; (mov r8, r8)
 8002444:	0800f0e4 	.word	0x0800f0e4

08002448 <lowerDR>:
inline dr_t  lowerDR  (dr_t dr, u1_t n) { while(n--){dr=decDR(dr);} return dr; } // decrease data rate by n steps
 8002448:	b590      	push	{r4, r7, lr}
 800244a:	b083      	sub	sp, #12
 800244c:	af00      	add	r7, sp, #0
 800244e:	0002      	movs	r2, r0
 8002450:	1dfb      	adds	r3, r7, #7
 8002452:	701a      	strb	r2, [r3, #0]
 8002454:	1dbb      	adds	r3, r7, #6
 8002456:	1c0a      	adds	r2, r1, #0
 8002458:	701a      	strb	r2, [r3, #0]
 800245a:	e007      	b.n	800246c <lowerDR+0x24>
 800245c:	1dfc      	adds	r4, r7, #7
 800245e:	1dfb      	adds	r3, r7, #7
 8002460:	781b      	ldrb	r3, [r3, #0]
 8002462:	0018      	movs	r0, r3
 8002464:	f7ff ffc0 	bl	80023e8 <decDR>
 8002468:	0003      	movs	r3, r0
 800246a:	7023      	strb	r3, [r4, #0]
 800246c:	1dbb      	adds	r3, r7, #6
 800246e:	781b      	ldrb	r3, [r3, #0]
 8002470:	1dba      	adds	r2, r7, #6
 8002472:	1e59      	subs	r1, r3, #1
 8002474:	7011      	strb	r1, [r2, #0]
 8002476:	2b00      	cmp	r3, #0
 8002478:	d1f0      	bne.n	800245c <lowerDR+0x14>
 800247a:	1dfb      	adds	r3, r7, #7
 800247c:	781b      	ldrb	r3, [r3, #0]
 800247e:	0018      	movs	r0, r3
 8002480:	46bd      	mov	sp, r7
 8002482:	b003      	add	sp, #12
 8002484:	bd90      	pop	{r4, r7, pc}

08002486 <os_rlsbf2>:
// BEG OS - default implementations for certain OS suport functions

#if !defined(HAS_os_calls)

#if !defined(os_rlsbf2)
u2_t os_rlsbf2 (xref2cu1_t buf) {
 8002486:	b580      	push	{r7, lr}
 8002488:	b082      	sub	sp, #8
 800248a:	af00      	add	r7, sp, #0
 800248c:	6078      	str	r0, [r7, #4]
    return (u2_t)(buf[0] | (buf[1]<<8));
 800248e:	687b      	ldr	r3, [r7, #4]
 8002490:	781b      	ldrb	r3, [r3, #0]
 8002492:	b21a      	sxth	r2, r3
 8002494:	687b      	ldr	r3, [r7, #4]
 8002496:	3301      	adds	r3, #1
 8002498:	781b      	ldrb	r3, [r3, #0]
 800249a:	021b      	lsls	r3, r3, #8
 800249c:	b21b      	sxth	r3, r3
 800249e:	4313      	orrs	r3, r2
 80024a0:	b21b      	sxth	r3, r3
 80024a2:	b29b      	uxth	r3, r3
}
 80024a4:	0018      	movs	r0, r3
 80024a6:	46bd      	mov	sp, r7
 80024a8:	b002      	add	sp, #8
 80024aa:	bd80      	pop	{r7, pc}

080024ac <os_rlsbf4>:
#endif

#if !defined(os_rlsbf4)
u4_t os_rlsbf4 (xref2cu1_t buf) {
 80024ac:	b580      	push	{r7, lr}
 80024ae:	b082      	sub	sp, #8
 80024b0:	af00      	add	r7, sp, #0
 80024b2:	6078      	str	r0, [r7, #4]
    return (u4_t)(buf[0] | (buf[1]<<8) | ((u4_t)buf[2]<<16) | ((u4_t)buf[3]<<24));
 80024b4:	687b      	ldr	r3, [r7, #4]
 80024b6:	781b      	ldrb	r3, [r3, #0]
 80024b8:	001a      	movs	r2, r3
 80024ba:	687b      	ldr	r3, [r7, #4]
 80024bc:	3301      	adds	r3, #1
 80024be:	781b      	ldrb	r3, [r3, #0]
 80024c0:	021b      	lsls	r3, r3, #8
 80024c2:	4313      	orrs	r3, r2
 80024c4:	001a      	movs	r2, r3
 80024c6:	687b      	ldr	r3, [r7, #4]
 80024c8:	3302      	adds	r3, #2
 80024ca:	781b      	ldrb	r3, [r3, #0]
 80024cc:	041b      	lsls	r3, r3, #16
 80024ce:	431a      	orrs	r2, r3
 80024d0:	687b      	ldr	r3, [r7, #4]
 80024d2:	3303      	adds	r3, #3
 80024d4:	781b      	ldrb	r3, [r3, #0]
 80024d6:	061b      	lsls	r3, r3, #24
 80024d8:	4313      	orrs	r3, r2
}
 80024da:	0018      	movs	r0, r3
 80024dc:	46bd      	mov	sp, r7
 80024de:	b002      	add	sp, #8
 80024e0:	bd80      	pop	{r7, pc}

080024e2 <os_rmsbf4>:
#endif


#if !defined(os_rmsbf4)
u4_t os_rmsbf4 (xref2cu1_t buf) {
 80024e2:	b580      	push	{r7, lr}
 80024e4:	b082      	sub	sp, #8
 80024e6:	af00      	add	r7, sp, #0
 80024e8:	6078      	str	r0, [r7, #4]
    return (u4_t)(buf[3] | (buf[2]<<8) | ((u4_t)buf[1]<<16) | ((u4_t)buf[0]<<24));
 80024ea:	687b      	ldr	r3, [r7, #4]
 80024ec:	3303      	adds	r3, #3
 80024ee:	781b      	ldrb	r3, [r3, #0]
 80024f0:	001a      	movs	r2, r3
 80024f2:	687b      	ldr	r3, [r7, #4]
 80024f4:	3302      	adds	r3, #2
 80024f6:	781b      	ldrb	r3, [r3, #0]
 80024f8:	021b      	lsls	r3, r3, #8
 80024fa:	4313      	orrs	r3, r2
 80024fc:	001a      	movs	r2, r3
 80024fe:	687b      	ldr	r3, [r7, #4]
 8002500:	3301      	adds	r3, #1
 8002502:	781b      	ldrb	r3, [r3, #0]
 8002504:	041b      	lsls	r3, r3, #16
 8002506:	431a      	orrs	r2, r3
 8002508:	687b      	ldr	r3, [r7, #4]
 800250a:	781b      	ldrb	r3, [r3, #0]
 800250c:	061b      	lsls	r3, r3, #24
 800250e:	4313      	orrs	r3, r2
}
 8002510:	0018      	movs	r0, r3
 8002512:	46bd      	mov	sp, r7
 8002514:	b002      	add	sp, #8
 8002516:	bd80      	pop	{r7, pc}

08002518 <os_wlsbf2>:
#endif


#if !defined(os_wlsbf2)
void os_wlsbf2 (xref2u1_t buf, u2_t v) {
 8002518:	b580      	push	{r7, lr}
 800251a:	b082      	sub	sp, #8
 800251c:	af00      	add	r7, sp, #0
 800251e:	6078      	str	r0, [r7, #4]
 8002520:	000a      	movs	r2, r1
 8002522:	1cbb      	adds	r3, r7, #2
 8002524:	801a      	strh	r2, [r3, #0]
    buf[0] = v;
 8002526:	1cbb      	adds	r3, r7, #2
 8002528:	881b      	ldrh	r3, [r3, #0]
 800252a:	b2da      	uxtb	r2, r3
 800252c:	687b      	ldr	r3, [r7, #4]
 800252e:	701a      	strb	r2, [r3, #0]
    buf[1] = v>>8;
 8002530:	1cbb      	adds	r3, r7, #2
 8002532:	881b      	ldrh	r3, [r3, #0]
 8002534:	0a1b      	lsrs	r3, r3, #8
 8002536:	b29a      	uxth	r2, r3
 8002538:	687b      	ldr	r3, [r7, #4]
 800253a:	3301      	adds	r3, #1
 800253c:	b2d2      	uxtb	r2, r2
 800253e:	701a      	strb	r2, [r3, #0]
}
 8002540:	46c0      	nop			; (mov r8, r8)
 8002542:	46bd      	mov	sp, r7
 8002544:	b002      	add	sp, #8
 8002546:	bd80      	pop	{r7, pc}

08002548 <os_wlsbf4>:
#endif

#if !defined(os_wlsbf4)
void os_wlsbf4 (xref2u1_t buf, u4_t v) {
 8002548:	b580      	push	{r7, lr}
 800254a:	b082      	sub	sp, #8
 800254c:	af00      	add	r7, sp, #0
 800254e:	6078      	str	r0, [r7, #4]
 8002550:	6039      	str	r1, [r7, #0]
    buf[0] = v;
 8002552:	683b      	ldr	r3, [r7, #0]
 8002554:	b2da      	uxtb	r2, r3
 8002556:	687b      	ldr	r3, [r7, #4]
 8002558:	701a      	strb	r2, [r3, #0]
    buf[1] = v>>8;
 800255a:	683b      	ldr	r3, [r7, #0]
 800255c:	0a1a      	lsrs	r2, r3, #8
 800255e:	687b      	ldr	r3, [r7, #4]
 8002560:	3301      	adds	r3, #1
 8002562:	b2d2      	uxtb	r2, r2
 8002564:	701a      	strb	r2, [r3, #0]
    buf[2] = v>>16;
 8002566:	683b      	ldr	r3, [r7, #0]
 8002568:	0c1a      	lsrs	r2, r3, #16
 800256a:	687b      	ldr	r3, [r7, #4]
 800256c:	3302      	adds	r3, #2
 800256e:	b2d2      	uxtb	r2, r2
 8002570:	701a      	strb	r2, [r3, #0]
    buf[3] = v>>24;
 8002572:	683b      	ldr	r3, [r7, #0]
 8002574:	0e1a      	lsrs	r2, r3, #24
 8002576:	687b      	ldr	r3, [r7, #4]
 8002578:	3303      	adds	r3, #3
 800257a:	b2d2      	uxtb	r2, r2
 800257c:	701a      	strb	r2, [r3, #0]
}
 800257e:	46c0      	nop			; (mov r8, r8)
 8002580:	46bd      	mov	sp, r7
 8002582:	b002      	add	sp, #8
 8002584:	bd80      	pop	{r7, pc}

08002586 <os_wmsbf4>:
#endif

#if !defined(os_wmsbf4)
void os_wmsbf4 (xref2u1_t buf, u4_t v) {
 8002586:	b580      	push	{r7, lr}
 8002588:	b082      	sub	sp, #8
 800258a:	af00      	add	r7, sp, #0
 800258c:	6078      	str	r0, [r7, #4]
 800258e:	6039      	str	r1, [r7, #0]
    buf[3] = v;
 8002590:	687b      	ldr	r3, [r7, #4]
 8002592:	3303      	adds	r3, #3
 8002594:	683a      	ldr	r2, [r7, #0]
 8002596:	b2d2      	uxtb	r2, r2
 8002598:	701a      	strb	r2, [r3, #0]
    buf[2] = v>>8;
 800259a:	683b      	ldr	r3, [r7, #0]
 800259c:	0a1a      	lsrs	r2, r3, #8
 800259e:	687b      	ldr	r3, [r7, #4]
 80025a0:	3302      	adds	r3, #2
 80025a2:	b2d2      	uxtb	r2, r2
 80025a4:	701a      	strb	r2, [r3, #0]
    buf[1] = v>>16;
 80025a6:	683b      	ldr	r3, [r7, #0]
 80025a8:	0c1a      	lsrs	r2, r3, #16
 80025aa:	687b      	ldr	r3, [r7, #4]
 80025ac:	3301      	adds	r3, #1
 80025ae:	b2d2      	uxtb	r2, r2
 80025b0:	701a      	strb	r2, [r3, #0]
    buf[0] = v>>24;
 80025b2:	683b      	ldr	r3, [r7, #0]
 80025b4:	0e1b      	lsrs	r3, r3, #24
 80025b6:	b2da      	uxtb	r2, r3
 80025b8:	687b      	ldr	r3, [r7, #4]
 80025ba:	701a      	strb	r2, [r3, #0]
}
 80025bc:	46c0      	nop			; (mov r8, r8)
 80025be:	46bd      	mov	sp, r7
 80025c0:	b002      	add	sp, #8
 80025c2:	bd80      	pop	{r7, pc}

080025c4 <os_getBattLevel>:
#endif

#if !defined(os_getBattLevel)
u1_t os_getBattLevel (void) {
 80025c4:	b580      	push	{r7, lr}
 80025c6:	af00      	add	r7, sp, #0
    return MCMD_DEVS_BATT_NOINFO;
 80025c8:	23ff      	movs	r3, #255	; 0xff
}
 80025ca:	0018      	movs	r0, r3
 80025cc:	46bd      	mov	sp, r7
 80025ce:	bd80      	pop	{r7, pc}

080025d0 <os_crc16>:
#endif

#if !defined(os_crc16)
// New CRC-16 CCITT(XMODEM) checksum for beacons:
u2_t os_crc16 (xref2u1_t data, uint len) {
 80025d0:	b580      	push	{r7, lr}
 80025d2:	b086      	sub	sp, #24
 80025d4:	af00      	add	r7, sp, #0
 80025d6:	6078      	str	r0, [r7, #4]
 80025d8:	6039      	str	r1, [r7, #0]
    u2_t remainder = 0;
 80025da:	2316      	movs	r3, #22
 80025dc:	18fb      	adds	r3, r7, r3
 80025de:	2200      	movs	r2, #0
 80025e0:	801a      	strh	r2, [r3, #0]
    u2_t polynomial = 0x1021;
 80025e2:	230c      	movs	r3, #12
 80025e4:	18fb      	adds	r3, r7, r3
 80025e6:	4a25      	ldr	r2, [pc, #148]	; (800267c <os_crc16+0xac>)
 80025e8:	801a      	strh	r2, [r3, #0]
    for( uint i = 0; i < len; i++ ) {
 80025ea:	2300      	movs	r3, #0
 80025ec:	613b      	str	r3, [r7, #16]
 80025ee:	e039      	b.n	8002664 <os_crc16+0x94>
        remainder ^= data[i] << 8;
 80025f0:	687a      	ldr	r2, [r7, #4]
 80025f2:	693b      	ldr	r3, [r7, #16]
 80025f4:	18d3      	adds	r3, r2, r3
 80025f6:	781b      	ldrb	r3, [r3, #0]
 80025f8:	021b      	lsls	r3, r3, #8
 80025fa:	b21a      	sxth	r2, r3
 80025fc:	2116      	movs	r1, #22
 80025fe:	187b      	adds	r3, r7, r1
 8002600:	2000      	movs	r0, #0
 8002602:	5e1b      	ldrsh	r3, [r3, r0]
 8002604:	4053      	eors	r3, r2
 8002606:	b21a      	sxth	r2, r3
 8002608:	187b      	adds	r3, r7, r1
 800260a:	801a      	strh	r2, [r3, #0]
        for( u1_t bit = 8; bit > 0; bit--) {
 800260c:	230f      	movs	r3, #15
 800260e:	18fb      	adds	r3, r7, r3
 8002610:	2208      	movs	r2, #8
 8002612:	701a      	strb	r2, [r3, #0]
 8002614:	e01e      	b.n	8002654 <os_crc16+0x84>
            if( (remainder & 0x8000) )
 8002616:	2116      	movs	r1, #22
 8002618:	187b      	adds	r3, r7, r1
 800261a:	2200      	movs	r2, #0
 800261c:	5e9b      	ldrsh	r3, [r3, r2]
 800261e:	2b00      	cmp	r3, #0
 8002620:	da0c      	bge.n	800263c <os_crc16+0x6c>
                remainder = (remainder << 1) ^ polynomial;
 8002622:	187b      	adds	r3, r7, r1
 8002624:	881b      	ldrh	r3, [r3, #0]
 8002626:	005b      	lsls	r3, r3, #1
 8002628:	b21a      	sxth	r2, r3
 800262a:	230c      	movs	r3, #12
 800262c:	18fb      	adds	r3, r7, r3
 800262e:	2000      	movs	r0, #0
 8002630:	5e1b      	ldrsh	r3, [r3, r0]
 8002632:	4053      	eors	r3, r2
 8002634:	b21a      	sxth	r2, r3
 8002636:	187b      	adds	r3, r7, r1
 8002638:	801a      	strh	r2, [r3, #0]
 800263a:	e005      	b.n	8002648 <os_crc16+0x78>
            else 
                remainder <<= 1;
 800263c:	2316      	movs	r3, #22
 800263e:	18fa      	adds	r2, r7, r3
 8002640:	18fb      	adds	r3, r7, r3
 8002642:	881b      	ldrh	r3, [r3, #0]
 8002644:	18db      	adds	r3, r3, r3
 8002646:	8013      	strh	r3, [r2, #0]
        for( u1_t bit = 8; bit > 0; bit--) {
 8002648:	210f      	movs	r1, #15
 800264a:	187b      	adds	r3, r7, r1
 800264c:	781a      	ldrb	r2, [r3, #0]
 800264e:	187b      	adds	r3, r7, r1
 8002650:	3a01      	subs	r2, #1
 8002652:	701a      	strb	r2, [r3, #0]
 8002654:	230f      	movs	r3, #15
 8002656:	18fb      	adds	r3, r7, r3
 8002658:	781b      	ldrb	r3, [r3, #0]
 800265a:	2b00      	cmp	r3, #0
 800265c:	d1db      	bne.n	8002616 <os_crc16+0x46>
    for( uint i = 0; i < len; i++ ) {
 800265e:	693b      	ldr	r3, [r7, #16]
 8002660:	3301      	adds	r3, #1
 8002662:	613b      	str	r3, [r7, #16]
 8002664:	693a      	ldr	r2, [r7, #16]
 8002666:	683b      	ldr	r3, [r7, #0]
 8002668:	429a      	cmp	r2, r3
 800266a:	d3c1      	bcc.n	80025f0 <os_crc16+0x20>
        }
    }
    return remainder;
 800266c:	2316      	movs	r3, #22
 800266e:	18fb      	adds	r3, r7, r3
 8002670:	881b      	ldrh	r3, [r3, #0]
}
 8002672:	0018      	movs	r0, r3
 8002674:	46bd      	mov	sp, r7
 8002676:	b006      	add	sp, #24
 8002678:	bd80      	pop	{r7, pc}
 800267a:	46c0      	nop			; (mov r8, r8)
 800267c:	00001021 	.word	0x00001021

08002680 <micB0>:
// ================================================================================

// ================================================================================
// BEG AES

static void micB0 (u4_t devaddr, u4_t seqno, int dndir, int len) {
 8002680:	b580      	push	{r7, lr}
 8002682:	b084      	sub	sp, #16
 8002684:	af00      	add	r7, sp, #0
 8002686:	60f8      	str	r0, [r7, #12]
 8002688:	60b9      	str	r1, [r7, #8]
 800268a:	607a      	str	r2, [r7, #4]
 800268c:	603b      	str	r3, [r7, #0]
    os_clearMem(AESaux,16);
 800268e:	4b11      	ldr	r3, [pc, #68]	; (80026d4 <micB0+0x54>)
 8002690:	2210      	movs	r2, #16
 8002692:	2100      	movs	r1, #0
 8002694:	0018      	movs	r0, r3
 8002696:	f00b f9ce 	bl	800da36 <memset>
    AESaux[0]  = 0x49;
 800269a:	4b0e      	ldr	r3, [pc, #56]	; (80026d4 <micB0+0x54>)
 800269c:	2249      	movs	r2, #73	; 0x49
 800269e:	701a      	strb	r2, [r3, #0]
    AESaux[5]  = dndir?1:0;
 80026a0:	687b      	ldr	r3, [r7, #4]
 80026a2:	1e5a      	subs	r2, r3, #1
 80026a4:	4193      	sbcs	r3, r2
 80026a6:	b2da      	uxtb	r2, r3
 80026a8:	4b0b      	ldr	r3, [pc, #44]	; (80026d8 <micB0+0x58>)
 80026aa:	701a      	strb	r2, [r3, #0]
    AESaux[15] = len;
 80026ac:	4b0b      	ldr	r3, [pc, #44]	; (80026dc <micB0+0x5c>)
 80026ae:	683a      	ldr	r2, [r7, #0]
 80026b0:	b2d2      	uxtb	r2, r2
 80026b2:	701a      	strb	r2, [r3, #0]
    os_wlsbf4(AESaux+ 6,devaddr);
 80026b4:	4b0a      	ldr	r3, [pc, #40]	; (80026e0 <micB0+0x60>)
 80026b6:	68fa      	ldr	r2, [r7, #12]
 80026b8:	0011      	movs	r1, r2
 80026ba:	0018      	movs	r0, r3
 80026bc:	f7ff ff44 	bl	8002548 <os_wlsbf4>
    os_wlsbf4(AESaux+10,seqno);
 80026c0:	4b08      	ldr	r3, [pc, #32]	; (80026e4 <micB0+0x64>)
 80026c2:	68ba      	ldr	r2, [r7, #8]
 80026c4:	0011      	movs	r1, r2
 80026c6:	0018      	movs	r0, r3
 80026c8:	f7ff ff3e 	bl	8002548 <os_wlsbf4>
}
 80026cc:	46c0      	nop			; (mov r8, r8)
 80026ce:	46bd      	mov	sp, r7
 80026d0:	b004      	add	sp, #16
 80026d2:	bd80      	pop	{r7, pc}
 80026d4:	20000150 	.word	0x20000150
 80026d8:	20000155 	.word	0x20000155
 80026dc:	2000015f 	.word	0x2000015f
 80026e0:	20000156 	.word	0x20000156
 80026e4:	2000015a 	.word	0x2000015a

080026e8 <aes_verifyMic>:


static int aes_verifyMic (xref2cu1_t key, u4_t devaddr, u4_t seqno, int dndir, xref2u1_t pdu, int len) {
 80026e8:	b590      	push	{r4, r7, lr}
 80026ea:	b085      	sub	sp, #20
 80026ec:	af00      	add	r7, sp, #0
 80026ee:	60f8      	str	r0, [r7, #12]
 80026f0:	60b9      	str	r1, [r7, #8]
 80026f2:	607a      	str	r2, [r7, #4]
 80026f4:	603b      	str	r3, [r7, #0]
    micB0(devaddr, seqno, dndir, len);
 80026f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026f8:	683a      	ldr	r2, [r7, #0]
 80026fa:	6879      	ldr	r1, [r7, #4]
 80026fc:	68b8      	ldr	r0, [r7, #8]
 80026fe:	f7ff ffbf 	bl	8002680 <micB0>
    os_copyMem(AESkey,key,16);
 8002702:	68f9      	ldr	r1, [r7, #12]
 8002704:	4b0d      	ldr	r3, [pc, #52]	; (800273c <aes_verifyMic+0x54>)
 8002706:	2210      	movs	r2, #16
 8002708:	0018      	movs	r0, r3
 800270a:	f00b f98b 	bl	800da24 <memcpy>
    return os_aes(AES_MIC, pdu, len) == os_rmsbf4(pdu+len);
 800270e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002710:	b29a      	uxth	r2, r3
 8002712:	6a3b      	ldr	r3, [r7, #32]
 8002714:	0019      	movs	r1, r3
 8002716:	2002      	movs	r0, #2
 8002718:	f7fe fe3a 	bl	8001390 <os_aes>
 800271c:	0004      	movs	r4, r0
 800271e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002720:	6a3a      	ldr	r2, [r7, #32]
 8002722:	18d3      	adds	r3, r2, r3
 8002724:	0018      	movs	r0, r3
 8002726:	f7ff fedc 	bl	80024e2 <os_rmsbf4>
 800272a:	0003      	movs	r3, r0
 800272c:	1ae3      	subs	r3, r4, r3
 800272e:	425a      	negs	r2, r3
 8002730:	4153      	adcs	r3, r2
 8002732:	b2db      	uxtb	r3, r3
}
 8002734:	0018      	movs	r0, r3
 8002736:	46bd      	mov	sp, r7
 8002738:	b005      	add	sp, #20
 800273a:	bd90      	pop	{r4, r7, pc}
 800273c:	200000a0 	.word	0x200000a0

08002740 <aes_appendMic>:


static void aes_appendMic (xref2cu1_t key, u4_t devaddr, u4_t seqno, int dndir, xref2u1_t pdu, int len) {
 8002740:	b590      	push	{r4, r7, lr}
 8002742:	b085      	sub	sp, #20
 8002744:	af00      	add	r7, sp, #0
 8002746:	60f8      	str	r0, [r7, #12]
 8002748:	60b9      	str	r1, [r7, #8]
 800274a:	607a      	str	r2, [r7, #4]
 800274c:	603b      	str	r3, [r7, #0]
    micB0(devaddr, seqno, dndir, len);
 800274e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002750:	683a      	ldr	r2, [r7, #0]
 8002752:	6879      	ldr	r1, [r7, #4]
 8002754:	68b8      	ldr	r0, [r7, #8]
 8002756:	f7ff ff93 	bl	8002680 <micB0>
    os_copyMem(AESkey,key,16);
 800275a:	68f9      	ldr	r1, [r7, #12]
 800275c:	4b0b      	ldr	r3, [pc, #44]	; (800278c <aes_appendMic+0x4c>)
 800275e:	2210      	movs	r2, #16
 8002760:	0018      	movs	r0, r3
 8002762:	f00b f95f 	bl	800da24 <memcpy>
    // MSB because of internal structure of AES
    os_wmsbf4(pdu+len, os_aes(AES_MIC, pdu, len));
 8002766:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002768:	6a3a      	ldr	r2, [r7, #32]
 800276a:	18d4      	adds	r4, r2, r3
 800276c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800276e:	b29a      	uxth	r2, r3
 8002770:	6a3b      	ldr	r3, [r7, #32]
 8002772:	0019      	movs	r1, r3
 8002774:	2002      	movs	r0, #2
 8002776:	f7fe fe0b 	bl	8001390 <os_aes>
 800277a:	0003      	movs	r3, r0
 800277c:	0019      	movs	r1, r3
 800277e:	0020      	movs	r0, r4
 8002780:	f7ff ff01 	bl	8002586 <os_wmsbf4>
}
 8002784:	46c0      	nop			; (mov r8, r8)
 8002786:	46bd      	mov	sp, r7
 8002788:	b005      	add	sp, #20
 800278a:	bd90      	pop	{r4, r7, pc}
 800278c:	200000a0 	.word	0x200000a0

08002790 <aes_appendMic0>:


static void aes_appendMic0 (xref2u1_t pdu, int len) {
 8002790:	b590      	push	{r4, r7, lr}
 8002792:	b083      	sub	sp, #12
 8002794:	af00      	add	r7, sp, #0
 8002796:	6078      	str	r0, [r7, #4]
 8002798:	6039      	str	r1, [r7, #0]
    os_getDevKey(AESkey);
 800279a:	4b0b      	ldr	r3, [pc, #44]	; (80027c8 <aes_appendMic0+0x38>)
 800279c:	0018      	movs	r0, r3
 800279e:	f003 f8b5 	bl	800590c <os_getDevKey>
    os_wmsbf4(pdu+len, os_aes(AES_MIC|AES_MICNOAUX, pdu, len));  // MSB because of internal structure of AES
 80027a2:	683b      	ldr	r3, [r7, #0]
 80027a4:	687a      	ldr	r2, [r7, #4]
 80027a6:	18d4      	adds	r4, r2, r3
 80027a8:	683b      	ldr	r3, [r7, #0]
 80027aa:	b29a      	uxth	r2, r3
 80027ac:	687b      	ldr	r3, [r7, #4]
 80027ae:	0019      	movs	r1, r3
 80027b0:	200a      	movs	r0, #10
 80027b2:	f7fe fded 	bl	8001390 <os_aes>
 80027b6:	0003      	movs	r3, r0
 80027b8:	0019      	movs	r1, r3
 80027ba:	0020      	movs	r0, r4
 80027bc:	f7ff fee3 	bl	8002586 <os_wmsbf4>
}
 80027c0:	46c0      	nop			; (mov r8, r8)
 80027c2:	46bd      	mov	sp, r7
 80027c4:	b003      	add	sp, #12
 80027c6:	bd90      	pop	{r4, r7, pc}
 80027c8:	200000a0 	.word	0x200000a0

080027cc <aes_verifyMic0>:


static int aes_verifyMic0 (xref2u1_t pdu, int len) {
 80027cc:	b590      	push	{r4, r7, lr}
 80027ce:	b083      	sub	sp, #12
 80027d0:	af00      	add	r7, sp, #0
 80027d2:	6078      	str	r0, [r7, #4]
 80027d4:	6039      	str	r1, [r7, #0]
    os_getDevKey(AESkey);
 80027d6:	4b0d      	ldr	r3, [pc, #52]	; (800280c <aes_verifyMic0+0x40>)
 80027d8:	0018      	movs	r0, r3
 80027da:	f003 f897 	bl	800590c <os_getDevKey>
    return os_aes(AES_MIC|AES_MICNOAUX, pdu, len) == os_rmsbf4(pdu+len);
 80027de:	683b      	ldr	r3, [r7, #0]
 80027e0:	b29a      	uxth	r2, r3
 80027e2:	687b      	ldr	r3, [r7, #4]
 80027e4:	0019      	movs	r1, r3
 80027e6:	200a      	movs	r0, #10
 80027e8:	f7fe fdd2 	bl	8001390 <os_aes>
 80027ec:	0004      	movs	r4, r0
 80027ee:	683b      	ldr	r3, [r7, #0]
 80027f0:	687a      	ldr	r2, [r7, #4]
 80027f2:	18d3      	adds	r3, r2, r3
 80027f4:	0018      	movs	r0, r3
 80027f6:	f7ff fe74 	bl	80024e2 <os_rmsbf4>
 80027fa:	0003      	movs	r3, r0
 80027fc:	1ae3      	subs	r3, r4, r3
 80027fe:	425a      	negs	r2, r3
 8002800:	4153      	adcs	r3, r2
 8002802:	b2db      	uxtb	r3, r3
}
 8002804:	0018      	movs	r0, r3
 8002806:	46bd      	mov	sp, r7
 8002808:	b003      	add	sp, #12
 800280a:	bd90      	pop	{r4, r7, pc}
 800280c:	200000a0 	.word	0x200000a0

08002810 <aes_encrypt>:


static void aes_encrypt (xref2u1_t pdu, int len) {
 8002810:	b580      	push	{r7, lr}
 8002812:	b082      	sub	sp, #8
 8002814:	af00      	add	r7, sp, #0
 8002816:	6078      	str	r0, [r7, #4]
 8002818:	6039      	str	r1, [r7, #0]
    os_getDevKey(AESkey);
 800281a:	4b07      	ldr	r3, [pc, #28]	; (8002838 <aes_encrypt+0x28>)
 800281c:	0018      	movs	r0, r3
 800281e:	f003 f875 	bl	800590c <os_getDevKey>
    os_aes(AES_ENC, pdu, len);
 8002822:	683b      	ldr	r3, [r7, #0]
 8002824:	b29a      	uxth	r2, r3
 8002826:	687b      	ldr	r3, [r7, #4]
 8002828:	0019      	movs	r1, r3
 800282a:	2000      	movs	r0, #0
 800282c:	f7fe fdb0 	bl	8001390 <os_aes>
}
 8002830:	46c0      	nop			; (mov r8, r8)
 8002832:	46bd      	mov	sp, r7
 8002834:	b002      	add	sp, #8
 8002836:	bd80      	pop	{r7, pc}
 8002838:	200000a0 	.word	0x200000a0

0800283c <aes_cipher>:


static void aes_cipher (xref2cu1_t key, u4_t devaddr, u4_t seqno, int dndir, xref2u1_t payload, int len) {
 800283c:	b580      	push	{r7, lr}
 800283e:	b084      	sub	sp, #16
 8002840:	af00      	add	r7, sp, #0
 8002842:	60f8      	str	r0, [r7, #12]
 8002844:	60b9      	str	r1, [r7, #8]
 8002846:	607a      	str	r2, [r7, #4]
 8002848:	603b      	str	r3, [r7, #0]
    if( len <= 0 )
 800284a:	69fb      	ldr	r3, [r7, #28]
 800284c:	2b00      	cmp	r3, #0
 800284e:	dd2b      	ble.n	80028a8 <aes_cipher+0x6c>
        return;
    os_clearMem(AESaux, 16);
 8002850:	4b17      	ldr	r3, [pc, #92]	; (80028b0 <aes_cipher+0x74>)
 8002852:	2210      	movs	r2, #16
 8002854:	2100      	movs	r1, #0
 8002856:	0018      	movs	r0, r3
 8002858:	f00b f8ed 	bl	800da36 <memset>
    AESaux[0] = AESaux[15] = 1; // mode=cipher / dir=down / block counter=1
 800285c:	4b15      	ldr	r3, [pc, #84]	; (80028b4 <aes_cipher+0x78>)
 800285e:	2201      	movs	r2, #1
 8002860:	701a      	strb	r2, [r3, #0]
 8002862:	4a13      	ldr	r2, [pc, #76]	; (80028b0 <aes_cipher+0x74>)
 8002864:	781b      	ldrb	r3, [r3, #0]
 8002866:	7013      	strb	r3, [r2, #0]
    AESaux[5] = dndir?1:0;
 8002868:	683b      	ldr	r3, [r7, #0]
 800286a:	1e5a      	subs	r2, r3, #1
 800286c:	4193      	sbcs	r3, r2
 800286e:	b2da      	uxtb	r2, r3
 8002870:	4b11      	ldr	r3, [pc, #68]	; (80028b8 <aes_cipher+0x7c>)
 8002872:	701a      	strb	r2, [r3, #0]
    os_wlsbf4(AESaux+ 6,devaddr);
 8002874:	4b11      	ldr	r3, [pc, #68]	; (80028bc <aes_cipher+0x80>)
 8002876:	68ba      	ldr	r2, [r7, #8]
 8002878:	0011      	movs	r1, r2
 800287a:	0018      	movs	r0, r3
 800287c:	f7ff fe64 	bl	8002548 <os_wlsbf4>
    os_wlsbf4(AESaux+10,seqno);
 8002880:	4b0f      	ldr	r3, [pc, #60]	; (80028c0 <aes_cipher+0x84>)
 8002882:	687a      	ldr	r2, [r7, #4]
 8002884:	0011      	movs	r1, r2
 8002886:	0018      	movs	r0, r3
 8002888:	f7ff fe5e 	bl	8002548 <os_wlsbf4>
    os_copyMem(AESkey,key,16);
 800288c:	68f9      	ldr	r1, [r7, #12]
 800288e:	4b0d      	ldr	r3, [pc, #52]	; (80028c4 <aes_cipher+0x88>)
 8002890:	2210      	movs	r2, #16
 8002892:	0018      	movs	r0, r3
 8002894:	f00b f8c6 	bl	800da24 <memcpy>
    os_aes(AES_CTR, payload, len);
 8002898:	69fb      	ldr	r3, [r7, #28]
 800289a:	b29a      	uxth	r2, r3
 800289c:	69bb      	ldr	r3, [r7, #24]
 800289e:	0019      	movs	r1, r3
 80028a0:	2004      	movs	r0, #4
 80028a2:	f7fe fd75 	bl	8001390 <os_aes>
 80028a6:	e000      	b.n	80028aa <aes_cipher+0x6e>
        return;
 80028a8:	46c0      	nop			; (mov r8, r8)
}
 80028aa:	46bd      	mov	sp, r7
 80028ac:	b004      	add	sp, #16
 80028ae:	bd80      	pop	{r7, pc}
 80028b0:	20000150 	.word	0x20000150
 80028b4:	2000015f 	.word	0x2000015f
 80028b8:	20000155 	.word	0x20000155
 80028bc:	20000156 	.word	0x20000156
 80028c0:	2000015a 	.word	0x2000015a
 80028c4:	200000a0 	.word	0x200000a0

080028c8 <aes_sessKeys>:


static void aes_sessKeys (u2_t devnonce, xref2cu1_t artnonce, xref2u1_t nwkkey, xref2u1_t artkey) {
 80028c8:	b590      	push	{r4, r7, lr}
 80028ca:	b085      	sub	sp, #20
 80028cc:	af00      	add	r7, sp, #0
 80028ce:	60b9      	str	r1, [r7, #8]
 80028d0:	607a      	str	r2, [r7, #4]
 80028d2:	603b      	str	r3, [r7, #0]
 80028d4:	240e      	movs	r4, #14
 80028d6:	193b      	adds	r3, r7, r4
 80028d8:	1c02      	adds	r2, r0, #0
 80028da:	801a      	strh	r2, [r3, #0]
    os_clearMem(nwkkey, 16);
 80028dc:	687b      	ldr	r3, [r7, #4]
 80028de:	2210      	movs	r2, #16
 80028e0:	2100      	movs	r1, #0
 80028e2:	0018      	movs	r0, r3
 80028e4:	f00b f8a7 	bl	800da36 <memset>
    nwkkey[0] = 0x01;
 80028e8:	687b      	ldr	r3, [r7, #4]
 80028ea:	2201      	movs	r2, #1
 80028ec:	701a      	strb	r2, [r3, #0]
    os_copyMem(nwkkey+1, artnonce, LEN_ARTNONCE+LEN_NETID);
 80028ee:	687b      	ldr	r3, [r7, #4]
 80028f0:	3301      	adds	r3, #1
 80028f2:	68b9      	ldr	r1, [r7, #8]
 80028f4:	2206      	movs	r2, #6
 80028f6:	0018      	movs	r0, r3
 80028f8:	f00b f894 	bl	800da24 <memcpy>
    os_wlsbf2(nwkkey+1+LEN_ARTNONCE+LEN_NETID, devnonce);
 80028fc:	687b      	ldr	r3, [r7, #4]
 80028fe:	1dda      	adds	r2, r3, #7
 8002900:	193b      	adds	r3, r7, r4
 8002902:	881b      	ldrh	r3, [r3, #0]
 8002904:	0019      	movs	r1, r3
 8002906:	0010      	movs	r0, r2
 8002908:	f7ff fe06 	bl	8002518 <os_wlsbf2>
    os_copyMem(artkey, nwkkey, 16);
 800290c:	6879      	ldr	r1, [r7, #4]
 800290e:	683b      	ldr	r3, [r7, #0]
 8002910:	2210      	movs	r2, #16
 8002912:	0018      	movs	r0, r3
 8002914:	f00b f886 	bl	800da24 <memcpy>
    artkey[0] = 0x02;
 8002918:	683b      	ldr	r3, [r7, #0]
 800291a:	2202      	movs	r2, #2
 800291c:	701a      	strb	r2, [r3, #0]

    os_getDevKey(AESkey);
 800291e:	4b0c      	ldr	r3, [pc, #48]	; (8002950 <aes_sessKeys+0x88>)
 8002920:	0018      	movs	r0, r3
 8002922:	f002 fff3 	bl	800590c <os_getDevKey>
    os_aes(AES_ENC, nwkkey, 16);
 8002926:	687b      	ldr	r3, [r7, #4]
 8002928:	2210      	movs	r2, #16
 800292a:	0019      	movs	r1, r3
 800292c:	2000      	movs	r0, #0
 800292e:	f7fe fd2f 	bl	8001390 <os_aes>
    os_getDevKey(AESkey);
 8002932:	4b07      	ldr	r3, [pc, #28]	; (8002950 <aes_sessKeys+0x88>)
 8002934:	0018      	movs	r0, r3
 8002936:	f002 ffe9 	bl	800590c <os_getDevKey>
    os_aes(AES_ENC, artkey, 16);
 800293a:	683b      	ldr	r3, [r7, #0]
 800293c:	2210      	movs	r2, #16
 800293e:	0019      	movs	r1, r3
 8002940:	2000      	movs	r0, #0
 8002942:	f7fe fd25 	bl	8001390 <os_aes>
}
 8002946:	46c0      	nop			; (mov r8, r8)
 8002948:	46bd      	mov	sp, r7
 800294a:	b005      	add	sp, #20
 800294c:	bd90      	pop	{r4, r7, pc}
 800294e:	46c0      	nop			; (mov r8, r8)
 8002950:	200000a0 	.word	0x200000a0

08002954 <getSensitivity>:
    { 141-135,  141-132, 141-129 },  // SF10
    { 141-138,  141-135, 141-132 },  // SF11
    { 141-141,  141-138, 141-135 }   // SF12
};

int getSensitivity (rps_t rps) {
 8002954:	b590      	push	{r4, r7, lr}
 8002956:	b083      	sub	sp, #12
 8002958:	af00      	add	r7, sp, #0
 800295a:	0002      	movs	r2, r0
 800295c:	1dbb      	adds	r3, r7, #6
 800295e:	801a      	strh	r2, [r3, #0]
    return -141 + SENSITIVITY[getSf(rps)][getBw(rps)];
 8002960:	1dbb      	adds	r3, r7, #6
 8002962:	881b      	ldrh	r3, [r3, #0]
 8002964:	0018      	movs	r0, r3
 8002966:	f7ff fc78 	bl	800225a <getSf>
 800296a:	0003      	movs	r3, r0
 800296c:	001c      	movs	r4, r3
 800296e:	1dbb      	adds	r3, r7, #6
 8002970:	881b      	ldrh	r3, [r3, #0]
 8002972:	0018      	movs	r0, r3
 8002974:	f7ff fc81 	bl	800227a <getBw>
 8002978:	0003      	movs	r3, r0
 800297a:	0019      	movs	r1, r3
 800297c:	4a05      	ldr	r2, [pc, #20]	; (8002994 <getSensitivity+0x40>)
 800297e:	0023      	movs	r3, r4
 8002980:	005b      	lsls	r3, r3, #1
 8002982:	191b      	adds	r3, r3, r4
 8002984:	18d3      	adds	r3, r2, r3
 8002986:	5c5b      	ldrb	r3, [r3, r1]
 8002988:	3b8d      	subs	r3, #141	; 0x8d
}
 800298a:	0018      	movs	r0, r3
 800298c:	46bd      	mov	sp, r7
 800298e:	b003      	add	sp, #12
 8002990:	bd90      	pop	{r4, r7, pc}
 8002992:	46c0      	nop			; (mov r8, r8)
 8002994:	0800f100 	.word	0x0800f100

08002998 <calcAirTime>:

ostime_t calcAirTime (rps_t rps, u1_t plen) {
 8002998:	b5b0      	push	{r4, r5, r7, lr}
 800299a:	b086      	sub	sp, #24
 800299c:	af00      	add	r7, sp, #0
 800299e:	0002      	movs	r2, r0
 80029a0:	1dbb      	adds	r3, r7, #6
 80029a2:	801a      	strh	r2, [r3, #0]
 80029a4:	1d7b      	adds	r3, r7, #5
 80029a6:	1c0a      	adds	r2, r1, #0
 80029a8:	701a      	strb	r2, [r3, #0]
    u1_t bw = getBw(rps);  // 0,1,2 = 125,250,500kHz
 80029aa:	230b      	movs	r3, #11
 80029ac:	18fc      	adds	r4, r7, r3
 80029ae:	1dbb      	adds	r3, r7, #6
 80029b0:	881b      	ldrh	r3, [r3, #0]
 80029b2:	0018      	movs	r0, r3
 80029b4:	f7ff fc61 	bl	800227a <getBw>
 80029b8:	0003      	movs	r3, r0
 80029ba:	7023      	strb	r3, [r4, #0]
    u1_t sf = getSf(rps);  // 0=FSK, 1..6 = SF7..12
 80029bc:	250a      	movs	r5, #10
 80029be:	197c      	adds	r4, r7, r5
 80029c0:	1dbb      	adds	r3, r7, #6
 80029c2:	881b      	ldrh	r3, [r3, #0]
 80029c4:	0018      	movs	r0, r3
 80029c6:	f7ff fc48 	bl	800225a <getSf>
 80029ca:	0003      	movs	r3, r0
 80029cc:	7023      	strb	r3, [r4, #0]
    if( sf == FSK ) {
 80029ce:	197b      	adds	r3, r7, r5
 80029d0:	781b      	ldrb	r3, [r3, #0]
 80029d2:	2b00      	cmp	r3, #0
 80029d4:	d10f      	bne.n	80029f6 <calcAirTime+0x5e>
        return (plen+/*preamble*/5+/*syncword*/3+/*len*/1+/*crc*/2) * /*bits/byte*/8
 80029d6:	1d7b      	adds	r3, r7, #5
 80029d8:	781b      	ldrb	r3, [r3, #0]
 80029da:	330b      	adds	r3, #11
 80029dc:	001a      	movs	r2, r3
            * (s4_t)OSTICKS_PER_SEC / /*kbit/s*/50000;
 80029de:	0013      	movs	r3, r2
 80029e0:	015b      	lsls	r3, r3, #5
 80029e2:	1a9b      	subs	r3, r3, r2
 80029e4:	009b      	lsls	r3, r3, #2
 80029e6:	189b      	adds	r3, r3, r2
 80029e8:	02db      	lsls	r3, r3, #11
 80029ea:	494c      	ldr	r1, [pc, #304]	; (8002b1c <calcAirTime+0x184>)
 80029ec:	0018      	movs	r0, r3
 80029ee:	f7fd fc15 	bl	800021c <__divsi3>
 80029f2:	0003      	movs	r3, r0
 80029f4:	e08d      	b.n	8002b12 <calcAirTime+0x17a>
    }
    u1_t sfx = 4*(sf+(7-SF7));
 80029f6:	210a      	movs	r1, #10
 80029f8:	187b      	adds	r3, r7, r1
 80029fa:	781b      	ldrb	r3, [r3, #0]
 80029fc:	3306      	adds	r3, #6
 80029fe:	b2da      	uxtb	r2, r3
 8002a00:	2317      	movs	r3, #23
 8002a02:	18fb      	adds	r3, r7, r3
 8002a04:	0092      	lsls	r2, r2, #2
 8002a06:	701a      	strb	r2, [r3, #0]
    u1_t q = sfx - (sf >= SF11 ? 8 : 0);
 8002a08:	187b      	adds	r3, r7, r1
 8002a0a:	781b      	ldrb	r3, [r3, #0]
 8002a0c:	2b04      	cmp	r3, #4
 8002a0e:	d901      	bls.n	8002a14 <calcAirTime+0x7c>
 8002a10:	2308      	movs	r3, #8
 8002a12:	e000      	b.n	8002a16 <calcAirTime+0x7e>
 8002a14:	2300      	movs	r3, #0
 8002a16:	2209      	movs	r2, #9
 8002a18:	18ba      	adds	r2, r7, r2
 8002a1a:	2017      	movs	r0, #23
 8002a1c:	1839      	adds	r1, r7, r0
 8002a1e:	7809      	ldrb	r1, [r1, #0]
 8002a20:	1acb      	subs	r3, r1, r3
 8002a22:	7013      	strb	r3, [r2, #0]
    int tmp = 8*plen - sfx + 28 + (getNocrc(rps)?0:16) - (getIh(rps)?20:0);
 8002a24:	1d7b      	adds	r3, r7, #5
 8002a26:	781b      	ldrb	r3, [r3, #0]
 8002a28:	00da      	lsls	r2, r3, #3
 8002a2a:	183b      	adds	r3, r7, r0
 8002a2c:	781b      	ldrb	r3, [r3, #0]
 8002a2e:	1ad3      	subs	r3, r2, r3
 8002a30:	331c      	adds	r3, #28
 8002a32:	001c      	movs	r4, r3
 8002a34:	1dbb      	adds	r3, r7, #6
 8002a36:	881b      	ldrh	r3, [r3, #0]
 8002a38:	0018      	movs	r0, r3
 8002a3a:	f7ff fc5c 	bl	80022f6 <getNocrc>
 8002a3e:	1e03      	subs	r3, r0, #0
 8002a40:	d001      	beq.n	8002a46 <calcAirTime+0xae>
 8002a42:	2300      	movs	r3, #0
 8002a44:	e000      	b.n	8002a48 <calcAirTime+0xb0>
 8002a46:	2310      	movs	r3, #16
 8002a48:	191c      	adds	r4, r3, r4
 8002a4a:	1dbb      	adds	r3, r7, #6
 8002a4c:	881b      	ldrh	r3, [r3, #0]
 8002a4e:	0018      	movs	r0, r3
 8002a50:	f7ff fc79 	bl	8002346 <getIh>
 8002a54:	1e03      	subs	r3, r0, #0
 8002a56:	d001      	beq.n	8002a5c <calcAirTime+0xc4>
 8002a58:	2314      	movs	r3, #20
 8002a5a:	e000      	b.n	8002a5e <calcAirTime+0xc6>
 8002a5c:	2300      	movs	r3, #0
 8002a5e:	1ae3      	subs	r3, r4, r3
 8002a60:	613b      	str	r3, [r7, #16]
    if( tmp > 0 ) {
 8002a62:	693b      	ldr	r3, [r7, #16]
 8002a64:	2b00      	cmp	r3, #0
 8002a66:	dd1b      	ble.n	8002aa0 <calcAirTime+0x108>
        tmp = (tmp + q - 1) / q;
 8002a68:	2109      	movs	r1, #9
 8002a6a:	187b      	adds	r3, r7, r1
 8002a6c:	781a      	ldrb	r2, [r3, #0]
 8002a6e:	693b      	ldr	r3, [r7, #16]
 8002a70:	18d3      	adds	r3, r2, r3
 8002a72:	1e5a      	subs	r2, r3, #1
 8002a74:	187b      	adds	r3, r7, r1
 8002a76:	781b      	ldrb	r3, [r3, #0]
 8002a78:	0019      	movs	r1, r3
 8002a7a:	0010      	movs	r0, r2
 8002a7c:	f7fd fbce 	bl	800021c <__divsi3>
 8002a80:	0003      	movs	r3, r0
 8002a82:	613b      	str	r3, [r7, #16]
        tmp *= getCr(rps)+5;
 8002a84:	1dbb      	adds	r3, r7, #6
 8002a86:	881b      	ldrh	r3, [r3, #0]
 8002a88:	0018      	movs	r0, r3
 8002a8a:	f7ff fc08 	bl	800229e <getCr>
 8002a8e:	0003      	movs	r3, r0
 8002a90:	1d5a      	adds	r2, r3, #5
 8002a92:	693b      	ldr	r3, [r7, #16]
 8002a94:	4353      	muls	r3, r2
 8002a96:	613b      	str	r3, [r7, #16]
        tmp += 8;
 8002a98:	693b      	ldr	r3, [r7, #16]
 8002a9a:	3308      	adds	r3, #8
 8002a9c:	613b      	str	r3, [r7, #16]
 8002a9e:	e001      	b.n	8002aa4 <calcAirTime+0x10c>
    } else {
        tmp = 8;
 8002aa0:	2308      	movs	r3, #8
 8002aa2:	613b      	str	r3, [r7, #16]
    }
    tmp = (tmp<<2) + /*preamble*/49 /* 4 * (8 + 4.25) */;
 8002aa4:	693b      	ldr	r3, [r7, #16]
 8002aa6:	009b      	lsls	r3, r3, #2
 8002aa8:	3331      	adds	r3, #49	; 0x31
 8002aaa:	613b      	str	r3, [r7, #16]
    //
    // osticks =  tmp * OSTICKS_PER_SEC * 1<<sf / bw
    //
    // 3 => counter reduced divisor 125000/8 => 15625
    // 2 => counter 2 shift on tmp
    sfx = sf+(7-SF7) - (3+2) - bw;
 8002aac:	230a      	movs	r3, #10
 8002aae:	18fa      	adds	r2, r7, r3
 8002ab0:	230b      	movs	r3, #11
 8002ab2:	18fb      	adds	r3, r7, r3
 8002ab4:	7812      	ldrb	r2, [r2, #0]
 8002ab6:	781b      	ldrb	r3, [r3, #0]
 8002ab8:	1ad3      	subs	r3, r2, r3
 8002aba:	b2da      	uxtb	r2, r3
 8002abc:	2117      	movs	r1, #23
 8002abe:	187b      	adds	r3, r7, r1
 8002ac0:	3201      	adds	r2, #1
 8002ac2:	701a      	strb	r2, [r3, #0]
    int div = 15625;
 8002ac4:	4b16      	ldr	r3, [pc, #88]	; (8002b20 <calcAirTime+0x188>)
 8002ac6:	60fb      	str	r3, [r7, #12]
    if( sfx > 4 ) {
 8002ac8:	187b      	adds	r3, r7, r1
 8002aca:	781b      	ldrb	r3, [r3, #0]
 8002acc:	2b04      	cmp	r3, #4
 8002ace:	d909      	bls.n	8002ae4 <calcAirTime+0x14c>
        // prevent 32bit signed int overflow in last step
        div >>= sfx-4;
 8002ad0:	187b      	adds	r3, r7, r1
 8002ad2:	781b      	ldrb	r3, [r3, #0]
 8002ad4:	3b04      	subs	r3, #4
 8002ad6:	68fa      	ldr	r2, [r7, #12]
 8002ad8:	411a      	asrs	r2, r3
 8002ada:	0013      	movs	r3, r2
 8002adc:	60fb      	str	r3, [r7, #12]
        sfx = 4;
 8002ade:	187b      	adds	r3, r7, r1
 8002ae0:	2204      	movs	r2, #4
 8002ae2:	701a      	strb	r2, [r3, #0]
    }
    // Need 32bit arithmetic for this last step
    return (((ostime_t)tmp << sfx) * OSTICKS_PER_SEC + div/2) / div;
 8002ae4:	2317      	movs	r3, #23
 8002ae6:	18fb      	adds	r3, r7, r3
 8002ae8:	781b      	ldrb	r3, [r3, #0]
 8002aea:	693a      	ldr	r2, [r7, #16]
 8002aec:	409a      	lsls	r2, r3
 8002aee:	0013      	movs	r3, r2
 8002af0:	015b      	lsls	r3, r3, #5
 8002af2:	1a9b      	subs	r3, r3, r2
 8002af4:	009b      	lsls	r3, r3, #2
 8002af6:	189b      	adds	r3, r3, r2
 8002af8:	021b      	lsls	r3, r3, #8
 8002afa:	001a      	movs	r2, r3
 8002afc:	68fb      	ldr	r3, [r7, #12]
 8002afe:	2b00      	cmp	r3, #0
 8002b00:	da00      	bge.n	8002b04 <calcAirTime+0x16c>
 8002b02:	3301      	adds	r3, #1
 8002b04:	105b      	asrs	r3, r3, #1
 8002b06:	18d3      	adds	r3, r2, r3
 8002b08:	68f9      	ldr	r1, [r7, #12]
 8002b0a:	0018      	movs	r0, r3
 8002b0c:	f7fd fb86 	bl	800021c <__divsi3>
 8002b10:	0003      	movs	r3, r0
}
 8002b12:	0018      	movs	r0, r3
 8002b14:	46bd      	mov	sp, r7
 8002b16:	b006      	add	sp, #24
 8002b18:	bdb0      	pop	{r4, r5, r7, pc}
 8002b1a:	46c0      	nop			; (mov r8, r8)
 8002b1c:	0000c350 	.word	0x0000c350
 8002b20:	00003d09 	.word	0x00003d09

08002b24 <calcRxWindow>:
    us2osticksRound(128<<0)   // ------    DR_SF7CR
#endif
};


static ostime_t calcRxWindow (u1_t secs, dr_t dr) {
 8002b24:	b590      	push	{r4, r7, lr}
 8002b26:	b087      	sub	sp, #28
 8002b28:	af00      	add	r7, sp, #0
 8002b2a:	0002      	movs	r2, r0
 8002b2c:	1dfb      	adds	r3, r7, #7
 8002b2e:	701a      	strb	r2, [r3, #0]
 8002b30:	1dbb      	adds	r3, r7, #6
 8002b32:	1c0a      	adds	r2, r1, #0
 8002b34:	701a      	strb	r2, [r3, #0]
    ostime_t rxoff, err;
    if( secs==0 ) {
 8002b36:	1dfb      	adds	r3, r7, #7
 8002b38:	781b      	ldrb	r3, [r3, #0]
 8002b3a:	2b00      	cmp	r3, #0
 8002b3c:	d108      	bne.n	8002b50 <calcRxWindow+0x2c>
        // aka 128 secs (next becaon)
        rxoff = LMIC.drift;
 8002b3e:	4b24      	ldr	r3, [pc, #144]	; (8002bd0 <calcRxWindow+0xac>)
 8002b40:	22b4      	movs	r2, #180	; 0xb4
 8002b42:	5e9b      	ldrsh	r3, [r3, r2]
 8002b44:	617b      	str	r3, [r7, #20]
        err = LMIC.lastDriftDiff;
 8002b46:	4b22      	ldr	r3, [pc, #136]	; (8002bd0 <calcRxWindow+0xac>)
 8002b48:	22b6      	movs	r2, #182	; 0xb6
 8002b4a:	5e9b      	ldrsh	r3, [r3, r2]
 8002b4c:	613b      	str	r3, [r7, #16]
 8002b4e:	e011      	b.n	8002b74 <calcRxWindow+0x50>
    } else {
        // scheduled RX window within secs into current beacon period
        rxoff = (LMIC.drift * (ostime_t)secs) >> BCN_INTV_exp;
 8002b50:	4b1f      	ldr	r3, [pc, #124]	; (8002bd0 <calcRxWindow+0xac>)
 8002b52:	22b4      	movs	r2, #180	; 0xb4
 8002b54:	5e9b      	ldrsh	r3, [r3, r2]
 8002b56:	001a      	movs	r2, r3
 8002b58:	1dfb      	adds	r3, r7, #7
 8002b5a:	781b      	ldrb	r3, [r3, #0]
 8002b5c:	4353      	muls	r3, r2
 8002b5e:	11db      	asrs	r3, r3, #7
 8002b60:	617b      	str	r3, [r7, #20]
        err = (LMIC.lastDriftDiff * (ostime_t)secs) >> BCN_INTV_exp;
 8002b62:	4b1b      	ldr	r3, [pc, #108]	; (8002bd0 <calcRxWindow+0xac>)
 8002b64:	22b6      	movs	r2, #182	; 0xb6
 8002b66:	5e9b      	ldrsh	r3, [r3, r2]
 8002b68:	001a      	movs	r2, r3
 8002b6a:	1dfb      	adds	r3, r7, #7
 8002b6c:	781b      	ldrb	r3, [r3, #0]
 8002b6e:	4353      	muls	r3, r2
 8002b70:	11db      	asrs	r3, r3, #7
 8002b72:	613b      	str	r3, [r7, #16]
    }
    u1_t rxsyms = MINRX_SYMS;
 8002b74:	240f      	movs	r4, #15
 8002b76:	193b      	adds	r3, r7, r4
 8002b78:	2205      	movs	r2, #5
 8002b7a:	701a      	strb	r2, [r3, #0]
    err += (ostime_t)LMIC.maxDriftDiff * LMIC.missedBcns;
 8002b7c:	4b14      	ldr	r3, [pc, #80]	; (8002bd0 <calcRxWindow+0xac>)
 8002b7e:	22b8      	movs	r2, #184	; 0xb8
 8002b80:	5e9b      	ldrsh	r3, [r3, r2]
 8002b82:	0019      	movs	r1, r3
 8002b84:	4a12      	ldr	r2, [pc, #72]	; (8002bd0 <calcRxWindow+0xac>)
 8002b86:	2332      	movs	r3, #50	; 0x32
 8002b88:	33ff      	adds	r3, #255	; 0xff
 8002b8a:	5cd3      	ldrb	r3, [r2, r3]
 8002b8c:	434b      	muls	r3, r1
 8002b8e:	693a      	ldr	r2, [r7, #16]
 8002b90:	18d3      	adds	r3, r2, r3
 8002b92:	613b      	str	r3, [r7, #16]
    LMIC.rxsyms = MINRX_SYMS + (err / dr2hsym(dr));
 8002b94:	1dbb      	adds	r3, r7, #6
 8002b96:	781a      	ldrb	r2, [r3, #0]
 8002b98:	4b0e      	ldr	r3, [pc, #56]	; (8002bd4 <calcRxWindow+0xb0>)
 8002b9a:	0092      	lsls	r2, r2, #2
 8002b9c:	58d3      	ldr	r3, [r2, r3]
 8002b9e:	0019      	movs	r1, r3
 8002ba0:	6938      	ldr	r0, [r7, #16]
 8002ba2:	f7fd fb3b 	bl	800021c <__divsi3>
 8002ba6:	0003      	movs	r3, r0
 8002ba8:	b2db      	uxtb	r3, r3
 8002baa:	3305      	adds	r3, #5
 8002bac:	b2da      	uxtb	r2, r3
 8002bae:	4b08      	ldr	r3, [pc, #32]	; (8002bd0 <calcRxWindow+0xac>)
 8002bb0:	741a      	strb	r2, [r3, #16]

    return (rxsyms-PAMBL_SYMS) * dr2hsym(dr) + rxoff;
 8002bb2:	193b      	adds	r3, r7, r4
 8002bb4:	781b      	ldrb	r3, [r3, #0]
 8002bb6:	3b08      	subs	r3, #8
 8002bb8:	1dba      	adds	r2, r7, #6
 8002bba:	7811      	ldrb	r1, [r2, #0]
 8002bbc:	4a05      	ldr	r2, [pc, #20]	; (8002bd4 <calcRxWindow+0xb0>)
 8002bbe:	0089      	lsls	r1, r1, #2
 8002bc0:	588a      	ldr	r2, [r1, r2]
 8002bc2:	435a      	muls	r2, r3
 8002bc4:	697b      	ldr	r3, [r7, #20]
 8002bc6:	18d3      	adds	r3, r2, r3
}
 8002bc8:	0018      	movs	r0, r3
 8002bca:	46bd      	mov	sp, r7
 8002bcc:	b007      	add	sp, #28
 8002bce:	bd90      	pop	{r4, r7, pc}
 8002bd0:	20000324 	.word	0x20000324
 8002bd4:	0800f124 	.word	0x0800f124

08002bd8 <calcBcnRxWindowFromMillis>:


// Setup beacon RX parameters assuming we have an error of ms (aka +/-(ms/2))
static void calcBcnRxWindowFromMillis (u1_t ms, bit_t ini) {
 8002bd8:	b5b0      	push	{r4, r5, r7, lr}
 8002bda:	b084      	sub	sp, #16
 8002bdc:	af00      	add	r7, sp, #0
 8002bde:	0002      	movs	r2, r0
 8002be0:	1dfb      	adds	r3, r7, #7
 8002be2:	701a      	strb	r2, [r3, #0]
 8002be4:	1dbb      	adds	r3, r7, #6
 8002be6:	1c0a      	adds	r2, r1, #0
 8002be8:	701a      	strb	r2, [r3, #0]
    if( ini ) {
 8002bea:	1dbb      	adds	r3, r7, #6
 8002bec:	781b      	ldrb	r3, [r3, #0]
 8002bee:	2b00      	cmp	r3, #0
 8002bf0:	d017      	beq.n	8002c22 <calcBcnRxWindowFromMillis+0x4a>
        LMIC.drift = 0;
 8002bf2:	4b2d      	ldr	r3, [pc, #180]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002bf4:	22b4      	movs	r2, #180	; 0xb4
 8002bf6:	2100      	movs	r1, #0
 8002bf8:	5299      	strh	r1, [r3, r2]
        LMIC.maxDriftDiff = 0;
 8002bfa:	4b2b      	ldr	r3, [pc, #172]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002bfc:	22b8      	movs	r2, #184	; 0xb8
 8002bfe:	2100      	movs	r1, #0
 8002c00:	5299      	strh	r1, [r3, r2]
        LMIC.missedBcns = 0;
 8002c02:	4a29      	ldr	r2, [pc, #164]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002c04:	2332      	movs	r3, #50	; 0x32
 8002c06:	33ff      	adds	r3, #255	; 0xff
 8002c08:	2100      	movs	r1, #0
 8002c0a:	54d1      	strb	r1, [r2, r3]
        LMIC.bcninfo.flags |= BCN_NODRIFT|BCN_NODDIFF;
 8002c0c:	4a26      	ldr	r2, [pc, #152]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002c0e:	23cb      	movs	r3, #203	; 0xcb
 8002c10:	005b      	lsls	r3, r3, #1
 8002c12:	5cd3      	ldrb	r3, [r2, r3]
 8002c14:	220c      	movs	r2, #12
 8002c16:	4313      	orrs	r3, r2
 8002c18:	b2d9      	uxtb	r1, r3
 8002c1a:	4a23      	ldr	r2, [pc, #140]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002c1c:	23cb      	movs	r3, #203	; 0xcb
 8002c1e:	005b      	lsls	r3, r3, #1
 8002c20:	54d1      	strb	r1, [r2, r3]
    }
    ostime_t hsym = dr2hsym(DR_BCN);
 8002c22:	2342      	movs	r3, #66	; 0x42
 8002c24:	60fb      	str	r3, [r7, #12]
    LMIC.bcnRxsyms = MINRX_SYMS + ms2osticksCeil(ms) / hsym;
 8002c26:	1dfb      	adds	r3, r7, #7
 8002c28:	781b      	ldrb	r3, [r3, #0]
 8002c2a:	b2db      	uxtb	r3, r3
 8002c2c:	001c      	movs	r4, r3
 8002c2e:	2300      	movs	r3, #0
 8002c30:	001d      	movs	r5, r3
 8002c32:	22fa      	movs	r2, #250	; 0xfa
 8002c34:	01d2      	lsls	r2, r2, #7
 8002c36:	2300      	movs	r3, #0
 8002c38:	0020      	movs	r0, r4
 8002c3a:	0029      	movs	r1, r5
 8002c3c:	f7fd fc1e 	bl	800047c <__aeabi_lmul>
 8002c40:	0002      	movs	r2, r0
 8002c42:	000b      	movs	r3, r1
 8002c44:	0010      	movs	r0, r2
 8002c46:	0019      	movs	r1, r3
 8002c48:	4a18      	ldr	r2, [pc, #96]	; (8002cac <calcBcnRxWindowFromMillis+0xd4>)
 8002c4a:	2300      	movs	r3, #0
 8002c4c:	1880      	adds	r0, r0, r2
 8002c4e:	4159      	adcs	r1, r3
 8002c50:	22fa      	movs	r2, #250	; 0xfa
 8002c52:	0092      	lsls	r2, r2, #2
 8002c54:	2300      	movs	r3, #0
 8002c56:	f7fd fbcd 	bl	80003f4 <__aeabi_ldivmod>
 8002c5a:	0002      	movs	r2, r0
 8002c5c:	000b      	movs	r3, r1
 8002c5e:	0013      	movs	r3, r2
 8002c60:	68f9      	ldr	r1, [r7, #12]
 8002c62:	0018      	movs	r0, r3
 8002c64:	f7fd fada 	bl	800021c <__divsi3>
 8002c68:	0003      	movs	r3, r0
 8002c6a:	b2db      	uxtb	r3, r3
 8002c6c:	3305      	adds	r3, #5
 8002c6e:	b2d9      	uxtb	r1, r3
 8002c70:	4a0d      	ldr	r2, [pc, #52]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002c72:	238a      	movs	r3, #138	; 0x8a
 8002c74:	33ff      	adds	r3, #255	; 0xff
 8002c76:	54d1      	strb	r1, [r2, r3]
    LMIC.bcnRxtime = LMIC.bcninfo.txtime + BCN_INTV_osticks - (LMIC.bcnRxsyms-PAMBL_SYMS) * hsym;
 8002c78:	4a0b      	ldr	r2, [pc, #44]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002c7a:	23c8      	movs	r3, #200	; 0xc8
 8002c7c:	005b      	lsls	r3, r3, #1
 8002c7e:	58d3      	ldr	r3, [r2, r3]
 8002c80:	22fa      	movs	r2, #250	; 0xfa
 8002c82:	0392      	lsls	r2, r2, #14
 8002c84:	189a      	adds	r2, r3, r2
 8002c86:	4908      	ldr	r1, [pc, #32]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002c88:	238a      	movs	r3, #138	; 0x8a
 8002c8a:	33ff      	adds	r3, #255	; 0xff
 8002c8c:	5ccb      	ldrb	r3, [r1, r3]
 8002c8e:	3b08      	subs	r3, #8
 8002c90:	68f9      	ldr	r1, [r7, #12]
 8002c92:	434b      	muls	r3, r1
 8002c94:	1ad1      	subs	r1, r2, r3
 8002c96:	4a04      	ldr	r2, [pc, #16]	; (8002ca8 <calcBcnRxWindowFromMillis+0xd0>)
 8002c98:	23c6      	movs	r3, #198	; 0xc6
 8002c9a:	005b      	lsls	r3, r3, #1
 8002c9c:	50d1      	str	r1, [r2, r3]
}
 8002c9e:	46c0      	nop			; (mov r8, r8)
 8002ca0:	46bd      	mov	sp, r7
 8002ca2:	b004      	add	sp, #16
 8002ca4:	bdb0      	pop	{r4, r5, r7, pc}
 8002ca6:	46c0      	nop			; (mov r8, r8)
 8002ca8:	20000324 	.word	0x20000324
 8002cac:	000003e7 	.word	0x000003e7

08002cb0 <rxschedInit>:


// Setup scheduled RX window (ping/multicast slot)
static void rxschedInit (xref2rxsched_t rxsched) {
 8002cb0:	b590      	push	{r4, r7, lr}
 8002cb2:	b085      	sub	sp, #20
 8002cb4:	af00      	add	r7, sp, #0
 8002cb6:	6078      	str	r0, [r7, #4]
    os_clearMem(AESkey,16);
 8002cb8:	4b33      	ldr	r3, [pc, #204]	; (8002d88 <rxschedInit+0xd8>)
 8002cba:	2210      	movs	r2, #16
 8002cbc:	2100      	movs	r1, #0
 8002cbe:	0018      	movs	r0, r3
 8002cc0:	f00a feb9 	bl	800da36 <memset>
    os_clearMem(LMIC.frame+8,8);
 8002cc4:	4b31      	ldr	r3, [pc, #196]	; (8002d8c <rxschedInit+0xdc>)
 8002cc6:	2208      	movs	r2, #8
 8002cc8:	2100      	movs	r1, #0
 8002cca:	0018      	movs	r0, r3
 8002ccc:	f00a feb3 	bl	800da36 <memset>
    os_wlsbf4(LMIC.frame, LMIC.bcninfo.time);
 8002cd0:	4a2f      	ldr	r2, [pc, #188]	; (8002d90 <rxschedInit+0xe0>)
 8002cd2:	23cc      	movs	r3, #204	; 0xcc
 8002cd4:	005b      	lsls	r3, r3, #1
 8002cd6:	58d2      	ldr	r2, [r2, r3]
 8002cd8:	4b2e      	ldr	r3, [pc, #184]	; (8002d94 <rxschedInit+0xe4>)
 8002cda:	0011      	movs	r1, r2
 8002cdc:	0018      	movs	r0, r3
 8002cde:	f7ff fc33 	bl	8002548 <os_wlsbf4>
    os_wlsbf4(LMIC.frame+4, LMIC.devaddr);
 8002ce2:	482d      	ldr	r0, [pc, #180]	; (8002d98 <rxschedInit+0xe8>)
 8002ce4:	4a2a      	ldr	r2, [pc, #168]	; (8002d90 <rxschedInit+0xe0>)
 8002ce6:	238a      	movs	r3, #138	; 0x8a
 8002ce8:	005b      	lsls	r3, r3, #1
 8002cea:	58d3      	ldr	r3, [r2, r3]
 8002cec:	0019      	movs	r1, r3
 8002cee:	f7ff fc2b 	bl	8002548 <os_wlsbf4>
    os_aes(AES_ENC,LMIC.frame,16);
 8002cf2:	4b28      	ldr	r3, [pc, #160]	; (8002d94 <rxschedInit+0xe4>)
 8002cf4:	2210      	movs	r2, #16
 8002cf6:	0019      	movs	r1, r3
 8002cf8:	2000      	movs	r0, #0
 8002cfa:	f7fe fb49 	bl	8001390 <os_aes>
    u1_t intvExp = rxsched->intvExp;
 8002cfe:	240f      	movs	r4, #15
 8002d00:	193b      	adds	r3, r7, r4
 8002d02:	687a      	ldr	r2, [r7, #4]
 8002d04:	7852      	ldrb	r2, [r2, #1]
 8002d06:	701a      	strb	r2, [r3, #0]
    ostime_t off = os_rlsbf2(LMIC.frame) & (0x0FFF >> (7 - intvExp)); // random offset (slot units)
 8002d08:	4b22      	ldr	r3, [pc, #136]	; (8002d94 <rxschedInit+0xe4>)
 8002d0a:	0018      	movs	r0, r3
 8002d0c:	f7ff fbbb 	bl	8002486 <os_rlsbf2>
 8002d10:	0003      	movs	r3, r0
 8002d12:	0019      	movs	r1, r3
 8002d14:	0020      	movs	r0, r4
 8002d16:	183b      	adds	r3, r7, r0
 8002d18:	781b      	ldrb	r3, [r3, #0]
 8002d1a:	2207      	movs	r2, #7
 8002d1c:	1ad3      	subs	r3, r2, r3
 8002d1e:	4a1f      	ldr	r2, [pc, #124]	; (8002d9c <rxschedInit+0xec>)
 8002d20:	411a      	asrs	r2, r3
 8002d22:	0013      	movs	r3, r2
 8002d24:	400b      	ands	r3, r1
 8002d26:	60bb      	str	r3, [r7, #8]
    rxsched->rxbase = (LMIC.bcninfo.txtime +
 8002d28:	4a19      	ldr	r2, [pc, #100]	; (8002d90 <rxschedInit+0xe0>)
 8002d2a:	23c8      	movs	r3, #200	; 0xc8
 8002d2c:	005b      	lsls	r3, r3, #1
 8002d2e:	58d3      	ldr	r3, [r2, r3]
                       BCN_RESERVE_osticks +
 8002d30:	0019      	movs	r1, r3
                       ms2osticks(BCN_SLOT_SPAN_ms * off)); // random offset osticks
 8002d32:	68ba      	ldr	r2, [r7, #8]
 8002d34:	0013      	movs	r3, r2
 8002d36:	011b      	lsls	r3, r3, #4
 8002d38:	1a9b      	subs	r3, r3, r2
 8002d3a:	019b      	lsls	r3, r3, #6
                       BCN_RESERVE_osticks +
 8002d3c:	18cb      	adds	r3, r1, r3
 8002d3e:	4a18      	ldr	r2, [pc, #96]	; (8002da0 <rxschedInit+0xf0>)
 8002d40:	4694      	mov	ip, r2
 8002d42:	4463      	add	r3, ip
 8002d44:	001a      	movs	r2, r3
    rxsched->rxbase = (LMIC.bcninfo.txtime +
 8002d46:	687b      	ldr	r3, [r7, #4]
 8002d48:	605a      	str	r2, [r3, #4]
    rxsched->slot   = 0;
 8002d4a:	687b      	ldr	r3, [r7, #4]
 8002d4c:	2200      	movs	r2, #0
 8002d4e:	709a      	strb	r2, [r3, #2]
    rxsched->rxtime = rxsched->rxbase - calcRxWindow(/*secs BCN_RESERVE*/2+(1<<intvExp),rxsched->dr);
 8002d50:	687b      	ldr	r3, [r7, #4]
 8002d52:	685c      	ldr	r4, [r3, #4]
 8002d54:	183b      	adds	r3, r7, r0
 8002d56:	781b      	ldrb	r3, [r3, #0]
 8002d58:	2201      	movs	r2, #1
 8002d5a:	409a      	lsls	r2, r3
 8002d5c:	0013      	movs	r3, r2
 8002d5e:	b2db      	uxtb	r3, r3
 8002d60:	3302      	adds	r3, #2
 8002d62:	b2da      	uxtb	r2, r3
 8002d64:	687b      	ldr	r3, [r7, #4]
 8002d66:	781b      	ldrb	r3, [r3, #0]
 8002d68:	0019      	movs	r1, r3
 8002d6a:	0010      	movs	r0, r2
 8002d6c:	f7ff feda 	bl	8002b24 <calcRxWindow>
 8002d70:	0003      	movs	r3, r0
 8002d72:	1ae2      	subs	r2, r4, r3
 8002d74:	687b      	ldr	r3, [r7, #4]
 8002d76:	609a      	str	r2, [r3, #8]
    rxsched->rxsyms = LMIC.rxsyms;
 8002d78:	4b05      	ldr	r3, [pc, #20]	; (8002d90 <rxschedInit+0xe0>)
 8002d7a:	7c1a      	ldrb	r2, [r3, #16]
 8002d7c:	687b      	ldr	r3, [r7, #4]
 8002d7e:	70da      	strb	r2, [r3, #3]
}
 8002d80:	46c0      	nop			; (mov r8, r8)
 8002d82:	46bd      	mov	sp, r7
 8002d84:	b005      	add	sp, #20
 8002d86:	bd90      	pop	{r4, r7, pc}
 8002d88:	200000a0 	.word	0x200000a0
 8002d8c:	20000474 	.word	0x20000474
 8002d90:	20000324 	.word	0x20000324
 8002d94:	2000046c 	.word	0x2000046c
 8002d98:	20000470 	.word	0x20000470
 8002d9c:	00000fff 	.word	0x00000fff
 8002da0:	00010900 	.word	0x00010900

08002da4 <rxschedNext>:


static bit_t rxschedNext (xref2rxsched_t rxsched, ostime_t cando) {
 8002da4:	b590      	push	{r4, r7, lr}
 8002da6:	b085      	sub	sp, #20
 8002da8:	af00      	add	r7, sp, #0
 8002daa:	6078      	str	r0, [r7, #4]
 8002dac:	6039      	str	r1, [r7, #0]
  again:
    if( rxsched->rxtime - cando >= 0 )
 8002dae:	687b      	ldr	r3, [r7, #4]
 8002db0:	689a      	ldr	r2, [r3, #8]
 8002db2:	683b      	ldr	r3, [r7, #0]
 8002db4:	1ad3      	subs	r3, r2, r3
 8002db6:	d401      	bmi.n	8002dbc <rxschedNext+0x18>
        return 1;
 8002db8:	2301      	movs	r3, #1
 8002dba:	e04a      	b.n	8002e52 <rxschedNext+0xae>
    u1_t slot;
    if( (slot=rxsched->slot) >= 128 )
 8002dbc:	210f      	movs	r1, #15
 8002dbe:	187b      	adds	r3, r7, r1
 8002dc0:	687a      	ldr	r2, [r7, #4]
 8002dc2:	7892      	ldrb	r2, [r2, #2]
 8002dc4:	701a      	strb	r2, [r3, #0]
 8002dc6:	187b      	adds	r3, r7, r1
 8002dc8:	781b      	ldrb	r3, [r3, #0]
 8002dca:	b25b      	sxtb	r3, r3
 8002dcc:	2b00      	cmp	r3, #0
 8002dce:	da01      	bge.n	8002dd4 <rxschedNext+0x30>
        return 0;
 8002dd0:	2300      	movs	r3, #0
 8002dd2:	e03e      	b.n	8002e52 <rxschedNext+0xae>
    u1_t intv = 1<<rxsched->intvExp;
 8002dd4:	687b      	ldr	r3, [r7, #4]
 8002dd6:	785b      	ldrb	r3, [r3, #1]
 8002dd8:	001a      	movs	r2, r3
 8002dda:	2301      	movs	r3, #1
 8002ddc:	4093      	lsls	r3, r2
 8002dde:	001a      	movs	r2, r3
 8002de0:	240e      	movs	r4, #14
 8002de2:	193b      	adds	r3, r7, r4
 8002de4:	701a      	strb	r2, [r3, #0]
    if( (rxsched->slot = (slot += (intv))) >= 128 )
 8002de6:	200f      	movs	r0, #15
 8002de8:	183b      	adds	r3, r7, r0
 8002dea:	1839      	adds	r1, r7, r0
 8002dec:	193a      	adds	r2, r7, r4
 8002dee:	7809      	ldrb	r1, [r1, #0]
 8002df0:	7812      	ldrb	r2, [r2, #0]
 8002df2:	188a      	adds	r2, r1, r2
 8002df4:	701a      	strb	r2, [r3, #0]
 8002df6:	687b      	ldr	r3, [r7, #4]
 8002df8:	183a      	adds	r2, r7, r0
 8002dfa:	7812      	ldrb	r2, [r2, #0]
 8002dfc:	709a      	strb	r2, [r3, #2]
 8002dfe:	687b      	ldr	r3, [r7, #4]
 8002e00:	789b      	ldrb	r3, [r3, #2]
 8002e02:	b25b      	sxtb	r3, r3
 8002e04:	2b00      	cmp	r3, #0
 8002e06:	da01      	bge.n	8002e0c <rxschedNext+0x68>
        return 0;
 8002e08:	2300      	movs	r3, #0
 8002e0a:	e022      	b.n	8002e52 <rxschedNext+0xae>
    rxsched->rxtime = rxsched->rxbase
 8002e0c:	687b      	ldr	r3, [r7, #4]
 8002e0e:	6859      	ldr	r1, [r3, #4]
        + ((BCN_WINDOW_osticks * (ostime_t)slot) >> BCN_INTV_exp)
 8002e10:	200f      	movs	r0, #15
 8002e12:	183b      	adds	r3, r7, r0
 8002e14:	781a      	ldrb	r2, [r3, #0]
 8002e16:	0013      	movs	r3, r2
 8002e18:	011b      	lsls	r3, r3, #4
 8002e1a:	1a9b      	subs	r3, r3, r2
 8002e1c:	049b      	lsls	r3, r3, #18
 8002e1e:	11db      	asrs	r3, r3, #7
 8002e20:	18cc      	adds	r4, r1, r3
        - calcRxWindow(/*secs BCN_RESERVE*/2+slot+intv,rxsched->dr);
 8002e22:	183a      	adds	r2, r7, r0
 8002e24:	230e      	movs	r3, #14
 8002e26:	18fb      	adds	r3, r7, r3
 8002e28:	7812      	ldrb	r2, [r2, #0]
 8002e2a:	781b      	ldrb	r3, [r3, #0]
 8002e2c:	18d3      	adds	r3, r2, r3
 8002e2e:	b2db      	uxtb	r3, r3
 8002e30:	3302      	adds	r3, #2
 8002e32:	b2da      	uxtb	r2, r3
 8002e34:	687b      	ldr	r3, [r7, #4]
 8002e36:	781b      	ldrb	r3, [r3, #0]
 8002e38:	0019      	movs	r1, r3
 8002e3a:	0010      	movs	r0, r2
 8002e3c:	f7ff fe72 	bl	8002b24 <calcRxWindow>
 8002e40:	0003      	movs	r3, r0
 8002e42:	1ae2      	subs	r2, r4, r3
    rxsched->rxtime = rxsched->rxbase
 8002e44:	687b      	ldr	r3, [r7, #4]
 8002e46:	609a      	str	r2, [r3, #8]
    rxsched->rxsyms = LMIC.rxsyms;
 8002e48:	4b04      	ldr	r3, [pc, #16]	; (8002e5c <rxschedNext+0xb8>)
 8002e4a:	7c1a      	ldrb	r2, [r3, #16]
 8002e4c:	687b      	ldr	r3, [r7, #4]
 8002e4e:	70da      	strb	r2, [r3, #3]
    goto again;
 8002e50:	e7ad      	b.n	8002dae <rxschedNext+0xa>
}
 8002e52:	0018      	movs	r0, r3
 8002e54:	46bd      	mov	sp, r7
 8002e56:	b005      	add	sp, #20
 8002e58:	bd90      	pop	{r4, r7, pc}
 8002e5a:	46c0      	nop			; (mov r8, r8)
 8002e5c:	20000324 	.word	0x20000324

08002e60 <rndDelay>:


static ostime_t rndDelay (u1_t secSpan) {
 8002e60:	b590      	push	{r4, r7, lr}
 8002e62:	b085      	sub	sp, #20
 8002e64:	af00      	add	r7, sp, #0
 8002e66:	0002      	movs	r2, r0
 8002e68:	1dfb      	adds	r3, r7, #7
 8002e6a:	701a      	strb	r2, [r3, #0]
    u2_t r = os_getRndU2();
 8002e6c:	f003 ffca 	bl	8006e04 <radio_rand1>
 8002e70:	0003      	movs	r3, r0
 8002e72:	021b      	lsls	r3, r3, #8
 8002e74:	b21c      	sxth	r4, r3
 8002e76:	f003 ffc5 	bl	8006e04 <radio_rand1>
 8002e7a:	0003      	movs	r3, r0
 8002e7c:	b21b      	sxth	r3, r3
 8002e7e:	4323      	orrs	r3, r4
 8002e80:	b21a      	sxth	r2, r3
 8002e82:	210a      	movs	r1, #10
 8002e84:	187b      	adds	r3, r7, r1
 8002e86:	801a      	strh	r2, [r3, #0]
    ostime_t delay = r;
 8002e88:	187b      	adds	r3, r7, r1
 8002e8a:	881b      	ldrh	r3, [r3, #0]
 8002e8c:	60fb      	str	r3, [r7, #12]
    if( delay > OSTICKS_PER_SEC )
 8002e8e:	68fa      	ldr	r2, [r7, #12]
 8002e90:	23fa      	movs	r3, #250	; 0xfa
 8002e92:	01db      	lsls	r3, r3, #7
 8002e94:	429a      	cmp	r2, r3
 8002e96:	dd09      	ble.n	8002eac <rndDelay+0x4c>
        delay = r % (u2_t)OSTICKS_PER_SEC;
 8002e98:	187b      	adds	r3, r7, r1
 8002e9a:	881b      	ldrh	r3, [r3, #0]
 8002e9c:	22fa      	movs	r2, #250	; 0xfa
 8002e9e:	01d1      	lsls	r1, r2, #7
 8002ea0:	0018      	movs	r0, r3
 8002ea2:	f7fd f9b7 	bl	8000214 <__aeabi_uidivmod>
 8002ea6:	000b      	movs	r3, r1
 8002ea8:	b29b      	uxth	r3, r3
 8002eaa:	60fb      	str	r3, [r7, #12]
    if( secSpan > 0 )
 8002eac:	1dfb      	adds	r3, r7, #7
 8002eae:	781b      	ldrb	r3, [r3, #0]
 8002eb0:	2b00      	cmp	r3, #0
 8002eb2:	d016      	beq.n	8002ee2 <rndDelay+0x82>
        delay += ((u1_t)r % secSpan) * OSTICKS_PER_SEC;
 8002eb4:	230a      	movs	r3, #10
 8002eb6:	18fb      	adds	r3, r7, r3
 8002eb8:	881b      	ldrh	r3, [r3, #0]
 8002eba:	b2da      	uxtb	r2, r3
 8002ebc:	1dfb      	adds	r3, r7, #7
 8002ebe:	781b      	ldrb	r3, [r3, #0]
 8002ec0:	0019      	movs	r1, r3
 8002ec2:	0010      	movs	r0, r2
 8002ec4:	f7fd f9a6 	bl	8000214 <__aeabi_uidivmod>
 8002ec8:	000b      	movs	r3, r1
 8002eca:	b2db      	uxtb	r3, r3
 8002ecc:	001a      	movs	r2, r3
 8002ece:	0013      	movs	r3, r2
 8002ed0:	015b      	lsls	r3, r3, #5
 8002ed2:	1a9b      	subs	r3, r3, r2
 8002ed4:	009b      	lsls	r3, r3, #2
 8002ed6:	189b      	adds	r3, r3, r2
 8002ed8:	021b      	lsls	r3, r3, #8
 8002eda:	001a      	movs	r2, r3
 8002edc:	68fb      	ldr	r3, [r7, #12]
 8002ede:	189b      	adds	r3, r3, r2
 8002ee0:	60fb      	str	r3, [r7, #12]
    return delay;
 8002ee2:	68fb      	ldr	r3, [r7, #12]
}
 8002ee4:	0018      	movs	r0, r3
 8002ee6:	46bd      	mov	sp, r7
 8002ee8:	b005      	add	sp, #20
 8002eea:	bd90      	pop	{r4, r7, pc}

08002eec <txDelay>:


static void txDelay (ostime_t reftime, u1_t secSpan) {
 8002eec:	b580      	push	{r7, lr}
 8002eee:	b082      	sub	sp, #8
 8002ef0:	af00      	add	r7, sp, #0
 8002ef2:	6078      	str	r0, [r7, #4]
 8002ef4:	000a      	movs	r2, r1
 8002ef6:	1cfb      	adds	r3, r7, #3
 8002ef8:	701a      	strb	r2, [r3, #0]
    reftime += rndDelay(secSpan);
 8002efa:	1cfb      	adds	r3, r7, #3
 8002efc:	781b      	ldrb	r3, [r3, #0]
 8002efe:	0018      	movs	r0, r3
 8002f00:	f7ff ffae 	bl	8002e60 <rndDelay>
 8002f04:	0002      	movs	r2, r0
 8002f06:	687b      	ldr	r3, [r7, #4]
 8002f08:	189b      	adds	r3, r3, r2
 8002f0a:	607b      	str	r3, [r7, #4]
    if( LMIC.globalDutyRate == 0  ||  (reftime - LMIC.globalDutyAvail) > 0 ) {
 8002f0c:	4b0e      	ldr	r3, [pc, #56]	; (8002f48 <txDelay+0x5c>)
 8002f0e:	22a3      	movs	r2, #163	; 0xa3
 8002f10:	5c9b      	ldrb	r3, [r3, r2]
 8002f12:	2b00      	cmp	r3, #0
 8002f14:	d006      	beq.n	8002f24 <txDelay+0x38>
 8002f16:	4b0c      	ldr	r3, [pc, #48]	; (8002f48 <txDelay+0x5c>)
 8002f18:	22a4      	movs	r2, #164	; 0xa4
 8002f1a:	589b      	ldr	r3, [r3, r2]
 8002f1c:	687a      	ldr	r2, [r7, #4]
 8002f1e:	1ad3      	subs	r3, r2, r3
 8002f20:	2b00      	cmp	r3, #0
 8002f22:	dd0d      	ble.n	8002f40 <txDelay+0x54>
        LMIC.globalDutyAvail = reftime;
 8002f24:	4b08      	ldr	r3, [pc, #32]	; (8002f48 <txDelay+0x5c>)
 8002f26:	21a4      	movs	r1, #164	; 0xa4
 8002f28:	687a      	ldr	r2, [r7, #4]
 8002f2a:	505a      	str	r2, [r3, r1]
        LMIC.opmode |= OP_RNDTX;
 8002f2c:	4b06      	ldr	r3, [pc, #24]	; (8002f48 <txDelay+0x5c>)
 8002f2e:	22ac      	movs	r2, #172	; 0xac
 8002f30:	5a9b      	ldrh	r3, [r3, r2]
 8002f32:	2280      	movs	r2, #128	; 0x80
 8002f34:	0052      	lsls	r2, r2, #1
 8002f36:	4313      	orrs	r3, r2
 8002f38:	b299      	uxth	r1, r3
 8002f3a:	4b03      	ldr	r3, [pc, #12]	; (8002f48 <txDelay+0x5c>)
 8002f3c:	22ac      	movs	r2, #172	; 0xac
 8002f3e:	5299      	strh	r1, [r3, r2]
    }
}
 8002f40:	46c0      	nop			; (mov r8, r8)
 8002f42:	46bd      	mov	sp, r7
 8002f44:	b002      	add	sp, #8
 8002f46:	bd80      	pop	{r7, pc}
 8002f48:	20000324 	.word	0x20000324

08002f4c <setDrJoin>:


static void setDrJoin (u1_t reason, u1_t dr) {
 8002f4c:	b580      	push	{r7, lr}
 8002f4e:	b082      	sub	sp, #8
 8002f50:	af00      	add	r7, sp, #0
 8002f52:	0002      	movs	r2, r0
 8002f54:	1dfb      	adds	r3, r7, #7
 8002f56:	701a      	strb	r2, [r3, #0]
 8002f58:	1dbb      	adds	r3, r7, #6
 8002f5a:	1c0a      	adds	r2, r1, #0
 8002f5c:	701a      	strb	r2, [r3, #0]
                        e_.deveui    = MAIN::CDEV->getEui(),
                        e_.dr        = dr|DR_PAGE,
                        e_.txpow     = LMIC.adrTxPow,
                        e_.prevdr    = LMIC.datarate|DR_PAGE,
                        e_.prevtxpow = LMIC.adrTxPow));
    LMIC.datarate = dr;
 8002f5e:	4b04      	ldr	r3, [pc, #16]	; (8002f70 <setDrJoin+0x24>)
 8002f60:	1dba      	adds	r2, r7, #6
 8002f62:	21b0      	movs	r1, #176	; 0xb0
 8002f64:	7812      	ldrb	r2, [r2, #0]
 8002f66:	545a      	strb	r2, [r3, r1]
    DO_DEVDB(LMIC.datarate,datarate);
}
 8002f68:	46c0      	nop			; (mov r8, r8)
 8002f6a:	46bd      	mov	sp, r7
 8002f6c:	b002      	add	sp, #8
 8002f6e:	bd80      	pop	{r7, pc}
 8002f70:	20000324 	.word	0x20000324

08002f74 <setDrTxpow>:


static void setDrTxpow (u1_t reason, u1_t dr, s1_t pow) {
 8002f74:	b590      	push	{r4, r7, lr}
 8002f76:	b083      	sub	sp, #12
 8002f78:	af00      	add	r7, sp, #0
 8002f7a:	0004      	movs	r4, r0
 8002f7c:	0008      	movs	r0, r1
 8002f7e:	0011      	movs	r1, r2
 8002f80:	1dfb      	adds	r3, r7, #7
 8002f82:	1c22      	adds	r2, r4, #0
 8002f84:	701a      	strb	r2, [r3, #0]
 8002f86:	1dbb      	adds	r3, r7, #6
 8002f88:	1c02      	adds	r2, r0, #0
 8002f8a:	701a      	strb	r2, [r3, #0]
 8002f8c:	1d7b      	adds	r3, r7, #5
 8002f8e:	1c0a      	adds	r2, r1, #0
 8002f90:	701a      	strb	r2, [r3, #0]
                        e_.dr        = dr|DR_PAGE,
                        e_.txpow     = pow,
                        e_.prevdr    = LMIC.datarate|DR_PAGE,
                        e_.prevtxpow = LMIC.adrTxPow));
    
    if( pow != KEEP_TXPOW )
 8002f92:	1d7b      	adds	r3, r7, #5
 8002f94:	781b      	ldrb	r3, [r3, #0]
 8002f96:	b25b      	sxtb	r3, r3
 8002f98:	3380      	adds	r3, #128	; 0x80
 8002f9a:	d004      	beq.n	8002fa6 <setDrTxpow+0x32>
        LMIC.adrTxPow = pow;
 8002f9c:	4b0f      	ldr	r3, [pc, #60]	; (8002fdc <setDrTxpow+0x68>)
 8002f9e:	1d7a      	adds	r2, r7, #5
 8002fa0:	21af      	movs	r1, #175	; 0xaf
 8002fa2:	7812      	ldrb	r2, [r2, #0]
 8002fa4:	545a      	strb	r2, [r3, r1]
    if( LMIC.datarate != dr ) {
 8002fa6:	4b0d      	ldr	r3, [pc, #52]	; (8002fdc <setDrTxpow+0x68>)
 8002fa8:	22b0      	movs	r2, #176	; 0xb0
 8002faa:	5c9b      	ldrb	r3, [r3, r2]
 8002fac:	1dba      	adds	r2, r7, #6
 8002fae:	7812      	ldrb	r2, [r2, #0]
 8002fb0:	429a      	cmp	r2, r3
 8002fb2:	d00e      	beq.n	8002fd2 <setDrTxpow+0x5e>
        LMIC.datarate = dr;
 8002fb4:	4b09      	ldr	r3, [pc, #36]	; (8002fdc <setDrTxpow+0x68>)
 8002fb6:	1dba      	adds	r2, r7, #6
 8002fb8:	21b0      	movs	r1, #176	; 0xb0
 8002fba:	7812      	ldrb	r2, [r2, #0]
 8002fbc:	545a      	strb	r2, [r3, r1]
        DO_DEVDB(LMIC.datarate,datarate);
        LMIC.opmode |= OP_NEXTCHNL;
 8002fbe:	4b07      	ldr	r3, [pc, #28]	; (8002fdc <setDrTxpow+0x68>)
 8002fc0:	22ac      	movs	r2, #172	; 0xac
 8002fc2:	5a9b      	ldrh	r3, [r3, r2]
 8002fc4:	2280      	movs	r2, #128	; 0x80
 8002fc6:	0112      	lsls	r2, r2, #4
 8002fc8:	4313      	orrs	r3, r2
 8002fca:	b299      	uxth	r1, r3
 8002fcc:	4b03      	ldr	r3, [pc, #12]	; (8002fdc <setDrTxpow+0x68>)
 8002fce:	22ac      	movs	r2, #172	; 0xac
 8002fd0:	5299      	strh	r1, [r3, r2]
    }
}
 8002fd2:	46c0      	nop			; (mov r8, r8)
 8002fd4:	46bd      	mov	sp, r7
 8002fd6:	b003      	add	sp, #12
 8002fd8:	bd90      	pop	{r4, r7, pc}
 8002fda:	46c0      	nop			; (mov r8, r8)
 8002fdc:	20000324 	.word	0x20000324

08002fe0 <initDefaultChannels>:
    // Default operational frequencies
    EU868_F1|BAND_CENTI, EU868_F2|BAND_CENTI, EU868_F3|BAND_CENTI,
    EU868_F4|BAND_MILLI, EU868_F5|BAND_MILLI, EU868_F6|BAND_DECI
};

static void initDefaultChannels (bit_t join) {
 8002fe0:	b590      	push	{r4, r7, lr}
 8002fe2:	b085      	sub	sp, #20
 8002fe4:	af00      	add	r7, sp, #0
 8002fe6:	0002      	movs	r2, r0
 8002fe8:	1dfb      	adds	r3, r7, #7
 8002fea:	701a      	strb	r2, [r3, #0]
    os_clearMem(&LMIC.channelFreq, sizeof(LMIC.channelFreq));
 8002fec:	4b46      	ldr	r3, [pc, #280]	; (8003108 <initDefaultChannels+0x128>)
 8002fee:	2240      	movs	r2, #64	; 0x40
 8002ff0:	2100      	movs	r1, #0
 8002ff2:	0018      	movs	r0, r3
 8002ff4:	f00a fd1f 	bl	800da36 <memset>
    os_clearMem(&LMIC.channelDrMap, sizeof(LMIC.channelDrMap));
 8002ff8:	4b44      	ldr	r3, [pc, #272]	; (800310c <initDefaultChannels+0x12c>)
 8002ffa:	2220      	movs	r2, #32
 8002ffc:	2100      	movs	r1, #0
 8002ffe:	0018      	movs	r0, r3
 8003000:	f00a fd19 	bl	800da36 <memset>
    os_clearMem(&LMIC.bands, sizeof(LMIC.bands));
 8003004:	4b42      	ldr	r3, [pc, #264]	; (8003110 <initDefaultChannels+0x130>)
 8003006:	2220      	movs	r2, #32
 8003008:	2100      	movs	r1, #0
 800300a:	0018      	movs	r0, r3
 800300c:	f00a fd13 	bl	800da36 <memset>

    LMIC.channelMap = (1 << NUM_DEFAULT_CHANNELS) - 1;
 8003010:	4b40      	ldr	r3, [pc, #256]	; (8003114 <initDefaultChannels+0x134>)
 8003012:	22a0      	movs	r2, #160	; 0xa0
 8003014:	213f      	movs	r1, #63	; 0x3f
 8003016:	5299      	strh	r1, [r3, r2]
    u1_t su = join ? 0 : NUM_DEFAULT_CHANNELS;
 8003018:	1dfb      	adds	r3, r7, #7
 800301a:	781b      	ldrb	r3, [r3, #0]
 800301c:	2b00      	cmp	r3, #0
 800301e:	d001      	beq.n	8003024 <initDefaultChannels+0x44>
 8003020:	2200      	movs	r2, #0
 8003022:	e000      	b.n	8003026 <initDefaultChannels+0x46>
 8003024:	2206      	movs	r2, #6
 8003026:	230f      	movs	r3, #15
 8003028:	18fb      	adds	r3, r7, r3
 800302a:	701a      	strb	r2, [r3, #0]
    for( u1_t fu=0; fu<NUM_DEFAULT_CHANNELS; fu++,su++ ) {
 800302c:	230e      	movs	r3, #14
 800302e:	18fb      	adds	r3, r7, r3
 8003030:	2200      	movs	r2, #0
 8003032:	701a      	strb	r2, [r3, #0]
 8003034:	e01d      	b.n	8003072 <initDefaultChannels+0x92>
        LMIC.channelFreq[fu]  = iniChannelFreq[su];
 8003036:	240f      	movs	r4, #15
 8003038:	193b      	adds	r3, r7, r4
 800303a:	7819      	ldrb	r1, [r3, #0]
 800303c:	200e      	movs	r0, #14
 800303e:	183b      	adds	r3, r7, r0
 8003040:	781a      	ldrb	r2, [r3, #0]
 8003042:	4b35      	ldr	r3, [pc, #212]	; (8003118 <initDefaultChannels+0x138>)
 8003044:	0089      	lsls	r1, r1, #2
 8003046:	58c9      	ldr	r1, [r1, r3]
 8003048:	4b32      	ldr	r3, [pc, #200]	; (8003114 <initDefaultChannels+0x134>)
 800304a:	3210      	adds	r2, #16
 800304c:	0092      	lsls	r2, r2, #2
 800304e:	50d1      	str	r1, [r2, r3]
        LMIC.channelDrMap[fu] = DR_RANGE_MAP(DR_SF12,DR_SF7);
 8003050:	183b      	adds	r3, r7, r0
 8003052:	781a      	ldrb	r2, [r3, #0]
 8003054:	4b2f      	ldr	r3, [pc, #188]	; (8003114 <initDefaultChannels+0x134>)
 8003056:	3240      	adds	r2, #64	; 0x40
 8003058:	0052      	lsls	r2, r2, #1
 800305a:	213f      	movs	r1, #63	; 0x3f
 800305c:	52d1      	strh	r1, [r2, r3]
    for( u1_t fu=0; fu<NUM_DEFAULT_CHANNELS; fu++,su++ ) {
 800305e:	183b      	adds	r3, r7, r0
 8003060:	781a      	ldrb	r2, [r3, #0]
 8003062:	183b      	adds	r3, r7, r0
 8003064:	3201      	adds	r2, #1
 8003066:	701a      	strb	r2, [r3, #0]
 8003068:	193b      	adds	r3, r7, r4
 800306a:	781a      	ldrb	r2, [r3, #0]
 800306c:	193b      	adds	r3, r7, r4
 800306e:	3201      	adds	r2, #1
 8003070:	701a      	strb	r2, [r3, #0]
 8003072:	230e      	movs	r3, #14
 8003074:	18fb      	adds	r3, r7, r3
 8003076:	781b      	ldrb	r3, [r3, #0]
 8003078:	2b05      	cmp	r3, #5
 800307a:	d9dc      	bls.n	8003036 <initDefaultChannels+0x56>
//    if( !join ) {
//        LMIC.channelDrMap[5] = DR_RANGE_MAP(DR_SF12,DR_SF7);
//        LMIC.channelDrMap[1] = DR_RANGE_MAP(DR_SF12,DR_FSK);
//    }

    LMIC.bands[BAND_MILLI].txcap    = 1000;  // 0.1%
 800307c:	4b25      	ldr	r3, [pc, #148]	; (8003114 <initDefaultChannels+0x134>)
 800307e:	22fa      	movs	r2, #250	; 0xfa
 8003080:	0092      	lsls	r2, r2, #2
 8003082:	841a      	strh	r2, [r3, #32]
    LMIC.bands[BAND_MILLI].txpow    = 14;
 8003084:	4b23      	ldr	r3, [pc, #140]	; (8003114 <initDefaultChannels+0x134>)
 8003086:	2222      	movs	r2, #34	; 0x22
 8003088:	210e      	movs	r1, #14
 800308a:	5499      	strb	r1, [r3, r2]
    LMIC.bands[BAND_MILLI].lastchnl = os_getRndU1() % MAX_CHANNELS;
 800308c:	f003 feba 	bl	8006e04 <radio_rand1>
 8003090:	0003      	movs	r3, r0
 8003092:	001a      	movs	r2, r3
 8003094:	230f      	movs	r3, #15
 8003096:	4013      	ands	r3, r2
 8003098:	b2d9      	uxtb	r1, r3
 800309a:	4b1e      	ldr	r3, [pc, #120]	; (8003114 <initDefaultChannels+0x134>)
 800309c:	2223      	movs	r2, #35	; 0x23
 800309e:	5499      	strb	r1, [r3, r2]
    LMIC.bands[BAND_CENTI].txcap    = 100;   // 1%
 80030a0:	4b1c      	ldr	r3, [pc, #112]	; (8003114 <initDefaultChannels+0x134>)
 80030a2:	2264      	movs	r2, #100	; 0x64
 80030a4:	851a      	strh	r2, [r3, #40]	; 0x28
    LMIC.bands[BAND_CENTI].txpow    = 14;
 80030a6:	4b1b      	ldr	r3, [pc, #108]	; (8003114 <initDefaultChannels+0x134>)
 80030a8:	222a      	movs	r2, #42	; 0x2a
 80030aa:	210e      	movs	r1, #14
 80030ac:	5499      	strb	r1, [r3, r2]
    LMIC.bands[BAND_CENTI].lastchnl = os_getRndU1() % MAX_CHANNELS;
 80030ae:	f003 fea9 	bl	8006e04 <radio_rand1>
 80030b2:	0003      	movs	r3, r0
 80030b4:	001a      	movs	r2, r3
 80030b6:	230f      	movs	r3, #15
 80030b8:	4013      	ands	r3, r2
 80030ba:	b2d9      	uxtb	r1, r3
 80030bc:	4b15      	ldr	r3, [pc, #84]	; (8003114 <initDefaultChannels+0x134>)
 80030be:	222b      	movs	r2, #43	; 0x2b
 80030c0:	5499      	strb	r1, [r3, r2]
    LMIC.bands[BAND_DECI ].txcap    = 10;    // 10%
 80030c2:	4b14      	ldr	r3, [pc, #80]	; (8003114 <initDefaultChannels+0x134>)
 80030c4:	220a      	movs	r2, #10
 80030c6:	861a      	strh	r2, [r3, #48]	; 0x30
    LMIC.bands[BAND_DECI ].txpow    = 27;
 80030c8:	4b12      	ldr	r3, [pc, #72]	; (8003114 <initDefaultChannels+0x134>)
 80030ca:	2232      	movs	r2, #50	; 0x32
 80030cc:	211b      	movs	r1, #27
 80030ce:	5499      	strb	r1, [r3, r2]
    LMIC.bands[BAND_DECI ].lastchnl = os_getRndU1() % MAX_CHANNELS;
 80030d0:	f003 fe98 	bl	8006e04 <radio_rand1>
 80030d4:	0003      	movs	r3, r0
 80030d6:	001a      	movs	r2, r3
 80030d8:	230f      	movs	r3, #15
 80030da:	4013      	ands	r3, r2
 80030dc:	b2d9      	uxtb	r1, r3
 80030de:	4b0d      	ldr	r3, [pc, #52]	; (8003114 <initDefaultChannels+0x134>)
 80030e0:	2233      	movs	r2, #51	; 0x33
 80030e2:	5499      	strb	r1, [r3, r2]
    LMIC.bands[BAND_MILLI].avail = 
    LMIC.bands[BAND_CENTI].avail =
    LMIC.bands[BAND_DECI ].avail = os_getTime();
 80030e4:	f003 f8f4 	bl	80062d0 <os_getTime>
 80030e8:	0002      	movs	r2, r0
 80030ea:	4b0a      	ldr	r3, [pc, #40]	; (8003114 <initDefaultChannels+0x134>)
 80030ec:	635a      	str	r2, [r3, #52]	; 0x34
 80030ee:	4b09      	ldr	r3, [pc, #36]	; (8003114 <initDefaultChannels+0x134>)
 80030f0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    LMIC.bands[BAND_CENTI].avail =
 80030f2:	4b08      	ldr	r3, [pc, #32]	; (8003114 <initDefaultChannels+0x134>)
 80030f4:	62da      	str	r2, [r3, #44]	; 0x2c
 80030f6:	4b07      	ldr	r3, [pc, #28]	; (8003114 <initDefaultChannels+0x134>)
 80030f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    LMIC.bands[BAND_MILLI].avail = 
 80030fa:	4b06      	ldr	r3, [pc, #24]	; (8003114 <initDefaultChannels+0x134>)
 80030fc:	625a      	str	r2, [r3, #36]	; 0x24
}
 80030fe:	46c0      	nop			; (mov r8, r8)
 8003100:	46bd      	mov	sp, r7
 8003102:	b005      	add	sp, #20
 8003104:	bd90      	pop	{r4, r7, pc}
 8003106:	46c0      	nop			; (mov r8, r8)
 8003108:	20000364 	.word	0x20000364
 800310c:	200003a4 	.word	0x200003a4
 8003110:	20000344 	.word	0x20000344
 8003114:	20000324 	.word	0x20000324
 8003118:	0800f144 	.word	0x0800f144

0800311c <LMIC_setupChannel>:
    b->avail = os_getTime();
    b->lastchnl = os_getRndU1() % MAX_CHANNELS;
    return 1;
}

bit_t LMIC_setupChannel (u1_t chidx, u4_t freq, u2_t drmap, s1_t band) {
 800311c:	b590      	push	{r4, r7, lr}
 800311e:	b083      	sub	sp, #12
 8003120:	af00      	add	r7, sp, #0
 8003122:	0004      	movs	r4, r0
 8003124:	6039      	str	r1, [r7, #0]
 8003126:	0010      	movs	r0, r2
 8003128:	0019      	movs	r1, r3
 800312a:	1dfb      	adds	r3, r7, #7
 800312c:	1c22      	adds	r2, r4, #0
 800312e:	701a      	strb	r2, [r3, #0]
 8003130:	1d3b      	adds	r3, r7, #4
 8003132:	1c02      	adds	r2, r0, #0
 8003134:	801a      	strh	r2, [r3, #0]
 8003136:	1dbb      	adds	r3, r7, #6
 8003138:	1c0a      	adds	r2, r1, #0
 800313a:	701a      	strb	r2, [r3, #0]
    if( chidx >= MAX_CHANNELS )
 800313c:	1dfb      	adds	r3, r7, #7
 800313e:	781b      	ldrb	r3, [r3, #0]
 8003140:	2b0f      	cmp	r3, #15
 8003142:	d901      	bls.n	8003148 <LMIC_setupChannel+0x2c>
        return 0;
 8003144:	2300      	movs	r3, #0
 8003146:	e05c      	b.n	8003202 <LMIC_setupChannel+0xe6>
    if( band == -1 ) {
 8003148:	1dbb      	adds	r3, r7, #6
 800314a:	781b      	ldrb	r3, [r3, #0]
 800314c:	b25b      	sxtb	r3, r3
 800314e:	3301      	adds	r3, #1
 8003150:	d121      	bne.n	8003196 <LMIC_setupChannel+0x7a>
        if( freq >= 869400000 && freq <= 869650000 )
 8003152:	683b      	ldr	r3, [r7, #0]
 8003154:	4a2d      	ldr	r2, [pc, #180]	; (800320c <LMIC_setupChannel+0xf0>)
 8003156:	4293      	cmp	r3, r2
 8003158:	d908      	bls.n	800316c <LMIC_setupChannel+0x50>
 800315a:	683b      	ldr	r3, [r7, #0]
 800315c:	4a2c      	ldr	r2, [pc, #176]	; (8003210 <LMIC_setupChannel+0xf4>)
 800315e:	4293      	cmp	r3, r2
 8003160:	d804      	bhi.n	800316c <LMIC_setupChannel+0x50>
            freq |= BAND_DECI;   // 10% 27dBm
 8003162:	683b      	ldr	r3, [r7, #0]
 8003164:	2202      	movs	r2, #2
 8003166:	4313      	orrs	r3, r2
 8003168:	603b      	str	r3, [r7, #0]
 800316a:	e024      	b.n	80031b6 <LMIC_setupChannel+0x9a>
        else if( (freq >= 868000000 && freq <= 868600000) ||
 800316c:	683b      	ldr	r3, [r7, #0]
 800316e:	4a29      	ldr	r2, [pc, #164]	; (8003214 <LMIC_setupChannel+0xf8>)
 8003170:	4293      	cmp	r3, r2
 8003172:	d903      	bls.n	800317c <LMIC_setupChannel+0x60>
 8003174:	683b      	ldr	r3, [r7, #0]
 8003176:	4a28      	ldr	r2, [pc, #160]	; (8003218 <LMIC_setupChannel+0xfc>)
 8003178:	4293      	cmp	r3, r2
 800317a:	d907      	bls.n	800318c <LMIC_setupChannel+0x70>
 800317c:	683b      	ldr	r3, [r7, #0]
 800317e:	4a27      	ldr	r2, [pc, #156]	; (800321c <LMIC_setupChannel+0x100>)
 8003180:	4293      	cmp	r3, r2
 8003182:	d918      	bls.n	80031b6 <LMIC_setupChannel+0x9a>
                 (freq >= 869700000 && freq <= 870000000)  )
 8003184:	683b      	ldr	r3, [r7, #0]
 8003186:	4a26      	ldr	r2, [pc, #152]	; (8003220 <LMIC_setupChannel+0x104>)
 8003188:	4293      	cmp	r3, r2
 800318a:	d814      	bhi.n	80031b6 <LMIC_setupChannel+0x9a>
            freq |= BAND_CENTI;  // 1% 14dBm 
 800318c:	683b      	ldr	r3, [r7, #0]
 800318e:	2201      	movs	r2, #1
 8003190:	4313      	orrs	r3, r2
 8003192:	603b      	str	r3, [r7, #0]
 8003194:	e00f      	b.n	80031b6 <LMIC_setupChannel+0x9a>
        else 
            freq |= BAND_MILLI;  // 0.1% 14dBm
    } else {
        if( band > BAND_AUX ) return 0;
 8003196:	1dbb      	adds	r3, r7, #6
 8003198:	781b      	ldrb	r3, [r3, #0]
 800319a:	b25b      	sxtb	r3, r3
 800319c:	2b03      	cmp	r3, #3
 800319e:	dd01      	ble.n	80031a4 <LMIC_setupChannel+0x88>
 80031a0:	2300      	movs	r3, #0
 80031a2:	e02e      	b.n	8003202 <LMIC_setupChannel+0xe6>
        freq = (freq&~3) | band;
 80031a4:	683b      	ldr	r3, [r7, #0]
 80031a6:	2203      	movs	r2, #3
 80031a8:	4393      	bics	r3, r2
 80031aa:	001a      	movs	r2, r3
 80031ac:	1dbb      	adds	r3, r7, #6
 80031ae:	781b      	ldrb	r3, [r3, #0]
 80031b0:	b25b      	sxtb	r3, r3
 80031b2:	4313      	orrs	r3, r2
 80031b4:	603b      	str	r3, [r7, #0]
    }
    LMIC.channelFreq [chidx] = freq;
 80031b6:	1dfb      	adds	r3, r7, #7
 80031b8:	781a      	ldrb	r2, [r3, #0]
 80031ba:	4b1a      	ldr	r3, [pc, #104]	; (8003224 <LMIC_setupChannel+0x108>)
 80031bc:	3210      	adds	r2, #16
 80031be:	0092      	lsls	r2, r2, #2
 80031c0:	6839      	ldr	r1, [r7, #0]
 80031c2:	50d1      	str	r1, [r2, r3]
    LMIC.channelDrMap[chidx] = drmap==0 ? DR_RANGE_MAP(DR_SF12,DR_SF7) : drmap;
 80031c4:	1d3b      	adds	r3, r7, #4
 80031c6:	881b      	ldrh	r3, [r3, #0]
 80031c8:	2b00      	cmp	r3, #0
 80031ca:	d002      	beq.n	80031d2 <LMIC_setupChannel+0xb6>
 80031cc:	1d3b      	adds	r3, r7, #4
 80031ce:	8819      	ldrh	r1, [r3, #0]
 80031d0:	e000      	b.n	80031d4 <LMIC_setupChannel+0xb8>
 80031d2:	213f      	movs	r1, #63	; 0x3f
 80031d4:	1dfb      	adds	r3, r7, #7
 80031d6:	781a      	ldrb	r2, [r3, #0]
 80031d8:	4b12      	ldr	r3, [pc, #72]	; (8003224 <LMIC_setupChannel+0x108>)
 80031da:	3240      	adds	r2, #64	; 0x40
 80031dc:	0052      	lsls	r2, r2, #1
 80031de:	52d1      	strh	r1, [r2, r3]
    LMIC.channelMap |= 1<<chidx;  // enabled right away
 80031e0:	4b10      	ldr	r3, [pc, #64]	; (8003224 <LMIC_setupChannel+0x108>)
 80031e2:	22a0      	movs	r2, #160	; 0xa0
 80031e4:	5a9b      	ldrh	r3, [r3, r2]
 80031e6:	b21a      	sxth	r2, r3
 80031e8:	1dfb      	adds	r3, r7, #7
 80031ea:	781b      	ldrb	r3, [r3, #0]
 80031ec:	2101      	movs	r1, #1
 80031ee:	4099      	lsls	r1, r3
 80031f0:	000b      	movs	r3, r1
 80031f2:	b21b      	sxth	r3, r3
 80031f4:	4313      	orrs	r3, r2
 80031f6:	b21b      	sxth	r3, r3
 80031f8:	b299      	uxth	r1, r3
 80031fa:	4b0a      	ldr	r3, [pc, #40]	; (8003224 <LMIC_setupChannel+0x108>)
 80031fc:	22a0      	movs	r2, #160	; 0xa0
 80031fe:	5299      	strh	r1, [r3, r2]
    return 1;
 8003200:	2301      	movs	r3, #1
}
 8003202:	0018      	movs	r0, r3
 8003204:	46bd      	mov	sp, r7
 8003206:	b003      	add	sp, #12
 8003208:	bd90      	pop	{r4, r7, pc}
 800320a:	46c0      	nop			; (mov r8, r8)
 800320c:	33d1fdbf 	.word	0x33d1fdbf
 8003210:	33d5ce50 	.word	0x33d5ce50
 8003214:	33bca0ff 	.word	0x33bca0ff
 8003218:	33c5c8c0 	.word	0x33c5c8c0
 800321c:	33d6919f 	.word	0x33d6919f
 8003220:	33db2580 	.word	0x33db2580
 8003224:	20000324 	.word	0x20000324

08003228 <convFreq>:
    LMIC.channelFreq[channel] = 0;
    LMIC.channelDrMap[channel] = 0;
    LMIC.channelMap &= ~(1<<channel);
}

static u4_t convFreq (xref2u1_t ptr) {
 8003228:	b580      	push	{r7, lr}
 800322a:	b084      	sub	sp, #16
 800322c:	af00      	add	r7, sp, #0
 800322e:	6078      	str	r0, [r7, #4]
    u4_t freq = (os_rlsbf4(ptr-1) >> 8) * 100;
 8003230:	687b      	ldr	r3, [r7, #4]
 8003232:	3b01      	subs	r3, #1
 8003234:	0018      	movs	r0, r3
 8003236:	f7ff f939 	bl	80024ac <os_rlsbf4>
 800323a:	0003      	movs	r3, r0
 800323c:	0a1b      	lsrs	r3, r3, #8
 800323e:	2264      	movs	r2, #100	; 0x64
 8003240:	4353      	muls	r3, r2
 8003242:	60fb      	str	r3, [r7, #12]
    if( freq < EU868_FREQ_MIN || freq > EU868_FREQ_MAX )
 8003244:	68fb      	ldr	r3, [r7, #12]
 8003246:	4a07      	ldr	r2, [pc, #28]	; (8003264 <convFreq+0x3c>)
 8003248:	4293      	cmp	r3, r2
 800324a:	d903      	bls.n	8003254 <convFreq+0x2c>
 800324c:	68fb      	ldr	r3, [r7, #12]
 800324e:	4a06      	ldr	r2, [pc, #24]	; (8003268 <convFreq+0x40>)
 8003250:	4293      	cmp	r3, r2
 8003252:	d901      	bls.n	8003258 <convFreq+0x30>
        freq = 0;
 8003254:	2300      	movs	r3, #0
 8003256:	60fb      	str	r3, [r7, #12]
    return freq;
 8003258:	68fb      	ldr	r3, [r7, #12]
}
 800325a:	0018      	movs	r0, r3
 800325c:	46bd      	mov	sp, r7
 800325e:	b004      	add	sp, #16
 8003260:	bd80      	pop	{r7, pc}
 8003262:	46c0      	nop			; (mov r8, r8)
 8003264:	337055bf 	.word	0x337055bf
 8003268:	33db2580 	.word	0x33db2580

0800326c <mapChannels>:

static u1_t mapChannels (u1_t chpage, u2_t chmap) {
 800326c:	b580      	push	{r7, lr}
 800326e:	b084      	sub	sp, #16
 8003270:	af00      	add	r7, sp, #0
 8003272:	0002      	movs	r2, r0
 8003274:	1dfb      	adds	r3, r7, #7
 8003276:	701a      	strb	r2, [r3, #0]
 8003278:	1d3b      	adds	r3, r7, #4
 800327a:	1c0a      	adds	r2, r1, #0
 800327c:	801a      	strh	r2, [r3, #0]
    // Bad page, disable all channel, enable non-existent
    if( chpage != 0 || chmap==0 || (chmap & ~LMIC.channelMap) != 0 )
 800327e:	1dfb      	adds	r3, r7, #7
 8003280:	781b      	ldrb	r3, [r3, #0]
 8003282:	2b00      	cmp	r3, #0
 8003284:	d10b      	bne.n	800329e <mapChannels+0x32>
 8003286:	1d3b      	adds	r3, r7, #4
 8003288:	881b      	ldrh	r3, [r3, #0]
 800328a:	2b00      	cmp	r3, #0
 800328c:	d007      	beq.n	800329e <mapChannels+0x32>
 800328e:	1d3b      	adds	r3, r7, #4
 8003290:	881b      	ldrh	r3, [r3, #0]
 8003292:	4a21      	ldr	r2, [pc, #132]	; (8003318 <mapChannels+0xac>)
 8003294:	21a0      	movs	r1, #160	; 0xa0
 8003296:	5a52      	ldrh	r2, [r2, r1]
 8003298:	43d2      	mvns	r2, r2
 800329a:	4013      	ands	r3, r2
 800329c:	d001      	beq.n	80032a2 <mapChannels+0x36>
        return 0;  // illegal input
 800329e:	2300      	movs	r3, #0
 80032a0:	e036      	b.n	8003310 <mapChannels+0xa4>
    for( u1_t chnl=0; chnl<MAX_CHANNELS; chnl++ ) {
 80032a2:	230f      	movs	r3, #15
 80032a4:	18fb      	adds	r3, r7, r3
 80032a6:	2200      	movs	r2, #0
 80032a8:	701a      	strb	r2, [r3, #0]
 80032aa:	e026      	b.n	80032fa <mapChannels+0x8e>
        if( (chmap & (1<<chnl)) != 0 && LMIC.channelFreq[chnl] == 0 )
 80032ac:	1d3b      	adds	r3, r7, #4
 80032ae:	881a      	ldrh	r2, [r3, #0]
 80032b0:	210f      	movs	r1, #15
 80032b2:	187b      	adds	r3, r7, r1
 80032b4:	781b      	ldrb	r3, [r3, #0]
 80032b6:	411a      	asrs	r2, r3
 80032b8:	0013      	movs	r3, r2
 80032ba:	2201      	movs	r2, #1
 80032bc:	4013      	ands	r3, r2
 80032be:	d016      	beq.n	80032ee <mapChannels+0x82>
 80032c0:	187b      	adds	r3, r7, r1
 80032c2:	781a      	ldrb	r2, [r3, #0]
 80032c4:	4b14      	ldr	r3, [pc, #80]	; (8003318 <mapChannels+0xac>)
 80032c6:	3210      	adds	r2, #16
 80032c8:	0092      	lsls	r2, r2, #2
 80032ca:	58d3      	ldr	r3, [r2, r3]
 80032cc:	2b00      	cmp	r3, #0
 80032ce:	d10e      	bne.n	80032ee <mapChannels+0x82>
            chmap &= ~(1<<chnl); // ignore - channel is not defined
 80032d0:	187b      	adds	r3, r7, r1
 80032d2:	781b      	ldrb	r3, [r3, #0]
 80032d4:	2201      	movs	r2, #1
 80032d6:	409a      	lsls	r2, r3
 80032d8:	0013      	movs	r3, r2
 80032da:	b21b      	sxth	r3, r3
 80032dc:	43db      	mvns	r3, r3
 80032de:	b21b      	sxth	r3, r3
 80032e0:	1d3a      	adds	r2, r7, #4
 80032e2:	2100      	movs	r1, #0
 80032e4:	5e52      	ldrsh	r2, [r2, r1]
 80032e6:	4013      	ands	r3, r2
 80032e8:	b21a      	sxth	r2, r3
 80032ea:	1d3b      	adds	r3, r7, #4
 80032ec:	801a      	strh	r2, [r3, #0]
    for( u1_t chnl=0; chnl<MAX_CHANNELS; chnl++ ) {
 80032ee:	210f      	movs	r1, #15
 80032f0:	187b      	adds	r3, r7, r1
 80032f2:	781a      	ldrb	r2, [r3, #0]
 80032f4:	187b      	adds	r3, r7, r1
 80032f6:	3201      	adds	r2, #1
 80032f8:	701a      	strb	r2, [r3, #0]
 80032fa:	230f      	movs	r3, #15
 80032fc:	18fb      	adds	r3, r7, r3
 80032fe:	781b      	ldrb	r3, [r3, #0]
 8003300:	2b0f      	cmp	r3, #15
 8003302:	d9d3      	bls.n	80032ac <mapChannels+0x40>
    }
    LMIC.channelMap = chmap;
 8003304:	4b04      	ldr	r3, [pc, #16]	; (8003318 <mapChannels+0xac>)
 8003306:	1d3a      	adds	r2, r7, #4
 8003308:	21a0      	movs	r1, #160	; 0xa0
 800330a:	8812      	ldrh	r2, [r2, #0]
 800330c:	525a      	strh	r2, [r3, r1]
    return 1;
 800330e:	2301      	movs	r3, #1
}
 8003310:	0018      	movs	r0, r3
 8003312:	46bd      	mov	sp, r7
 8003314:	b004      	add	sp, #16
 8003316:	bd80      	pop	{r7, pc}
 8003318:	20000324 	.word	0x20000324

0800331c <updateTx>:


static void updateTx (ostime_t txbeg) {
 800331c:	b580      	push	{r7, lr}
 800331e:	b086      	sub	sp, #24
 8003320:	af00      	add	r7, sp, #0
 8003322:	6078      	str	r0, [r7, #4]
    u4_t freq = LMIC.channelFreq[LMIC.txChnl];
 8003324:	4b22      	ldr	r3, [pc, #136]	; (80033b0 <updateTx+0x94>)
 8003326:	22a2      	movs	r2, #162	; 0xa2
 8003328:	5c9b      	ldrb	r3, [r3, r2]
 800332a:	001a      	movs	r2, r3
 800332c:	4b20      	ldr	r3, [pc, #128]	; (80033b0 <updateTx+0x94>)
 800332e:	3210      	adds	r2, #16
 8003330:	0092      	lsls	r2, r2, #2
 8003332:	58d3      	ldr	r3, [r2, r3]
 8003334:	617b      	str	r3, [r7, #20]
    // Update global/band specific duty cycle stats
    ostime_t airtime = calcAirTime(LMIC.rps, LMIC.dataLen);
 8003336:	4b1e      	ldr	r3, [pc, #120]	; (80033b0 <updateTx+0x94>)
 8003338:	89d8      	ldrh	r0, [r3, #14]
 800333a:	4a1d      	ldr	r2, [pc, #116]	; (80033b0 <updateTx+0x94>)
 800333c:	2348      	movs	r3, #72	; 0x48
 800333e:	33ff      	adds	r3, #255	; 0xff
 8003340:	5cd3      	ldrb	r3, [r2, r3]
 8003342:	0019      	movs	r1, r3
 8003344:	f7ff fb28 	bl	8002998 <calcAirTime>
 8003348:	0003      	movs	r3, r0
 800334a:	613b      	str	r3, [r7, #16]
    // Update channel/global duty cycle stats
    xref2band_t band = &LMIC.bands[freq & 0x3];
 800334c:	697b      	ldr	r3, [r7, #20]
 800334e:	2203      	movs	r2, #3
 8003350:	4013      	ands	r3, r2
 8003352:	3304      	adds	r3, #4
 8003354:	00da      	lsls	r2, r3, #3
 8003356:	4b16      	ldr	r3, [pc, #88]	; (80033b0 <updateTx+0x94>)
 8003358:	18d3      	adds	r3, r2, r3
 800335a:	60fb      	str	r3, [r7, #12]
    LMIC.freq  = freq & ~(u4_t)3;
 800335c:	697b      	ldr	r3, [r7, #20]
 800335e:	2203      	movs	r2, #3
 8003360:	4393      	bics	r3, r2
 8003362:	001a      	movs	r2, r3
 8003364:	4b12      	ldr	r3, [pc, #72]	; (80033b0 <updateTx+0x94>)
 8003366:	609a      	str	r2, [r3, #8]
    LMIC.txpow = band->txpow;
 8003368:	68fb      	ldr	r3, [r7, #12]
 800336a:	2202      	movs	r2, #2
 800336c:	569a      	ldrsb	r2, [r3, r2]
 800336e:	4b10      	ldr	r3, [pc, #64]	; (80033b0 <updateTx+0x94>)
 8003370:	749a      	strb	r2, [r3, #18]
    band->avail = txbeg + airtime * band->txcap;
 8003372:	68fb      	ldr	r3, [r7, #12]
 8003374:	881b      	ldrh	r3, [r3, #0]
 8003376:	001a      	movs	r2, r3
 8003378:	693b      	ldr	r3, [r7, #16]
 800337a:	435a      	muls	r2, r3
 800337c:	687b      	ldr	r3, [r7, #4]
 800337e:	18d2      	adds	r2, r2, r3
 8003380:	68fb      	ldr	r3, [r7, #12]
 8003382:	605a      	str	r2, [r3, #4]
    if( LMIC.globalDutyRate != 0 )
 8003384:	4b0a      	ldr	r3, [pc, #40]	; (80033b0 <updateTx+0x94>)
 8003386:	22a3      	movs	r2, #163	; 0xa3
 8003388:	5c9b      	ldrb	r3, [r3, r2]
 800338a:	2b00      	cmp	r3, #0
 800338c:	d00b      	beq.n	80033a6 <updateTx+0x8a>
        LMIC.globalDutyAvail = txbeg + (airtime<<LMIC.globalDutyRate);
 800338e:	4b08      	ldr	r3, [pc, #32]	; (80033b0 <updateTx+0x94>)
 8003390:	22a3      	movs	r2, #163	; 0xa3
 8003392:	5c9b      	ldrb	r3, [r3, r2]
 8003394:	001a      	movs	r2, r3
 8003396:	693b      	ldr	r3, [r7, #16]
 8003398:	4093      	lsls	r3, r2
 800339a:	001a      	movs	r2, r3
 800339c:	687b      	ldr	r3, [r7, #4]
 800339e:	18d2      	adds	r2, r2, r3
 80033a0:	4b03      	ldr	r3, [pc, #12]	; (80033b0 <updateTx+0x94>)
 80033a2:	21a4      	movs	r1, #164	; 0xa4
 80033a4:	505a      	str	r2, [r3, r1]
}
 80033a6:	46c0      	nop			; (mov r8, r8)
 80033a8:	46bd      	mov	sp, r7
 80033aa:	b006      	add	sp, #24
 80033ac:	bd80      	pop	{r7, pc}
 80033ae:	46c0      	nop			; (mov r8, r8)
 80033b0:	20000324 	.word	0x20000324

080033b4 <nextTx>:

static ostime_t nextTx (ostime_t now) {
 80033b4:	b590      	push	{r4, r7, lr}
 80033b6:	b087      	sub	sp, #28
 80033b8:	af00      	add	r7, sp, #0
 80033ba:	6078      	str	r0, [r7, #4]
    u1_t bmap=0xF;
 80033bc:	2317      	movs	r3, #23
 80033be:	18fb      	adds	r3, r7, r3
 80033c0:	220f      	movs	r2, #15
 80033c2:	701a      	strb	r2, [r3, #0]
    do {
        ostime_t mintime = now + /*10h*/36000*OSTICKS_PER_SEC;
 80033c4:	687b      	ldr	r3, [r7, #4]
 80033c6:	4a61      	ldr	r2, [pc, #388]	; (800354c <nextTx+0x198>)
 80033c8:	4694      	mov	ip, r2
 80033ca:	4463      	add	r3, ip
 80033cc:	613b      	str	r3, [r7, #16]
        u1_t band=0;
 80033ce:	230f      	movs	r3, #15
 80033d0:	18fb      	adds	r3, r7, r3
 80033d2:	2200      	movs	r2, #0
 80033d4:	701a      	strb	r2, [r3, #0]
        for( u1_t bi=0; bi<4; bi++ ) {
 80033d6:	230e      	movs	r3, #14
 80033d8:	18fb      	adds	r3, r7, r3
 80033da:	2200      	movs	r2, #0
 80033dc:	701a      	strb	r2, [r3, #0]
 80033de:	e02a      	b.n	8003436 <nextTx+0x82>
            if( (bmap & (1<<bi)) && mintime - LMIC.bands[bi].avail > 0 )
 80033e0:	2317      	movs	r3, #23
 80033e2:	18fb      	adds	r3, r7, r3
 80033e4:	781a      	ldrb	r2, [r3, #0]
 80033e6:	210e      	movs	r1, #14
 80033e8:	187b      	adds	r3, r7, r1
 80033ea:	781b      	ldrb	r3, [r3, #0]
 80033ec:	411a      	asrs	r2, r3
 80033ee:	0013      	movs	r3, r2
 80033f0:	2201      	movs	r2, #1
 80033f2:	4013      	ands	r3, r2
 80033f4:	d019      	beq.n	800342a <nextTx+0x76>
 80033f6:	187b      	adds	r3, r7, r1
 80033f8:	781b      	ldrb	r3, [r3, #0]
 80033fa:	4a55      	ldr	r2, [pc, #340]	; (8003550 <nextTx+0x19c>)
 80033fc:	3304      	adds	r3, #4
 80033fe:	00db      	lsls	r3, r3, #3
 8003400:	18d3      	adds	r3, r2, r3
 8003402:	3304      	adds	r3, #4
 8003404:	681b      	ldr	r3, [r3, #0]
 8003406:	693a      	ldr	r2, [r7, #16]
 8003408:	1ad3      	subs	r3, r2, r3
 800340a:	2b00      	cmp	r3, #0
 800340c:	dd0d      	ble.n	800342a <nextTx+0x76>
                mintime = LMIC.bands[band = bi].avail;
 800340e:	200f      	movs	r0, #15
 8003410:	183b      	adds	r3, r7, r0
 8003412:	187a      	adds	r2, r7, r1
 8003414:	7812      	ldrb	r2, [r2, #0]
 8003416:	701a      	strb	r2, [r3, #0]
 8003418:	183b      	adds	r3, r7, r0
 800341a:	781b      	ldrb	r3, [r3, #0]
 800341c:	4a4c      	ldr	r2, [pc, #304]	; (8003550 <nextTx+0x19c>)
 800341e:	3304      	adds	r3, #4
 8003420:	00db      	lsls	r3, r3, #3
 8003422:	18d3      	adds	r3, r2, r3
 8003424:	3304      	adds	r3, #4
 8003426:	681b      	ldr	r3, [r3, #0]
 8003428:	613b      	str	r3, [r7, #16]
        for( u1_t bi=0; bi<4; bi++ ) {
 800342a:	210e      	movs	r1, #14
 800342c:	187b      	adds	r3, r7, r1
 800342e:	781a      	ldrb	r2, [r3, #0]
 8003430:	187b      	adds	r3, r7, r1
 8003432:	3201      	adds	r2, #1
 8003434:	701a      	strb	r2, [r3, #0]
 8003436:	230e      	movs	r3, #14
 8003438:	18fb      	adds	r3, r7, r3
 800343a:	781b      	ldrb	r3, [r3, #0]
 800343c:	2b03      	cmp	r3, #3
 800343e:	d9cf      	bls.n	80033e0 <nextTx+0x2c>
        }
        // Find next channel in given band
        u1_t chnl = LMIC.bands[band].lastchnl;
 8003440:	230f      	movs	r3, #15
 8003442:	18fb      	adds	r3, r7, r3
 8003444:	781a      	ldrb	r2, [r3, #0]
 8003446:	230d      	movs	r3, #13
 8003448:	18fb      	adds	r3, r7, r3
 800344a:	4941      	ldr	r1, [pc, #260]	; (8003550 <nextTx+0x19c>)
 800344c:	3204      	adds	r2, #4
 800344e:	00d2      	lsls	r2, r2, #3
 8003450:	188a      	adds	r2, r1, r2
 8003452:	3203      	adds	r2, #3
 8003454:	7812      	ldrb	r2, [r2, #0]
 8003456:	701a      	strb	r2, [r3, #0]
        for( u1_t ci=0; ci<MAX_CHANNELS; ci++ ) {
 8003458:	230c      	movs	r3, #12
 800345a:	18fb      	adds	r3, r7, r3
 800345c:	2200      	movs	r2, #0
 800345e:	701a      	strb	r2, [r3, #0]
 8003460:	e054      	b.n	800350c <nextTx+0x158>
            if( (chnl = (chnl+1)) >= MAX_CHANNELS )
 8003462:	210d      	movs	r1, #13
 8003464:	187b      	adds	r3, r7, r1
 8003466:	187a      	adds	r2, r7, r1
 8003468:	7812      	ldrb	r2, [r2, #0]
 800346a:	3201      	adds	r2, #1
 800346c:	701a      	strb	r2, [r3, #0]
 800346e:	187b      	adds	r3, r7, r1
 8003470:	781b      	ldrb	r3, [r3, #0]
 8003472:	2b0f      	cmp	r3, #15
 8003474:	d904      	bls.n	8003480 <nextTx+0xcc>
                chnl -=  MAX_CHANNELS;
 8003476:	187b      	adds	r3, r7, r1
 8003478:	187a      	adds	r2, r7, r1
 800347a:	7812      	ldrb	r2, [r2, #0]
 800347c:	3a10      	subs	r2, #16
 800347e:	701a      	strb	r2, [r3, #0]
            if( (LMIC.channelMap & (1<<chnl)) != 0  &&  // channel enabled
 8003480:	4b33      	ldr	r3, [pc, #204]	; (8003550 <nextTx+0x19c>)
 8003482:	22a0      	movs	r2, #160	; 0xa0
 8003484:	5a9b      	ldrh	r3, [r3, r2]
 8003486:	001a      	movs	r2, r3
 8003488:	200d      	movs	r0, #13
 800348a:	183b      	adds	r3, r7, r0
 800348c:	781b      	ldrb	r3, [r3, #0]
 800348e:	411a      	asrs	r2, r3
 8003490:	0013      	movs	r3, r2
 8003492:	2201      	movs	r2, #1
 8003494:	4013      	ands	r3, r2
 8003496:	d033      	beq.n	8003500 <nextTx+0x14c>
                (LMIC.channelDrMap[chnl] & (1<<(LMIC.datarate&0xF))) != 0  &&
 8003498:	183b      	adds	r3, r7, r0
 800349a:	781a      	ldrb	r2, [r3, #0]
 800349c:	4b2c      	ldr	r3, [pc, #176]	; (8003550 <nextTx+0x19c>)
 800349e:	3240      	adds	r2, #64	; 0x40
 80034a0:	0052      	lsls	r2, r2, #1
 80034a2:	5ad3      	ldrh	r3, [r2, r3]
 80034a4:	0019      	movs	r1, r3
 80034a6:	4b2a      	ldr	r3, [pc, #168]	; (8003550 <nextTx+0x19c>)
 80034a8:	22b0      	movs	r2, #176	; 0xb0
 80034aa:	5c9b      	ldrb	r3, [r3, r2]
 80034ac:	001a      	movs	r2, r3
 80034ae:	230f      	movs	r3, #15
 80034b0:	4013      	ands	r3, r2
 80034b2:	4119      	asrs	r1, r3
 80034b4:	000b      	movs	r3, r1
 80034b6:	2201      	movs	r2, #1
 80034b8:	4013      	ands	r3, r2
            if( (LMIC.channelMap & (1<<chnl)) != 0  &&  // channel enabled
 80034ba:	d021      	beq.n	8003500 <nextTx+0x14c>
                band == (LMIC.channelFreq[chnl] & 0x3) ) { // in selected band
 80034bc:	240f      	movs	r4, #15
 80034be:	193b      	adds	r3, r7, r4
 80034c0:	781a      	ldrb	r2, [r3, #0]
 80034c2:	183b      	adds	r3, r7, r0
 80034c4:	7819      	ldrb	r1, [r3, #0]
 80034c6:	4b22      	ldr	r3, [pc, #136]	; (8003550 <nextTx+0x19c>)
 80034c8:	3110      	adds	r1, #16
 80034ca:	0089      	lsls	r1, r1, #2
 80034cc:	58cb      	ldr	r3, [r1, r3]
 80034ce:	2103      	movs	r1, #3
 80034d0:	400b      	ands	r3, r1
                (LMIC.channelDrMap[chnl] & (1<<(LMIC.datarate&0xF))) != 0  &&
 80034d2:	429a      	cmp	r2, r3
 80034d4:	d114      	bne.n	8003500 <nextTx+0x14c>
                LMIC.txChnl = LMIC.bands[band].lastchnl = chnl;
 80034d6:	193b      	adds	r3, r7, r4
 80034d8:	781b      	ldrb	r3, [r3, #0]
 80034da:	491d      	ldr	r1, [pc, #116]	; (8003550 <nextTx+0x19c>)
 80034dc:	1d1a      	adds	r2, r3, #4
 80034de:	00d2      	lsls	r2, r2, #3
 80034e0:	188a      	adds	r2, r1, r2
 80034e2:	3203      	adds	r2, #3
 80034e4:	1839      	adds	r1, r7, r0
 80034e6:	7809      	ldrb	r1, [r1, #0]
 80034e8:	7011      	strb	r1, [r2, #0]
 80034ea:	4a19      	ldr	r2, [pc, #100]	; (8003550 <nextTx+0x19c>)
 80034ec:	3304      	adds	r3, #4
 80034ee:	00db      	lsls	r3, r3, #3
 80034f0:	18d3      	adds	r3, r2, r3
 80034f2:	3303      	adds	r3, #3
 80034f4:	7819      	ldrb	r1, [r3, #0]
 80034f6:	4b16      	ldr	r3, [pc, #88]	; (8003550 <nextTx+0x19c>)
 80034f8:	22a2      	movs	r2, #162	; 0xa2
 80034fa:	5499      	strb	r1, [r3, r2]
                return mintime;
 80034fc:	693b      	ldr	r3, [r7, #16]
 80034fe:	e021      	b.n	8003544 <nextTx+0x190>
        for( u1_t ci=0; ci<MAX_CHANNELS; ci++ ) {
 8003500:	210c      	movs	r1, #12
 8003502:	187b      	adds	r3, r7, r1
 8003504:	781a      	ldrb	r2, [r3, #0]
 8003506:	187b      	adds	r3, r7, r1
 8003508:	3201      	adds	r2, #1
 800350a:	701a      	strb	r2, [r3, #0]
 800350c:	230c      	movs	r3, #12
 800350e:	18fb      	adds	r3, r7, r3
 8003510:	781b      	ldrb	r3, [r3, #0]
 8003512:	2b0f      	cmp	r3, #15
 8003514:	d9a5      	bls.n	8003462 <nextTx+0xae>
            }
        }
        if( (bmap &= ~(1<<band)) == 0 ) {
 8003516:	230f      	movs	r3, #15
 8003518:	18fb      	adds	r3, r7, r3
 800351a:	781b      	ldrb	r3, [r3, #0]
 800351c:	2201      	movs	r2, #1
 800351e:	409a      	lsls	r2, r3
 8003520:	0013      	movs	r3, r2
 8003522:	b25b      	sxtb	r3, r3
 8003524:	43db      	mvns	r3, r3
 8003526:	b25b      	sxtb	r3, r3
 8003528:	2117      	movs	r1, #23
 800352a:	187a      	adds	r2, r7, r1
 800352c:	7812      	ldrb	r2, [r2, #0]
 800352e:	b252      	sxtb	r2, r2
 8003530:	4013      	ands	r3, r2
 8003532:	b25a      	sxtb	r2, r3
 8003534:	187b      	adds	r3, r7, r1
 8003536:	701a      	strb	r2, [r3, #0]
 8003538:	187b      	adds	r3, r7, r1
 800353a:	781b      	ldrb	r3, [r3, #0]
 800353c:	2b00      	cmp	r3, #0
 800353e:	d000      	beq.n	8003542 <nextTx+0x18e>
 8003540:	e740      	b.n	80033c4 <nextTx+0x10>
            // No feasible channel  found!
            return mintime;
 8003542:	693b      	ldr	r3, [r7, #16]
        }
    } while(1);
}
 8003544:	0018      	movs	r0, r3
 8003546:	46bd      	mov	sp, r7
 8003548:	b007      	add	sp, #28
 800354a:	bd90      	pop	{r4, r7, pc}
 800354c:	44aa2000 	.word	0x44aa2000
 8003550:	20000324 	.word	0x20000324

08003554 <setBcnRxParams>:


static void setBcnRxParams (void) {
 8003554:	b580      	push	{r7, lr}
 8003556:	af00      	add	r7, sp, #0
    LMIC.dataLen = 0;
 8003558:	4a13      	ldr	r2, [pc, #76]	; (80035a8 <setBcnRxParams+0x54>)
 800355a:	2348      	movs	r3, #72	; 0x48
 800355c:	33ff      	adds	r3, #255	; 0xff
 800355e:	2100      	movs	r1, #0
 8003560:	54d1      	strb	r1, [r2, r3]
    LMIC.freq = LMIC.channelFreq[LMIC.bcnChnl] & ~(u4_t)3;
 8003562:	4a11      	ldr	r2, [pc, #68]	; (80035a8 <setBcnRxParams+0x54>)
 8003564:	23c4      	movs	r3, #196	; 0xc4
 8003566:	005b      	lsls	r3, r3, #1
 8003568:	5cd3      	ldrb	r3, [r2, r3]
 800356a:	001a      	movs	r2, r3
 800356c:	4b0e      	ldr	r3, [pc, #56]	; (80035a8 <setBcnRxParams+0x54>)
 800356e:	3210      	adds	r2, #16
 8003570:	0092      	lsls	r2, r2, #2
 8003572:	58d3      	ldr	r3, [r2, r3]
 8003574:	2203      	movs	r2, #3
 8003576:	4393      	bics	r3, r2
 8003578:	001a      	movs	r2, r3
 800357a:	4b0b      	ldr	r3, [pc, #44]	; (80035a8 <setBcnRxParams+0x54>)
 800357c:	609a      	str	r2, [r3, #8]
    LMIC.rps  = setIh(setNocrc(dndr2rps((dr_t)DR_BCN),1),LEN_BCN);
 800357e:	2003      	movs	r0, #3
 8003580:	f7fe ff1c 	bl	80023bc <dndr2rps>
 8003584:	0003      	movs	r3, r0
 8003586:	2101      	movs	r1, #1
 8003588:	0018      	movs	r0, r3
 800358a:	f7fe fec5 	bl	8002318 <setNocrc>
 800358e:	0003      	movs	r3, r0
 8003590:	2111      	movs	r1, #17
 8003592:	0018      	movs	r0, r3
 8003594:	f7fe fee8 	bl	8002368 <setIh>
 8003598:	0003      	movs	r3, r0
 800359a:	001a      	movs	r2, r3
 800359c:	4b02      	ldr	r3, [pc, #8]	; (80035a8 <setBcnRxParams+0x54>)
 800359e:	81da      	strh	r2, [r3, #14]
}
 80035a0:	46c0      	nop			; (mov r8, r8)
 80035a2:	46bd      	mov	sp, r7
 80035a4:	bd80      	pop	{r7, pc}
 80035a6:	46c0      	nop			; (mov r8, r8)
 80035a8:	20000324 	.word	0x20000324

080035ac <initJoinLoop>:

#define setRx1Params() /*LMIC.freq/rps remain unchanged*/

static void initJoinLoop (void) {
 80035ac:	b5b0      	push	{r4, r5, r7, lr}
 80035ae:	af00      	add	r7, sp, #0
#if CFG_TxContinuousMode
  LMIC.txChnl = 0;
#else
    LMIC.txChnl = os_getRndU1() % NUM_DEFAULT_CHANNELS;
 80035b0:	f003 fc28 	bl	8006e04 <radio_rand1>
 80035b4:	0003      	movs	r3, r0
 80035b6:	2106      	movs	r1, #6
 80035b8:	0018      	movs	r0, r3
 80035ba:	f7fc fe2b 	bl	8000214 <__aeabi_uidivmod>
 80035be:	000b      	movs	r3, r1
 80035c0:	b2d9      	uxtb	r1, r3
 80035c2:	4b12      	ldr	r3, [pc, #72]	; (800360c <initJoinLoop+0x60>)
 80035c4:	22a2      	movs	r2, #162	; 0xa2
 80035c6:	5499      	strb	r1, [r3, r2]
#endif
    LMIC.adrTxPow = 14;
 80035c8:	4b10      	ldr	r3, [pc, #64]	; (800360c <initJoinLoop+0x60>)
 80035ca:	22af      	movs	r2, #175	; 0xaf
 80035cc:	210e      	movs	r1, #14
 80035ce:	5499      	strb	r1, [r3, r2]
    setDrJoin(DRCHG_SET, DR_SF7);
 80035d0:	2105      	movs	r1, #5
 80035d2:	2000      	movs	r0, #0
 80035d4:	f7ff fcba 	bl	8002f4c <setDrJoin>
    initDefaultChannels(1);
 80035d8:	2001      	movs	r0, #1
 80035da:	f7ff fd01 	bl	8002fe0 <initDefaultChannels>
    ASSERT((LMIC.opmode & OP_NEXTCHNL)==0);
 80035de:	4b0b      	ldr	r3, [pc, #44]	; (800360c <initJoinLoop+0x60>)
 80035e0:	22ac      	movs	r2, #172	; 0xac
 80035e2:	5a9b      	ldrh	r3, [r3, r2]
 80035e4:	001a      	movs	r2, r3
 80035e6:	2380      	movs	r3, #128	; 0x80
 80035e8:	011b      	lsls	r3, r3, #4
 80035ea:	4013      	ands	r3, r2
 80035ec:	d001      	beq.n	80035f2 <initJoinLoop+0x46>
 80035ee:	f7fe fe2d 	bl	800224c <hal_failed>
    LMIC.txend = LMIC.bands[BAND_MILLI].avail + rndDelay(8);
 80035f2:	4b06      	ldr	r3, [pc, #24]	; (800360c <initJoinLoop+0x60>)
 80035f4:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80035f6:	2008      	movs	r0, #8
 80035f8:	f7ff fc32 	bl	8002e60 <rndDelay>
 80035fc:	0003      	movs	r3, r0
 80035fe:	18e2      	adds	r2, r4, r3
 8003600:	4b02      	ldr	r3, [pc, #8]	; (800360c <initJoinLoop+0x60>)
 8003602:	601a      	str	r2, [r3, #0]
}
 8003604:	46c0      	nop			; (mov r8, r8)
 8003606:	46bd      	mov	sp, r7
 8003608:	bdb0      	pop	{r4, r5, r7, pc}
 800360a:	46c0      	nop			; (mov r8, r8)
 800360c:	20000324 	.word	0x20000324

08003610 <nextJoinState>:


static ostime_t nextJoinState (void) {
 8003610:	b580      	push	{r7, lr}
 8003612:	b082      	sub	sp, #8
 8003614:	af00      	add	r7, sp, #0
    u1_t failed = 0;
 8003616:	1dfb      	adds	r3, r7, #7
 8003618:	2200      	movs	r2, #0
 800361a:	701a      	strb	r2, [r3, #0]

    // Try 869.x and then 864.x with same DR
    // If both fail try next lower datarate
    if( ++LMIC.txChnl == NUM_DEFAULT_CHANNELS )
 800361c:	4b31      	ldr	r3, [pc, #196]	; (80036e4 <nextJoinState+0xd4>)
 800361e:	22a2      	movs	r2, #162	; 0xa2
 8003620:	5c9b      	ldrb	r3, [r3, r2]
 8003622:	3301      	adds	r3, #1
 8003624:	b2d9      	uxtb	r1, r3
 8003626:	4b2f      	ldr	r3, [pc, #188]	; (80036e4 <nextJoinState+0xd4>)
 8003628:	22a2      	movs	r2, #162	; 0xa2
 800362a:	5499      	strb	r1, [r3, r2]
 800362c:	4b2d      	ldr	r3, [pc, #180]	; (80036e4 <nextJoinState+0xd4>)
 800362e:	22a2      	movs	r2, #162	; 0xa2
 8003630:	5c9b      	ldrb	r3, [r3, r2]
 8003632:	2b06      	cmp	r3, #6
 8003634:	d103      	bne.n	800363e <nextJoinState+0x2e>
        LMIC.txChnl = 0;
 8003636:	4b2b      	ldr	r3, [pc, #172]	; (80036e4 <nextJoinState+0xd4>)
 8003638:	22a2      	movs	r2, #162	; 0xa2
 800363a:	2100      	movs	r1, #0
 800363c:	5499      	strb	r1, [r3, r2]
    if( (++LMIC.txCnt & 1) == 0 ) {
 800363e:	4a29      	ldr	r2, [pc, #164]	; (80036e4 <nextJoinState+0xd4>)
 8003640:	23a2      	movs	r3, #162	; 0xa2
 8003642:	005b      	lsls	r3, r3, #1
 8003644:	5cd3      	ldrb	r3, [r2, r3]
 8003646:	3301      	adds	r3, #1
 8003648:	b2d9      	uxtb	r1, r3
 800364a:	4a26      	ldr	r2, [pc, #152]	; (80036e4 <nextJoinState+0xd4>)
 800364c:	23a2      	movs	r3, #162	; 0xa2
 800364e:	005b      	lsls	r3, r3, #1
 8003650:	54d1      	strb	r1, [r2, r3]
 8003652:	4a24      	ldr	r2, [pc, #144]	; (80036e4 <nextJoinState+0xd4>)
 8003654:	23a2      	movs	r3, #162	; 0xa2
 8003656:	005b      	lsls	r3, r3, #1
 8003658:	5cd3      	ldrb	r3, [r2, r3]
 800365a:	001a      	movs	r2, r3
 800365c:	2301      	movs	r3, #1
 800365e:	4013      	ands	r3, r2
 8003660:	d113      	bne.n	800368a <nextJoinState+0x7a>
        // Lower DR every 2nd try (having tried 868.x and 864.x with the same DR)
        if( LMIC.datarate == DR_SF12 )
 8003662:	4b20      	ldr	r3, [pc, #128]	; (80036e4 <nextJoinState+0xd4>)
 8003664:	22b0      	movs	r2, #176	; 0xb0
 8003666:	5c9b      	ldrb	r3, [r3, r2]
 8003668:	2b00      	cmp	r3, #0
 800366a:	d103      	bne.n	8003674 <nextJoinState+0x64>
            failed = 1; // we have tried all DR - signal EV_JOIN_FAILED
 800366c:	1dfb      	adds	r3, r7, #7
 800366e:	2201      	movs	r2, #1
 8003670:	701a      	strb	r2, [r3, #0]
 8003672:	e00a      	b.n	800368a <nextJoinState+0x7a>
        else
            setDrJoin(DRCHG_NOJACC, decDR((dr_t)LMIC.datarate));
 8003674:	4b1b      	ldr	r3, [pc, #108]	; (80036e4 <nextJoinState+0xd4>)
 8003676:	22b0      	movs	r2, #176	; 0xb0
 8003678:	5c9b      	ldrb	r3, [r3, r2]
 800367a:	0018      	movs	r0, r3
 800367c:	f7fe feb4 	bl	80023e8 <decDR>
 8003680:	0003      	movs	r3, r0
 8003682:	0019      	movs	r1, r3
 8003684:	2001      	movs	r0, #1
 8003686:	f7ff fc61 	bl	8002f4c <setDrJoin>
    }
    // Clear NEXTCHNL because join state engine controls channel hopping
    LMIC.opmode &= ~OP_NEXTCHNL;
 800368a:	4b16      	ldr	r3, [pc, #88]	; (80036e4 <nextJoinState+0xd4>)
 800368c:	22ac      	movs	r2, #172	; 0xac
 800368e:	5a9b      	ldrh	r3, [r3, r2]
 8003690:	4a15      	ldr	r2, [pc, #84]	; (80036e8 <nextJoinState+0xd8>)
 8003692:	4013      	ands	r3, r2
 8003694:	b299      	uxth	r1, r3
 8003696:	4b13      	ldr	r3, [pc, #76]	; (80036e4 <nextJoinState+0xd4>)
 8003698:	22ac      	movs	r2, #172	; 0xac
 800369a:	5299      	strh	r1, [r3, r2]
    // Move txend to randomize synchronized concurrent joins.
    // Duty cycle is based on txend.
    ostime_t time = os_getTime();
 800369c:	f002 fe18 	bl	80062d0 <os_getTime>
 80036a0:	0003      	movs	r3, r0
 80036a2:	603b      	str	r3, [r7, #0]
    if( time - LMIC.bands[BAND_MILLI].avail < 0 )
 80036a4:	4b0f      	ldr	r3, [pc, #60]	; (80036e4 <nextJoinState+0xd4>)
 80036a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80036a8:	683a      	ldr	r2, [r7, #0]
 80036aa:	1ad3      	subs	r3, r2, r3
 80036ac:	d502      	bpl.n	80036b4 <nextJoinState+0xa4>
        time = LMIC.bands[BAND_MILLI].avail;
 80036ae:	4b0d      	ldr	r3, [pc, #52]	; (80036e4 <nextJoinState+0xd4>)
 80036b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80036b2:	603b      	str	r3, [r7, #0]
        (isTESTMODE()
         // Avoid collision with JOIN ACCEPT @ SF12 being sent by GW (but we missed it)
         ? DNW2_SAFETY_ZONE
         // Otherwise: randomize join (street lamp case):
         // SF12:255, SF11:127, .., SF7:8secs
         : DNW2_SAFETY_ZONE+rndDelay(255>>LMIC.datarate));
 80036b4:	4b0b      	ldr	r3, [pc, #44]	; (80036e4 <nextJoinState+0xd4>)
 80036b6:	22b0      	movs	r2, #176	; 0xb0
 80036b8:	5c9b      	ldrb	r3, [r3, r2]
 80036ba:	001a      	movs	r2, r3
 80036bc:	23ff      	movs	r3, #255	; 0xff
 80036be:	4113      	asrs	r3, r2
 80036c0:	b2db      	uxtb	r3, r3
 80036c2:	0018      	movs	r0, r3
 80036c4:	f7ff fbcc 	bl	8002e60 <rndDelay>
 80036c8:	0003      	movs	r3, r0
 80036ca:	4a08      	ldr	r2, [pc, #32]	; (80036ec <nextJoinState+0xdc>)
 80036cc:	189a      	adds	r2, r3, r2
    LMIC.txend = time +
 80036ce:	683b      	ldr	r3, [r7, #0]
 80036d0:	18d2      	adds	r2, r2, r3
 80036d2:	4b04      	ldr	r3, [pc, #16]	; (80036e4 <nextJoinState+0xd4>)
 80036d4:	601a      	str	r2, [r3, #0]
    // 1 - triggers EV_JOIN_FAILED event
    return failed;
 80036d6:	1dfb      	adds	r3, r7, #7
 80036d8:	781b      	ldrb	r3, [r3, #0]
}
 80036da:	0018      	movs	r0, r3
 80036dc:	46bd      	mov	sp, r7
 80036de:	b002      	add	sp, #8
 80036e0:	bd80      	pop	{r7, pc}
 80036e2:	46c0      	nop			; (mov r8, r8)
 80036e4:	20000324 	.word	0x20000324
 80036e8:	fffff7ff 	.word	0xfffff7ff
 80036ec:	00017700 	.word	0x00017700

080036f0 <runEngineUpdate>:
#else
#error Unsupported frequency band!
#endif


static void runEngineUpdate (xref2osjob_t osjob) {
 80036f0:	b580      	push	{r7, lr}
 80036f2:	b082      	sub	sp, #8
 80036f4:	af00      	add	r7, sp, #0
 80036f6:	6078      	str	r0, [r7, #4]
    engineUpdate();
 80036f8:	f001 fe32 	bl	8005360 <engineUpdate>
}
 80036fc:	46c0      	nop			; (mov r8, r8)
 80036fe:	46bd      	mov	sp, r7
 8003700:	b002      	add	sp, #8
 8003702:	bd80      	pop	{r7, pc}

08003704 <reportEvent>:


static void reportEvent (ev_t ev) {
 8003704:	b580      	push	{r7, lr}
 8003706:	b082      	sub	sp, #8
 8003708:	af00      	add	r7, sp, #0
 800370a:	0002      	movs	r2, r0
 800370c:	1dfb      	adds	r3, r7, #7
 800370e:	701a      	strb	r2, [r3, #0]
    EV(devCond, INFO, (e_.reason = EV::devCond_t::LMIC_EV,
                       e_.eui    = MAIN::CDEV->getEui(),
                       e_.info   = ev));
    ON_LMIC_EVENT(ev);
 8003710:	1dfb      	adds	r3, r7, #7
 8003712:	781b      	ldrb	r3, [r3, #0]
 8003714:	0018      	movs	r0, r3
 8003716:	f002 fa3d 	bl	8005b94 <onEvent>
    engineUpdate();
 800371a:	f001 fe21 	bl	8005360 <engineUpdate>
}
 800371e:	46c0      	nop			; (mov r8, r8)
 8003720:	46bd      	mov	sp, r7
 8003722:	b002      	add	sp, #8
 8003724:	bd80      	pop	{r7, pc}

08003726 <runReset>:


static void runReset (xref2osjob_t osjob) {
 8003726:	b580      	push	{r7, lr}
 8003728:	b082      	sub	sp, #8
 800372a:	af00      	add	r7, sp, #0
 800372c:	6078      	str	r0, [r7, #4]
    // Disable session
    LMIC_reset();
 800372e:	f002 f80b 	bl	8005748 <LMIC_reset>
    LMIC_startJoining();
 8003732:	f001 fb29 	bl	8004d88 <LMIC_startJoining>
    reportEvent(EV_RESET);
 8003736:	200c      	movs	r0, #12
 8003738:	f7ff ffe4 	bl	8003704 <reportEvent>
}
 800373c:	46c0      	nop			; (mov r8, r8)
 800373e:	46bd      	mov	sp, r7
 8003740:	b002      	add	sp, #8
 8003742:	bd80      	pop	{r7, pc}

08003744 <stateJustJoined>:

static void stateJustJoined (void) {
 8003744:	b580      	push	{r7, lr}
 8003746:	af00      	add	r7, sp, #0
    LMIC.seqnoDn     = LMIC.seqnoUp = 0;
 8003748:	4a3a      	ldr	r2, [pc, #232]	; (8003834 <stateJustJoined+0xf0>)
 800374a:	238e      	movs	r3, #142	; 0x8e
 800374c:	005b      	lsls	r3, r3, #1
 800374e:	2100      	movs	r1, #0
 8003750:	50d1      	str	r1, [r2, r3]
 8003752:	4a38      	ldr	r2, [pc, #224]	; (8003834 <stateJustJoined+0xf0>)
 8003754:	238e      	movs	r3, #142	; 0x8e
 8003756:	005b      	lsls	r3, r3, #1
 8003758:	58d1      	ldr	r1, [r2, r3]
 800375a:	4a36      	ldr	r2, [pc, #216]	; (8003834 <stateJustJoined+0xf0>)
 800375c:	238c      	movs	r3, #140	; 0x8c
 800375e:	005b      	lsls	r3, r3, #1
 8003760:	50d1      	str	r1, [r2, r3]
    LMIC.rejoinCnt   = 0;
 8003762:	4b34      	ldr	r3, [pc, #208]	; (8003834 <stateJustJoined+0xf0>)
 8003764:	22b2      	movs	r2, #178	; 0xb2
 8003766:	2100      	movs	r1, #0
 8003768:	5499      	strb	r1, [r3, r2]
    LMIC.dnConf      = LMIC.adrChanged = LMIC.ladrAns = LMIC.devsAns = 0;
 800376a:	4a32      	ldr	r2, [pc, #200]	; (8003834 <stateJustJoined+0xf0>)
 800376c:	2393      	movs	r3, #147	; 0x93
 800376e:	005b      	lsls	r3, r3, #1
 8003770:	2100      	movs	r1, #0
 8003772:	54d1      	strb	r1, [r2, r3]
 8003774:	4a2f      	ldr	r2, [pc, #188]	; (8003834 <stateJustJoined+0xf0>)
 8003776:	2393      	movs	r3, #147	; 0x93
 8003778:	005b      	lsls	r3, r3, #1
 800377a:	5cd1      	ldrb	r1, [r2, r3]
 800377c:	4a2d      	ldr	r2, [pc, #180]	; (8003834 <stateJustJoined+0xf0>)
 800377e:	2326      	movs	r3, #38	; 0x26
 8003780:	33ff      	adds	r3, #255	; 0xff
 8003782:	54d1      	strb	r1, [r2, r3]
 8003784:	4a2b      	ldr	r2, [pc, #172]	; (8003834 <stateJustJoined+0xf0>)
 8003786:	2326      	movs	r3, #38	; 0x26
 8003788:	33ff      	adds	r3, #255	; 0xff
 800378a:	5cd1      	ldrb	r1, [r2, r3]
 800378c:	4a29      	ldr	r2, [pc, #164]	; (8003834 <stateJustJoined+0xf0>)
 800378e:	2391      	movs	r3, #145	; 0x91
 8003790:	005b      	lsls	r3, r3, #1
 8003792:	54d1      	strb	r1, [r2, r3]
 8003794:	4a27      	ldr	r2, [pc, #156]	; (8003834 <stateJustJoined+0xf0>)
 8003796:	2391      	movs	r3, #145	; 0x91
 8003798:	005b      	lsls	r3, r3, #1
 800379a:	5cd1      	ldrb	r1, [r2, r3]
 800379c:	4a25      	ldr	r2, [pc, #148]	; (8003834 <stateJustJoined+0xf0>)
 800379e:	2390      	movs	r3, #144	; 0x90
 80037a0:	005b      	lsls	r3, r3, #1
 80037a2:	54d1      	strb	r1, [r2, r3]
    LMIC.moreData    = LMIC.dn2Ans = LMIC.snchAns = LMIC.dutyCapAns = 0;
 80037a4:	4a23      	ldr	r2, [pc, #140]	; (8003834 <stateJustJoined+0xf0>)
 80037a6:	232a      	movs	r3, #42	; 0x2a
 80037a8:	33ff      	adds	r3, #255	; 0xff
 80037aa:	2100      	movs	r1, #0
 80037ac:	54d1      	strb	r1, [r2, r3]
 80037ae:	4a21      	ldr	r2, [pc, #132]	; (8003834 <stateJustJoined+0xf0>)
 80037b0:	232a      	movs	r3, #42	; 0x2a
 80037b2:	33ff      	adds	r3, #255	; 0xff
 80037b4:	5cd1      	ldrb	r1, [r2, r3]
 80037b6:	4a1f      	ldr	r2, [pc, #124]	; (8003834 <stateJustJoined+0xf0>)
 80037b8:	2395      	movs	r3, #149	; 0x95
 80037ba:	005b      	lsls	r3, r3, #1
 80037bc:	54d1      	strb	r1, [r2, r3]
 80037be:	4a1d      	ldr	r2, [pc, #116]	; (8003834 <stateJustJoined+0xf0>)
 80037c0:	2395      	movs	r3, #149	; 0x95
 80037c2:	005b      	lsls	r3, r3, #1
 80037c4:	5cd1      	ldrb	r1, [r2, r3]
 80037c6:	4a1b      	ldr	r2, [pc, #108]	; (8003834 <stateJustJoined+0xf0>)
 80037c8:	2398      	movs	r3, #152	; 0x98
 80037ca:	005b      	lsls	r3, r3, #1
 80037cc:	54d1      	strb	r1, [r2, r3]
 80037ce:	4a19      	ldr	r2, [pc, #100]	; (8003834 <stateJustJoined+0xf0>)
 80037d0:	2398      	movs	r3, #152	; 0x98
 80037d2:	005b      	lsls	r3, r3, #1
 80037d4:	5cd1      	ldrb	r1, [r2, r3]
 80037d6:	4a17      	ldr	r2, [pc, #92]	; (8003834 <stateJustJoined+0xf0>)
 80037d8:	2394      	movs	r3, #148	; 0x94
 80037da:	005b      	lsls	r3, r3, #1
 80037dc:	54d1      	strb	r1, [r2, r3]
    LMIC.pingSetAns  = 0;
 80037de:	4a15      	ldr	r2, [pc, #84]	; (8003834 <stateJustJoined+0xf0>)
 80037e0:	2334      	movs	r3, #52	; 0x34
 80037e2:	33ff      	adds	r3, #255	; 0xff
 80037e4:	2100      	movs	r1, #0
 80037e6:	54d1      	strb	r1, [r2, r3]
    LMIC.upRepeat    = 0;
 80037e8:	4b12      	ldr	r3, [pc, #72]	; (8003834 <stateJustJoined+0xf0>)
 80037ea:	22ae      	movs	r2, #174	; 0xae
 80037ec:	2100      	movs	r1, #0
 80037ee:	5499      	strb	r1, [r3, r2]
    LMIC.adrAckReq   = LINK_CHECK_INIT;
 80037f0:	4a10      	ldr	r2, [pc, #64]	; (8003834 <stateJustJoined+0xf0>)
 80037f2:	2322      	movs	r3, #34	; 0x22
 80037f4:	33ff      	adds	r3, #255	; 0xff
 80037f6:	21f4      	movs	r1, #244	; 0xf4
 80037f8:	54d1      	strb	r1, [r2, r3]
    LMIC.dn2Dr       = DR_DNW2;
 80037fa:	4a0e      	ldr	r2, [pc, #56]	; (8003834 <stateJustJoined+0xf0>)
 80037fc:	232c      	movs	r3, #44	; 0x2c
 80037fe:	33ff      	adds	r3, #255	; 0xff
 8003800:	2100      	movs	r1, #0
 8003802:	54d1      	strb	r1, [r2, r3]
    LMIC.dn2Freq     = FREQ_DNW2;
 8003804:	4a0b      	ldr	r2, [pc, #44]	; (8003834 <stateJustJoined+0xf0>)
 8003806:	2396      	movs	r3, #150	; 0x96
 8003808:	005b      	lsls	r3, r3, #1
 800380a:	490b      	ldr	r1, [pc, #44]	; (8003838 <stateJustJoined+0xf4>)
 800380c:	50d1      	str	r1, [r2, r3]
    LMIC.bcnChnl     = CHNL_BCN;
 800380e:	4a09      	ldr	r2, [pc, #36]	; (8003834 <stateJustJoined+0xf0>)
 8003810:	23c4      	movs	r3, #196	; 0xc4
 8003812:	005b      	lsls	r3, r3, #1
 8003814:	2105      	movs	r1, #5
 8003816:	54d1      	strb	r1, [r2, r3]
    LMIC.ping.freq   = FREQ_PING;
 8003818:	4a06      	ldr	r2, [pc, #24]	; (8003834 <stateJustJoined+0xf0>)
 800381a:	23a0      	movs	r3, #160	; 0xa0
 800381c:	005b      	lsls	r3, r3, #1
 800381e:	4906      	ldr	r1, [pc, #24]	; (8003838 <stateJustJoined+0xf4>)
 8003820:	50d1      	str	r1, [r2, r3]
    LMIC.ping.dr     = DR_PING;
 8003822:	4a04      	ldr	r2, [pc, #16]	; (8003834 <stateJustJoined+0xf0>)
 8003824:	239a      	movs	r3, #154	; 0x9a
 8003826:	005b      	lsls	r3, r3, #1
 8003828:	2103      	movs	r1, #3
 800382a:	54d1      	strb	r1, [r2, r3]
}
 800382c:	46c0      	nop			; (mov r8, r8)
 800382e:	46bd      	mov	sp, r7
 8003830:	bd80      	pop	{r7, pc}
 8003832:	46c0      	nop			; (mov r8, r8)
 8003834:	20000324 	.word	0x20000324
 8003838:	33d3e608 	.word	0x33d3e608

0800383c <decodeBeacon>:
// ================================================================================
// Decoding frames


// Decode beacon  - do not overwrite bcninfo unless we have a match!
static int decodeBeacon (void) {
 800383c:	b590      	push	{r4, r7, lr}
 800383e:	b083      	sub	sp, #12
 8003840:	af00      	add	r7, sp, #0
    ASSERT(LMIC.dataLen == LEN_BCN); // implicit header RX guarantees this
 8003842:	4a4e      	ldr	r2, [pc, #312]	; (800397c <decodeBeacon+0x140>)
 8003844:	2348      	movs	r3, #72	; 0x48
 8003846:	33ff      	adds	r3, #255	; 0xff
 8003848:	5cd3      	ldrb	r3, [r2, r3]
 800384a:	2b11      	cmp	r3, #17
 800384c:	d001      	beq.n	8003852 <decodeBeacon+0x16>
 800384e:	f7fe fcfd 	bl	800224c <hal_failed>
    xref2u1_t d = LMIC.frame;
 8003852:	4b4b      	ldr	r3, [pc, #300]	; (8003980 <decodeBeacon+0x144>)
 8003854:	607b      	str	r3, [r7, #4]
    if(
#if defined CFG_eu868
        d[OFF_BCN_CRC1] != (u1_t)os_crc16(d,OFF_BCN_CRC1)
 8003856:	687b      	ldr	r3, [r7, #4]
 8003858:	3307      	adds	r3, #7
 800385a:	781c      	ldrb	r4, [r3, #0]
 800385c:	687b      	ldr	r3, [r7, #4]
 800385e:	2107      	movs	r1, #7
 8003860:	0018      	movs	r0, r3
 8003862:	f7fe feb5 	bl	80025d0 <os_crc16>
 8003866:	0003      	movs	r3, r0
 8003868:	b2db      	uxtb	r3, r3
    if(
 800386a:	429c      	cmp	r4, r3
 800386c:	d001      	beq.n	8003872 <decodeBeacon+0x36>
#elif CFG_us915
        os_rlsbf2(&d[OFF_BCN_CRC1]) != os_crc16(d,OFF_BCN_CRC1)
#endif
        )
        return 0;   // first (common) part fails CRC check
 800386e:	2300      	movs	r3, #0
 8003870:	e07f      	b.n	8003972 <decodeBeacon+0x136>
    // First set of fields is ok
    u4_t bcnnetid = os_rlsbf4(&d[OFF_BCN_NETID]) & 0xFFFFFF;
 8003872:	687b      	ldr	r3, [r7, #4]
 8003874:	0018      	movs	r0, r3
 8003876:	f7fe fe19 	bl	80024ac <os_rlsbf4>
 800387a:	0003      	movs	r3, r0
 800387c:	021b      	lsls	r3, r3, #8
 800387e:	0a1b      	lsrs	r3, r3, #8
 8003880:	603b      	str	r3, [r7, #0]
    if( bcnnetid != LMIC.netid )
 8003882:	4b3e      	ldr	r3, [pc, #248]	; (800397c <decodeBeacon+0x140>)
 8003884:	22a8      	movs	r2, #168	; 0xa8
 8003886:	589b      	ldr	r3, [r3, r2]
 8003888:	683a      	ldr	r2, [r7, #0]
 800388a:	429a      	cmp	r2, r3
 800388c:	d002      	beq.n	8003894 <decodeBeacon+0x58>
        return -1;  // not the beacon we're looking for
 800388e:	2301      	movs	r3, #1
 8003890:	425b      	negs	r3, r3
 8003892:	e06e      	b.n	8003972 <decodeBeacon+0x136>

    LMIC.bcninfo.flags &= ~(BCN_PARTIAL|BCN_FULL);
 8003894:	4a39      	ldr	r2, [pc, #228]	; (800397c <decodeBeacon+0x140>)
 8003896:	23cb      	movs	r3, #203	; 0xcb
 8003898:	005b      	lsls	r3, r3, #1
 800389a:	5cd3      	ldrb	r3, [r2, r3]
 800389c:	2203      	movs	r2, #3
 800389e:	4393      	bics	r3, r2
 80038a0:	b2d9      	uxtb	r1, r3
 80038a2:	4a36      	ldr	r2, [pc, #216]	; (800397c <decodeBeacon+0x140>)
 80038a4:	23cb      	movs	r3, #203	; 0xcb
 80038a6:	005b      	lsls	r3, r3, #1
 80038a8:	54d1      	strb	r1, [r2, r3]
    // Match - update bcninfo structure
    LMIC.bcninfo.snr    = LMIC.snr;
 80038aa:	4b34      	ldr	r3, [pc, #208]	; (800397c <decodeBeacon+0x140>)
 80038ac:	210d      	movs	r1, #13
 80038ae:	5659      	ldrsb	r1, [r3, r1]
 80038b0:	4a32      	ldr	r2, [pc, #200]	; (800397c <decodeBeacon+0x140>)
 80038b2:	2396      	movs	r3, #150	; 0x96
 80038b4:	33ff      	adds	r3, #255	; 0xff
 80038b6:	54d1      	strb	r1, [r2, r3]
    LMIC.bcninfo.rssi   = LMIC.rssi;
 80038b8:	4b30      	ldr	r3, [pc, #192]	; (800397c <decodeBeacon+0x140>)
 80038ba:	210c      	movs	r1, #12
 80038bc:	5659      	ldrsb	r1, [r3, r1]
 80038be:	4a2f      	ldr	r2, [pc, #188]	; (800397c <decodeBeacon+0x140>)
 80038c0:	23ca      	movs	r3, #202	; 0xca
 80038c2:	005b      	lsls	r3, r3, #1
 80038c4:	54d1      	strb	r1, [r2, r3]
    LMIC.bcninfo.txtime = LMIC.rxtime - AIRTIME_BCN_osticks;
 80038c6:	4b2d      	ldr	r3, [pc, #180]	; (800397c <decodeBeacon+0x140>)
 80038c8:	685b      	ldr	r3, [r3, #4]
 80038ca:	4a2e      	ldr	r2, [pc, #184]	; (8003984 <decodeBeacon+0x148>)
 80038cc:	1899      	adds	r1, r3, r2
 80038ce:	4a2b      	ldr	r2, [pc, #172]	; (800397c <decodeBeacon+0x140>)
 80038d0:	23c8      	movs	r3, #200	; 0xc8
 80038d2:	005b      	lsls	r3, r3, #1
 80038d4:	50d1      	str	r1, [r2, r3]
    LMIC.bcninfo.time   = os_rlsbf4(&d[OFF_BCN_TIME]);
 80038d6:	687b      	ldr	r3, [r7, #4]
 80038d8:	3303      	adds	r3, #3
 80038da:	0018      	movs	r0, r3
 80038dc:	f7fe fde6 	bl	80024ac <os_rlsbf4>
 80038e0:	0001      	movs	r1, r0
 80038e2:	4a26      	ldr	r2, [pc, #152]	; (800397c <decodeBeacon+0x140>)
 80038e4:	23cc      	movs	r3, #204	; 0xcc
 80038e6:	005b      	lsls	r3, r3, #1
 80038e8:	50d1      	str	r1, [r2, r3]
    LMIC.bcninfo.flags |= BCN_PARTIAL;
 80038ea:	4a24      	ldr	r2, [pc, #144]	; (800397c <decodeBeacon+0x140>)
 80038ec:	23cb      	movs	r3, #203	; 0xcb
 80038ee:	005b      	lsls	r3, r3, #1
 80038f0:	5cd3      	ldrb	r3, [r2, r3]
 80038f2:	2201      	movs	r2, #1
 80038f4:	4313      	orrs	r3, r2
 80038f6:	b2d9      	uxtb	r1, r3
 80038f8:	4a20      	ldr	r2, [pc, #128]	; (800397c <decodeBeacon+0x140>)
 80038fa:	23cb      	movs	r3, #203	; 0xcb
 80038fc:	005b      	lsls	r3, r3, #1
 80038fe:	54d1      	strb	r1, [r2, r3]

    // Check 2nd set
    if( os_rlsbf2(&d[OFF_BCN_CRC2]) != os_crc16(d,OFF_BCN_CRC2) )
 8003900:	687b      	ldr	r3, [r7, #4]
 8003902:	330f      	adds	r3, #15
 8003904:	0018      	movs	r0, r3
 8003906:	f7fe fdbe 	bl	8002486 <os_rlsbf2>
 800390a:	0003      	movs	r3, r0
 800390c:	001c      	movs	r4, r3
 800390e:	687b      	ldr	r3, [r7, #4]
 8003910:	210f      	movs	r1, #15
 8003912:	0018      	movs	r0, r3
 8003914:	f7fe fe5c 	bl	80025d0 <os_crc16>
 8003918:	0003      	movs	r3, r0
 800391a:	429c      	cmp	r4, r3
 800391c:	d001      	beq.n	8003922 <decodeBeacon+0xe6>
        return 1;
 800391e:	2301      	movs	r3, #1
 8003920:	e027      	b.n	8003972 <decodeBeacon+0x136>
    // Second set of fields is ok
    LMIC.bcninfo.lat    = (s4_t)os_rlsbf4(&d[OFF_BCN_LAT-1]) >> 8; // read as signed 24-bit
 8003922:	687b      	ldr	r3, [r7, #4]
 8003924:	3308      	adds	r3, #8
 8003926:	0018      	movs	r0, r3
 8003928:	f7fe fdc0 	bl	80024ac <os_rlsbf4>
 800392c:	0003      	movs	r3, r0
 800392e:	1219      	asrs	r1, r3, #8
 8003930:	4a12      	ldr	r2, [pc, #72]	; (800397c <decodeBeacon+0x140>)
 8003932:	23d0      	movs	r3, #208	; 0xd0
 8003934:	005b      	lsls	r3, r3, #1
 8003936:	50d1      	str	r1, [r2, r3]
    LMIC.bcninfo.lon    = (s4_t)os_rlsbf4(&d[OFF_BCN_LON-1]) >> 8; // ditto
 8003938:	687b      	ldr	r3, [r7, #4]
 800393a:	330b      	adds	r3, #11
 800393c:	0018      	movs	r0, r3
 800393e:	f7fe fdb5 	bl	80024ac <os_rlsbf4>
 8003942:	0003      	movs	r3, r0
 8003944:	1219      	asrs	r1, r3, #8
 8003946:	4a0d      	ldr	r2, [pc, #52]	; (800397c <decodeBeacon+0x140>)
 8003948:	23d2      	movs	r3, #210	; 0xd2
 800394a:	005b      	lsls	r3, r3, #1
 800394c:	50d1      	str	r1, [r2, r3]
    LMIC.bcninfo.info   = d[OFF_BCN_INFO];
 800394e:	687b      	ldr	r3, [r7, #4]
 8003950:	7a19      	ldrb	r1, [r3, #8]
 8003952:	4a0a      	ldr	r2, [pc, #40]	; (800397c <decodeBeacon+0x140>)
 8003954:	23ce      	movs	r3, #206	; 0xce
 8003956:	005b      	lsls	r3, r3, #1
 8003958:	54d1      	strb	r1, [r2, r3]
    LMIC.bcninfo.flags |= BCN_FULL;
 800395a:	4a08      	ldr	r2, [pc, #32]	; (800397c <decodeBeacon+0x140>)
 800395c:	23cb      	movs	r3, #203	; 0xcb
 800395e:	005b      	lsls	r3, r3, #1
 8003960:	5cd3      	ldrb	r3, [r2, r3]
 8003962:	2202      	movs	r2, #2
 8003964:	4313      	orrs	r3, r2
 8003966:	b2d9      	uxtb	r1, r3
 8003968:	4a04      	ldr	r2, [pc, #16]	; (800397c <decodeBeacon+0x140>)
 800396a:	23cb      	movs	r3, #203	; 0xcb
 800396c:	005b      	lsls	r3, r3, #1
 800396e:	54d1      	strb	r1, [r2, r3]
    return 2;
 8003970:	2302      	movs	r3, #2
}
 8003972:	0018      	movs	r0, r3
 8003974:	46bd      	mov	sp, r7
 8003976:	b003      	add	sp, #12
 8003978:	bd90      	pop	{r4, r7, pc}
 800397a:	46c0      	nop			; (mov r8, r8)
 800397c:	20000324 	.word	0x20000324
 8003980:	2000046c 	.word	0x2000046c
 8003984:	ffffedf4 	.word	0xffffedf4

08003988 <decodeFrame>:


static bit_t decodeFrame (void) {
 8003988:	b5b0      	push	{r4, r5, r7, lr}
 800398a:	b09a      	sub	sp, #104	; 0x68
 800398c:	af02      	add	r7, sp, #8
    xref2u1_t d = LMIC.frame;
 800398e:	4bd3      	ldr	r3, [pc, #844]	; (8003cdc <decodeFrame+0x354>)
 8003990:	64bb      	str	r3, [r7, #72]	; 0x48
    u1_t hdr    = d[0];
 8003992:	2047      	movs	r0, #71	; 0x47
 8003994:	183b      	adds	r3, r7, r0
 8003996:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8003998:	7812      	ldrb	r2, [r2, #0]
 800399a:	701a      	strb	r2, [r3, #0]
    u1_t ftype  = hdr & HDR_FTYPE;
 800399c:	2446      	movs	r4, #70	; 0x46
 800399e:	193b      	adds	r3, r7, r4
 80039a0:	183a      	adds	r2, r7, r0
 80039a2:	7812      	ldrb	r2, [r2, #0]
 80039a4:	211f      	movs	r1, #31
 80039a6:	438a      	bics	r2, r1
 80039a8:	701a      	strb	r2, [r3, #0]
    int  dlen   = LMIC.dataLen;
 80039aa:	4acd      	ldr	r2, [pc, #820]	; (8003ce0 <decodeFrame+0x358>)
 80039ac:	2348      	movs	r3, #72	; 0x48
 80039ae:	33ff      	adds	r3, #255	; 0xff
 80039b0:	5cd3      	ldrb	r3, [r2, r3]
 80039b2:	643b      	str	r3, [r7, #64]	; 0x40
    if( dlen < OFF_DAT_OPTS+4 ||
 80039b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80039b6:	2b0b      	cmp	r3, #11
 80039b8:	dd0c      	ble.n	80039d4 <decodeFrame+0x4c>
        (hdr & HDR_MAJOR) != HDR_MAJOR_V1 ||
 80039ba:	183b      	adds	r3, r7, r0
 80039bc:	781b      	ldrb	r3, [r3, #0]
 80039be:	2203      	movs	r2, #3
 80039c0:	4013      	ands	r3, r2
    if( dlen < OFF_DAT_OPTS+4 ||
 80039c2:	d107      	bne.n	80039d4 <decodeFrame+0x4c>
        (hdr & HDR_MAJOR) != HDR_MAJOR_V1 ||
 80039c4:	193b      	adds	r3, r7, r4
 80039c6:	781b      	ldrb	r3, [r3, #0]
 80039c8:	2b60      	cmp	r3, #96	; 0x60
 80039ca:	d015      	beq.n	80039f8 <decodeFrame+0x70>
        (ftype != HDR_FTYPE_DADN  &&  ftype != HDR_FTYPE_DCDN) ) {
 80039cc:	193b      	adds	r3, r7, r4
 80039ce:	781b      	ldrb	r3, [r3, #0]
 80039d0:	2ba0      	cmp	r3, #160	; 0xa0
 80039d2:	d011      	beq.n	80039f8 <decodeFrame+0x70>
        // Basic sanity checks failed
        EV(specCond, WARN, (e_.reason = EV::specCond_t::UNEXPECTED_FRAME,
                            e_.eui    = MAIN::CDEV->getEui(),
                            e_.info   = dlen < 4 ? 0 : os_rlsbf4(&d[dlen-4]),
                            e_.info2  = hdr + (dlen<<8)));
      norx:
 80039d4:	46c0      	nop			; (mov r8, r8)
 80039d6:	e008      	b.n	80039ea <decodeFrame+0x62>
    if( addr != LMIC.devaddr ) {
        EV(specCond, WARN, (e_.reason = EV::specCond_t::ALIEN_ADDRESS,
                            e_.eui    = MAIN::CDEV->getEui(),
                            e_.info   = addr,
                            e_.info2  = LMIC.devaddr));
        goto norx;
 80039d8:	46c0      	nop			; (mov r8, r8)
 80039da:	e006      	b.n	80039ea <decodeFrame+0x62>
    }
    if( poff > pend ) {
        EV(specCond, ERR, (e_.reason = EV::specCond_t::CORRUPTED_FRAME,
                           e_.eui    = MAIN::CDEV->getEui(),
                           e_.info   = 0x1000000 + (poff-pend) + (fct<<8) + (dlen<<16)));
        goto norx;
 80039dc:	46c0      	nop			; (mov r8, r8)
 80039de:	e004      	b.n	80039ea <decodeFrame+0x62>
        EV(spe3Cond, ERR, (e_.reason = EV::spe3Cond_t::CORRUPTED_MIC,
                           e_.eui1   = MAIN::CDEV->getEui(),
                           e_.info1  = Base::lsbf4(&d[pend]),
                           e_.info2  = seqno,
                           e_.info3  = LMIC.devaddr));
        goto norx;
 80039e0:	46c0      	nop			; (mov r8, r8)
 80039e2:	e002      	b.n	80039ea <decodeFrame+0x62>
        if( (s4_t)seqno > (s4_t)LMIC.seqnoDn ) {
            EV(specCond, INFO, (e_.reason = EV::specCond_t::DNSEQNO_ROLL_OVER,
                                e_.eui    = MAIN::CDEV->getEui(),
                                e_.info   = LMIC.seqnoDn, 
                                e_.info2  = seqno));
            goto norx;
 80039e4:	46c0      	nop			; (mov r8, r8)
 80039e6:	e000      	b.n	80039ea <decodeFrame+0x62>
        if( seqno != LMIC.seqnoDn-1 || !LMIC.dnConf || ftype != HDR_FTYPE_DCDN ) {
            EV(specCond, INFO, (e_.reason = EV::specCond_t::DNSEQNO_OBSOLETE,
                                e_.eui    = MAIN::CDEV->getEui(),
                                e_.info   = LMIC.seqnoDn, 
                                e_.info2  = seqno));
            goto norx;
 80039e8:	46c0      	nop			; (mov r8, r8)
        LMIC.dataLen = 0;
 80039ea:	4abd      	ldr	r2, [pc, #756]	; (8003ce0 <decodeFrame+0x358>)
 80039ec:	2348      	movs	r3, #72	; 0x48
 80039ee:	33ff      	adds	r3, #255	; 0xff
 80039f0:	2100      	movs	r1, #0
 80039f2:	54d1      	strb	r1, [r2, r3]
        return 0;
 80039f4:	2300      	movs	r3, #0
 80039f6:	e32b      	b.n	8004050 <decodeFrame+0x6c8>
    int  fct   = d[OFF_DAT_FCT];
 80039f8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80039fa:	3305      	adds	r3, #5
 80039fc:	781b      	ldrb	r3, [r3, #0]
 80039fe:	63fb      	str	r3, [r7, #60]	; 0x3c
    u4_t addr  = os_rlsbf4(&d[OFF_DAT_ADDR]);
 8003a00:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003a02:	3301      	adds	r3, #1
 8003a04:	0018      	movs	r0, r3
 8003a06:	f7fe fd51 	bl	80024ac <os_rlsbf4>
 8003a0a:	0003      	movs	r3, r0
 8003a0c:	63bb      	str	r3, [r7, #56]	; 0x38
    u4_t seqno = os_rlsbf2(&d[OFF_DAT_SEQNO]);
 8003a0e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003a10:	3306      	adds	r3, #6
 8003a12:	0018      	movs	r0, r3
 8003a14:	f7fe fd37 	bl	8002486 <os_rlsbf2>
 8003a18:	0003      	movs	r3, r0
 8003a1a:	637b      	str	r3, [r7, #52]	; 0x34
    int  olen  = fct & FCT_OPTLEN;
 8003a1c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003a1e:	220f      	movs	r2, #15
 8003a20:	4013      	ands	r3, r2
 8003a22:	633b      	str	r3, [r7, #48]	; 0x30
    int  ackup = (fct & FCT_ACK) != 0 ? 1 : 0;   // ACK last up frame
 8003a24:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003a26:	115b      	asrs	r3, r3, #5
 8003a28:	2201      	movs	r2, #1
 8003a2a:	4013      	ands	r3, r2
 8003a2c:	62fb      	str	r3, [r7, #44]	; 0x2c
    int  poff  = OFF_DAT_OPTS+olen;
 8003a2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003a30:	3308      	adds	r3, #8
 8003a32:	65fb      	str	r3, [r7, #92]	; 0x5c
    int  pend  = dlen-4;  // MIC
 8003a34:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003a36:	3b04      	subs	r3, #4
 8003a38:	62bb      	str	r3, [r7, #40]	; 0x28
    if( addr != LMIC.devaddr ) {
 8003a3a:	4aa9      	ldr	r2, [pc, #676]	; (8003ce0 <decodeFrame+0x358>)
 8003a3c:	238a      	movs	r3, #138	; 0x8a
 8003a3e:	005b      	lsls	r3, r3, #1
 8003a40:	58d3      	ldr	r3, [r2, r3]
 8003a42:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8003a44:	429a      	cmp	r2, r3
 8003a46:	d1c7      	bne.n	80039d8 <decodeFrame+0x50>
    if( poff > pend ) {
 8003a48:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8003a4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003a4c:	429a      	cmp	r2, r3
 8003a4e:	dcc5      	bgt.n	80039dc <decodeFrame+0x54>
    int port = -1;
 8003a50:	2301      	movs	r3, #1
 8003a52:	425b      	negs	r3, r3
 8003a54:	65bb      	str	r3, [r7, #88]	; 0x58
    int replayConf = 0;
 8003a56:	2300      	movs	r3, #0
 8003a58:	657b      	str	r3, [r7, #84]	; 0x54
    if( pend > poff )
 8003a5a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003a5c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8003a5e:	429a      	cmp	r2, r3
 8003a60:	dd07      	ble.n	8003a72 <decodeFrame+0xea>
        port = d[poff++];
 8003a62:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8003a64:	1c5a      	adds	r2, r3, #1
 8003a66:	65fa      	str	r2, [r7, #92]	; 0x5c
 8003a68:	001a      	movs	r2, r3
 8003a6a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003a6c:	189b      	adds	r3, r3, r2
 8003a6e:	781b      	ldrb	r3, [r3, #0]
 8003a70:	65bb      	str	r3, [r7, #88]	; 0x58
    seqno = LMIC.seqnoDn + (u2_t)(seqno - LMIC.seqnoDn);
 8003a72:	4a9b      	ldr	r2, [pc, #620]	; (8003ce0 <decodeFrame+0x358>)
 8003a74:	238c      	movs	r3, #140	; 0x8c
 8003a76:	005b      	lsls	r3, r3, #1
 8003a78:	58d3      	ldr	r3, [r2, r3]
 8003a7a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003a7c:	b291      	uxth	r1, r2
 8003a7e:	4898      	ldr	r0, [pc, #608]	; (8003ce0 <decodeFrame+0x358>)
 8003a80:	228c      	movs	r2, #140	; 0x8c
 8003a82:	0052      	lsls	r2, r2, #1
 8003a84:	5882      	ldr	r2, [r0, r2]
 8003a86:	b292      	uxth	r2, r2
 8003a88:	1a8a      	subs	r2, r1, r2
 8003a8a:	b292      	uxth	r2, r2
 8003a8c:	189b      	adds	r3, r3, r2
 8003a8e:	637b      	str	r3, [r7, #52]	; 0x34
    if( !aes_verifyMic(LMIC.nwkKey, LMIC.devaddr, seqno, /*dn*/1, d, pend) ) {
 8003a90:	4a93      	ldr	r2, [pc, #588]	; (8003ce0 <decodeFrame+0x358>)
 8003a92:	238a      	movs	r3, #138	; 0x8a
 8003a94:	005b      	lsls	r3, r3, #1
 8003a96:	58d1      	ldr	r1, [r2, r3]
 8003a98:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003a9a:	4892      	ldr	r0, [pc, #584]	; (8003ce4 <decodeFrame+0x35c>)
 8003a9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003a9e:	9301      	str	r3, [sp, #4]
 8003aa0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003aa2:	9300      	str	r3, [sp, #0]
 8003aa4:	2301      	movs	r3, #1
 8003aa6:	f7fe fe1f 	bl	80026e8 <aes_verifyMic>
 8003aaa:	1e03      	subs	r3, r0, #0
 8003aac:	d098      	beq.n	80039e0 <decodeFrame+0x58>
    if( seqno < LMIC.seqnoDn ) {
 8003aae:	4a8c      	ldr	r2, [pc, #560]	; (8003ce0 <decodeFrame+0x358>)
 8003ab0:	238c      	movs	r3, #140	; 0x8c
 8003ab2:	005b      	lsls	r3, r3, #1
 8003ab4:	58d3      	ldr	r3, [r2, r3]
 8003ab6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003ab8:	429a      	cmp	r2, r3
 8003aba:	d21f      	bcs.n	8003afc <decodeFrame+0x174>
        if( (s4_t)seqno > (s4_t)LMIC.seqnoDn ) {
 8003abc:	4a88      	ldr	r2, [pc, #544]	; (8003ce0 <decodeFrame+0x358>)
 8003abe:	238c      	movs	r3, #140	; 0x8c
 8003ac0:	005b      	lsls	r3, r3, #1
 8003ac2:	58d3      	ldr	r3, [r2, r3]
 8003ac4:	001a      	movs	r2, r3
 8003ac6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003ac8:	429a      	cmp	r2, r3
 8003aca:	db8b      	blt.n	80039e4 <decodeFrame+0x5c>
        if( seqno != LMIC.seqnoDn-1 || !LMIC.dnConf || ftype != HDR_FTYPE_DCDN ) {
 8003acc:	4a84      	ldr	r2, [pc, #528]	; (8003ce0 <decodeFrame+0x358>)
 8003ace:	238c      	movs	r3, #140	; 0x8c
 8003ad0:	005b      	lsls	r3, r3, #1
 8003ad2:	58d3      	ldr	r3, [r2, r3]
 8003ad4:	3b01      	subs	r3, #1
 8003ad6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003ad8:	429a      	cmp	r2, r3
 8003ada:	d185      	bne.n	80039e8 <decodeFrame+0x60>
 8003adc:	4a80      	ldr	r2, [pc, #512]	; (8003ce0 <decodeFrame+0x358>)
 8003ade:	2390      	movs	r3, #144	; 0x90
 8003ae0:	005b      	lsls	r3, r3, #1
 8003ae2:	5cd3      	ldrb	r3, [r2, r3]
 8003ae4:	2b00      	cmp	r3, #0
 8003ae6:	d100      	bne.n	8003aea <decodeFrame+0x162>
 8003ae8:	e77e      	b.n	80039e8 <decodeFrame+0x60>
 8003aea:	2346      	movs	r3, #70	; 0x46
 8003aec:	18fb      	adds	r3, r7, r3
 8003aee:	781b      	ldrb	r3, [r3, #0]
 8003af0:	2ba0      	cmp	r3, #160	; 0xa0
 8003af2:	d000      	beq.n	8003af6 <decodeFrame+0x16e>
 8003af4:	e778      	b.n	80039e8 <decodeFrame+0x60>
        }
        // Replay of previous sequence number allowed only if
        // previous frame and repeated both requested confirmation
        replayConf = 1;
 8003af6:	2301      	movs	r3, #1
 8003af8:	657b      	str	r3, [r7, #84]	; 0x54
 8003afa:	e011      	b.n	8003b20 <decodeFrame+0x198>
            EV(specCond, INFO, (e_.reason = EV::specCond_t::DNSEQNO_SKIP,
                                e_.eui    = MAIN::CDEV->getEui(),
                                e_.info   = LMIC.seqnoDn, 
                                e_.info2  = seqno));
        }
        LMIC.seqnoDn = seqno+1;  // next number to be expected
 8003afc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003afe:	1c59      	adds	r1, r3, #1
 8003b00:	4a77      	ldr	r2, [pc, #476]	; (8003ce0 <decodeFrame+0x358>)
 8003b02:	238c      	movs	r3, #140	; 0x8c
 8003b04:	005b      	lsls	r3, r3, #1
 8003b06:	50d1      	str	r1, [r2, r3]
        DO_DEVDB(LMIC.seqnoDn,seqnoDn);
        // DN frame requested confirmation - provide ACK once with next UP frame
        LMIC.dnConf = (ftype == HDR_FTYPE_DCDN ? FCT_ACK : 0);
 8003b08:	2346      	movs	r3, #70	; 0x46
 8003b0a:	18fb      	adds	r3, r7, r3
 8003b0c:	781b      	ldrb	r3, [r3, #0]
 8003b0e:	2ba0      	cmp	r3, #160	; 0xa0
 8003b10:	d101      	bne.n	8003b16 <decodeFrame+0x18e>
 8003b12:	2120      	movs	r1, #32
 8003b14:	e000      	b.n	8003b18 <decodeFrame+0x190>
 8003b16:	2100      	movs	r1, #0
 8003b18:	4a71      	ldr	r2, [pc, #452]	; (8003ce0 <decodeFrame+0x358>)
 8003b1a:	2390      	movs	r3, #144	; 0x90
 8003b1c:	005b      	lsls	r3, r3, #1
 8003b1e:	54d1      	strb	r1, [r2, r3]
    }

    if( LMIC.dnConf || (fct & FCT_MORE) )
 8003b20:	4a6f      	ldr	r2, [pc, #444]	; (8003ce0 <decodeFrame+0x358>)
 8003b22:	2390      	movs	r3, #144	; 0x90
 8003b24:	005b      	lsls	r3, r3, #1
 8003b26:	5cd3      	ldrb	r3, [r2, r3]
 8003b28:	2b00      	cmp	r3, #0
 8003b2a:	d103      	bne.n	8003b34 <decodeFrame+0x1ac>
 8003b2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003b2e:	2210      	movs	r2, #16
 8003b30:	4013      	ands	r3, r2
 8003b32:	d008      	beq.n	8003b46 <decodeFrame+0x1be>
        LMIC.opmode |= OP_POLL;
 8003b34:	4b6a      	ldr	r3, [pc, #424]	; (8003ce0 <decodeFrame+0x358>)
 8003b36:	22ac      	movs	r2, #172	; 0xac
 8003b38:	5a9b      	ldrh	r3, [r3, r2]
 8003b3a:	2210      	movs	r2, #16
 8003b3c:	4313      	orrs	r3, r2
 8003b3e:	b299      	uxth	r1, r3
 8003b40:	4b67      	ldr	r3, [pc, #412]	; (8003ce0 <decodeFrame+0x358>)
 8003b42:	22ac      	movs	r2, #172	; 0xac
 8003b44:	5299      	strh	r1, [r3, r2]

    // We heard from network
    LMIC.adrChanged = LMIC.rejoinCnt = 0;
 8003b46:	4b66      	ldr	r3, [pc, #408]	; (8003ce0 <decodeFrame+0x358>)
 8003b48:	22b2      	movs	r2, #178	; 0xb2
 8003b4a:	2100      	movs	r1, #0
 8003b4c:	5499      	strb	r1, [r3, r2]
 8003b4e:	4b64      	ldr	r3, [pc, #400]	; (8003ce0 <decodeFrame+0x358>)
 8003b50:	22b2      	movs	r2, #178	; 0xb2
 8003b52:	5c99      	ldrb	r1, [r3, r2]
 8003b54:	4a62      	ldr	r2, [pc, #392]	; (8003ce0 <decodeFrame+0x358>)
 8003b56:	2391      	movs	r3, #145	; 0x91
 8003b58:	005b      	lsls	r3, r3, #1
 8003b5a:	54d1      	strb	r1, [r2, r3]
    if( LMIC.adrAckReq != LINK_CHECK_OFF )
 8003b5c:	4a60      	ldr	r2, [pc, #384]	; (8003ce0 <decodeFrame+0x358>)
 8003b5e:	2322      	movs	r3, #34	; 0x22
 8003b60:	33ff      	adds	r3, #255	; 0xff
 8003b62:	56d3      	ldrsb	r3, [r2, r3]
 8003b64:	3380      	adds	r3, #128	; 0x80
 8003b66:	d004      	beq.n	8003b72 <decodeFrame+0x1ea>
        LMIC.adrAckReq = LINK_CHECK_INIT;
 8003b68:	4a5d      	ldr	r2, [pc, #372]	; (8003ce0 <decodeFrame+0x358>)
 8003b6a:	2322      	movs	r3, #34	; 0x22
 8003b6c:	33ff      	adds	r3, #255	; 0xff
 8003b6e:	21f4      	movs	r1, #244	; 0xf4
 8003b70:	54d1      	strb	r1, [r2, r3]

    // Process OPTS
    int m = LMIC.rssi - RSSI_OFF - getSensitivity(LMIC.rps);
 8003b72:	4b5b      	ldr	r3, [pc, #364]	; (8003ce0 <decodeFrame+0x358>)
 8003b74:	7b1b      	ldrb	r3, [r3, #12]
 8003b76:	b25b      	sxtb	r3, r3
 8003b78:	3b40      	subs	r3, #64	; 0x40
 8003b7a:	001c      	movs	r4, r3
 8003b7c:	4b58      	ldr	r3, [pc, #352]	; (8003ce0 <decodeFrame+0x358>)
 8003b7e:	89db      	ldrh	r3, [r3, #14]
 8003b80:	0018      	movs	r0, r3
 8003b82:	f7fe fee7 	bl	8002954 <getSensitivity>
 8003b86:	0003      	movs	r3, r0
 8003b88:	1ae3      	subs	r3, r4, r3
 8003b8a:	627b      	str	r3, [r7, #36]	; 0x24
    LMIC.margin = m < 0 ? 0 : m > 254 ? 254 : m;
 8003b8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b8e:	2b00      	cmp	r3, #0
 8003b90:	db05      	blt.n	8003b9e <decodeFrame+0x216>
 8003b92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003b94:	2bfe      	cmp	r3, #254	; 0xfe
 8003b96:	dd00      	ble.n	8003b9a <decodeFrame+0x212>
 8003b98:	23fe      	movs	r3, #254	; 0xfe
 8003b9a:	b2d9      	uxtb	r1, r3
 8003b9c:	e000      	b.n	8003ba0 <decodeFrame+0x218>
 8003b9e:	2100      	movs	r1, #0
 8003ba0:	4a4f      	ldr	r2, [pc, #316]	; (8003ce0 <decodeFrame+0x358>)
 8003ba2:	2392      	movs	r3, #146	; 0x92
 8003ba4:	005b      	lsls	r3, r3, #1
 8003ba6:	54d1      	strb	r1, [r2, r3]

    xref2u1_t opts = &d[OFF_DAT_OPTS];
 8003ba8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003baa:	3308      	adds	r3, #8
 8003bac:	623b      	str	r3, [r7, #32]
    int oidx = 0;
 8003bae:	2300      	movs	r3, #0
 8003bb0:	653b      	str	r3, [r7, #80]	; 0x50
    while( oidx < olen ) {
 8003bb2:	e1d4      	b.n	8003f5e <decodeFrame+0x5d6>
        switch( opts[oidx] ) {
 8003bb4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003bb6:	6a3a      	ldr	r2, [r7, #32]
 8003bb8:	18d3      	adds	r3, r2, r3
 8003bba:	781b      	ldrb	r3, [r3, #0]
 8003bbc:	2b12      	cmp	r3, #18
 8003bbe:	d900      	bls.n	8003bc2 <decodeFrame+0x23a>
 8003bc0:	e1d3      	b.n	8003f6a <decodeFrame+0x5e2>
 8003bc2:	009a      	lsls	r2, r3, #2
 8003bc4:	4b48      	ldr	r3, [pc, #288]	; (8003ce8 <decodeFrame+0x360>)
 8003bc6:	18d3      	adds	r3, r2, r3
 8003bc8:	681b      	ldr	r3, [r3, #0]
 8003bca:	469f      	mov	pc, r3
        case MCMD_LCHK_ANS: {
            //int gwmargin = opts[oidx+1];
            //int ngws = opts[oidx+2];
            oidx += 3;
 8003bcc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003bce:	3303      	adds	r3, #3
 8003bd0:	653b      	str	r3, [r7, #80]	; 0x50
            continue;
 8003bd2:	e1c4      	b.n	8003f5e <decodeFrame+0x5d6>
        }
        case MCMD_LADR_REQ: {
            u1_t p1     = opts[oidx+1];            // txpow + DR
 8003bd4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003bd6:	3301      	adds	r3, #1
 8003bd8:	6a3a      	ldr	r2, [r7, #32]
 8003bda:	18d2      	adds	r2, r2, r3
 8003bdc:	230a      	movs	r3, #10
 8003bde:	18fb      	adds	r3, r7, r3
 8003be0:	7812      	ldrb	r2, [r2, #0]
 8003be2:	701a      	strb	r2, [r3, #0]
            u2_t chmap  = os_rlsbf2(&opts[oidx+2]);// list of enabled channels
 8003be4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003be6:	3302      	adds	r3, #2
 8003be8:	6a3a      	ldr	r2, [r7, #32]
 8003bea:	18d3      	adds	r3, r2, r3
 8003bec:	2508      	movs	r5, #8
 8003bee:	197c      	adds	r4, r7, r5
 8003bf0:	0018      	movs	r0, r3
 8003bf2:	f7fe fc48 	bl	8002486 <os_rlsbf2>
 8003bf6:	0003      	movs	r3, r0
 8003bf8:	8023      	strh	r3, [r4, #0]
            u1_t chpage = opts[oidx+4] & MCMD_LADR_CHPAGE_MASK;     // channel page
 8003bfa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003bfc:	3304      	adds	r3, #4
 8003bfe:	6a3a      	ldr	r2, [r7, #32]
 8003c00:	18d3      	adds	r3, r2, r3
 8003c02:	781a      	ldrb	r2, [r3, #0]
 8003c04:	1dfb      	adds	r3, r7, #7
 8003c06:	210f      	movs	r1, #15
 8003c08:	438a      	bics	r2, r1
 8003c0a:	701a      	strb	r2, [r3, #0]
            u1_t uprpt  = opts[oidx+4] & MCMD_LADR_REPEAT_MASK;     // up repeat count
 8003c0c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003c0e:	3304      	adds	r3, #4
 8003c10:	6a3a      	ldr	r2, [r7, #32]
 8003c12:	18d3      	adds	r3, r2, r3
 8003c14:	781a      	ldrb	r2, [r3, #0]
 8003c16:	1dbb      	adds	r3, r7, #6
 8003c18:	210f      	movs	r1, #15
 8003c1a:	400a      	ands	r2, r1
 8003c1c:	701a      	strb	r2, [r3, #0]
            oidx += 5;
 8003c1e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003c20:	3305      	adds	r3, #5
 8003c22:	653b      	str	r3, [r7, #80]	; 0x50

            LMIC.ladrAns = 0x80 |     // Include an answer into next frame up
 8003c24:	4a2e      	ldr	r2, [pc, #184]	; (8003ce0 <decodeFrame+0x358>)
 8003c26:	2326      	movs	r3, #38	; 0x26
 8003c28:	33ff      	adds	r3, #255	; 0xff
 8003c2a:	2187      	movs	r1, #135	; 0x87
 8003c2c:	54d1      	strb	r1, [r2, r3]
                MCMD_LADR_ANS_POWACK | MCMD_LADR_ANS_CHACK | MCMD_LADR_ANS_DRACK;
            if( !mapChannels(chpage, chmap) )
 8003c2e:	197b      	adds	r3, r7, r5
 8003c30:	881a      	ldrh	r2, [r3, #0]
 8003c32:	1dfb      	adds	r3, r7, #7
 8003c34:	781b      	ldrb	r3, [r3, #0]
 8003c36:	0011      	movs	r1, r2
 8003c38:	0018      	movs	r0, r3
 8003c3a:	f7ff fb17 	bl	800326c <mapChannels>
 8003c3e:	1e03      	subs	r3, r0, #0
 8003c40:	d10a      	bne.n	8003c58 <decodeFrame+0x2d0>
                LMIC.ladrAns &= ~MCMD_LADR_ANS_CHACK;
 8003c42:	4a27      	ldr	r2, [pc, #156]	; (8003ce0 <decodeFrame+0x358>)
 8003c44:	2326      	movs	r3, #38	; 0x26
 8003c46:	33ff      	adds	r3, #255	; 0xff
 8003c48:	5cd3      	ldrb	r3, [r2, r3]
 8003c4a:	2201      	movs	r2, #1
 8003c4c:	4393      	bics	r3, r2
 8003c4e:	b2d9      	uxtb	r1, r3
 8003c50:	4a23      	ldr	r2, [pc, #140]	; (8003ce0 <decodeFrame+0x358>)
 8003c52:	2326      	movs	r3, #38	; 0x26
 8003c54:	33ff      	adds	r3, #255	; 0xff
 8003c56:	54d1      	strb	r1, [r2, r3]
            dr_t dr = (dr_t)(p1>>MCMD_LADR_DR_SHIFT);
 8003c58:	1d7b      	adds	r3, r7, #5
 8003c5a:	220a      	movs	r2, #10
 8003c5c:	18ba      	adds	r2, r7, r2
 8003c5e:	7812      	ldrb	r2, [r2, #0]
 8003c60:	0912      	lsrs	r2, r2, #4
 8003c62:	701a      	strb	r2, [r3, #0]
            if( !validDR(dr) ) {
 8003c64:	1d7b      	adds	r3, r7, #5
 8003c66:	781b      	ldrb	r3, [r3, #0]
 8003c68:	0018      	movs	r0, r3
 8003c6a:	f7fe fbd7 	bl	800241c <validDR>
 8003c6e:	1e03      	subs	r3, r0, #0
 8003c70:	d10a      	bne.n	8003c88 <decodeFrame+0x300>
                LMIC.ladrAns &= ~MCMD_LADR_ANS_DRACK;
 8003c72:	4a1b      	ldr	r2, [pc, #108]	; (8003ce0 <decodeFrame+0x358>)
 8003c74:	2326      	movs	r3, #38	; 0x26
 8003c76:	33ff      	adds	r3, #255	; 0xff
 8003c78:	5cd3      	ldrb	r3, [r2, r3]
 8003c7a:	2202      	movs	r2, #2
 8003c7c:	4393      	bics	r3, r2
 8003c7e:	b2d9      	uxtb	r1, r3
 8003c80:	4a17      	ldr	r2, [pc, #92]	; (8003ce0 <decodeFrame+0x358>)
 8003c82:	2326      	movs	r3, #38	; 0x26
 8003c84:	33ff      	adds	r3, #255	; 0xff
 8003c86:	54d1      	strb	r1, [r2, r3]
                EV(specCond, ERR, (e_.reason = EV::specCond_t::BAD_MAC_CMD,
                                   e_.eui    = MAIN::CDEV->getEui(),
                                   e_.info   = Base::lsbf4(&d[pend]),
                                   e_.info2  = Base::msbf4(&opts[oidx-4])));
            }
            if( (LMIC.ladrAns & 0x7F) == (MCMD_LADR_ANS_POWACK | MCMD_LADR_ANS_CHACK | MCMD_LADR_ANS_DRACK) ) {
 8003c88:	4a15      	ldr	r2, [pc, #84]	; (8003ce0 <decodeFrame+0x358>)
 8003c8a:	2326      	movs	r3, #38	; 0x26
 8003c8c:	33ff      	adds	r3, #255	; 0xff
 8003c8e:	5cd3      	ldrb	r3, [r2, r3]
 8003c90:	001a      	movs	r2, r3
 8003c92:	237f      	movs	r3, #127	; 0x7f
 8003c94:	4013      	ands	r3, r2
 8003c96:	2b07      	cmp	r3, #7
 8003c98:	d111      	bne.n	8003cbe <decodeFrame+0x336>
                // Nothing went wrong - use settings
                LMIC.upRepeat = uprpt;
 8003c9a:	4b11      	ldr	r3, [pc, #68]	; (8003ce0 <decodeFrame+0x358>)
 8003c9c:	1dba      	adds	r2, r7, #6
 8003c9e:	21ae      	movs	r1, #174	; 0xae
 8003ca0:	7812      	ldrb	r2, [r2, #0]
 8003ca2:	545a      	strb	r2, [r3, r1]
                setDrTxpow(DRCHG_NWKCMD, dr, pow2dBm(p1));
 8003ca4:	230a      	movs	r3, #10
 8003ca6:	18fb      	adds	r3, r7, r3
 8003ca8:	781b      	ldrb	r3, [r3, #0]
 8003caa:	220f      	movs	r2, #15
 8003cac:	4013      	ands	r3, r2
 8003cae:	4a0f      	ldr	r2, [pc, #60]	; (8003cec <decodeFrame+0x364>)
 8003cb0:	56d2      	ldrsb	r2, [r2, r3]
 8003cb2:	1d7b      	adds	r3, r7, #5
 8003cb4:	781b      	ldrb	r3, [r3, #0]
 8003cb6:	0019      	movs	r1, r3
 8003cb8:	2004      	movs	r0, #4
 8003cba:	f7ff f95b 	bl	8002f74 <setDrTxpow>
            }
            LMIC.adrChanged = 1;  // Trigger an ACK to NWK
 8003cbe:	4a08      	ldr	r2, [pc, #32]	; (8003ce0 <decodeFrame+0x358>)
 8003cc0:	2391      	movs	r3, #145	; 0x91
 8003cc2:	005b      	lsls	r3, r3, #1
 8003cc4:	2101      	movs	r1, #1
 8003cc6:	54d1      	strb	r1, [r2, r3]
            continue;
 8003cc8:	e149      	b.n	8003f5e <decodeFrame+0x5d6>
        }
        case MCMD_DEVS_REQ: {
            LMIC.devsAns = 1;
 8003cca:	4a05      	ldr	r2, [pc, #20]	; (8003ce0 <decodeFrame+0x358>)
 8003ccc:	2393      	movs	r3, #147	; 0x93
 8003cce:	005b      	lsls	r3, r3, #1
 8003cd0:	2101      	movs	r1, #1
 8003cd2:	54d1      	strb	r1, [r2, r3]
            oidx += 1;
 8003cd4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003cd6:	3301      	adds	r3, #1
 8003cd8:	653b      	str	r3, [r7, #80]	; 0x50
            continue;
 8003cda:	e140      	b.n	8003f5e <decodeFrame+0x5d6>
 8003cdc:	2000046c 	.word	0x2000046c
 8003ce0:	20000324 	.word	0x20000324
 8003ce4:	20000418 	.word	0x20000418
 8003ce8:	0800f174 	.word	0x0800f174
 8003cec:	0800f0f0 	.word	0x0800f0f0
        }
        case MCMD_DN2P_SET: {
            dr_t dr = (dr_t)(opts[oidx+1] & 0x0F);
 8003cf0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003cf2:	3301      	adds	r3, #1
 8003cf4:	6a3a      	ldr	r2, [r7, #32]
 8003cf6:	18d3      	adds	r3, r2, r3
 8003cf8:	781a      	ldrb	r2, [r3, #0]
 8003cfa:	2412      	movs	r4, #18
 8003cfc:	193b      	adds	r3, r7, r4
 8003cfe:	210f      	movs	r1, #15
 8003d00:	400a      	ands	r2, r1
 8003d02:	701a      	strb	r2, [r3, #0]
            u4_t freq = convFreq(&opts[oidx+2]);
 8003d04:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003d06:	3302      	adds	r3, #2
 8003d08:	6a3a      	ldr	r2, [r7, #32]
 8003d0a:	18d3      	adds	r3, r2, r3
 8003d0c:	0018      	movs	r0, r3
 8003d0e:	f7ff fa8b 	bl	8003228 <convFreq>
 8003d12:	0003      	movs	r3, r0
 8003d14:	60fb      	str	r3, [r7, #12]
            oidx += 5;
 8003d16:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003d18:	3305      	adds	r3, #5
 8003d1a:	653b      	str	r3, [r7, #80]	; 0x50
            LMIC.dn2Ans = 0x80;   // answer pending
 8003d1c:	4ace      	ldr	r2, [pc, #824]	; (8004058 <decodeFrame+0x6d0>)
 8003d1e:	2398      	movs	r3, #152	; 0x98
 8003d20:	005b      	lsls	r3, r3, #1
 8003d22:	2180      	movs	r1, #128	; 0x80
 8003d24:	54d1      	strb	r1, [r2, r3]
            if( validDR(dr) )
 8003d26:	193b      	adds	r3, r7, r4
 8003d28:	781b      	ldrb	r3, [r3, #0]
 8003d2a:	0018      	movs	r0, r3
 8003d2c:	f7fe fb76 	bl	800241c <validDR>
 8003d30:	1e03      	subs	r3, r0, #0
 8003d32:	d00a      	beq.n	8003d4a <decodeFrame+0x3c2>
                LMIC.dn2Ans |= MCMD_DN2P_ANS_DRACK;
 8003d34:	4ac8      	ldr	r2, [pc, #800]	; (8004058 <decodeFrame+0x6d0>)
 8003d36:	2398      	movs	r3, #152	; 0x98
 8003d38:	005b      	lsls	r3, r3, #1
 8003d3a:	5cd3      	ldrb	r3, [r2, r3]
 8003d3c:	2202      	movs	r2, #2
 8003d3e:	4313      	orrs	r3, r2
 8003d40:	b2d9      	uxtb	r1, r3
 8003d42:	4ac5      	ldr	r2, [pc, #788]	; (8004058 <decodeFrame+0x6d0>)
 8003d44:	2398      	movs	r3, #152	; 0x98
 8003d46:	005b      	lsls	r3, r3, #1
 8003d48:	54d1      	strb	r1, [r2, r3]
            if( freq != 0 )
 8003d4a:	68fb      	ldr	r3, [r7, #12]
 8003d4c:	2b00      	cmp	r3, #0
 8003d4e:	d00a      	beq.n	8003d66 <decodeFrame+0x3de>
                LMIC.dn2Ans |= MCMD_DN2P_ANS_CHACK;
 8003d50:	4ac1      	ldr	r2, [pc, #772]	; (8004058 <decodeFrame+0x6d0>)
 8003d52:	2398      	movs	r3, #152	; 0x98
 8003d54:	005b      	lsls	r3, r3, #1
 8003d56:	5cd3      	ldrb	r3, [r2, r3]
 8003d58:	2201      	movs	r2, #1
 8003d5a:	4313      	orrs	r3, r2
 8003d5c:	b2d9      	uxtb	r1, r3
 8003d5e:	4abe      	ldr	r2, [pc, #760]	; (8004058 <decodeFrame+0x6d0>)
 8003d60:	2398      	movs	r3, #152	; 0x98
 8003d62:	005b      	lsls	r3, r3, #1
 8003d64:	54d1      	strb	r1, [r2, r3]
            if( LMIC.dn2Ans == (0x80|MCMD_DN2P_ANS_DRACK|MCMD_DN2P_ANS_CHACK) ) {
 8003d66:	4abc      	ldr	r2, [pc, #752]	; (8004058 <decodeFrame+0x6d0>)
 8003d68:	2398      	movs	r3, #152	; 0x98
 8003d6a:	005b      	lsls	r3, r3, #1
 8003d6c:	5cd3      	ldrb	r3, [r2, r3]
 8003d6e:	2b83      	cmp	r3, #131	; 0x83
 8003d70:	d000      	beq.n	8003d74 <decodeFrame+0x3ec>
 8003d72:	e0f4      	b.n	8003f5e <decodeFrame+0x5d6>
                LMIC.dn2Dr = dr;
 8003d74:	4ab8      	ldr	r2, [pc, #736]	; (8004058 <decodeFrame+0x6d0>)
 8003d76:	2312      	movs	r3, #18
 8003d78:	18f9      	adds	r1, r7, r3
 8003d7a:	232c      	movs	r3, #44	; 0x2c
 8003d7c:	33ff      	adds	r3, #255	; 0xff
 8003d7e:	7809      	ldrb	r1, [r1, #0]
 8003d80:	54d1      	strb	r1, [r2, r3]
                LMIC.dn2Freq = freq;
 8003d82:	4ab5      	ldr	r2, [pc, #724]	; (8004058 <decodeFrame+0x6d0>)
 8003d84:	2396      	movs	r3, #150	; 0x96
 8003d86:	005b      	lsls	r3, r3, #1
 8003d88:	68f9      	ldr	r1, [r7, #12]
 8003d8a:	50d1      	str	r1, [r2, r3]
                DO_DEVDB(LMIC.dn2Dr,dn2Dr);
                DO_DEVDB(LMIC.dn2Freq,dn2Freq);
            }
            continue;
 8003d8c:	e0e7      	b.n	8003f5e <decodeFrame+0x5d6>
        }
        case MCMD_DCAP_REQ: {
            u1_t cap = opts[oidx+1];
 8003d8e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003d90:	3301      	adds	r3, #1
 8003d92:	6a3a      	ldr	r2, [r7, #32]
 8003d94:	18d2      	adds	r2, r2, r3
 8003d96:	210b      	movs	r1, #11
 8003d98:	187b      	adds	r3, r7, r1
 8003d9a:	7812      	ldrb	r2, [r2, #0]
 8003d9c:	701a      	strb	r2, [r3, #0]
            oidx += 2;
 8003d9e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003da0:	3302      	adds	r3, #2
 8003da2:	653b      	str	r3, [r7, #80]	; 0x50
            // A value cap=0xFF means device is OFF unless enabled again manually.
            if( cap==0xFF )
 8003da4:	187b      	adds	r3, r7, r1
 8003da6:	781b      	ldrb	r3, [r3, #0]
 8003da8:	2bff      	cmp	r3, #255	; 0xff
 8003daa:	d108      	bne.n	8003dbe <decodeFrame+0x436>
                LMIC.opmode |= OP_SHUTDOWN;  // stop any sending
 8003dac:	4baa      	ldr	r3, [pc, #680]	; (8004058 <decodeFrame+0x6d0>)
 8003dae:	22ac      	movs	r2, #172	; 0xac
 8003db0:	5a9b      	ldrh	r3, [r3, r2]
 8003db2:	2240      	movs	r2, #64	; 0x40
 8003db4:	4313      	orrs	r3, r2
 8003db6:	b299      	uxth	r1, r3
 8003db8:	4ba7      	ldr	r3, [pc, #668]	; (8004058 <decodeFrame+0x6d0>)
 8003dba:	22ac      	movs	r2, #172	; 0xac
 8003dbc:	5299      	strh	r1, [r3, r2]
            LMIC.globalDutyRate  = cap & 0xF;
 8003dbe:	230b      	movs	r3, #11
 8003dc0:	18fb      	adds	r3, r7, r3
 8003dc2:	781b      	ldrb	r3, [r3, #0]
 8003dc4:	220f      	movs	r2, #15
 8003dc6:	4013      	ands	r3, r2
 8003dc8:	b2d9      	uxtb	r1, r3
 8003dca:	4ba3      	ldr	r3, [pc, #652]	; (8004058 <decodeFrame+0x6d0>)
 8003dcc:	22a3      	movs	r2, #163	; 0xa3
 8003dce:	5499      	strb	r1, [r3, r2]
            LMIC.globalDutyAvail = os_getTime();
 8003dd0:	f002 fa7e 	bl	80062d0 <os_getTime>
 8003dd4:	0002      	movs	r2, r0
 8003dd6:	4ba0      	ldr	r3, [pc, #640]	; (8004058 <decodeFrame+0x6d0>)
 8003dd8:	21a4      	movs	r1, #164	; 0xa4
 8003dda:	505a      	str	r2, [r3, r1]
            DO_DEVDB(cap,dutyCap);
            LMIC.dutyCapAns = 1;
 8003ddc:	4a9e      	ldr	r2, [pc, #632]	; (8004058 <decodeFrame+0x6d0>)
 8003dde:	232a      	movs	r3, #42	; 0x2a
 8003de0:	33ff      	adds	r3, #255	; 0xff
 8003de2:	2101      	movs	r1, #1
 8003de4:	54d1      	strb	r1, [r2, r3]
            continue;
 8003de6:	e0ba      	b.n	8003f5e <decodeFrame+0x5d6>
        }
        case MCMD_SNCH_REQ: {
            u1_t chidx = opts[oidx+1];  // channel
 8003de8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003dea:	3301      	adds	r3, #1
 8003dec:	6a3a      	ldr	r2, [r7, #32]
 8003dee:	18d2      	adds	r2, r2, r3
 8003df0:	251b      	movs	r5, #27
 8003df2:	197b      	adds	r3, r7, r5
 8003df4:	7812      	ldrb	r2, [r2, #0]
 8003df6:	701a      	strb	r2, [r3, #0]
            u4_t freq  = convFreq(&opts[oidx+2]); // freq
 8003df8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003dfa:	3302      	adds	r3, #2
 8003dfc:	6a3a      	ldr	r2, [r7, #32]
 8003dfe:	18d3      	adds	r3, r2, r3
 8003e00:	0018      	movs	r0, r3
 8003e02:	f7ff fa11 	bl	8003228 <convFreq>
 8003e06:	0003      	movs	r3, r0
 8003e08:	617b      	str	r3, [r7, #20]
            u1_t drs   = opts[oidx+5];  // datarate span
 8003e0a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003e0c:	3305      	adds	r3, #5
 8003e0e:	6a3a      	ldr	r2, [r7, #32]
 8003e10:	18d2      	adds	r2, r2, r3
 8003e12:	2013      	movs	r0, #19
 8003e14:	183b      	adds	r3, r7, r0
 8003e16:	7812      	ldrb	r2, [r2, #0]
 8003e18:	701a      	strb	r2, [r3, #0]
            LMIC.snchAns = 0x80;
 8003e1a:	4a8f      	ldr	r2, [pc, #572]	; (8004058 <decodeFrame+0x6d0>)
 8003e1c:	2395      	movs	r3, #149	; 0x95
 8003e1e:	005b      	lsls	r3, r3, #1
 8003e20:	2180      	movs	r1, #128	; 0x80
 8003e22:	54d1      	strb	r1, [r2, r3]
            if( freq != 0 && LMIC_setupChannel(chidx, freq, DR_RANGE_MAP(drs&0xF,drs>>4), -1) )
 8003e24:	697b      	ldr	r3, [r7, #20]
 8003e26:	2b00      	cmp	r3, #0
 8003e28:	d02b      	beq.n	8003e82 <decodeFrame+0x4fa>
 8003e2a:	0001      	movs	r1, r0
 8003e2c:	187b      	adds	r3, r7, r1
 8003e2e:	781b      	ldrb	r3, [r3, #0]
 8003e30:	220f      	movs	r2, #15
 8003e32:	4013      	ands	r3, r2
 8003e34:	4a89      	ldr	r2, [pc, #548]	; (800405c <decodeFrame+0x6d4>)
 8003e36:	409a      	lsls	r2, r3
 8003e38:	0013      	movs	r3, r2
 8003e3a:	b21b      	sxth	r3, r3
 8003e3c:	187a      	adds	r2, r7, r1
 8003e3e:	7812      	ldrb	r2, [r2, #0]
 8003e40:	0912      	lsrs	r2, r2, #4
 8003e42:	b2d2      	uxtb	r2, r2
 8003e44:	0011      	movs	r1, r2
 8003e46:	220f      	movs	r2, #15
 8003e48:	1a52      	subs	r2, r2, r1
 8003e4a:	4984      	ldr	r1, [pc, #528]	; (800405c <decodeFrame+0x6d4>)
 8003e4c:	4111      	asrs	r1, r2
 8003e4e:	000a      	movs	r2, r1
 8003e50:	b212      	sxth	r2, r2
 8003e52:	4013      	ands	r3, r2
 8003e54:	b21b      	sxth	r3, r3
 8003e56:	b29a      	uxth	r2, r3
 8003e58:	2301      	movs	r3, #1
 8003e5a:	425c      	negs	r4, r3
 8003e5c:	6979      	ldr	r1, [r7, #20]
 8003e5e:	197b      	adds	r3, r7, r5
 8003e60:	7818      	ldrb	r0, [r3, #0]
 8003e62:	0023      	movs	r3, r4
 8003e64:	f7ff f95a 	bl	800311c <LMIC_setupChannel>
 8003e68:	1e03      	subs	r3, r0, #0
 8003e6a:	d00a      	beq.n	8003e82 <decodeFrame+0x4fa>
                LMIC.snchAns |= MCMD_SNCH_ANS_DRACK|MCMD_SNCH_ANS_FQACK;
 8003e6c:	4a7a      	ldr	r2, [pc, #488]	; (8004058 <decodeFrame+0x6d0>)
 8003e6e:	2395      	movs	r3, #149	; 0x95
 8003e70:	005b      	lsls	r3, r3, #1
 8003e72:	5cd3      	ldrb	r3, [r2, r3]
 8003e74:	2203      	movs	r2, #3
 8003e76:	4313      	orrs	r3, r2
 8003e78:	b2d9      	uxtb	r1, r3
 8003e7a:	4a77      	ldr	r2, [pc, #476]	; (8004058 <decodeFrame+0x6d0>)
 8003e7c:	2395      	movs	r3, #149	; 0x95
 8003e7e:	005b      	lsls	r3, r3, #1
 8003e80:	54d1      	strb	r1, [r2, r3]
            oidx += 6;
 8003e82:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003e84:	3306      	adds	r3, #6
 8003e86:	653b      	str	r3, [r7, #80]	; 0x50
            continue;
 8003e88:	e069      	b.n	8003f5e <decodeFrame+0x5d6>
        }
        case MCMD_PING_SET: {
            u4_t freq = convFreq(&opts[oidx+1]);
 8003e8a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003e8c:	3301      	adds	r3, #1
 8003e8e:	6a3a      	ldr	r2, [r7, #32]
 8003e90:	18d3      	adds	r3, r2, r3
 8003e92:	0018      	movs	r0, r3
 8003e94:	f7ff f9c8 	bl	8003228 <convFreq>
 8003e98:	0003      	movs	r3, r0
 8003e9a:	61fb      	str	r3, [r7, #28]
            oidx += 4;
 8003e9c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003e9e:	3304      	adds	r3, #4
 8003ea0:	653b      	str	r3, [r7, #80]	; 0x50
            u1_t flags = 0x80;
 8003ea2:	214f      	movs	r1, #79	; 0x4f
 8003ea4:	187b      	adds	r3, r7, r1
 8003ea6:	2280      	movs	r2, #128	; 0x80
 8003ea8:	701a      	strb	r2, [r3, #0]
            if( freq != 0 ) {
 8003eaa:	69fb      	ldr	r3, [r7, #28]
 8003eac:	2b00      	cmp	r3, #0
 8003eae:	d00a      	beq.n	8003ec6 <decodeFrame+0x53e>
                flags |= MCMD_PING_ANS_FQACK;
 8003eb0:	187b      	adds	r3, r7, r1
 8003eb2:	187a      	adds	r2, r7, r1
 8003eb4:	7812      	ldrb	r2, [r2, #0]
 8003eb6:	2101      	movs	r1, #1
 8003eb8:	430a      	orrs	r2, r1
 8003eba:	701a      	strb	r2, [r3, #0]
                LMIC.ping.freq = freq;
 8003ebc:	4a66      	ldr	r2, [pc, #408]	; (8004058 <decodeFrame+0x6d0>)
 8003ebe:	23a0      	movs	r3, #160	; 0xa0
 8003ec0:	005b      	lsls	r3, r3, #1
 8003ec2:	69f9      	ldr	r1, [r7, #28]
 8003ec4:	50d1      	str	r1, [r2, r3]
                DO_DEVDB(LMIC.ping.intvExp, pingIntvExp);
                DO_DEVDB(LMIC.ping.freq, pingFreq);
                DO_DEVDB(LMIC.ping.dr, pingDr);
            }
            LMIC.pingSetAns = flags;
 8003ec6:	4a64      	ldr	r2, [pc, #400]	; (8004058 <decodeFrame+0x6d0>)
 8003ec8:	234f      	movs	r3, #79	; 0x4f
 8003eca:	18f9      	adds	r1, r7, r3
 8003ecc:	2334      	movs	r3, #52	; 0x34
 8003ece:	33ff      	adds	r3, #255	; 0xff
 8003ed0:	7809      	ldrb	r1, [r1, #0]
 8003ed2:	54d1      	strb	r1, [r2, r3]
            continue;
 8003ed4:	e043      	b.n	8003f5e <decodeFrame+0x5d6>
        }
        case MCMD_BCNI_ANS: {
            // Ignore if tracking already enabled
            if( (LMIC.opmode & OP_TRACK) == 0 ) {
 8003ed6:	4b60      	ldr	r3, [pc, #384]	; (8004058 <decodeFrame+0x6d0>)
 8003ed8:	22ac      	movs	r2, #172	; 0xac
 8003eda:	5a9b      	ldrh	r3, [r3, r2]
 8003edc:	001a      	movs	r2, r3
 8003ede:	2302      	movs	r3, #2
 8003ee0:	4013      	ands	r3, r2
 8003ee2:	d138      	bne.n	8003f56 <decodeFrame+0x5ce>
                LMIC.bcnChnl = opts[oidx+3];
 8003ee4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003ee6:	3303      	adds	r3, #3
 8003ee8:	6a3a      	ldr	r2, [r7, #32]
 8003eea:	18d3      	adds	r3, r2, r3
 8003eec:	7819      	ldrb	r1, [r3, #0]
 8003eee:	4a5a      	ldr	r2, [pc, #360]	; (8004058 <decodeFrame+0x6d0>)
 8003ef0:	23c4      	movs	r3, #196	; 0xc4
 8003ef2:	005b      	lsls	r3, r3, #1
 8003ef4:	54d1      	strb	r1, [r2, r3]
                // Enable tracking - bcninfoTries
                LMIC.opmode |= OP_TRACK;
 8003ef6:	4b58      	ldr	r3, [pc, #352]	; (8004058 <decodeFrame+0x6d0>)
 8003ef8:	22ac      	movs	r2, #172	; 0xac
 8003efa:	5a9b      	ldrh	r3, [r3, r2]
 8003efc:	2202      	movs	r2, #2
 8003efe:	4313      	orrs	r3, r2
 8003f00:	b299      	uxth	r1, r3
 8003f02:	4b55      	ldr	r3, [pc, #340]	; (8004058 <decodeFrame+0x6d0>)
 8003f04:	22ac      	movs	r2, #172	; 0xac
 8003f06:	5299      	strh	r1, [r3, r2]
                // Cleared later in txComplete handling - triggers EV_BEACON_FOUND
                ASSERT(LMIC.bcninfoTries!=0);
 8003f08:	4a53      	ldr	r2, [pc, #332]	; (8004058 <decodeFrame+0x6d0>)
 8003f0a:	2399      	movs	r3, #153	; 0x99
 8003f0c:	005b      	lsls	r3, r3, #1
 8003f0e:	5cd3      	ldrb	r3, [r2, r3]
 8003f10:	2b00      	cmp	r3, #0
 8003f12:	d101      	bne.n	8003f18 <decodeFrame+0x590>
 8003f14:	f7fe f99a 	bl	800224c <hal_failed>
                // Setup RX parameters
                LMIC.bcninfo.txtime = (LMIC.rxtime
 8003f18:	4b4f      	ldr	r3, [pc, #316]	; (8004058 <decodeFrame+0x6d0>)
 8003f1a:	685c      	ldr	r4, [r3, #4]
                                       + ms2osticks(os_rlsbf2(&opts[oidx+1]) * MCMD_BCNI_TUNIT)
 8003f1c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003f1e:	3301      	adds	r3, #1
 8003f20:	6a3a      	ldr	r2, [r7, #32]
 8003f22:	18d3      	adds	r3, r2, r3
 8003f24:	0018      	movs	r0, r3
 8003f26:	f7fe faae 	bl	8002486 <os_rlsbf2>
 8003f2a:	0003      	movs	r3, r0
 8003f2c:	001a      	movs	r2, r3
 8003f2e:	0013      	movs	r3, r2
 8003f30:	011b      	lsls	r3, r3, #4
 8003f32:	1a9b      	subs	r3, r3, r2
 8003f34:	019b      	lsls	r3, r3, #6
 8003f36:	18e3      	adds	r3, r4, r3
                                       + ms2osticksCeil(MCMD_BCNI_TUNIT/2)
                                       - BCN_INTV_osticks);
 8003f38:	4a49      	ldr	r2, [pc, #292]	; (8004060 <decodeFrame+0x6d8>)
 8003f3a:	1899      	adds	r1, r3, r2
                LMIC.bcninfo.txtime = (LMIC.rxtime
 8003f3c:	4a46      	ldr	r2, [pc, #280]	; (8004058 <decodeFrame+0x6d0>)
 8003f3e:	23c8      	movs	r3, #200	; 0xc8
 8003f40:	005b      	lsls	r3, r3, #1
 8003f42:	50d1      	str	r1, [r2, r3]
                LMIC.bcninfo.flags = 0;  // txtime above cannot be used as reference (BCN_PARTIAL|BCN_FULL cleared)
 8003f44:	4a44      	ldr	r2, [pc, #272]	; (8004058 <decodeFrame+0x6d0>)
 8003f46:	23cb      	movs	r3, #203	; 0xcb
 8003f48:	005b      	lsls	r3, r3, #1
 8003f4a:	2100      	movs	r1, #0
 8003f4c:	54d1      	strb	r1, [r2, r3]
                calcBcnRxWindowFromMillis(MCMD_BCNI_TUNIT,1);  // error of +/-N ms 
 8003f4e:	2101      	movs	r1, #1
 8003f50:	201e      	movs	r0, #30
 8003f52:	f7fe fe41 	bl	8002bd8 <calcBcnRxWindowFromMillis>
                                     e_.info    = (LMIC.missedBcns |
                                                   (osticks2us(LMIC.bcninfo.txtime + BCN_INTV_osticks
                                                               - LMIC.bcnRxtime) << 8)),
                                     e_.time    = MAIN::CDEV->ostime2ustime(LMIC.bcninfo.txtime + BCN_INTV_osticks)));
            }
            oidx += 4;
 8003f56:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003f58:	3304      	adds	r3, #4
 8003f5a:	653b      	str	r3, [r7, #80]	; 0x50
            continue;
 8003f5c:	46c0      	nop			; (mov r8, r8)
    while( oidx < olen ) {
 8003f5e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8003f60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003f62:	429a      	cmp	r2, r3
 8003f64:	da00      	bge.n	8003f68 <decodeFrame+0x5e0>
 8003f66:	e625      	b.n	8003bb4 <decodeFrame+0x22c>
 8003f68:	e000      	b.n	8003f6c <decodeFrame+0x5e4>
        }
        EV(specCond, ERR, (e_.reason = EV::specCond_t::BAD_MAC_CMD,
                           e_.eui    = MAIN::CDEV->getEui(),
                           e_.info   = Base::lsbf4(&d[pend]),
                           e_.info2  = Base::msbf4(&opts[oidx])));
        break;
 8003f6a:	46c0      	nop			; (mov r8, r8)
        EV(specCond, ERR, (e_.reason = EV::specCond_t::CORRUPTED_FRAME,
                           e_.eui    = MAIN::CDEV->getEui(),
                           e_.info   = 0x1000000 + (oidx) + (olen<<8)));
    }

    if( !replayConf ) {
 8003f6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8003f6e:	2b00      	cmp	r3, #0
 8003f70:	d11f      	bne.n	8003fb2 <decodeFrame+0x62a>
        // Handle payload only if not a replay
        // Decrypt payload - if any
        if( port >= 0  &&  pend-poff > 0 )
 8003f72:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8003f74:	2b00      	cmp	r3, #0
 8003f76:	db1c      	blt.n	8003fb2 <decodeFrame+0x62a>
 8003f78:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003f7a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8003f7c:	1ad3      	subs	r3, r2, r3
 8003f7e:	2b00      	cmp	r3, #0
 8003f80:	dd17      	ble.n	8003fb2 <decodeFrame+0x62a>
            aes_cipher(port <= 0 ? LMIC.nwkKey : LMIC.artKey, LMIC.devaddr, seqno, /*dn*/1, d+poff, pend-poff);
 8003f82:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8003f84:	2b00      	cmp	r3, #0
 8003f86:	dc01      	bgt.n	8003f8c <decodeFrame+0x604>
 8003f88:	4836      	ldr	r0, [pc, #216]	; (8004064 <decodeFrame+0x6dc>)
 8003f8a:	e000      	b.n	8003f8e <decodeFrame+0x606>
 8003f8c:	4836      	ldr	r0, [pc, #216]	; (8004068 <decodeFrame+0x6e0>)
 8003f8e:	4a32      	ldr	r2, [pc, #200]	; (8004058 <decodeFrame+0x6d0>)
 8003f90:	238a      	movs	r3, #138	; 0x8a
 8003f92:	005b      	lsls	r3, r3, #1
 8003f94:	58d4      	ldr	r4, [r2, r3]
 8003f96:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8003f98:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8003f9a:	18d3      	adds	r3, r2, r3
 8003f9c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8003f9e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8003fa0:	1a8a      	subs	r2, r1, r2
 8003fa2:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8003fa4:	9201      	str	r2, [sp, #4]
 8003fa6:	9300      	str	r3, [sp, #0]
 8003fa8:	2301      	movs	r3, #1
 8003faa:	000a      	movs	r2, r1
 8003fac:	0021      	movs	r1, r4
 8003fae:	f7fe fc45 	bl	800283c <aes_cipher>
                           e_.eui    = MAIN::CDEV->getEui(),
                           e_.info   = seqno,
                           e_.info2  = ackup));
    }

    if( LMIC.txCnt != 0 ) // we requested an ACK
 8003fb2:	4a29      	ldr	r2, [pc, #164]	; (8004058 <decodeFrame+0x6d0>)
 8003fb4:	23a2      	movs	r3, #162	; 0xa2
 8003fb6:	005b      	lsls	r3, r3, #1
 8003fb8:	5cd3      	ldrb	r3, [r2, r3]
 8003fba:	2b00      	cmp	r3, #0
 8003fbc:	d012      	beq.n	8003fe4 <decodeFrame+0x65c>
        LMIC.txrxFlags |= ackup ? TXRX_ACK : TXRX_NACK;
 8003fbe:	4a26      	ldr	r2, [pc, #152]	; (8004058 <decodeFrame+0x6d0>)
 8003fc0:	2346      	movs	r3, #70	; 0x46
 8003fc2:	33ff      	adds	r3, #255	; 0xff
 8003fc4:	5cd3      	ldrb	r3, [r2, r3]
 8003fc6:	b25a      	sxtb	r2, r3
 8003fc8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003fca:	2b00      	cmp	r3, #0
 8003fcc:	d002      	beq.n	8003fd4 <decodeFrame+0x64c>
 8003fce:	2380      	movs	r3, #128	; 0x80
 8003fd0:	425b      	negs	r3, r3
 8003fd2:	e000      	b.n	8003fd6 <decodeFrame+0x64e>
 8003fd4:	2340      	movs	r3, #64	; 0x40
 8003fd6:	4313      	orrs	r3, r2
 8003fd8:	b25b      	sxtb	r3, r3
 8003fda:	b2d9      	uxtb	r1, r3
 8003fdc:	4a1e      	ldr	r2, [pc, #120]	; (8004058 <decodeFrame+0x6d0>)
 8003fde:	2346      	movs	r3, #70	; 0x46
 8003fe0:	33ff      	adds	r3, #255	; 0xff
 8003fe2:	54d1      	strb	r1, [r2, r3]

    if( port < 0 ) {
 8003fe4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8003fe6:	2b00      	cmp	r3, #0
 8003fe8:	da16      	bge.n	8004018 <decodeFrame+0x690>
        LMIC.txrxFlags |= TXRX_NOPORT;
 8003fea:	4a1b      	ldr	r2, [pc, #108]	; (8004058 <decodeFrame+0x6d0>)
 8003fec:	2346      	movs	r3, #70	; 0x46
 8003fee:	33ff      	adds	r3, #255	; 0xff
 8003ff0:	5cd3      	ldrb	r3, [r2, r3]
 8003ff2:	2220      	movs	r2, #32
 8003ff4:	4313      	orrs	r3, r2
 8003ff6:	b2d9      	uxtb	r1, r3
 8003ff8:	4a17      	ldr	r2, [pc, #92]	; (8004058 <decodeFrame+0x6d0>)
 8003ffa:	2346      	movs	r3, #70	; 0x46
 8003ffc:	33ff      	adds	r3, #255	; 0xff
 8003ffe:	54d1      	strb	r1, [r2, r3]
        LMIC.dataBeg = poff;
 8004000:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004002:	b2d9      	uxtb	r1, r3
 8004004:	4a14      	ldr	r2, [pc, #80]	; (8004058 <decodeFrame+0x6d0>)
 8004006:	23a3      	movs	r3, #163	; 0xa3
 8004008:	005b      	lsls	r3, r3, #1
 800400a:	54d1      	strb	r1, [r2, r3]
        LMIC.dataLen = 0;
 800400c:	4a12      	ldr	r2, [pc, #72]	; (8004058 <decodeFrame+0x6d0>)
 800400e:	2348      	movs	r3, #72	; 0x48
 8004010:	33ff      	adds	r3, #255	; 0xff
 8004012:	2100      	movs	r1, #0
 8004014:	54d1      	strb	r1, [r2, r3]
 8004016:	e01a      	b.n	800404e <decodeFrame+0x6c6>
    } else {
        LMIC.txrxFlags |= TXRX_PORT;
 8004018:	4a0f      	ldr	r2, [pc, #60]	; (8004058 <decodeFrame+0x6d0>)
 800401a:	2346      	movs	r3, #70	; 0x46
 800401c:	33ff      	adds	r3, #255	; 0xff
 800401e:	5cd3      	ldrb	r3, [r2, r3]
 8004020:	2210      	movs	r2, #16
 8004022:	4313      	orrs	r3, r2
 8004024:	b2d9      	uxtb	r1, r3
 8004026:	4a0c      	ldr	r2, [pc, #48]	; (8004058 <decodeFrame+0x6d0>)
 8004028:	2346      	movs	r3, #70	; 0x46
 800402a:	33ff      	adds	r3, #255	; 0xff
 800402c:	54d1      	strb	r1, [r2, r3]
        LMIC.dataBeg = poff;
 800402e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004030:	b2d9      	uxtb	r1, r3
 8004032:	4a09      	ldr	r2, [pc, #36]	; (8004058 <decodeFrame+0x6d0>)
 8004034:	23a3      	movs	r3, #163	; 0xa3
 8004036:	005b      	lsls	r3, r3, #1
 8004038:	54d1      	strb	r1, [r2, r3]
        LMIC.dataLen = pend-poff;
 800403a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800403c:	b2da      	uxtb	r2, r3
 800403e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004040:	b2db      	uxtb	r3, r3
 8004042:	1ad3      	subs	r3, r2, r3
 8004044:	b2d9      	uxtb	r1, r3
 8004046:	4a04      	ldr	r2, [pc, #16]	; (8004058 <decodeFrame+0x6d0>)
 8004048:	2348      	movs	r3, #72	; 0x48
 800404a:	33ff      	adds	r3, #255	; 0xff
 800404c:	54d1      	strb	r1, [r2, r3]
    }
    return 1;
 800404e:	2301      	movs	r3, #1
}
 8004050:	0018      	movs	r0, r3
 8004052:	46bd      	mov	sp, r7
 8004054:	b018      	add	sp, #96	; 0x60
 8004056:	bdb0      	pop	{r4, r5, r7, pc}
 8004058:	20000324 	.word	0x20000324
 800405c:	0000ffff 	.word	0x0000ffff
 8004060:	ffc181e0 	.word	0xffc181e0
 8004064:	20000418 	.word	0x20000418
 8004068:	20000428 	.word	0x20000428

0800406c <setupRx2>:

// ================================================================================
// TX/RX transaction support


static void setupRx2 (void) {
 800406c:	b580      	push	{r7, lr}
 800406e:	af00      	add	r7, sp, #0
    LMIC.txrxFlags = TXRX_DNW2;
 8004070:	4a10      	ldr	r2, [pc, #64]	; (80040b4 <setupRx2+0x48>)
 8004072:	2346      	movs	r3, #70	; 0x46
 8004074:	33ff      	adds	r3, #255	; 0xff
 8004076:	2102      	movs	r1, #2
 8004078:	54d1      	strb	r1, [r2, r3]
    LMIC.rps = dndr2rps(LMIC.dn2Dr);
 800407a:	4a0e      	ldr	r2, [pc, #56]	; (80040b4 <setupRx2+0x48>)
 800407c:	232c      	movs	r3, #44	; 0x2c
 800407e:	33ff      	adds	r3, #255	; 0xff
 8004080:	5cd3      	ldrb	r3, [r2, r3]
 8004082:	0018      	movs	r0, r3
 8004084:	f7fe f99a 	bl	80023bc <dndr2rps>
 8004088:	0003      	movs	r3, r0
 800408a:	001a      	movs	r2, r3
 800408c:	4b09      	ldr	r3, [pc, #36]	; (80040b4 <setupRx2+0x48>)
 800408e:	81da      	strh	r2, [r3, #14]
    LMIC.freq = LMIC.dn2Freq;
 8004090:	4a08      	ldr	r2, [pc, #32]	; (80040b4 <setupRx2+0x48>)
 8004092:	2396      	movs	r3, #150	; 0x96
 8004094:	005b      	lsls	r3, r3, #1
 8004096:	58d2      	ldr	r2, [r2, r3]
 8004098:	4b06      	ldr	r3, [pc, #24]	; (80040b4 <setupRx2+0x48>)
 800409a:	609a      	str	r2, [r3, #8]
    LMIC.dataLen = 0;
 800409c:	4a05      	ldr	r2, [pc, #20]	; (80040b4 <setupRx2+0x48>)
 800409e:	2348      	movs	r3, #72	; 0x48
 80040a0:	33ff      	adds	r3, #255	; 0xff
 80040a2:	2100      	movs	r1, #0
 80040a4:	54d1      	strb	r1, [r2, r3]
    os_radio(RADIO_RX);
 80040a6:	2002      	movs	r0, #2
 80040a8:	f002 ffc6 	bl	8007038 <os_radio>
}
 80040ac:	46c0      	nop			; (mov r8, r8)
 80040ae:	46bd      	mov	sp, r7
 80040b0:	bd80      	pop	{r7, pc}
 80040b2:	46c0      	nop			; (mov r8, r8)
 80040b4:	20000324 	.word	0x20000324

080040b8 <schedRx2>:


static void schedRx2 (ostime_t delay, osjobcb_t func) {
 80040b8:	b580      	push	{r7, lr}
 80040ba:	b082      	sub	sp, #8
 80040bc:	af00      	add	r7, sp, #0
 80040be:	6078      	str	r0, [r7, #4]
 80040c0:	6039      	str	r1, [r7, #0]
    // Add 1.5 symbols we need 5 out of 8. Try to sync 1.5 symbols into the preamble.
    LMIC.rxtime = LMIC.txend + delay + (PAMBL_SYMS-MINRX_SYMS)*dr2hsym(LMIC.dn2Dr);
 80040c2:	4b0f      	ldr	r3, [pc, #60]	; (8004100 <schedRx2+0x48>)
 80040c4:	681a      	ldr	r2, [r3, #0]
 80040c6:	687b      	ldr	r3, [r7, #4]
 80040c8:	18d1      	adds	r1, r2, r3
 80040ca:	4a0d      	ldr	r2, [pc, #52]	; (8004100 <schedRx2+0x48>)
 80040cc:	232c      	movs	r3, #44	; 0x2c
 80040ce:	33ff      	adds	r3, #255	; 0xff
 80040d0:	5cd3      	ldrb	r3, [r2, r3]
 80040d2:	001a      	movs	r2, r3
 80040d4:	4b0b      	ldr	r3, [pc, #44]	; (8004104 <schedRx2+0x4c>)
 80040d6:	0092      	lsls	r2, r2, #2
 80040d8:	58d2      	ldr	r2, [r2, r3]
 80040da:	0013      	movs	r3, r2
 80040dc:	005b      	lsls	r3, r3, #1
 80040de:	189b      	adds	r3, r3, r2
 80040e0:	18ca      	adds	r2, r1, r3
 80040e2:	4b07      	ldr	r3, [pc, #28]	; (8004100 <schedRx2+0x48>)
 80040e4:	605a      	str	r2, [r3, #4]
    os_setTimedCallback(&LMIC.osjob, LMIC.rxtime - RX_RAMPUP, func);
 80040e6:	4b06      	ldr	r3, [pc, #24]	; (8004100 <schedRx2+0x48>)
 80040e8:	685b      	ldr	r3, [r3, #4]
 80040ea:	3b40      	subs	r3, #64	; 0x40
 80040ec:	0019      	movs	r1, r3
 80040ee:	683a      	ldr	r2, [r7, #0]
 80040f0:	4b05      	ldr	r3, [pc, #20]	; (8004108 <schedRx2+0x50>)
 80040f2:	0018      	movs	r0, r3
 80040f4:	f002 f95a 	bl	80063ac <os_setTimedCallback>
}
 80040f8:	46c0      	nop			; (mov r8, r8)
 80040fa:	46bd      	mov	sp, r7
 80040fc:	b002      	add	sp, #8
 80040fe:	bd80      	pop	{r7, pc}
 8004100:	20000324 	.word	0x20000324
 8004104:	0800f124 	.word	0x0800f124
 8004108:	20000338 	.word	0x20000338

0800410c <setupRx1>:

static void setupRx1 (osjobcb_t func) {
 800410c:	b580      	push	{r7, lr}
 800410e:	b082      	sub	sp, #8
 8004110:	af00      	add	r7, sp, #0
 8004112:	6078      	str	r0, [r7, #4]
    LMIC.txrxFlags = TXRX_DNW1;
 8004114:	4a0e      	ldr	r2, [pc, #56]	; (8004150 <setupRx1+0x44>)
 8004116:	2346      	movs	r3, #70	; 0x46
 8004118:	33ff      	adds	r3, #255	; 0xff
 800411a:	2101      	movs	r1, #1
 800411c:	54d1      	strb	r1, [r2, r3]
    // Turn LMIC.rps from TX over to RX
    LMIC.rps = setNocrc(LMIC.rps,1);
 800411e:	4b0c      	ldr	r3, [pc, #48]	; (8004150 <setupRx1+0x44>)
 8004120:	89db      	ldrh	r3, [r3, #14]
 8004122:	2101      	movs	r1, #1
 8004124:	0018      	movs	r0, r3
 8004126:	f7fe f8f7 	bl	8002318 <setNocrc>
 800412a:	0003      	movs	r3, r0
 800412c:	001a      	movs	r2, r3
 800412e:	4b08      	ldr	r3, [pc, #32]	; (8004150 <setupRx1+0x44>)
 8004130:	81da      	strh	r2, [r3, #14]
    LMIC.dataLen = 0;
 8004132:	4a07      	ldr	r2, [pc, #28]	; (8004150 <setupRx1+0x44>)
 8004134:	2348      	movs	r3, #72	; 0x48
 8004136:	33ff      	adds	r3, #255	; 0xff
 8004138:	2100      	movs	r1, #0
 800413a:	54d1      	strb	r1, [r2, r3]
    LMIC.osjob.func = func;
 800413c:	4b04      	ldr	r3, [pc, #16]	; (8004150 <setupRx1+0x44>)
 800413e:	687a      	ldr	r2, [r7, #4]
 8004140:	61da      	str	r2, [r3, #28]
    os_radio(RADIO_RX);
 8004142:	2002      	movs	r0, #2
 8004144:	f002 ff78 	bl	8007038 <os_radio>
}
 8004148:	46c0      	nop			; (mov r8, r8)
 800414a:	46bd      	mov	sp, r7
 800414c:	b002      	add	sp, #8
 800414e:	bd80      	pop	{r7, pc}
 8004150:	20000324 	.word	0x20000324

08004154 <txDone>:


// Called by HAL once TX complete and delivers exact end of TX time stamp in LMIC.rxtime
static void txDone (ostime_t delay, osjobcb_t func) {
 8004154:	b580      	push	{r7, lr}
 8004156:	b082      	sub	sp, #8
 8004158:	af00      	add	r7, sp, #0
 800415a:	6078      	str	r0, [r7, #4]
 800415c:	6039      	str	r1, [r7, #0]
    if( (LMIC.opmode & (OP_TRACK|OP_PINGABLE|OP_PINGINI)) == (OP_TRACK|OP_PINGABLE) ) {
 800415e:	4b23      	ldr	r3, [pc, #140]	; (80041ec <txDone+0x98>)
 8004160:	22ac      	movs	r2, #172	; 0xac
 8004162:	5a9b      	ldrh	r3, [r3, r2]
 8004164:	001a      	movs	r2, r3
 8004166:	4b22      	ldr	r3, [pc, #136]	; (80041f0 <txDone+0x9c>)
 8004168:	4013      	ands	r3, r2
 800416a:	4a22      	ldr	r2, [pc, #136]	; (80041f4 <txDone+0xa0>)
 800416c:	4293      	cmp	r3, r2
 800416e:	d10d      	bne.n	800418c <txDone+0x38>
        rxschedInit(&LMIC.ping);    // note: reuses LMIC.frame buffer!
 8004170:	4b21      	ldr	r3, [pc, #132]	; (80041f8 <txDone+0xa4>)
 8004172:	0018      	movs	r0, r3
 8004174:	f7fe fd9c 	bl	8002cb0 <rxschedInit>
        LMIC.opmode |= OP_PINGINI;
 8004178:	4b1c      	ldr	r3, [pc, #112]	; (80041ec <txDone+0x98>)
 800417a:	22ac      	movs	r2, #172	; 0xac
 800417c:	5a9b      	ldrh	r3, [r3, r2]
 800417e:	2280      	movs	r2, #128	; 0x80
 8004180:	0092      	lsls	r2, r2, #2
 8004182:	4313      	orrs	r3, r2
 8004184:	b299      	uxth	r1, r3
 8004186:	4b19      	ldr	r3, [pc, #100]	; (80041ec <txDone+0x98>)
 8004188:	22ac      	movs	r2, #172	; 0xac
 800418a:	5299      	strh	r1, [r3, r2]
    setRx1Params();
    // LMIC.rxsyms carries the TX datarate (can be != LMIC.datarate [confirm retries etc.])
    // Setup receive - LMIC.rxtime is preloaded with 1.5 symbols offset to tune
    // into the middle of the 8 symbols preamble.
#if defined(CFG_eu868)
    if( /* TX datarate */LMIC.rxsyms == DR_FSK ) {
 800418c:	4b17      	ldr	r3, [pc, #92]	; (80041ec <txDone+0x98>)
 800418e:	7c1b      	ldrb	r3, [r3, #16]
 8004190:	2b07      	cmp	r3, #7
 8004192:	d10a      	bne.n	80041aa <txDone+0x56>
        LMIC.rxtime = LMIC.txend + delay - PRERX_FSK*us2osticksRound(160);
 8004194:	4b15      	ldr	r3, [pc, #84]	; (80041ec <txDone+0x98>)
 8004196:	681a      	ldr	r2, [r3, #0]
 8004198:	687b      	ldr	r3, [r7, #4]
 800419a:	18d3      	adds	r3, r2, r3
 800419c:	1f5a      	subs	r2, r3, #5
 800419e:	4b13      	ldr	r3, [pc, #76]	; (80041ec <txDone+0x98>)
 80041a0:	605a      	str	r2, [r3, #4]
        LMIC.rxsyms = RXLEN_FSK;
 80041a2:	4b12      	ldr	r3, [pc, #72]	; (80041ec <txDone+0x98>)
 80041a4:	2208      	movs	r2, #8
 80041a6:	741a      	strb	r2, [r3, #16]
 80041a8:	e012      	b.n	80041d0 <txDone+0x7c>
    }
    else
#endif
    {
        LMIC.rxtime = LMIC.txend + delay + (PAMBL_SYMS-MINRX_SYMS)*dr2hsym(LMIC.dndr);
 80041aa:	4b10      	ldr	r3, [pc, #64]	; (80041ec <txDone+0x98>)
 80041ac:	681a      	ldr	r2, [r3, #0]
 80041ae:	687b      	ldr	r3, [r7, #4]
 80041b0:	18d1      	adds	r1, r2, r3
 80041b2:	4b0e      	ldr	r3, [pc, #56]	; (80041ec <txDone+0x98>)
 80041b4:	7c5b      	ldrb	r3, [r3, #17]
 80041b6:	001a      	movs	r2, r3
 80041b8:	4b10      	ldr	r3, [pc, #64]	; (80041fc <txDone+0xa8>)
 80041ba:	0092      	lsls	r2, r2, #2
 80041bc:	58d2      	ldr	r2, [r2, r3]
 80041be:	0013      	movs	r3, r2
 80041c0:	005b      	lsls	r3, r3, #1
 80041c2:	189b      	adds	r3, r3, r2
 80041c4:	18ca      	adds	r2, r1, r3
 80041c6:	4b09      	ldr	r3, [pc, #36]	; (80041ec <txDone+0x98>)
 80041c8:	605a      	str	r2, [r3, #4]
        LMIC.rxsyms = MINRX_SYMS;
 80041ca:	4b08      	ldr	r3, [pc, #32]	; (80041ec <txDone+0x98>)
 80041cc:	2205      	movs	r2, #5
 80041ce:	741a      	strb	r2, [r3, #16]
    }
    os_setTimedCallback(&LMIC.osjob, LMIC.rxtime - RX_RAMPUP, func);
 80041d0:	4b06      	ldr	r3, [pc, #24]	; (80041ec <txDone+0x98>)
 80041d2:	685b      	ldr	r3, [r3, #4]
 80041d4:	3b40      	subs	r3, #64	; 0x40
 80041d6:	0019      	movs	r1, r3
 80041d8:	683a      	ldr	r2, [r7, #0]
 80041da:	4b09      	ldr	r3, [pc, #36]	; (8004200 <txDone+0xac>)
 80041dc:	0018      	movs	r0, r3
 80041de:	f002 f8e5 	bl	80063ac <os_setTimedCallback>
}
 80041e2:	46c0      	nop			; (mov r8, r8)
 80041e4:	46bd      	mov	sp, r7
 80041e6:	b002      	add	sp, #8
 80041e8:	bd80      	pop	{r7, pc}
 80041ea:	46c0      	nop			; (mov r8, r8)
 80041ec:	20000324 	.word	0x20000324
 80041f0:	00000602 	.word	0x00000602
 80041f4:	00000402 	.word	0x00000402
 80041f8:	20000458 	.word	0x20000458
 80041fc:	0800f124 	.word	0x0800f124
 8004200:	20000338 	.word	0x20000338

08004204 <onJoinFailed>:


// ======================================== Join frames


static void onJoinFailed (xref2osjob_t osjob) {
 8004204:	b580      	push	{r7, lr}
 8004206:	b082      	sub	sp, #8
 8004208:	af00      	add	r7, sp, #0
 800420a:	6078      	str	r0, [r7, #4]
    // Notify app - must call LMIC_reset() to stop joining
    // otherwise join procedure continues.
    reportEvent(EV_JOIN_FAILED);
 800420c:	2008      	movs	r0, #8
 800420e:	f7ff fa79 	bl	8003704 <reportEvent>
}
 8004212:	46c0      	nop			; (mov r8, r8)
 8004214:	46bd      	mov	sp, r7
 8004216:	b002      	add	sp, #8
 8004218:	bd80      	pop	{r7, pc}
	...

0800421c <processJoinAccept>:


static bit_t processJoinAccept (void) {
 800421c:	b590      	push	{r4, r7, lr}
 800421e:	b087      	sub	sp, #28
 8004220:	af00      	add	r7, sp, #0
    ASSERT(LMIC.txrxFlags != TXRX_DNW1 || LMIC.dataLen != 0);
 8004222:	4ab1      	ldr	r2, [pc, #708]	; (80044e8 <processJoinAccept+0x2cc>)
 8004224:	2346      	movs	r3, #70	; 0x46
 8004226:	33ff      	adds	r3, #255	; 0xff
 8004228:	5cd3      	ldrb	r3, [r2, r3]
 800422a:	2b01      	cmp	r3, #1
 800422c:	d107      	bne.n	800423e <processJoinAccept+0x22>
 800422e:	4aae      	ldr	r2, [pc, #696]	; (80044e8 <processJoinAccept+0x2cc>)
 8004230:	2348      	movs	r3, #72	; 0x48
 8004232:	33ff      	adds	r3, #255	; 0xff
 8004234:	5cd3      	ldrb	r3, [r2, r3]
 8004236:	2b00      	cmp	r3, #0
 8004238:	d101      	bne.n	800423e <processJoinAccept+0x22>
 800423a:	f7fe f807 	bl	800224c <hal_failed>
    ASSERT((LMIC.opmode & OP_TXRXPEND)!=0);
 800423e:	4baa      	ldr	r3, [pc, #680]	; (80044e8 <processJoinAccept+0x2cc>)
 8004240:	22ac      	movs	r2, #172	; 0xac
 8004242:	5a9b      	ldrh	r3, [r3, r2]
 8004244:	001a      	movs	r2, r3
 8004246:	2380      	movs	r3, #128	; 0x80
 8004248:	4013      	ands	r3, r2
 800424a:	d101      	bne.n	8004250 <processJoinAccept+0x34>
 800424c:	f7fd fffe 	bl	800224c <hal_failed>

    if( LMIC.dataLen == 0 ) {
 8004250:	4aa5      	ldr	r2, [pc, #660]	; (80044e8 <processJoinAccept+0x2cc>)
 8004252:	2348      	movs	r3, #72	; 0x48
 8004254:	33ff      	adds	r3, #255	; 0xff
 8004256:	5cd3      	ldrb	r3, [r2, r3]
 8004258:	2b00      	cmp	r3, #0
 800425a:	d14c      	bne.n	80042f6 <processJoinAccept+0xda>
      nojoinframe:
 800425c:	46c0      	nop			; (mov r8, r8)
 800425e:	e000      	b.n	8004262 <processJoinAccept+0x46>
                           e_.info   = dlen < 4 ? 0 : mic,
                           e_.info2  = hdr + (dlen<<8)));
      badframe:
        if( (LMIC.txrxFlags & TXRX_DNW1) != 0 )
            return 0;
        goto nojoinframe;
 8004260:	46c0      	nop			; (mov r8, r8)
        if( (LMIC.opmode & OP_JOINING) == 0 ) {
 8004262:	4ba1      	ldr	r3, [pc, #644]	; (80044e8 <processJoinAccept+0x2cc>)
 8004264:	22ac      	movs	r2, #172	; 0xac
 8004266:	5a9b      	ldrh	r3, [r3, r2]
 8004268:	001a      	movs	r2, r3
 800426a:	2304      	movs	r3, #4
 800426c:	4013      	ands	r3, r2
 800426e:	d123      	bne.n	80042b8 <processJoinAccept+0x9c>
            ASSERT((LMIC.opmode & OP_REJOIN) != 0);
 8004270:	4b9d      	ldr	r3, [pc, #628]	; (80044e8 <processJoinAccept+0x2cc>)
 8004272:	22ac      	movs	r2, #172	; 0xac
 8004274:	5a9b      	ldrh	r3, [r3, r2]
 8004276:	001a      	movs	r2, r3
 8004278:	2320      	movs	r3, #32
 800427a:	4013      	ands	r3, r2
 800427c:	d101      	bne.n	8004282 <processJoinAccept+0x66>
 800427e:	f7fd ffe5 	bl	800224c <hal_failed>
            LMIC.opmode &= ~(OP_REJOIN|OP_TXRXPEND);
 8004282:	4b99      	ldr	r3, [pc, #612]	; (80044e8 <processJoinAccept+0x2cc>)
 8004284:	22ac      	movs	r2, #172	; 0xac
 8004286:	5a9b      	ldrh	r3, [r3, r2]
 8004288:	22a0      	movs	r2, #160	; 0xa0
 800428a:	4393      	bics	r3, r2
 800428c:	b299      	uxth	r1, r3
 800428e:	4b96      	ldr	r3, [pc, #600]	; (80044e8 <processJoinAccept+0x2cc>)
 8004290:	22ac      	movs	r2, #172	; 0xac
 8004292:	5299      	strh	r1, [r3, r2]
            if( LMIC.rejoinCnt < 10 )
 8004294:	4b94      	ldr	r3, [pc, #592]	; (80044e8 <processJoinAccept+0x2cc>)
 8004296:	22b2      	movs	r2, #178	; 0xb2
 8004298:	5c9b      	ldrb	r3, [r3, r2]
 800429a:	2b09      	cmp	r3, #9
 800429c:	d807      	bhi.n	80042ae <processJoinAccept+0x92>
                LMIC.rejoinCnt++;
 800429e:	4b92      	ldr	r3, [pc, #584]	; (80044e8 <processJoinAccept+0x2cc>)
 80042a0:	22b2      	movs	r2, #178	; 0xb2
 80042a2:	5c9b      	ldrb	r3, [r3, r2]
 80042a4:	3301      	adds	r3, #1
 80042a6:	b2d9      	uxtb	r1, r3
 80042a8:	4b8f      	ldr	r3, [pc, #572]	; (80044e8 <processJoinAccept+0x2cc>)
 80042aa:	22b2      	movs	r2, #178	; 0xb2
 80042ac:	5499      	strb	r1, [r3, r2]
            reportEvent(EV_REJOIN_FAILED);
 80042ae:	2009      	movs	r0, #9
 80042b0:	f7ff fa28 	bl	8003704 <reportEvent>
            return 1;
 80042b4:	2301      	movs	r3, #1
 80042b6:	e113      	b.n	80044e0 <processJoinAccept+0x2c4>
        LMIC.opmode &= ~OP_TXRXPEND;
 80042b8:	4b8b      	ldr	r3, [pc, #556]	; (80044e8 <processJoinAccept+0x2cc>)
 80042ba:	22ac      	movs	r2, #172	; 0xac
 80042bc:	5a9b      	ldrh	r3, [r3, r2]
 80042be:	2280      	movs	r2, #128	; 0x80
 80042c0:	4393      	bics	r3, r2
 80042c2:	b299      	uxth	r1, r3
 80042c4:	4b88      	ldr	r3, [pc, #544]	; (80044e8 <processJoinAccept+0x2cc>)
 80042c6:	22ac      	movs	r2, #172	; 0xac
 80042c8:	5299      	strh	r1, [r3, r2]
        ostime_t delay = nextJoinState();
 80042ca:	f7ff f9a1 	bl	8003610 <nextJoinState>
 80042ce:	0003      	movs	r3, r0
 80042d0:	607b      	str	r3, [r7, #4]
        os_setTimedCallback(&LMIC.osjob, os_getTime()+delay,
 80042d2:	f001 fffd 	bl	80062d0 <os_getTime>
 80042d6:	0002      	movs	r2, r0
 80042d8:	687b      	ldr	r3, [r7, #4]
 80042da:	18d1      	adds	r1, r2, r3
                            (delay&1) != 0
 80042dc:	687b      	ldr	r3, [r7, #4]
 80042de:	2201      	movs	r2, #1
 80042e0:	4013      	ands	r3, r2
        os_setTimedCallback(&LMIC.osjob, os_getTime()+delay,
 80042e2:	d001      	beq.n	80042e8 <processJoinAccept+0xcc>
 80042e4:	4b81      	ldr	r3, [pc, #516]	; (80044ec <processJoinAccept+0x2d0>)
 80042e6:	e000      	b.n	80042ea <processJoinAccept+0xce>
 80042e8:	4b81      	ldr	r3, [pc, #516]	; (80044f0 <processJoinAccept+0x2d4>)
 80042ea:	4882      	ldr	r0, [pc, #520]	; (80044f4 <processJoinAccept+0x2d8>)
 80042ec:	001a      	movs	r2, r3
 80042ee:	f002 f85d 	bl	80063ac <os_setTimedCallback>
        return 1;
 80042f2:	2301      	movs	r3, #1
 80042f4:	e0f4      	b.n	80044e0 <processJoinAccept+0x2c4>
    u1_t hdr  = LMIC.frame[0];
 80042f6:	2315      	movs	r3, #21
 80042f8:	18fb      	adds	r3, r7, r3
 80042fa:	497b      	ldr	r1, [pc, #492]	; (80044e8 <processJoinAccept+0x2cc>)
 80042fc:	22a4      	movs	r2, #164	; 0xa4
 80042fe:	0052      	lsls	r2, r2, #1
 8004300:	5c8a      	ldrb	r2, [r1, r2]
 8004302:	701a      	strb	r2, [r3, #0]
    u1_t dlen = LMIC.dataLen;
 8004304:	2417      	movs	r4, #23
 8004306:	193b      	adds	r3, r7, r4
 8004308:	4977      	ldr	r1, [pc, #476]	; (80044e8 <processJoinAccept+0x2cc>)
 800430a:	2248      	movs	r2, #72	; 0x48
 800430c:	32ff      	adds	r2, #255	; 0xff
 800430e:	5c8a      	ldrb	r2, [r1, r2]
 8004310:	701a      	strb	r2, [r3, #0]
    u4_t mic  = os_rlsbf4(&LMIC.frame[dlen-4]); // safe before modified by encrypt!
 8004312:	193b      	adds	r3, r7, r4
 8004314:	781b      	ldrb	r3, [r3, #0]
 8004316:	3b04      	subs	r3, #4
 8004318:	3349      	adds	r3, #73	; 0x49
 800431a:	33ff      	adds	r3, #255	; 0xff
 800431c:	001a      	movs	r2, r3
 800431e:	4b72      	ldr	r3, [pc, #456]	; (80044e8 <processJoinAccept+0x2cc>)
 8004320:	18d3      	adds	r3, r2, r3
 8004322:	0018      	movs	r0, r3
 8004324:	f7fe f8c2 	bl	80024ac <os_rlsbf4>
 8004328:	0003      	movs	r3, r0
 800432a:	613b      	str	r3, [r7, #16]
    if( (dlen != LEN_JA && dlen != LEN_JAEXT)
 800432c:	193b      	adds	r3, r7, r4
 800432e:	781b      	ldrb	r3, [r3, #0]
 8004330:	2b11      	cmp	r3, #17
 8004332:	d003      	beq.n	800433c <processJoinAccept+0x120>
 8004334:	193b      	adds	r3, r7, r4
 8004336:	781b      	ldrb	r3, [r3, #0]
 8004338:	2b21      	cmp	r3, #33	; 0x21
 800433a:	d106      	bne.n	800434a <processJoinAccept+0x12e>
        || (hdr & (HDR_FTYPE|HDR_MAJOR)) != (HDR_FTYPE_JACC|HDR_MAJOR_V1) ) {
 800433c:	2315      	movs	r3, #21
 800433e:	18fb      	adds	r3, r7, r3
 8004340:	781b      	ldrb	r3, [r3, #0]
 8004342:	22e3      	movs	r2, #227	; 0xe3
 8004344:	4013      	ands	r3, r2
 8004346:	2b20      	cmp	r3, #32
 8004348:	d00d      	beq.n	8004366 <processJoinAccept+0x14a>
      badframe:
 800434a:	46c0      	nop			; (mov r8, r8)
 800434c:	e000      	b.n	8004350 <processJoinAccept+0x134>
    }
    aes_encrypt(LMIC.frame+1, dlen-1);
    if( !aes_verifyMic0(LMIC.frame, dlen-4) ) {
        EV(specCond, ERR, (e_.reason = EV::specCond_t::JOIN_BAD_MIC,
                           e_.info   = mic));
        goto badframe;
 800434e:	46c0      	nop			; (mov r8, r8)
        if( (LMIC.txrxFlags & TXRX_DNW1) != 0 )
 8004350:	4a65      	ldr	r2, [pc, #404]	; (80044e8 <processJoinAccept+0x2cc>)
 8004352:	2346      	movs	r3, #70	; 0x46
 8004354:	33ff      	adds	r3, #255	; 0xff
 8004356:	5cd3      	ldrb	r3, [r2, r3]
 8004358:	001a      	movs	r2, r3
 800435a:	2301      	movs	r3, #1
 800435c:	4013      	ands	r3, r2
 800435e:	d100      	bne.n	8004362 <processJoinAccept+0x146>
 8004360:	e77e      	b.n	8004260 <processJoinAccept+0x44>
            return 0;
 8004362:	2300      	movs	r3, #0
 8004364:	e0bc      	b.n	80044e0 <processJoinAccept+0x2c4>
    aes_encrypt(LMIC.frame+1, dlen-1);
 8004366:	4a64      	ldr	r2, [pc, #400]	; (80044f8 <processJoinAccept+0x2dc>)
 8004368:	2417      	movs	r4, #23
 800436a:	193b      	adds	r3, r7, r4
 800436c:	781b      	ldrb	r3, [r3, #0]
 800436e:	3b01      	subs	r3, #1
 8004370:	0019      	movs	r1, r3
 8004372:	0010      	movs	r0, r2
 8004374:	f7fe fa4c 	bl	8002810 <aes_encrypt>
    if( !aes_verifyMic0(LMIC.frame, dlen-4) ) {
 8004378:	193b      	adds	r3, r7, r4
 800437a:	781b      	ldrb	r3, [r3, #0]
 800437c:	1f1a      	subs	r2, r3, #4
 800437e:	4b5f      	ldr	r3, [pc, #380]	; (80044fc <processJoinAccept+0x2e0>)
 8004380:	0011      	movs	r1, r2
 8004382:	0018      	movs	r0, r3
 8004384:	f7fe fa22 	bl	80027cc <aes_verifyMic0>
 8004388:	1e03      	subs	r3, r0, #0
 800438a:	d0e0      	beq.n	800434e <processJoinAccept+0x132>
    }

    u4_t addr = os_rlsbf4(LMIC.frame+OFF_JA_DEVADDR);
 800438c:	4b5c      	ldr	r3, [pc, #368]	; (8004500 <processJoinAccept+0x2e4>)
 800438e:	0018      	movs	r0, r3
 8004390:	f7fe f88c 	bl	80024ac <os_rlsbf4>
 8004394:	0003      	movs	r3, r0
 8004396:	60fb      	str	r3, [r7, #12]
    LMIC.devaddr = addr;
 8004398:	4a53      	ldr	r2, [pc, #332]	; (80044e8 <processJoinAccept+0x2cc>)
 800439a:	238a      	movs	r3, #138	; 0x8a
 800439c:	005b      	lsls	r3, r3, #1
 800439e:	68f9      	ldr	r1, [r7, #12]
 80043a0:	50d1      	str	r1, [r2, r3]
    LMIC.netid = os_rlsbf4(&LMIC.frame[OFF_JA_NETID]) & 0xFFFFFF;
 80043a2:	4b58      	ldr	r3, [pc, #352]	; (8004504 <processJoinAccept+0x2e8>)
 80043a4:	0018      	movs	r0, r3
 80043a6:	f7fe f881 	bl	80024ac <os_rlsbf4>
 80043aa:	0003      	movs	r3, r0
 80043ac:	021b      	lsls	r3, r3, #8
 80043ae:	0a1a      	lsrs	r2, r3, #8
 80043b0:	4b4d      	ldr	r3, [pc, #308]	; (80044e8 <processJoinAccept+0x2cc>)
 80043b2:	21a8      	movs	r1, #168	; 0xa8
 80043b4:	505a      	str	r2, [r3, r1]

#if defined(CFG_eu868)
    initDefaultChannels(0);
 80043b6:	2000      	movs	r0, #0
 80043b8:	f7fe fe12 	bl	8002fe0 <initDefaultChannels>
#endif
    if( dlen > LEN_JA ) {
 80043bc:	193b      	adds	r3, r7, r4
 80043be:	781b      	ldrb	r3, [r3, #0]
 80043c0:	2b11      	cmp	r3, #17
 80043c2:	d932      	bls.n	800442a <processJoinAccept+0x20e>
#if defined(CFG_us915)
        goto badframe;
#endif
        dlen = OFF_CFLIST;
 80043c4:	193b      	adds	r3, r7, r4
 80043c6:	220d      	movs	r2, #13
 80043c8:	701a      	strb	r2, [r3, #0]
        for( u1_t chidx=3; chidx<8; chidx++, dlen+=3 ) {
 80043ca:	2316      	movs	r3, #22
 80043cc:	18fb      	adds	r3, r7, r3
 80043ce:	2203      	movs	r2, #3
 80043d0:	701a      	strb	r2, [r3, #0]
 80043d2:	e025      	b.n	8004420 <processJoinAccept+0x204>
            u4_t freq = convFreq(&LMIC.frame[dlen]);
 80043d4:	2317      	movs	r3, #23
 80043d6:	18fb      	adds	r3, r7, r3
 80043d8:	781b      	ldrb	r3, [r3, #0]
 80043da:	3349      	adds	r3, #73	; 0x49
 80043dc:	33ff      	adds	r3, #255	; 0xff
 80043de:	001a      	movs	r2, r3
 80043e0:	4b41      	ldr	r3, [pc, #260]	; (80044e8 <processJoinAccept+0x2cc>)
 80043e2:	18d3      	adds	r3, r2, r3
 80043e4:	0018      	movs	r0, r3
 80043e6:	f7fe ff1f 	bl	8003228 <convFreq>
 80043ea:	0003      	movs	r3, r0
 80043ec:	60bb      	str	r3, [r7, #8]
            if( freq )
 80043ee:	68bb      	ldr	r3, [r7, #8]
 80043f0:	2b00      	cmp	r3, #0
 80043f2:	d009      	beq.n	8004408 <processJoinAccept+0x1ec>
                LMIC_setupChannel(chidx, freq, 0, -1);
 80043f4:	2301      	movs	r3, #1
 80043f6:	425a      	negs	r2, r3
 80043f8:	68b9      	ldr	r1, [r7, #8]
 80043fa:	2316      	movs	r3, #22
 80043fc:	18fb      	adds	r3, r7, r3
 80043fe:	7818      	ldrb	r0, [r3, #0]
 8004400:	0013      	movs	r3, r2
 8004402:	2200      	movs	r2, #0
 8004404:	f7fe fe8a 	bl	800311c <LMIC_setupChannel>
        for( u1_t chidx=3; chidx<8; chidx++, dlen+=3 ) {
 8004408:	2116      	movs	r1, #22
 800440a:	187b      	adds	r3, r7, r1
 800440c:	781a      	ldrb	r2, [r3, #0]
 800440e:	187b      	adds	r3, r7, r1
 8004410:	3201      	adds	r2, #1
 8004412:	701a      	strb	r2, [r3, #0]
 8004414:	2217      	movs	r2, #23
 8004416:	18bb      	adds	r3, r7, r2
 8004418:	18ba      	adds	r2, r7, r2
 800441a:	7812      	ldrb	r2, [r2, #0]
 800441c:	3203      	adds	r2, #3
 800441e:	701a      	strb	r2, [r3, #0]
 8004420:	2316      	movs	r3, #22
 8004422:	18fb      	adds	r3, r7, r3
 8004424:	781b      	ldrb	r3, [r3, #0]
 8004426:	2b07      	cmp	r3, #7
 8004428:	d9d4      	bls.n	80043d4 <processJoinAccept+0x1b8>
        }
    }

    // already incremented when JOIN REQ got sent off
    aes_sessKeys(LMIC.devNonce-1, &LMIC.frame[OFF_JA_ARTNONCE], LMIC.nwkKey, LMIC.artKey);
 800442a:	4b2f      	ldr	r3, [pc, #188]	; (80044e8 <processJoinAccept+0x2cc>)
 800442c:	22f2      	movs	r2, #242	; 0xf2
 800442e:	5a9b      	ldrh	r3, [r3, r2]
 8004430:	3b01      	subs	r3, #1
 8004432:	b298      	uxth	r0, r3
 8004434:	4b34      	ldr	r3, [pc, #208]	; (8004508 <processJoinAccept+0x2ec>)
 8004436:	4a35      	ldr	r2, [pc, #212]	; (800450c <processJoinAccept+0x2f0>)
 8004438:	492f      	ldr	r1, [pc, #188]	; (80044f8 <processJoinAccept+0x2dc>)
 800443a:	f7fe fa45 	bl	80028c8 <aes_sessKeys>
                        e_.mic     = mic,
                        e_.reason  = ((LMIC.opmode & OP_REJOIN) != 0
                                      ? EV::joininfo_t::REJOIN_ACCEPT
                                      : EV::joininfo_t::ACCEPT)));
    
    ASSERT((LMIC.opmode & (OP_JOINING|OP_REJOIN))!=0);
 800443e:	4b2a      	ldr	r3, [pc, #168]	; (80044e8 <processJoinAccept+0x2cc>)
 8004440:	22ac      	movs	r2, #172	; 0xac
 8004442:	5a9b      	ldrh	r3, [r3, r2]
 8004444:	001a      	movs	r2, r3
 8004446:	2324      	movs	r3, #36	; 0x24
 8004448:	4013      	ands	r3, r2
 800444a:	d101      	bne.n	8004450 <processJoinAccept+0x234>
 800444c:	f7fd fefe 	bl	800224c <hal_failed>
    if( (LMIC.opmode & OP_REJOIN) != 0 ) {
 8004450:	4b25      	ldr	r3, [pc, #148]	; (80044e8 <processJoinAccept+0x2cc>)
 8004452:	22ac      	movs	r2, #172	; 0xac
 8004454:	5a9b      	ldrh	r3, [r3, r2]
 8004456:	001a      	movs	r2, r3
 8004458:	2320      	movs	r3, #32
 800445a:	4013      	ands	r3, r2
 800445c:	d00e      	beq.n	800447c <processJoinAccept+0x260>
        // Lower DR every try below current UP DR
        LMIC.datarate = lowerDR(LMIC.datarate, LMIC.rejoinCnt);
 800445e:	4b22      	ldr	r3, [pc, #136]	; (80044e8 <processJoinAccept+0x2cc>)
 8004460:	22b0      	movs	r2, #176	; 0xb0
 8004462:	5c9a      	ldrb	r2, [r3, r2]
 8004464:	4b20      	ldr	r3, [pc, #128]	; (80044e8 <processJoinAccept+0x2cc>)
 8004466:	21b2      	movs	r1, #178	; 0xb2
 8004468:	5c5b      	ldrb	r3, [r3, r1]
 800446a:	0019      	movs	r1, r3
 800446c:	0010      	movs	r0, r2
 800446e:	f7fd ffeb 	bl	8002448 <lowerDR>
 8004472:	0003      	movs	r3, r0
 8004474:	0019      	movs	r1, r3
 8004476:	4b1c      	ldr	r3, [pc, #112]	; (80044e8 <processJoinAccept+0x2cc>)
 8004478:	22b0      	movs	r2, #176	; 0xb0
 800447a:	5499      	strb	r1, [r3, r2]
    }
    LMIC.opmode &= ~(OP_JOINING|OP_TRACK|OP_REJOIN|OP_TXRXPEND|OP_PINGINI) | OP_NEXTCHNL;
 800447c:	4b1a      	ldr	r3, [pc, #104]	; (80044e8 <processJoinAccept+0x2cc>)
 800447e:	22ac      	movs	r2, #172	; 0xac
 8004480:	5a9b      	ldrh	r3, [r3, r2]
 8004482:	4a23      	ldr	r2, [pc, #140]	; (8004510 <processJoinAccept+0x2f4>)
 8004484:	4013      	ands	r3, r2
 8004486:	b299      	uxth	r1, r3
 8004488:	4b17      	ldr	r3, [pc, #92]	; (80044e8 <processJoinAccept+0x2cc>)
 800448a:	22ac      	movs	r2, #172	; 0xac
 800448c:	5299      	strh	r1, [r3, r2]
    LMIC.txCnt = 0;
 800448e:	4a16      	ldr	r2, [pc, #88]	; (80044e8 <processJoinAccept+0x2cc>)
 8004490:	23a2      	movs	r3, #162	; 0xa2
 8004492:	005b      	lsls	r3, r3, #1
 8004494:	2100      	movs	r1, #0
 8004496:	54d1      	strb	r1, [r2, r3]
    stateJustJoined();
 8004498:	f7ff f954 	bl	8003744 <stateJustJoined>
    LMIC.dn2Dr = LMIC.frame[OFF_JA_DLSET] & 0x0F;
 800449c:	4a12      	ldr	r2, [pc, #72]	; (80044e8 <processJoinAccept+0x2cc>)
 800449e:	2354      	movs	r3, #84	; 0x54
 80044a0:	33ff      	adds	r3, #255	; 0xff
 80044a2:	5cd3      	ldrb	r3, [r2, r3]
 80044a4:	220f      	movs	r2, #15
 80044a6:	4013      	ands	r3, r2
 80044a8:	b2d9      	uxtb	r1, r3
 80044aa:	4a0f      	ldr	r2, [pc, #60]	; (80044e8 <processJoinAccept+0x2cc>)
 80044ac:	232c      	movs	r3, #44	; 0x2c
 80044ae:	33ff      	adds	r3, #255	; 0xff
 80044b0:	54d1      	strb	r1, [r2, r3]
    LMIC.rxDelay = LMIC.frame[OFF_JA_RXDLY];
 80044b2:	4a0d      	ldr	r2, [pc, #52]	; (80044e8 <processJoinAccept+0x2cc>)
 80044b4:	23aa      	movs	r3, #170	; 0xaa
 80044b6:	005b      	lsls	r3, r3, #1
 80044b8:	5cd1      	ldrb	r1, [r2, r3]
 80044ba:	4a0b      	ldr	r2, [pc, #44]	; (80044e8 <processJoinAccept+0x2cc>)
 80044bc:	2324      	movs	r3, #36	; 0x24
 80044be:	33ff      	adds	r3, #255	; 0xff
 80044c0:	54d1      	strb	r1, [r2, r3]
    if (LMIC.rxDelay == 0) LMIC.rxDelay = 1;   
 80044c2:	4a09      	ldr	r2, [pc, #36]	; (80044e8 <processJoinAccept+0x2cc>)
 80044c4:	2324      	movs	r3, #36	; 0x24
 80044c6:	33ff      	adds	r3, #255	; 0xff
 80044c8:	5cd3      	ldrb	r3, [r2, r3]
 80044ca:	2b00      	cmp	r3, #0
 80044cc:	d104      	bne.n	80044d8 <processJoinAccept+0x2bc>
 80044ce:	4a06      	ldr	r2, [pc, #24]	; (80044e8 <processJoinAccept+0x2cc>)
 80044d0:	2324      	movs	r3, #36	; 0x24
 80044d2:	33ff      	adds	r3, #255	; 0xff
 80044d4:	2101      	movs	r1, #1
 80044d6:	54d1      	strb	r1, [r2, r3]
    reportEvent(EV_JOINED);
 80044d8:	2006      	movs	r0, #6
 80044da:	f7ff f913 	bl	8003704 <reportEvent>
    return 1;
 80044de:	2301      	movs	r3, #1
}
 80044e0:	0018      	movs	r0, r3
 80044e2:	46bd      	mov	sp, r7
 80044e4:	b007      	add	sp, #28
 80044e6:	bd90      	pop	{r4, r7, pc}
 80044e8:	20000324 	.word	0x20000324
 80044ec:	08004205 	.word	0x08004205
 80044f0:	080036f1 	.word	0x080036f1
 80044f4:	20000338 	.word	0x20000338
 80044f8:	2000046d 	.word	0x2000046d
 80044fc:	2000046c 	.word	0x2000046c
 8004500:	20000473 	.word	0x20000473
 8004504:	20000470 	.word	0x20000470
 8004508:	20000428 	.word	0x20000428
 800450c:	20000418 	.word	0x20000418
 8004510:	fffffd59 	.word	0xfffffd59

08004514 <processRx2Jacc>:


static void processRx2Jacc (xref2osjob_t osjob) {
 8004514:	b580      	push	{r7, lr}
 8004516:	b082      	sub	sp, #8
 8004518:	af00      	add	r7, sp, #0
 800451a:	6078      	str	r0, [r7, #4]
    if( LMIC.dataLen == 0 )
 800451c:	4a08      	ldr	r2, [pc, #32]	; (8004540 <processRx2Jacc+0x2c>)
 800451e:	2348      	movs	r3, #72	; 0x48
 8004520:	33ff      	adds	r3, #255	; 0xff
 8004522:	5cd3      	ldrb	r3, [r2, r3]
 8004524:	2b00      	cmp	r3, #0
 8004526:	d104      	bne.n	8004532 <processRx2Jacc+0x1e>
        LMIC.txrxFlags = 0;  // nothing in 1st/2nd DN slot
 8004528:	4a05      	ldr	r2, [pc, #20]	; (8004540 <processRx2Jacc+0x2c>)
 800452a:	2346      	movs	r3, #70	; 0x46
 800452c:	33ff      	adds	r3, #255	; 0xff
 800452e:	2100      	movs	r1, #0
 8004530:	54d1      	strb	r1, [r2, r3]
    processJoinAccept();
 8004532:	f7ff fe73 	bl	800421c <processJoinAccept>
}
 8004536:	46c0      	nop			; (mov r8, r8)
 8004538:	46bd      	mov	sp, r7
 800453a:	b002      	add	sp, #8
 800453c:	bd80      	pop	{r7, pc}
 800453e:	46c0      	nop			; (mov r8, r8)
 8004540:	20000324 	.word	0x20000324

08004544 <setupRx2Jacc>:


static void setupRx2Jacc (xref2osjob_t osjob) {
 8004544:	b580      	push	{r7, lr}
 8004546:	b082      	sub	sp, #8
 8004548:	af00      	add	r7, sp, #0
 800454a:	6078      	str	r0, [r7, #4]
    LMIC.osjob.func = FUNC_ADDR(processRx2Jacc);
 800454c:	4b04      	ldr	r3, [pc, #16]	; (8004560 <setupRx2Jacc+0x1c>)
 800454e:	4a05      	ldr	r2, [pc, #20]	; (8004564 <setupRx2Jacc+0x20>)
 8004550:	61da      	str	r2, [r3, #28]
    setupRx2();
 8004552:	f7ff fd8b 	bl	800406c <setupRx2>
}
 8004556:	46c0      	nop			; (mov r8, r8)
 8004558:	46bd      	mov	sp, r7
 800455a:	b002      	add	sp, #8
 800455c:	bd80      	pop	{r7, pc}
 800455e:	46c0      	nop			; (mov r8, r8)
 8004560:	20000324 	.word	0x20000324
 8004564:	08004515 	.word	0x08004515

08004568 <processRx1Jacc>:


static void processRx1Jacc (xref2osjob_t osjob) {
 8004568:	b580      	push	{r7, lr}
 800456a:	b082      	sub	sp, #8
 800456c:	af00      	add	r7, sp, #0
 800456e:	6078      	str	r0, [r7, #4]
    if( LMIC.dataLen == 0 || !processJoinAccept() )
 8004570:	4a09      	ldr	r2, [pc, #36]	; (8004598 <processRx1Jacc+0x30>)
 8004572:	2348      	movs	r3, #72	; 0x48
 8004574:	33ff      	adds	r3, #255	; 0xff
 8004576:	5cd3      	ldrb	r3, [r2, r3]
 8004578:	2b00      	cmp	r3, #0
 800457a:	d003      	beq.n	8004584 <processRx1Jacc+0x1c>
 800457c:	f7ff fe4e 	bl	800421c <processJoinAccept>
 8004580:	1e03      	subs	r3, r0, #0
 8004582:	d105      	bne.n	8004590 <processRx1Jacc+0x28>
        schedRx2(DELAY_JACC2_osticks, FUNC_ADDR(setupRx2Jacc));
 8004584:	4b05      	ldr	r3, [pc, #20]	; (800459c <processRx1Jacc+0x34>)
 8004586:	4a06      	ldr	r2, [pc, #24]	; (80045a0 <processRx1Jacc+0x38>)
 8004588:	0019      	movs	r1, r3
 800458a:	0010      	movs	r0, r2
 800458c:	f7ff fd94 	bl	80040b8 <schedRx2>
}
 8004590:	46c0      	nop			; (mov r8, r8)
 8004592:	46bd      	mov	sp, r7
 8004594:	b002      	add	sp, #8
 8004596:	bd80      	pop	{r7, pc}
 8004598:	20000324 	.word	0x20000324
 800459c:	08004545 	.word	0x08004545
 80045a0:	0002ee00 	.word	0x0002ee00

080045a4 <setupRx1Jacc>:


static void setupRx1Jacc (xref2osjob_t osjob) {
 80045a4:	b580      	push	{r7, lr}
 80045a6:	b082      	sub	sp, #8
 80045a8:	af00      	add	r7, sp, #0
 80045aa:	6078      	str	r0, [r7, #4]
    setupRx1(FUNC_ADDR(processRx1Jacc));
 80045ac:	4b03      	ldr	r3, [pc, #12]	; (80045bc <setupRx1Jacc+0x18>)
 80045ae:	0018      	movs	r0, r3
 80045b0:	f7ff fdac 	bl	800410c <setupRx1>
}
 80045b4:	46c0      	nop			; (mov r8, r8)
 80045b6:	46bd      	mov	sp, r7
 80045b8:	b002      	add	sp, #8
 80045ba:	bd80      	pop	{r7, pc}
 80045bc:	08004569 	.word	0x08004569

080045c0 <jreqDone>:


static void jreqDone (xref2osjob_t osjob) {
 80045c0:	b580      	push	{r7, lr}
 80045c2:	b082      	sub	sp, #8
 80045c4:	af00      	add	r7, sp, #0
 80045c6:	6078      	str	r0, [r7, #4]
    txDone(DELAY_JACC1_osticks, FUNC_ADDR(setupRx1Jacc));
 80045c8:	4b04      	ldr	r3, [pc, #16]	; (80045dc <jreqDone+0x1c>)
 80045ca:	4a05      	ldr	r2, [pc, #20]	; (80045e0 <jreqDone+0x20>)
 80045cc:	0019      	movs	r1, r3
 80045ce:	0010      	movs	r0, r2
 80045d0:	f7ff fdc0 	bl	8004154 <txDone>
}
 80045d4:	46c0      	nop			; (mov r8, r8)
 80045d6:	46bd      	mov	sp, r7
 80045d8:	b002      	add	sp, #8
 80045da:	bd80      	pop	{r7, pc}
 80045dc:	080045a5 	.word	0x080045a5
 80045e0:	00027100 	.word	0x00027100

080045e4 <processRx2DnDataDelay>:
// ======================================== Data frames

// Fwd decl.
static bit_t processDnData(void);

static void processRx2DnDataDelay (xref2osjob_t osjob) {
 80045e4:	b580      	push	{r7, lr}
 80045e6:	b082      	sub	sp, #8
 80045e8:	af00      	add	r7, sp, #0
 80045ea:	6078      	str	r0, [r7, #4]
    processDnData();
 80045ec:	f000 fc3a 	bl	8004e64 <processDnData>
}
 80045f0:	46c0      	nop			; (mov r8, r8)
 80045f2:	46bd      	mov	sp, r7
 80045f4:	b002      	add	sp, #8
 80045f6:	bd80      	pop	{r7, pc}

080045f8 <processRx2DnData>:

static void processRx2DnData (xref2osjob_t osjob) {
 80045f8:	b590      	push	{r4, r7, lr}
 80045fa:	b083      	sub	sp, #12
 80045fc:	af00      	add	r7, sp, #0
 80045fe:	6078      	str	r0, [r7, #4]
    if( LMIC.dataLen == 0 ) {
 8004600:	4a0f      	ldr	r2, [pc, #60]	; (8004640 <processRx2DnData+0x48>)
 8004602:	2348      	movs	r3, #72	; 0x48
 8004604:	33ff      	adds	r3, #255	; 0xff
 8004606:	5cd3      	ldrb	r3, [r2, r3]
 8004608:	2b00      	cmp	r3, #0
 800460a:	d114      	bne.n	8004636 <processRx2DnData+0x3e>
        LMIC.txrxFlags = 0;  // nothing in 1st/2nd DN slot
 800460c:	4a0c      	ldr	r2, [pc, #48]	; (8004640 <processRx2DnData+0x48>)
 800460e:	2346      	movs	r3, #70	; 0x46
 8004610:	33ff      	adds	r3, #255	; 0xff
 8004612:	2100      	movs	r1, #0
 8004614:	54d1      	strb	r1, [r2, r3]
        // Delay callback processing to avoid up TX while gateway is txing our missed frame! 
        // Since DNW2 uses SF12 by default we wait 3 secs.
        os_setTimedCallback(&LMIC.osjob,
                            (os_getTime() + DNW2_SAFETY_ZONE + rndDelay(2)),
 8004616:	f001 fe5b 	bl	80062d0 <os_getTime>
 800461a:	0003      	movs	r3, r0
 800461c:	4a09      	ldr	r2, [pc, #36]	; (8004644 <processRx2DnData+0x4c>)
 800461e:	189c      	adds	r4, r3, r2
 8004620:	2002      	movs	r0, #2
 8004622:	f7fe fc1d 	bl	8002e60 <rndDelay>
 8004626:	0003      	movs	r3, r0
        os_setTimedCallback(&LMIC.osjob,
 8004628:	18e1      	adds	r1, r4, r3
 800462a:	4a07      	ldr	r2, [pc, #28]	; (8004648 <processRx2DnData+0x50>)
 800462c:	4b07      	ldr	r3, [pc, #28]	; (800464c <processRx2DnData+0x54>)
 800462e:	0018      	movs	r0, r3
 8004630:	f001 febc 	bl	80063ac <os_setTimedCallback>
                            FUNC_ADDR(processRx2DnDataDelay));
        return;
 8004634:	e001      	b.n	800463a <processRx2DnData+0x42>
    }
    processDnData();
 8004636:	f000 fc15 	bl	8004e64 <processDnData>
}
 800463a:	46bd      	mov	sp, r7
 800463c:	b003      	add	sp, #12
 800463e:	bd90      	pop	{r4, r7, pc}
 8004640:	20000324 	.word	0x20000324
 8004644:	00017700 	.word	0x00017700
 8004648:	080045e5 	.word	0x080045e5
 800464c:	20000338 	.word	0x20000338

08004650 <setupRx2DnData>:


static void setupRx2DnData (xref2osjob_t osjob) {
 8004650:	b580      	push	{r7, lr}
 8004652:	b082      	sub	sp, #8
 8004654:	af00      	add	r7, sp, #0
 8004656:	6078      	str	r0, [r7, #4]
    LMIC.osjob.func = FUNC_ADDR(processRx2DnData);
 8004658:	4b04      	ldr	r3, [pc, #16]	; (800466c <setupRx2DnData+0x1c>)
 800465a:	4a05      	ldr	r2, [pc, #20]	; (8004670 <setupRx2DnData+0x20>)
 800465c:	61da      	str	r2, [r3, #28]
    setupRx2();
 800465e:	f7ff fd05 	bl	800406c <setupRx2>
}
 8004662:	46c0      	nop			; (mov r8, r8)
 8004664:	46bd      	mov	sp, r7
 8004666:	b002      	add	sp, #8
 8004668:	bd80      	pop	{r7, pc}
 800466a:	46c0      	nop			; (mov r8, r8)
 800466c:	20000324 	.word	0x20000324
 8004670:	080045f9 	.word	0x080045f9

08004674 <processRx1DnData>:


static void processRx1DnData (xref2osjob_t osjob) {
 8004674:	b580      	push	{r7, lr}
 8004676:	b082      	sub	sp, #8
 8004678:	af00      	add	r7, sp, #0
 800467a:	6078      	str	r0, [r7, #4]
    if( LMIC.dataLen == 0 || !processDnData() )
 800467c:	4a0f      	ldr	r2, [pc, #60]	; (80046bc <processRx1DnData+0x48>)
 800467e:	2348      	movs	r3, #72	; 0x48
 8004680:	33ff      	adds	r3, #255	; 0xff
 8004682:	5cd3      	ldrb	r3, [r2, r3]
 8004684:	2b00      	cmp	r3, #0
 8004686:	d003      	beq.n	8004690 <processRx1DnData+0x1c>
 8004688:	f000 fbec 	bl	8004e64 <processDnData>
 800468c:	1e03      	subs	r3, r0, #0
 800468e:	d111      	bne.n	80046b4 <processRx1DnData+0x40>
        schedRx2(sec2osticks(LMIC.rxDelay + (int)DELAY_EXTDNW2), FUNC_ADDR(setupRx2DnData));
 8004690:	4a0a      	ldr	r2, [pc, #40]	; (80046bc <processRx1DnData+0x48>)
 8004692:	2324      	movs	r3, #36	; 0x24
 8004694:	33ff      	adds	r3, #255	; 0xff
 8004696:	5cd3      	ldrb	r3, [r2, r3]
 8004698:	3301      	adds	r3, #1
 800469a:	001a      	movs	r2, r3
 800469c:	0013      	movs	r3, r2
 800469e:	015b      	lsls	r3, r3, #5
 80046a0:	1a9b      	subs	r3, r3, r2
 80046a2:	009b      	lsls	r3, r3, #2
 80046a4:	189b      	adds	r3, r3, r2
 80046a6:	021b      	lsls	r3, r3, #8
 80046a8:	001a      	movs	r2, r3
 80046aa:	4b05      	ldr	r3, [pc, #20]	; (80046c0 <processRx1DnData+0x4c>)
 80046ac:	0019      	movs	r1, r3
 80046ae:	0010      	movs	r0, r2
 80046b0:	f7ff fd02 	bl	80040b8 <schedRx2>
}
 80046b4:	46c0      	nop			; (mov r8, r8)
 80046b6:	46bd      	mov	sp, r7
 80046b8:	b002      	add	sp, #8
 80046ba:	bd80      	pop	{r7, pc}
 80046bc:	20000324 	.word	0x20000324
 80046c0:	08004651 	.word	0x08004651

080046c4 <setupRx1DnData>:


static void setupRx1DnData (xref2osjob_t osjob) {
 80046c4:	b580      	push	{r7, lr}
 80046c6:	b082      	sub	sp, #8
 80046c8:	af00      	add	r7, sp, #0
 80046ca:	6078      	str	r0, [r7, #4]
    setupRx1(FUNC_ADDR(processRx1DnData));
 80046cc:	4b03      	ldr	r3, [pc, #12]	; (80046dc <setupRx1DnData+0x18>)
 80046ce:	0018      	movs	r0, r3
 80046d0:	f7ff fd1c 	bl	800410c <setupRx1>
}
 80046d4:	46c0      	nop			; (mov r8, r8)
 80046d6:	46bd      	mov	sp, r7
 80046d8:	b002      	add	sp, #8
 80046da:	bd80      	pop	{r7, pc}
 80046dc:	08004675 	.word	0x08004675

080046e0 <updataDone>:


static void updataDone (xref2osjob_t osjob) {
 80046e0:	b580      	push	{r7, lr}
 80046e2:	b082      	sub	sp, #8
 80046e4:	af00      	add	r7, sp, #0
 80046e6:	6078      	str	r0, [r7, #4]
    txDone(sec2osticks(LMIC.rxDelay), FUNC_ADDR(setupRx1DnData));
 80046e8:	4a0a      	ldr	r2, [pc, #40]	; (8004714 <updataDone+0x34>)
 80046ea:	2324      	movs	r3, #36	; 0x24
 80046ec:	33ff      	adds	r3, #255	; 0xff
 80046ee:	5cd3      	ldrb	r3, [r2, r3]
 80046f0:	001a      	movs	r2, r3
 80046f2:	0013      	movs	r3, r2
 80046f4:	015b      	lsls	r3, r3, #5
 80046f6:	1a9b      	subs	r3, r3, r2
 80046f8:	009b      	lsls	r3, r3, #2
 80046fa:	189b      	adds	r3, r3, r2
 80046fc:	021b      	lsls	r3, r3, #8
 80046fe:	001a      	movs	r2, r3
 8004700:	4b05      	ldr	r3, [pc, #20]	; (8004718 <updataDone+0x38>)
 8004702:	0019      	movs	r1, r3
 8004704:	0010      	movs	r0, r2
 8004706:	f7ff fd25 	bl	8004154 <txDone>
}
 800470a:	46c0      	nop			; (mov r8, r8)
 800470c:	46bd      	mov	sp, r7
 800470e:	b002      	add	sp, #8
 8004710:	bd80      	pop	{r7, pc}
 8004712:	46c0      	nop			; (mov r8, r8)
 8004714:	20000324 	.word	0x20000324
 8004718:	080046c5 	.word	0x080046c5

0800471c <buildDataFrame>:

// ======================================== 


static void buildDataFrame (void) {
 800471c:	b590      	push	{r4, r7, lr}
 800471e:	b087      	sub	sp, #28
 8004720:	af02      	add	r7, sp, #8
    bit_t txdata = ((LMIC.opmode & (OP_TXDATA|OP_POLL)) != OP_POLL);
 8004722:	4bc2      	ldr	r3, [pc, #776]	; (8004a2c <buildDataFrame+0x310>)
 8004724:	22ac      	movs	r2, #172	; 0xac
 8004726:	5a9b      	ldrh	r3, [r3, r2]
 8004728:	001a      	movs	r2, r3
 800472a:	2318      	movs	r3, #24
 800472c:	4013      	ands	r3, r2
 800472e:	3b10      	subs	r3, #16
 8004730:	1e5a      	subs	r2, r3, #1
 8004732:	4193      	sbcs	r3, r2
 8004734:	b2da      	uxtb	r2, r3
 8004736:	210f      	movs	r1, #15
 8004738:	187b      	adds	r3, r7, r1
 800473a:	701a      	strb	r2, [r3, #0]
    u1_t dlen = txdata ? LMIC.pendTxLen : 0;
 800473c:	187b      	adds	r3, r7, r1
 800473e:	781b      	ldrb	r3, [r3, #0]
 8004740:	2b00      	cmp	r3, #0
 8004742:	d003      	beq.n	800474c <buildDataFrame+0x30>
 8004744:	4bb9      	ldr	r3, [pc, #740]	; (8004a2c <buildDataFrame+0x310>)
 8004746:	22bc      	movs	r2, #188	; 0xbc
 8004748:	5c9a      	ldrb	r2, [r3, r2]
 800474a:	e000      	b.n	800474e <buildDataFrame+0x32>
 800474c:	2200      	movs	r2, #0
 800474e:	1dbb      	adds	r3, r7, #6
 8004750:	701a      	strb	r2, [r3, #0]

    // Piggyback MAC options
    // Prioritize by importance
    int  end = OFF_DAT_OPTS;
 8004752:	2308      	movs	r3, #8
 8004754:	60bb      	str	r3, [r7, #8]
    if( (LMIC.opmode & (OP_TRACK|OP_PINGABLE)) == (OP_TRACK|OP_PINGABLE) ) {
 8004756:	4bb5      	ldr	r3, [pc, #724]	; (8004a2c <buildDataFrame+0x310>)
 8004758:	22ac      	movs	r2, #172	; 0xac
 800475a:	5a9b      	ldrh	r3, [r3, r2]
 800475c:	001a      	movs	r2, r3
 800475e:	4bb4      	ldr	r3, [pc, #720]	; (8004a30 <buildDataFrame+0x314>)
 8004760:	4013      	ands	r3, r2
 8004762:	4ab3      	ldr	r2, [pc, #716]	; (8004a30 <buildDataFrame+0x314>)
 8004764:	4293      	cmp	r3, r2
 8004766:	d121      	bne.n	80047ac <buildDataFrame+0x90>
        // Indicate pingability in every UP frame
        LMIC.frame[end] = MCMD_PING_IND;
 8004768:	49b0      	ldr	r1, [pc, #704]	; (8004a2c <buildDataFrame+0x310>)
 800476a:	23a4      	movs	r3, #164	; 0xa4
 800476c:	005b      	lsls	r3, r3, #1
 800476e:	68ba      	ldr	r2, [r7, #8]
 8004770:	188a      	adds	r2, r1, r2
 8004772:	18d3      	adds	r3, r2, r3
 8004774:	2210      	movs	r2, #16
 8004776:	701a      	strb	r2, [r3, #0]
        LMIC.frame[end+1] = LMIC.ping.dr | (LMIC.ping.intvExp<<4);
 8004778:	4aac      	ldr	r2, [pc, #688]	; (8004a2c <buildDataFrame+0x310>)
 800477a:	239a      	movs	r3, #154	; 0x9a
 800477c:	005b      	lsls	r3, r3, #1
 800477e:	5cd3      	ldrb	r3, [r2, r3]
 8004780:	b25a      	sxtb	r2, r3
 8004782:	49aa      	ldr	r1, [pc, #680]	; (8004a2c <buildDataFrame+0x310>)
 8004784:	2336      	movs	r3, #54	; 0x36
 8004786:	33ff      	adds	r3, #255	; 0xff
 8004788:	5ccb      	ldrb	r3, [r1, r3]
 800478a:	011b      	lsls	r3, r3, #4
 800478c:	b25b      	sxtb	r3, r3
 800478e:	4313      	orrs	r3, r2
 8004790:	b259      	sxtb	r1, r3
 8004792:	68bb      	ldr	r3, [r7, #8]
 8004794:	1c5a      	adds	r2, r3, #1
 8004796:	b2c8      	uxtb	r0, r1
 8004798:	49a4      	ldr	r1, [pc, #656]	; (8004a2c <buildDataFrame+0x310>)
 800479a:	23a4      	movs	r3, #164	; 0xa4
 800479c:	005b      	lsls	r3, r3, #1
 800479e:	188a      	adds	r2, r1, r2
 80047a0:	18d3      	adds	r3, r2, r3
 80047a2:	1c02      	adds	r2, r0, #0
 80047a4:	701a      	strb	r2, [r3, #0]
        end += 2;
 80047a6:	68bb      	ldr	r3, [r7, #8]
 80047a8:	3302      	adds	r3, #2
 80047aa:	60bb      	str	r3, [r7, #8]
    }
    if( LMIC.dutyCapAns ) {
 80047ac:	4a9f      	ldr	r2, [pc, #636]	; (8004a2c <buildDataFrame+0x310>)
 80047ae:	232a      	movs	r3, #42	; 0x2a
 80047b0:	33ff      	adds	r3, #255	; 0xff
 80047b2:	5cd3      	ldrb	r3, [r2, r3]
 80047b4:	2b00      	cmp	r3, #0
 80047b6:	d00f      	beq.n	80047d8 <buildDataFrame+0xbc>
        LMIC.frame[end] = MCMD_DCAP_ANS;
 80047b8:	499c      	ldr	r1, [pc, #624]	; (8004a2c <buildDataFrame+0x310>)
 80047ba:	23a4      	movs	r3, #164	; 0xa4
 80047bc:	005b      	lsls	r3, r3, #1
 80047be:	68ba      	ldr	r2, [r7, #8]
 80047c0:	188a      	adds	r2, r1, r2
 80047c2:	18d3      	adds	r3, r2, r3
 80047c4:	2204      	movs	r2, #4
 80047c6:	701a      	strb	r2, [r3, #0]
        end += 1;
 80047c8:	68bb      	ldr	r3, [r7, #8]
 80047ca:	3301      	adds	r3, #1
 80047cc:	60bb      	str	r3, [r7, #8]
        LMIC.dutyCapAns = 0;
 80047ce:	4a97      	ldr	r2, [pc, #604]	; (8004a2c <buildDataFrame+0x310>)
 80047d0:	232a      	movs	r3, #42	; 0x2a
 80047d2:	33ff      	adds	r3, #255	; 0xff
 80047d4:	2100      	movs	r1, #0
 80047d6:	54d1      	strb	r1, [r2, r3]
    }
    if( LMIC.dn2Ans ) {
 80047d8:	4a94      	ldr	r2, [pc, #592]	; (8004a2c <buildDataFrame+0x310>)
 80047da:	2398      	movs	r3, #152	; 0x98
 80047dc:	005b      	lsls	r3, r3, #1
 80047de:	5cd3      	ldrb	r3, [r2, r3]
 80047e0:	2b00      	cmp	r3, #0
 80047e2:	d01f      	beq.n	8004824 <buildDataFrame+0x108>
        LMIC.frame[end+0] = MCMD_DN2P_ANS;
 80047e4:	4991      	ldr	r1, [pc, #580]	; (8004a2c <buildDataFrame+0x310>)
 80047e6:	23a4      	movs	r3, #164	; 0xa4
 80047e8:	005b      	lsls	r3, r3, #1
 80047ea:	68ba      	ldr	r2, [r7, #8]
 80047ec:	188a      	adds	r2, r1, r2
 80047ee:	18d3      	adds	r3, r2, r3
 80047f0:	2205      	movs	r2, #5
 80047f2:	701a      	strb	r2, [r3, #0]
        LMIC.frame[end+1] = LMIC.dn2Ans & ~MCMD_DN2P_ANS_RFU;
 80047f4:	4a8d      	ldr	r2, [pc, #564]	; (8004a2c <buildDataFrame+0x310>)
 80047f6:	2398      	movs	r3, #152	; 0x98
 80047f8:	005b      	lsls	r3, r3, #1
 80047fa:	5cd3      	ldrb	r3, [r2, r3]
 80047fc:	68ba      	ldr	r2, [r7, #8]
 80047fe:	3201      	adds	r2, #1
 8004800:	2103      	movs	r1, #3
 8004802:	400b      	ands	r3, r1
 8004804:	b2d8      	uxtb	r0, r3
 8004806:	4989      	ldr	r1, [pc, #548]	; (8004a2c <buildDataFrame+0x310>)
 8004808:	23a4      	movs	r3, #164	; 0xa4
 800480a:	005b      	lsls	r3, r3, #1
 800480c:	188a      	adds	r2, r1, r2
 800480e:	18d3      	adds	r3, r2, r3
 8004810:	1c02      	adds	r2, r0, #0
 8004812:	701a      	strb	r2, [r3, #0]
        end += 2;
 8004814:	68bb      	ldr	r3, [r7, #8]
 8004816:	3302      	adds	r3, #2
 8004818:	60bb      	str	r3, [r7, #8]
        LMIC.dn2Ans = 0;
 800481a:	4a84      	ldr	r2, [pc, #528]	; (8004a2c <buildDataFrame+0x310>)
 800481c:	2398      	movs	r3, #152	; 0x98
 800481e:	005b      	lsls	r3, r3, #1
 8004820:	2100      	movs	r1, #0
 8004822:	54d1      	strb	r1, [r2, r3]
    }
    if( LMIC.devsAns ) {  // answer to device status
 8004824:	4a81      	ldr	r2, [pc, #516]	; (8004a2c <buildDataFrame+0x310>)
 8004826:	2393      	movs	r3, #147	; 0x93
 8004828:	005b      	lsls	r3, r3, #1
 800482a:	5cd3      	ldrb	r3, [r2, r3]
 800482c:	2b00      	cmp	r3, #0
 800482e:	d029      	beq.n	8004884 <buildDataFrame+0x168>
        LMIC.frame[end+0] = MCMD_DEVS_ANS;
 8004830:	497e      	ldr	r1, [pc, #504]	; (8004a2c <buildDataFrame+0x310>)
 8004832:	23a4      	movs	r3, #164	; 0xa4
 8004834:	005b      	lsls	r3, r3, #1
 8004836:	68ba      	ldr	r2, [r7, #8]
 8004838:	188a      	adds	r2, r1, r2
 800483a:	18d3      	adds	r3, r2, r3
 800483c:	2206      	movs	r2, #6
 800483e:	701a      	strb	r2, [r3, #0]
        LMIC.frame[end+1] = os_getBattLevel();
 8004840:	68bb      	ldr	r3, [r7, #8]
 8004842:	1c5c      	adds	r4, r3, #1
 8004844:	f7fd febe 	bl	80025c4 <os_getBattLevel>
 8004848:	0003      	movs	r3, r0
 800484a:	0019      	movs	r1, r3
 800484c:	4a77      	ldr	r2, [pc, #476]	; (8004a2c <buildDataFrame+0x310>)
 800484e:	23a4      	movs	r3, #164	; 0xa4
 8004850:	005b      	lsls	r3, r3, #1
 8004852:	1912      	adds	r2, r2, r4
 8004854:	18d3      	adds	r3, r2, r3
 8004856:	1c0a      	adds	r2, r1, #0
 8004858:	701a      	strb	r2, [r3, #0]
        LMIC.frame[end+2] = LMIC.margin;
 800485a:	68bb      	ldr	r3, [r7, #8]
 800485c:	1c9a      	adds	r2, r3, #2
 800485e:	4973      	ldr	r1, [pc, #460]	; (8004a2c <buildDataFrame+0x310>)
 8004860:	2392      	movs	r3, #146	; 0x92
 8004862:	005b      	lsls	r3, r3, #1
 8004864:	5cc8      	ldrb	r0, [r1, r3]
 8004866:	4971      	ldr	r1, [pc, #452]	; (8004a2c <buildDataFrame+0x310>)
 8004868:	23a4      	movs	r3, #164	; 0xa4
 800486a:	005b      	lsls	r3, r3, #1
 800486c:	188a      	adds	r2, r1, r2
 800486e:	18d3      	adds	r3, r2, r3
 8004870:	1c02      	adds	r2, r0, #0
 8004872:	701a      	strb	r2, [r3, #0]
        end += 3;
 8004874:	68bb      	ldr	r3, [r7, #8]
 8004876:	3303      	adds	r3, #3
 8004878:	60bb      	str	r3, [r7, #8]
        LMIC.devsAns = 0;
 800487a:	4a6c      	ldr	r2, [pc, #432]	; (8004a2c <buildDataFrame+0x310>)
 800487c:	2393      	movs	r3, #147	; 0x93
 800487e:	005b      	lsls	r3, r3, #1
 8004880:	2100      	movs	r1, #0
 8004882:	54d1      	strb	r1, [r2, r3]
    }
    if( LMIC.ladrAns ) {  // answer to ADR change
 8004884:	4a69      	ldr	r2, [pc, #420]	; (8004a2c <buildDataFrame+0x310>)
 8004886:	2326      	movs	r3, #38	; 0x26
 8004888:	33ff      	adds	r3, #255	; 0xff
 800488a:	5cd3      	ldrb	r3, [r2, r3]
 800488c:	2b00      	cmp	r3, #0
 800488e:	d01f      	beq.n	80048d0 <buildDataFrame+0x1b4>
        LMIC.frame[end+0] = MCMD_LADR_ANS;
 8004890:	4966      	ldr	r1, [pc, #408]	; (8004a2c <buildDataFrame+0x310>)
 8004892:	23a4      	movs	r3, #164	; 0xa4
 8004894:	005b      	lsls	r3, r3, #1
 8004896:	68ba      	ldr	r2, [r7, #8]
 8004898:	188a      	adds	r2, r1, r2
 800489a:	18d3      	adds	r3, r2, r3
 800489c:	2203      	movs	r2, #3
 800489e:	701a      	strb	r2, [r3, #0]
        LMIC.frame[end+1] = LMIC.ladrAns & ~MCMD_LADR_ANS_RFU;
 80048a0:	4a62      	ldr	r2, [pc, #392]	; (8004a2c <buildDataFrame+0x310>)
 80048a2:	2326      	movs	r3, #38	; 0x26
 80048a4:	33ff      	adds	r3, #255	; 0xff
 80048a6:	5cd3      	ldrb	r3, [r2, r3]
 80048a8:	68ba      	ldr	r2, [r7, #8]
 80048aa:	3201      	adds	r2, #1
 80048ac:	2107      	movs	r1, #7
 80048ae:	400b      	ands	r3, r1
 80048b0:	b2d8      	uxtb	r0, r3
 80048b2:	495e      	ldr	r1, [pc, #376]	; (8004a2c <buildDataFrame+0x310>)
 80048b4:	23a4      	movs	r3, #164	; 0xa4
 80048b6:	005b      	lsls	r3, r3, #1
 80048b8:	188a      	adds	r2, r1, r2
 80048ba:	18d3      	adds	r3, r2, r3
 80048bc:	1c02      	adds	r2, r0, #0
 80048be:	701a      	strb	r2, [r3, #0]
        end += 2;
 80048c0:	68bb      	ldr	r3, [r7, #8]
 80048c2:	3302      	adds	r3, #2
 80048c4:	60bb      	str	r3, [r7, #8]
        LMIC.ladrAns = 0;
 80048c6:	4a59      	ldr	r2, [pc, #356]	; (8004a2c <buildDataFrame+0x310>)
 80048c8:	2326      	movs	r3, #38	; 0x26
 80048ca:	33ff      	adds	r3, #255	; 0xff
 80048cc:	2100      	movs	r1, #0
 80048ce:	54d1      	strb	r1, [r2, r3]
    }
    if( LMIC.bcninfoTries > 0 ) {
 80048d0:	4a56      	ldr	r2, [pc, #344]	; (8004a2c <buildDataFrame+0x310>)
 80048d2:	2399      	movs	r3, #153	; 0x99
 80048d4:	005b      	lsls	r3, r3, #1
 80048d6:	5cd3      	ldrb	r3, [r2, r3]
 80048d8:	2b00      	cmp	r3, #0
 80048da:	d00a      	beq.n	80048f2 <buildDataFrame+0x1d6>
        LMIC.frame[end] = MCMD_BCNI_REQ;
 80048dc:	4953      	ldr	r1, [pc, #332]	; (8004a2c <buildDataFrame+0x310>)
 80048de:	23a4      	movs	r3, #164	; 0xa4
 80048e0:	005b      	lsls	r3, r3, #1
 80048e2:	68ba      	ldr	r2, [r7, #8]
 80048e4:	188a      	adds	r2, r1, r2
 80048e6:	18d3      	adds	r3, r2, r3
 80048e8:	2212      	movs	r2, #18
 80048ea:	701a      	strb	r2, [r3, #0]
        end += 1;
 80048ec:	68bb      	ldr	r3, [r7, #8]
 80048ee:	3301      	adds	r3, #1
 80048f0:	60bb      	str	r3, [r7, #8]
    }
    if( LMIC.adrChanged ) {
 80048f2:	4a4e      	ldr	r2, [pc, #312]	; (8004a2c <buildDataFrame+0x310>)
 80048f4:	2391      	movs	r3, #145	; 0x91
 80048f6:	005b      	lsls	r3, r3, #1
 80048f8:	5cd3      	ldrb	r3, [r2, r3]
 80048fa:	2b00      	cmp	r3, #0
 80048fc:	d00f      	beq.n	800491e <buildDataFrame+0x202>
        if( LMIC.adrAckReq < 0 )
 80048fe:	4a4b      	ldr	r2, [pc, #300]	; (8004a2c <buildDataFrame+0x310>)
 8004900:	2322      	movs	r3, #34	; 0x22
 8004902:	33ff      	adds	r3, #255	; 0xff
 8004904:	56d3      	ldrsb	r3, [r2, r3]
 8004906:	2b00      	cmp	r3, #0
 8004908:	da04      	bge.n	8004914 <buildDataFrame+0x1f8>
            LMIC.adrAckReq = 0;
 800490a:	4a48      	ldr	r2, [pc, #288]	; (8004a2c <buildDataFrame+0x310>)
 800490c:	2322      	movs	r3, #34	; 0x22
 800490e:	33ff      	adds	r3, #255	; 0xff
 8004910:	2100      	movs	r1, #0
 8004912:	54d1      	strb	r1, [r2, r3]
        LMIC.adrChanged = 0;
 8004914:	4a45      	ldr	r2, [pc, #276]	; (8004a2c <buildDataFrame+0x310>)
 8004916:	2391      	movs	r3, #145	; 0x91
 8004918:	005b      	lsls	r3, r3, #1
 800491a:	2100      	movs	r1, #0
 800491c:	54d1      	strb	r1, [r2, r3]
    }
    if( LMIC.pingSetAns != 0 ) {
 800491e:	4a43      	ldr	r2, [pc, #268]	; (8004a2c <buildDataFrame+0x310>)
 8004920:	2334      	movs	r3, #52	; 0x34
 8004922:	33ff      	adds	r3, #255	; 0xff
 8004924:	5cd3      	ldrb	r3, [r2, r3]
 8004926:	2b00      	cmp	r3, #0
 8004928:	d01f      	beq.n	800496a <buildDataFrame+0x24e>
        LMIC.frame[end+0] = MCMD_PING_ANS;
 800492a:	4940      	ldr	r1, [pc, #256]	; (8004a2c <buildDataFrame+0x310>)
 800492c:	23a4      	movs	r3, #164	; 0xa4
 800492e:	005b      	lsls	r3, r3, #1
 8004930:	68ba      	ldr	r2, [r7, #8]
 8004932:	188a      	adds	r2, r1, r2
 8004934:	18d3      	adds	r3, r2, r3
 8004936:	2211      	movs	r2, #17
 8004938:	701a      	strb	r2, [r3, #0]
        LMIC.frame[end+1] = LMIC.pingSetAns & ~MCMD_PING_ANS_RFU;
 800493a:	4a3c      	ldr	r2, [pc, #240]	; (8004a2c <buildDataFrame+0x310>)
 800493c:	2334      	movs	r3, #52	; 0x34
 800493e:	33ff      	adds	r3, #255	; 0xff
 8004940:	5cd3      	ldrb	r3, [r2, r3]
 8004942:	68ba      	ldr	r2, [r7, #8]
 8004944:	3201      	adds	r2, #1
 8004946:	2101      	movs	r1, #1
 8004948:	400b      	ands	r3, r1
 800494a:	b2d8      	uxtb	r0, r3
 800494c:	4937      	ldr	r1, [pc, #220]	; (8004a2c <buildDataFrame+0x310>)
 800494e:	23a4      	movs	r3, #164	; 0xa4
 8004950:	005b      	lsls	r3, r3, #1
 8004952:	188a      	adds	r2, r1, r2
 8004954:	18d3      	adds	r3, r2, r3
 8004956:	1c02      	adds	r2, r0, #0
 8004958:	701a      	strb	r2, [r3, #0]
        end += 2;
 800495a:	68bb      	ldr	r3, [r7, #8]
 800495c:	3302      	adds	r3, #2
 800495e:	60bb      	str	r3, [r7, #8]
        LMIC.pingSetAns = 0;
 8004960:	4a32      	ldr	r2, [pc, #200]	; (8004a2c <buildDataFrame+0x310>)
 8004962:	2334      	movs	r3, #52	; 0x34
 8004964:	33ff      	adds	r3, #255	; 0xff
 8004966:	2100      	movs	r1, #0
 8004968:	54d1      	strb	r1, [r2, r3]
    }
    if( LMIC.snchAns ) {
 800496a:	4a30      	ldr	r2, [pc, #192]	; (8004a2c <buildDataFrame+0x310>)
 800496c:	2395      	movs	r3, #149	; 0x95
 800496e:	005b      	lsls	r3, r3, #1
 8004970:	5cd3      	ldrb	r3, [r2, r3]
 8004972:	2b00      	cmp	r3, #0
 8004974:	d01f      	beq.n	80049b6 <buildDataFrame+0x29a>
        LMIC.frame[end+0] = MCMD_SNCH_ANS;
 8004976:	492d      	ldr	r1, [pc, #180]	; (8004a2c <buildDataFrame+0x310>)
 8004978:	23a4      	movs	r3, #164	; 0xa4
 800497a:	005b      	lsls	r3, r3, #1
 800497c:	68ba      	ldr	r2, [r7, #8]
 800497e:	188a      	adds	r2, r1, r2
 8004980:	18d3      	adds	r3, r2, r3
 8004982:	2207      	movs	r2, #7
 8004984:	701a      	strb	r2, [r3, #0]
        LMIC.frame[end+1] = LMIC.snchAns & ~MCMD_SNCH_ANS_RFU;
 8004986:	4a29      	ldr	r2, [pc, #164]	; (8004a2c <buildDataFrame+0x310>)
 8004988:	2395      	movs	r3, #149	; 0x95
 800498a:	005b      	lsls	r3, r3, #1
 800498c:	5cd3      	ldrb	r3, [r2, r3]
 800498e:	68ba      	ldr	r2, [r7, #8]
 8004990:	3201      	adds	r2, #1
 8004992:	2103      	movs	r1, #3
 8004994:	400b      	ands	r3, r1
 8004996:	b2d8      	uxtb	r0, r3
 8004998:	4924      	ldr	r1, [pc, #144]	; (8004a2c <buildDataFrame+0x310>)
 800499a:	23a4      	movs	r3, #164	; 0xa4
 800499c:	005b      	lsls	r3, r3, #1
 800499e:	188a      	adds	r2, r1, r2
 80049a0:	18d3      	adds	r3, r2, r3
 80049a2:	1c02      	adds	r2, r0, #0
 80049a4:	701a      	strb	r2, [r3, #0]
        end += 2;
 80049a6:	68bb      	ldr	r3, [r7, #8]
 80049a8:	3302      	adds	r3, #2
 80049aa:	60bb      	str	r3, [r7, #8]
        LMIC.snchAns = 0;
 80049ac:	4a1f      	ldr	r2, [pc, #124]	; (8004a2c <buildDataFrame+0x310>)
 80049ae:	2395      	movs	r3, #149	; 0x95
 80049b0:	005b      	lsls	r3, r3, #1
 80049b2:	2100      	movs	r1, #0
 80049b4:	54d1      	strb	r1, [r2, r3]
    }
    ASSERT(end <= OFF_DAT_OPTS+16);
 80049b6:	68bb      	ldr	r3, [r7, #8]
 80049b8:	2b18      	cmp	r3, #24
 80049ba:	dd01      	ble.n	80049c0 <buildDataFrame+0x2a4>
 80049bc:	f7fd fc46 	bl	800224c <hal_failed>

    u1_t flen = end + (txdata ? 5+dlen : 4);
 80049c0:	230f      	movs	r3, #15
 80049c2:	18fb      	adds	r3, r7, r3
 80049c4:	781b      	ldrb	r3, [r3, #0]
 80049c6:	2b00      	cmp	r3, #0
 80049c8:	d004      	beq.n	80049d4 <buildDataFrame+0x2b8>
 80049ca:	1dbb      	adds	r3, r7, #6
 80049cc:	781b      	ldrb	r3, [r3, #0]
 80049ce:	3305      	adds	r3, #5
 80049d0:	b2db      	uxtb	r3, r3
 80049d2:	e000      	b.n	80049d6 <buildDataFrame+0x2ba>
 80049d4:	2304      	movs	r3, #4
 80049d6:	68ba      	ldr	r2, [r7, #8]
 80049d8:	b2d1      	uxtb	r1, r2
 80049da:	1dfa      	adds	r2, r7, #7
 80049dc:	185b      	adds	r3, r3, r1
 80049de:	7013      	strb	r3, [r2, #0]
    if( flen > MAX_LEN_FRAME ) {
 80049e0:	1dfb      	adds	r3, r7, #7
 80049e2:	781b      	ldrb	r3, [r3, #0]
 80049e4:	2b40      	cmp	r3, #64	; 0x40
 80049e6:	d908      	bls.n	80049fa <buildDataFrame+0x2de>
        // Options and payload too big - delay payload
        txdata = 0;
 80049e8:	230f      	movs	r3, #15
 80049ea:	18fb      	adds	r3, r7, r3
 80049ec:	2200      	movs	r2, #0
 80049ee:	701a      	strb	r2, [r3, #0]
        flen = end+4;
 80049f0:	68bb      	ldr	r3, [r7, #8]
 80049f2:	b2da      	uxtb	r2, r3
 80049f4:	1dfb      	adds	r3, r7, #7
 80049f6:	3204      	adds	r2, #4
 80049f8:	701a      	strb	r2, [r3, #0]
    }
    LMIC.frame[OFF_DAT_HDR] = HDR_FTYPE_DAUP | HDR_MAJOR_V1;
 80049fa:	4a0c      	ldr	r2, [pc, #48]	; (8004a2c <buildDataFrame+0x310>)
 80049fc:	23a4      	movs	r3, #164	; 0xa4
 80049fe:	005b      	lsls	r3, r3, #1
 8004a00:	2140      	movs	r1, #64	; 0x40
 8004a02:	54d1      	strb	r1, [r2, r3]
    LMIC.frame[OFF_DAT_FCT] = (LMIC.dnConf | LMIC.adrEnabled
 8004a04:	4a09      	ldr	r2, [pc, #36]	; (8004a2c <buildDataFrame+0x310>)
 8004a06:	2390      	movs	r3, #144	; 0x90
 8004a08:	005b      	lsls	r3, r3, #1
 8004a0a:	5cd2      	ldrb	r2, [r2, r3]
 8004a0c:	4907      	ldr	r1, [pc, #28]	; (8004a2c <buildDataFrame+0x310>)
 8004a0e:	2328      	movs	r3, #40	; 0x28
 8004a10:	33ff      	adds	r3, #255	; 0xff
 8004a12:	5ccb      	ldrb	r3, [r1, r3]
                              | (LMIC.adrAckReq >= 0 ? FCT_ADRARQ : 0)
 8004a14:	4313      	orrs	r3, r2
 8004a16:	b2db      	uxtb	r3, r3
 8004a18:	b25a      	sxtb	r2, r3
 8004a1a:	4904      	ldr	r1, [pc, #16]	; (8004a2c <buildDataFrame+0x310>)
 8004a1c:	2322      	movs	r3, #34	; 0x22
 8004a1e:	33ff      	adds	r3, #255	; 0xff
 8004a20:	56cb      	ldrsb	r3, [r1, r3]
 8004a22:	2b00      	cmp	r3, #0
 8004a24:	db06      	blt.n	8004a34 <buildDataFrame+0x318>
 8004a26:	2340      	movs	r3, #64	; 0x40
 8004a28:	e005      	b.n	8004a36 <buildDataFrame+0x31a>
 8004a2a:	46c0      	nop			; (mov r8, r8)
 8004a2c:	20000324 	.word	0x20000324
 8004a30:	00000402 	.word	0x00000402
 8004a34:	2300      	movs	r3, #0
 8004a36:	4313      	orrs	r3, r2
 8004a38:	b25a      	sxtb	r2, r3
                              | (end-OFF_DAT_OPTS));
 8004a3a:	68bb      	ldr	r3, [r7, #8]
 8004a3c:	b2db      	uxtb	r3, r3
 8004a3e:	3b08      	subs	r3, #8
 8004a40:	b2db      	uxtb	r3, r3
 8004a42:	b25b      	sxtb	r3, r3
 8004a44:	4313      	orrs	r3, r2
 8004a46:	b25b      	sxtb	r3, r3
 8004a48:	b2d9      	uxtb	r1, r3
    LMIC.frame[OFF_DAT_FCT] = (LMIC.dnConf | LMIC.adrEnabled
 8004a4a:	4a4a      	ldr	r2, [pc, #296]	; (8004b74 <buildDataFrame+0x458>)
 8004a4c:	234e      	movs	r3, #78	; 0x4e
 8004a4e:	33ff      	adds	r3, #255	; 0xff
 8004a50:	54d1      	strb	r1, [r2, r3]
    os_wlsbf4(LMIC.frame+OFF_DAT_ADDR,  LMIC.devaddr);
 8004a52:	4849      	ldr	r0, [pc, #292]	; (8004b78 <buildDataFrame+0x45c>)
 8004a54:	4a47      	ldr	r2, [pc, #284]	; (8004b74 <buildDataFrame+0x458>)
 8004a56:	238a      	movs	r3, #138	; 0x8a
 8004a58:	005b      	lsls	r3, r3, #1
 8004a5a:	58d3      	ldr	r3, [r2, r3]
 8004a5c:	0019      	movs	r1, r3
 8004a5e:	f7fd fd73 	bl	8002548 <os_wlsbf4>

    if( LMIC.txCnt == 0 ) {
 8004a62:	4a44      	ldr	r2, [pc, #272]	; (8004b74 <buildDataFrame+0x458>)
 8004a64:	23a2      	movs	r3, #162	; 0xa2
 8004a66:	005b      	lsls	r3, r3, #1
 8004a68:	5cd3      	ldrb	r3, [r2, r3]
 8004a6a:	2b00      	cmp	r3, #0
 8004a6c:	d108      	bne.n	8004a80 <buildDataFrame+0x364>
        LMIC.seqnoUp += 1;
 8004a6e:	4a41      	ldr	r2, [pc, #260]	; (8004b74 <buildDataFrame+0x458>)
 8004a70:	238e      	movs	r3, #142	; 0x8e
 8004a72:	005b      	lsls	r3, r3, #1
 8004a74:	58d3      	ldr	r3, [r2, r3]
 8004a76:	1c59      	adds	r1, r3, #1
 8004a78:	4a3e      	ldr	r2, [pc, #248]	; (8004b74 <buildDataFrame+0x458>)
 8004a7a:	238e      	movs	r3, #142	; 0x8e
 8004a7c:	005b      	lsls	r3, r3, #1
 8004a7e:	50d1      	str	r1, [r2, r3]
                           e_.info   = LMIC.seqnoUp-1,
                           e_.info2  = ((LMIC.txCnt+1) |
                                        (DRADJUST[LMIC.txCnt+1] << 8) |
                                        ((LMIC.datarate|DR_PAGE)<<16))));
    }
    os_wlsbf2(LMIC.frame+OFF_DAT_SEQNO, LMIC.seqnoUp-1);
 8004a80:	483e      	ldr	r0, [pc, #248]	; (8004b7c <buildDataFrame+0x460>)
 8004a82:	4a3c      	ldr	r2, [pc, #240]	; (8004b74 <buildDataFrame+0x458>)
 8004a84:	238e      	movs	r3, #142	; 0x8e
 8004a86:	005b      	lsls	r3, r3, #1
 8004a88:	58d3      	ldr	r3, [r2, r3]
 8004a8a:	b29b      	uxth	r3, r3
 8004a8c:	3b01      	subs	r3, #1
 8004a8e:	b29b      	uxth	r3, r3
 8004a90:	0019      	movs	r1, r3
 8004a92:	f7fd fd41 	bl	8002518 <os_wlsbf2>

    // Clear pending DN confirmation
    LMIC.dnConf = 0;
 8004a96:	4a37      	ldr	r2, [pc, #220]	; (8004b74 <buildDataFrame+0x458>)
 8004a98:	2390      	movs	r3, #144	; 0x90
 8004a9a:	005b      	lsls	r3, r3, #1
 8004a9c:	2100      	movs	r1, #0
 8004a9e:	54d1      	strb	r1, [r2, r3]

    if( txdata ) {
 8004aa0:	230f      	movs	r3, #15
 8004aa2:	18fb      	adds	r3, r7, r3
 8004aa4:	781b      	ldrb	r3, [r3, #0]
 8004aa6:	2b00      	cmp	r3, #0
 8004aa8:	d046      	beq.n	8004b38 <buildDataFrame+0x41c>
        if( LMIC.pendTxConf ) {
 8004aaa:	4b32      	ldr	r3, [pc, #200]	; (8004b74 <buildDataFrame+0x458>)
 8004aac:	22bb      	movs	r2, #187	; 0xbb
 8004aae:	5c9b      	ldrb	r3, [r3, r2]
 8004ab0:	2b00      	cmp	r3, #0
 8004ab2:	d00f      	beq.n	8004ad4 <buildDataFrame+0x3b8>
            // Confirmed only makes sense if we have a payload (or at least a port)
            LMIC.frame[OFF_DAT_HDR] = HDR_FTYPE_DCUP | HDR_MAJOR_V1;
 8004ab4:	4a2f      	ldr	r2, [pc, #188]	; (8004b74 <buildDataFrame+0x458>)
 8004ab6:	23a4      	movs	r3, #164	; 0xa4
 8004ab8:	005b      	lsls	r3, r3, #1
 8004aba:	2180      	movs	r1, #128	; 0x80
 8004abc:	54d1      	strb	r1, [r2, r3]
            if( LMIC.txCnt == 0 ) LMIC.txCnt = 1;
 8004abe:	4a2d      	ldr	r2, [pc, #180]	; (8004b74 <buildDataFrame+0x458>)
 8004ac0:	23a2      	movs	r3, #162	; 0xa2
 8004ac2:	005b      	lsls	r3, r3, #1
 8004ac4:	5cd3      	ldrb	r3, [r2, r3]
 8004ac6:	2b00      	cmp	r3, #0
 8004ac8:	d104      	bne.n	8004ad4 <buildDataFrame+0x3b8>
 8004aca:	4a2a      	ldr	r2, [pc, #168]	; (8004b74 <buildDataFrame+0x458>)
 8004acc:	23a2      	movs	r3, #162	; 0xa2
 8004ace:	005b      	lsls	r3, r3, #1
 8004ad0:	2101      	movs	r1, #1
 8004ad2:	54d1      	strb	r1, [r2, r3]
        }
        LMIC.frame[end] = LMIC.pendTxPort;
 8004ad4:	4b27      	ldr	r3, [pc, #156]	; (8004b74 <buildDataFrame+0x458>)
 8004ad6:	22ba      	movs	r2, #186	; 0xba
 8004ad8:	5c98      	ldrb	r0, [r3, r2]
 8004ada:	4926      	ldr	r1, [pc, #152]	; (8004b74 <buildDataFrame+0x458>)
 8004adc:	23a4      	movs	r3, #164	; 0xa4
 8004ade:	005b      	lsls	r3, r3, #1
 8004ae0:	68ba      	ldr	r2, [r7, #8]
 8004ae2:	188a      	adds	r2, r1, r2
 8004ae4:	18d3      	adds	r3, r2, r3
 8004ae6:	1c02      	adds	r2, r0, #0
 8004ae8:	701a      	strb	r2, [r3, #0]
        os_copyMem(LMIC.frame+end+1, LMIC.pendTxData, dlen);
 8004aea:	68bb      	ldr	r3, [r7, #8]
 8004aec:	1c5a      	adds	r2, r3, #1
 8004aee:	4b24      	ldr	r3, [pc, #144]	; (8004b80 <buildDataFrame+0x464>)
 8004af0:	18d0      	adds	r0, r2, r3
 8004af2:	1dbb      	adds	r3, r7, #6
 8004af4:	781a      	ldrb	r2, [r3, #0]
 8004af6:	4b23      	ldr	r3, [pc, #140]	; (8004b84 <buildDataFrame+0x468>)
 8004af8:	0019      	movs	r1, r3
 8004afa:	f008 ff93 	bl	800da24 <memcpy>
        aes_cipher(LMIC.pendTxPort==0 ? LMIC.nwkKey : LMIC.artKey,
 8004afe:	4b1d      	ldr	r3, [pc, #116]	; (8004b74 <buildDataFrame+0x458>)
 8004b00:	22ba      	movs	r2, #186	; 0xba
 8004b02:	5c9b      	ldrb	r3, [r3, r2]
 8004b04:	2b00      	cmp	r3, #0
 8004b06:	d101      	bne.n	8004b0c <buildDataFrame+0x3f0>
 8004b08:	481f      	ldr	r0, [pc, #124]	; (8004b88 <buildDataFrame+0x46c>)
 8004b0a:	e000      	b.n	8004b0e <buildDataFrame+0x3f2>
 8004b0c:	481f      	ldr	r0, [pc, #124]	; (8004b8c <buildDataFrame+0x470>)
 8004b0e:	4a19      	ldr	r2, [pc, #100]	; (8004b74 <buildDataFrame+0x458>)
 8004b10:	238a      	movs	r3, #138	; 0x8a
 8004b12:	005b      	lsls	r3, r3, #1
 8004b14:	58d1      	ldr	r1, [r2, r3]
                   LMIC.devaddr, LMIC.seqnoUp-1,
 8004b16:	4a17      	ldr	r2, [pc, #92]	; (8004b74 <buildDataFrame+0x458>)
 8004b18:	238e      	movs	r3, #142	; 0x8e
 8004b1a:	005b      	lsls	r3, r3, #1
 8004b1c:	58d3      	ldr	r3, [r2, r3]
        aes_cipher(LMIC.pendTxPort==0 ? LMIC.nwkKey : LMIC.artKey,
 8004b1e:	1e5c      	subs	r4, r3, #1
                   /*up*/0, LMIC.frame+end+1, dlen);
 8004b20:	68bb      	ldr	r3, [r7, #8]
 8004b22:	1c5a      	adds	r2, r3, #1
        aes_cipher(LMIC.pendTxPort==0 ? LMIC.nwkKey : LMIC.artKey,
 8004b24:	4b16      	ldr	r3, [pc, #88]	; (8004b80 <buildDataFrame+0x464>)
 8004b26:	18d3      	adds	r3, r2, r3
 8004b28:	1dba      	adds	r2, r7, #6
 8004b2a:	7812      	ldrb	r2, [r2, #0]
 8004b2c:	9201      	str	r2, [sp, #4]
 8004b2e:	9300      	str	r3, [sp, #0]
 8004b30:	2300      	movs	r3, #0
 8004b32:	0022      	movs	r2, r4
 8004b34:	f7fd fe82 	bl	800283c <aes_cipher>
    }
    aes_appendMic(LMIC.nwkKey, LMIC.devaddr, LMIC.seqnoUp-1, /*up*/0, LMIC.frame, flen-4);
 8004b38:	4a0e      	ldr	r2, [pc, #56]	; (8004b74 <buildDataFrame+0x458>)
 8004b3a:	238a      	movs	r3, #138	; 0x8a
 8004b3c:	005b      	lsls	r3, r3, #1
 8004b3e:	58d1      	ldr	r1, [r2, r3]
 8004b40:	4a0c      	ldr	r2, [pc, #48]	; (8004b74 <buildDataFrame+0x458>)
 8004b42:	238e      	movs	r3, #142	; 0x8e
 8004b44:	005b      	lsls	r3, r3, #1
 8004b46:	58d3      	ldr	r3, [r2, r3]
 8004b48:	1e5a      	subs	r2, r3, #1
 8004b4a:	1dfb      	adds	r3, r7, #7
 8004b4c:	781b      	ldrb	r3, [r3, #0]
 8004b4e:	3b04      	subs	r3, #4
 8004b50:	480d      	ldr	r0, [pc, #52]	; (8004b88 <buildDataFrame+0x46c>)
 8004b52:	9301      	str	r3, [sp, #4]
 8004b54:	4b0a      	ldr	r3, [pc, #40]	; (8004b80 <buildDataFrame+0x464>)
 8004b56:	9300      	str	r3, [sp, #0]
 8004b58:	2300      	movs	r3, #0
 8004b5a:	f7fd fdf1 	bl	8002740 <aes_appendMic>
                       e_.fct     = LMIC.frame[LORA::OFF_DAT_FCT],
                       e_.port    = LMIC.pendTxPort,
                       e_.plen    = txdata ? dlen : 0,
                       e_.opts.length = end-LORA::OFF_DAT_OPTS,
                       memcpy(&e_.opts[0], LMIC.frame+LORA::OFF_DAT_OPTS, end-LORA::OFF_DAT_OPTS)));
    LMIC.dataLen = flen;
 8004b5e:	4a05      	ldr	r2, [pc, #20]	; (8004b74 <buildDataFrame+0x458>)
 8004b60:	1df9      	adds	r1, r7, #7
 8004b62:	2348      	movs	r3, #72	; 0x48
 8004b64:	33ff      	adds	r3, #255	; 0xff
 8004b66:	7809      	ldrb	r1, [r1, #0]
 8004b68:	54d1      	strb	r1, [r2, r3]
}
 8004b6a:	46c0      	nop			; (mov r8, r8)
 8004b6c:	46bd      	mov	sp, r7
 8004b6e:	b005      	add	sp, #20
 8004b70:	bd90      	pop	{r4, r7, pc}
 8004b72:	46c0      	nop			; (mov r8, r8)
 8004b74:	20000324 	.word	0x20000324
 8004b78:	2000046d 	.word	0x2000046d
 8004b7c:	20000472 	.word	0x20000472
 8004b80:	2000046c 	.word	0x2000046c
 8004b84:	200003e1 	.word	0x200003e1
 8004b88:	20000418 	.word	0x20000418
 8004b8c:	20000428 	.word	0x20000428

08004b90 <onBcnRx>:


// Callback from HAL during scan mode or when job timer expires.
static void onBcnRx (xref2osjob_t job) {
 8004b90:	b580      	push	{r7, lr}
 8004b92:	b082      	sub	sp, #8
 8004b94:	af00      	add	r7, sp, #0
 8004b96:	6078      	str	r0, [r7, #4]
    // If we arrive via job timer make sure to put radio to rest.
    os_radio(RADIO_RST);
 8004b98:	2000      	movs	r0, #0
 8004b9a:	f002 fa4d 	bl	8007038 <os_radio>
    os_clearCallback(&LMIC.osjob);
 8004b9e:	4b24      	ldr	r3, [pc, #144]	; (8004c30 <onBcnRx+0xa0>)
 8004ba0:	0018      	movs	r0, r3
 8004ba2:	f001 fbbb 	bl	800631c <os_clearCallback>
    if( LMIC.dataLen == 0 ) {
 8004ba6:	4a23      	ldr	r2, [pc, #140]	; (8004c34 <onBcnRx+0xa4>)
 8004ba8:	2348      	movs	r3, #72	; 0x48
 8004baa:	33ff      	adds	r3, #255	; 0xff
 8004bac:	5cd3      	ldrb	r3, [r2, r3]
 8004bae:	2b00      	cmp	r3, #0
 8004bb0:	d10c      	bne.n	8004bcc <onBcnRx+0x3c>
        // Nothing received - timeout
        LMIC.opmode &= ~(OP_SCAN | OP_TRACK);
 8004bb2:	4b20      	ldr	r3, [pc, #128]	; (8004c34 <onBcnRx+0xa4>)
 8004bb4:	22ac      	movs	r2, #172	; 0xac
 8004bb6:	5a9b      	ldrh	r3, [r3, r2]
 8004bb8:	2203      	movs	r2, #3
 8004bba:	4393      	bics	r3, r2
 8004bbc:	b299      	uxth	r1, r3
 8004bbe:	4b1d      	ldr	r3, [pc, #116]	; (8004c34 <onBcnRx+0xa4>)
 8004bc0:	22ac      	movs	r2, #172	; 0xac
 8004bc2:	5299      	strh	r1, [r3, r2]
        reportEvent(EV_SCAN_TIMEOUT);
 8004bc4:	2001      	movs	r0, #1
 8004bc6:	f7fe fd9d 	bl	8003704 <reportEvent>
        return;
 8004bca:	e02e      	b.n	8004c2a <onBcnRx+0x9a>
    }
    if( decodeBeacon() <= 0 ) {
 8004bcc:	f7fe fe36 	bl	800383c <decodeBeacon>
 8004bd0:	1e03      	subs	r3, r0, #0
 8004bd2:	dc11      	bgt.n	8004bf8 <onBcnRx+0x68>
        // Something is wrong with the beacon - continue scan
        LMIC.dataLen = 0;
 8004bd4:	4a17      	ldr	r2, [pc, #92]	; (8004c34 <onBcnRx+0xa4>)
 8004bd6:	2348      	movs	r3, #72	; 0x48
 8004bd8:	33ff      	adds	r3, #255	; 0xff
 8004bda:	2100      	movs	r1, #0
 8004bdc:	54d1      	strb	r1, [r2, r3]
        os_radio(RADIO_RXON);
 8004bde:	2003      	movs	r0, #3
 8004be0:	f002 fa2a 	bl	8007038 <os_radio>
        os_setTimedCallback(&LMIC.osjob, LMIC.bcninfo.txtime, FUNC_ADDR(onBcnRx));
 8004be4:	4a13      	ldr	r2, [pc, #76]	; (8004c34 <onBcnRx+0xa4>)
 8004be6:	23c8      	movs	r3, #200	; 0xc8
 8004be8:	005b      	lsls	r3, r3, #1
 8004bea:	58d1      	ldr	r1, [r2, r3]
 8004bec:	4a12      	ldr	r2, [pc, #72]	; (8004c38 <onBcnRx+0xa8>)
 8004bee:	4b10      	ldr	r3, [pc, #64]	; (8004c30 <onBcnRx+0xa0>)
 8004bf0:	0018      	movs	r0, r3
 8004bf2:	f001 fbdb 	bl	80063ac <os_setTimedCallback>
        return;
 8004bf6:	e018      	b.n	8004c2a <onBcnRx+0x9a>
    }
    // Found our 1st beacon
    // We don't have a previous beacon to calc some drift - assume
    // an max error of 13ms = 128sec*100ppm which is roughly +/-100ppm
    calcBcnRxWindowFromMillis(13,1);
 8004bf8:	2101      	movs	r1, #1
 8004bfa:	200d      	movs	r0, #13
 8004bfc:	f7fd ffec 	bl	8002bd8 <calcBcnRxWindowFromMillis>
    LMIC.opmode &= ~OP_SCAN;          // turn SCAN off
 8004c00:	4b0c      	ldr	r3, [pc, #48]	; (8004c34 <onBcnRx+0xa4>)
 8004c02:	22ac      	movs	r2, #172	; 0xac
 8004c04:	5a9b      	ldrh	r3, [r3, r2]
 8004c06:	2201      	movs	r2, #1
 8004c08:	4393      	bics	r3, r2
 8004c0a:	b299      	uxth	r1, r3
 8004c0c:	4b09      	ldr	r3, [pc, #36]	; (8004c34 <onBcnRx+0xa4>)
 8004c0e:	22ac      	movs	r2, #172	; 0xac
 8004c10:	5299      	strh	r1, [r3, r2]
    LMIC.opmode |=  OP_TRACK;         // auto enable tracking
 8004c12:	4b08      	ldr	r3, [pc, #32]	; (8004c34 <onBcnRx+0xa4>)
 8004c14:	22ac      	movs	r2, #172	; 0xac
 8004c16:	5a9b      	ldrh	r3, [r3, r2]
 8004c18:	2202      	movs	r2, #2
 8004c1a:	4313      	orrs	r3, r2
 8004c1c:	b299      	uxth	r1, r3
 8004c1e:	4b05      	ldr	r3, [pc, #20]	; (8004c34 <onBcnRx+0xa4>)
 8004c20:	22ac      	movs	r2, #172	; 0xac
 8004c22:	5299      	strh	r1, [r3, r2]
    reportEvent(EV_BEACON_FOUND);    // can be disabled in callback
 8004c24:	2002      	movs	r0, #2
 8004c26:	f7fe fd6d 	bl	8003704 <reportEvent>
}
 8004c2a:	46bd      	mov	sp, r7
 8004c2c:	b002      	add	sp, #8
 8004c2e:	bd80      	pop	{r7, pc}
 8004c30:	20000338 	.word	0x20000338
 8004c34:	20000324 	.word	0x20000324
 8004c38:	08004b91 	.word	0x08004b91

08004c3c <startScan>:
// Enable receiver to listen to incoming beacons
// netid defines when scan stops (any or specific beacon)
// This mode ends with events: EV_SCAN_TIMEOUT/EV_SCAN_BEACON
// Implicitely cancels any pending TX/RX transaction.
// Also cancels an onpoing joining procedure.
static void startScan (void) {
 8004c3c:	b580      	push	{r7, lr}
 8004c3e:	af00      	add	r7, sp, #0
    ASSERT(LMIC.devaddr!=0 && (LMIC.opmode & OP_JOINING)==0);
 8004c40:	4a2a      	ldr	r2, [pc, #168]	; (8004cec <startScan+0xb0>)
 8004c42:	238a      	movs	r3, #138	; 0x8a
 8004c44:	005b      	lsls	r3, r3, #1
 8004c46:	58d3      	ldr	r3, [r2, r3]
 8004c48:	2b00      	cmp	r3, #0
 8004c4a:	d006      	beq.n	8004c5a <startScan+0x1e>
 8004c4c:	4b27      	ldr	r3, [pc, #156]	; (8004cec <startScan+0xb0>)
 8004c4e:	22ac      	movs	r2, #172	; 0xac
 8004c50:	5a9b      	ldrh	r3, [r3, r2]
 8004c52:	001a      	movs	r2, r3
 8004c54:	2304      	movs	r3, #4
 8004c56:	4013      	ands	r3, r2
 8004c58:	d001      	beq.n	8004c5e <startScan+0x22>
 8004c5a:	f7fd faf7 	bl	800224c <hal_failed>
    if( (LMIC.opmode & OP_SHUTDOWN) != 0 )
 8004c5e:	4b23      	ldr	r3, [pc, #140]	; (8004cec <startScan+0xb0>)
 8004c60:	22ac      	movs	r2, #172	; 0xac
 8004c62:	5a9b      	ldrh	r3, [r3, r2]
 8004c64:	001a      	movs	r2, r3
 8004c66:	2340      	movs	r3, #64	; 0x40
 8004c68:	4013      	ands	r3, r2
 8004c6a:	d13c      	bne.n	8004ce6 <startScan+0xaa>
        return;
    // Cancel onging TX/RX transaction
    LMIC.txCnt = LMIC.dnConf = LMIC.bcninfo.flags = 0;
 8004c6c:	4a1f      	ldr	r2, [pc, #124]	; (8004cec <startScan+0xb0>)
 8004c6e:	23cb      	movs	r3, #203	; 0xcb
 8004c70:	005b      	lsls	r3, r3, #1
 8004c72:	2100      	movs	r1, #0
 8004c74:	54d1      	strb	r1, [r2, r3]
 8004c76:	4a1d      	ldr	r2, [pc, #116]	; (8004cec <startScan+0xb0>)
 8004c78:	23cb      	movs	r3, #203	; 0xcb
 8004c7a:	005b      	lsls	r3, r3, #1
 8004c7c:	5cd1      	ldrb	r1, [r2, r3]
 8004c7e:	4a1b      	ldr	r2, [pc, #108]	; (8004cec <startScan+0xb0>)
 8004c80:	2390      	movs	r3, #144	; 0x90
 8004c82:	005b      	lsls	r3, r3, #1
 8004c84:	54d1      	strb	r1, [r2, r3]
 8004c86:	4a19      	ldr	r2, [pc, #100]	; (8004cec <startScan+0xb0>)
 8004c88:	2390      	movs	r3, #144	; 0x90
 8004c8a:	005b      	lsls	r3, r3, #1
 8004c8c:	5cd1      	ldrb	r1, [r2, r3]
 8004c8e:	4a17      	ldr	r2, [pc, #92]	; (8004cec <startScan+0xb0>)
 8004c90:	23a2      	movs	r3, #162	; 0xa2
 8004c92:	005b      	lsls	r3, r3, #1
 8004c94:	54d1      	strb	r1, [r2, r3]
    LMIC.opmode = (LMIC.opmode | OP_SCAN) & ~(OP_TXRXPEND);
 8004c96:	4b15      	ldr	r3, [pc, #84]	; (8004cec <startScan+0xb0>)
 8004c98:	22ac      	movs	r2, #172	; 0xac
 8004c9a:	5a9b      	ldrh	r3, [r3, r2]
 8004c9c:	2201      	movs	r2, #1
 8004c9e:	4313      	orrs	r3, r2
 8004ca0:	b29b      	uxth	r3, r3
 8004ca2:	2280      	movs	r2, #128	; 0x80
 8004ca4:	4393      	bics	r3, r2
 8004ca6:	b299      	uxth	r1, r3
 8004ca8:	4b10      	ldr	r3, [pc, #64]	; (8004cec <startScan+0xb0>)
 8004caa:	22ac      	movs	r2, #172	; 0xac
 8004cac:	5299      	strh	r1, [r3, r2]
    setBcnRxParams();
 8004cae:	f7fe fc51 	bl	8003554 <setBcnRxParams>
    LMIC.rxtime = LMIC.bcninfo.txtime = os_getTime() + sec2osticks(BCN_INTV_sec+1);
 8004cb2:	f001 fb0d 	bl	80062d0 <os_getTime>
 8004cb6:	0003      	movs	r3, r0
 8004cb8:	4a0d      	ldr	r2, [pc, #52]	; (8004cf0 <startScan+0xb4>)
 8004cba:	1899      	adds	r1, r3, r2
 8004cbc:	4a0b      	ldr	r2, [pc, #44]	; (8004cec <startScan+0xb0>)
 8004cbe:	23c8      	movs	r3, #200	; 0xc8
 8004cc0:	005b      	lsls	r3, r3, #1
 8004cc2:	50d1      	str	r1, [r2, r3]
 8004cc4:	4a09      	ldr	r2, [pc, #36]	; (8004cec <startScan+0xb0>)
 8004cc6:	23c8      	movs	r3, #200	; 0xc8
 8004cc8:	005b      	lsls	r3, r3, #1
 8004cca:	58d2      	ldr	r2, [r2, r3]
 8004ccc:	4b07      	ldr	r3, [pc, #28]	; (8004cec <startScan+0xb0>)
 8004cce:	605a      	str	r2, [r3, #4]
    os_setTimedCallback(&LMIC.osjob, LMIC.rxtime, FUNC_ADDR(onBcnRx));
 8004cd0:	4b06      	ldr	r3, [pc, #24]	; (8004cec <startScan+0xb0>)
 8004cd2:	6859      	ldr	r1, [r3, #4]
 8004cd4:	4a07      	ldr	r2, [pc, #28]	; (8004cf4 <startScan+0xb8>)
 8004cd6:	4b08      	ldr	r3, [pc, #32]	; (8004cf8 <startScan+0xbc>)
 8004cd8:	0018      	movs	r0, r3
 8004cda:	f001 fb67 	bl	80063ac <os_setTimedCallback>
    os_radio(RADIO_RXON);
 8004cde:	2003      	movs	r0, #3
 8004ce0:	f002 f9aa 	bl	8007038 <os_radio>
 8004ce4:	e000      	b.n	8004ce8 <startScan+0xac>
        return;
 8004ce6:	46c0      	nop			; (mov r8, r8)
}
 8004ce8:	46bd      	mov	sp, r7
 8004cea:	bd80      	pop	{r7, pc}
 8004cec:	20000324 	.word	0x20000324
 8004cf0:	003efd00 	.word	0x003efd00
 8004cf4:	08004b91 	.word	0x08004b91
 8004cf8:	20000338 	.word	0x20000338

08004cfc <buildJoinRequest>:
//
// Join stuff
//
// ================================================================================

static void buildJoinRequest (u1_t ftype) {
 8004cfc:	b580      	push	{r7, lr}
 8004cfe:	b084      	sub	sp, #16
 8004d00:	af00      	add	r7, sp, #0
 8004d02:	0002      	movs	r2, r0
 8004d04:	1dfb      	adds	r3, r7, #7
 8004d06:	701a      	strb	r2, [r3, #0]
    // Do not use pendTxData since we might have a pending
    // user level frame in there. Use RX holding area instead.
    xref2u1_t d = LMIC.frame;
 8004d08:	4b17      	ldr	r3, [pc, #92]	; (8004d68 <buildJoinRequest+0x6c>)
 8004d0a:	60fb      	str	r3, [r7, #12]
    d[OFF_JR_HDR] = ftype;
 8004d0c:	68fb      	ldr	r3, [r7, #12]
 8004d0e:	1dfa      	adds	r2, r7, #7
 8004d10:	7812      	ldrb	r2, [r2, #0]
 8004d12:	701a      	strb	r2, [r3, #0]
    os_getArtEui(d + OFF_JR_ARTEUI);
 8004d14:	68fb      	ldr	r3, [r7, #12]
 8004d16:	3301      	adds	r3, #1
 8004d18:	0018      	movs	r0, r3
 8004d1a:	f000 fdd3 	bl	80058c4 <os_getArtEui>
    os_getDevEui(d + OFF_JR_DEVEUI);
 8004d1e:	68fb      	ldr	r3, [r7, #12]
 8004d20:	3309      	adds	r3, #9
 8004d22:	0018      	movs	r0, r3
 8004d24:	f000 fde0 	bl	80058e8 <os_getDevEui>
    os_wlsbf2(d + OFF_JR_DEVNONCE, LMIC.devNonce);
 8004d28:	68fb      	ldr	r3, [r7, #12]
 8004d2a:	3311      	adds	r3, #17
 8004d2c:	001a      	movs	r2, r3
 8004d2e:	4b0f      	ldr	r3, [pc, #60]	; (8004d6c <buildJoinRequest+0x70>)
 8004d30:	21f2      	movs	r1, #242	; 0xf2
 8004d32:	5a5b      	ldrh	r3, [r3, r1]
 8004d34:	0019      	movs	r1, r3
 8004d36:	0010      	movs	r0, r2
 8004d38:	f7fd fbee 	bl	8002518 <os_wlsbf2>
    aes_appendMic0(d, OFF_JR_MIC);
 8004d3c:	68fb      	ldr	r3, [r7, #12]
 8004d3e:	2113      	movs	r1, #19
 8004d40:	0018      	movs	r0, r3
 8004d42:	f7fd fd25 	bl	8002790 <aes_appendMic0>
                      e_.oldaddr = LMIC.devaddr,
                      e_.mic     = Base::lsbf4(&d[LORA::OFF_JR_MIC]),
                      e_.reason  = ((LMIC.opmode & OP_REJOIN) != 0
                                    ? EV::joininfo_t::REJOIN_REQUEST
                                    : EV::joininfo_t::REQUEST)));
    LMIC.dataLen = LEN_JR;
 8004d46:	4a09      	ldr	r2, [pc, #36]	; (8004d6c <buildJoinRequest+0x70>)
 8004d48:	2348      	movs	r3, #72	; 0x48
 8004d4a:	33ff      	adds	r3, #255	; 0xff
 8004d4c:	2117      	movs	r1, #23
 8004d4e:	54d1      	strb	r1, [r2, r3]
    LMIC.devNonce++;
 8004d50:	4b06      	ldr	r3, [pc, #24]	; (8004d6c <buildJoinRequest+0x70>)
 8004d52:	22f2      	movs	r2, #242	; 0xf2
 8004d54:	5a9b      	ldrh	r3, [r3, r2]
 8004d56:	3301      	adds	r3, #1
 8004d58:	b299      	uxth	r1, r3
 8004d5a:	4b04      	ldr	r3, [pc, #16]	; (8004d6c <buildJoinRequest+0x70>)
 8004d5c:	22f2      	movs	r2, #242	; 0xf2
 8004d5e:	5299      	strh	r1, [r3, r2]
    DO_DEVDB(LMIC.devNonce,devNonce);
}
 8004d60:	46c0      	nop			; (mov r8, r8)
 8004d62:	46bd      	mov	sp, r7
 8004d64:	b004      	add	sp, #16
 8004d66:	bd80      	pop	{r7, pc}
 8004d68:	2000046c 	.word	0x2000046c
 8004d6c:	20000324 	.word	0x20000324

08004d70 <startJoining>:

static void startJoining (xref2osjob_t osjob) {
 8004d70:	b580      	push	{r7, lr}
 8004d72:	b082      	sub	sp, #8
 8004d74:	af00      	add	r7, sp, #0
 8004d76:	6078      	str	r0, [r7, #4]
    reportEvent(EV_JOINING);
 8004d78:	2005      	movs	r0, #5
 8004d7a:	f7fe fcc3 	bl	8003704 <reportEvent>
}
 8004d7e:	46c0      	nop			; (mov r8, r8)
 8004d80:	46bd      	mov	sp, r7
 8004d82:	b002      	add	sp, #8
 8004d84:	bd80      	pop	{r7, pc}
	...

08004d88 <LMIC_startJoining>:

// Start join procedure if not already joined.
bit_t LMIC_startJoining (void) {
 8004d88:	b580      	push	{r7, lr}
 8004d8a:	af00      	add	r7, sp, #0
    if( LMIC.devaddr == 0 ) {
 8004d8c:	4a22      	ldr	r2, [pc, #136]	; (8004e18 <LMIC_startJoining+0x90>)
 8004d8e:	238a      	movs	r3, #138	; 0x8a
 8004d90:	005b      	lsls	r3, r3, #1
 8004d92:	58d3      	ldr	r3, [r2, r3]
 8004d94:	2b00      	cmp	r3, #0
 8004d96:	d13a      	bne.n	8004e0e <LMIC_startJoining+0x86>
        // There should be no TX/RX going on
        ASSERT((LMIC.opmode & (OP_POLL|OP_TXRXPEND)) == 0);
 8004d98:	4b1f      	ldr	r3, [pc, #124]	; (8004e18 <LMIC_startJoining+0x90>)
 8004d9a:	22ac      	movs	r2, #172	; 0xac
 8004d9c:	5a9b      	ldrh	r3, [r3, r2]
 8004d9e:	001a      	movs	r2, r3
 8004da0:	2390      	movs	r3, #144	; 0x90
 8004da2:	4013      	ands	r3, r2
 8004da4:	d001      	beq.n	8004daa <LMIC_startJoining+0x22>
 8004da6:	f7fd fa51 	bl	800224c <hal_failed>
        // Lift any previous duty limitation
        LMIC.globalDutyRate = 0;
 8004daa:	4b1b      	ldr	r3, [pc, #108]	; (8004e18 <LMIC_startJoining+0x90>)
 8004dac:	22a3      	movs	r2, #163	; 0xa3
 8004dae:	2100      	movs	r1, #0
 8004db0:	5499      	strb	r1, [r3, r2]
        // Cancel scanning
        LMIC.opmode &= ~(OP_SCAN|OP_REJOIN|OP_LINKDEAD|OP_NEXTCHNL);
 8004db2:	4b19      	ldr	r3, [pc, #100]	; (8004e18 <LMIC_startJoining+0x90>)
 8004db4:	22ac      	movs	r2, #172	; 0xac
 8004db6:	5a9b      	ldrh	r3, [r3, r2]
 8004db8:	4a18      	ldr	r2, [pc, #96]	; (8004e1c <LMIC_startJoining+0x94>)
 8004dba:	4013      	ands	r3, r2
 8004dbc:	b299      	uxth	r1, r3
 8004dbe:	4b16      	ldr	r3, [pc, #88]	; (8004e18 <LMIC_startJoining+0x90>)
 8004dc0:	22ac      	movs	r2, #172	; 0xac
 8004dc2:	5299      	strh	r1, [r3, r2]
        // Setup state
        LMIC.rejoinCnt = LMIC.txCnt = LMIC.pendTxConf = 0;
 8004dc4:	4b14      	ldr	r3, [pc, #80]	; (8004e18 <LMIC_startJoining+0x90>)
 8004dc6:	22bb      	movs	r2, #187	; 0xbb
 8004dc8:	2100      	movs	r1, #0
 8004dca:	5499      	strb	r1, [r3, r2]
 8004dcc:	4b12      	ldr	r3, [pc, #72]	; (8004e18 <LMIC_startJoining+0x90>)
 8004dce:	22bb      	movs	r2, #187	; 0xbb
 8004dd0:	5c99      	ldrb	r1, [r3, r2]
 8004dd2:	4a11      	ldr	r2, [pc, #68]	; (8004e18 <LMIC_startJoining+0x90>)
 8004dd4:	23a2      	movs	r3, #162	; 0xa2
 8004dd6:	005b      	lsls	r3, r3, #1
 8004dd8:	54d1      	strb	r1, [r2, r3]
 8004dda:	4a0f      	ldr	r2, [pc, #60]	; (8004e18 <LMIC_startJoining+0x90>)
 8004ddc:	23a2      	movs	r3, #162	; 0xa2
 8004dde:	005b      	lsls	r3, r3, #1
 8004de0:	5cd1      	ldrb	r1, [r2, r3]
 8004de2:	4b0d      	ldr	r3, [pc, #52]	; (8004e18 <LMIC_startJoining+0x90>)
 8004de4:	22b2      	movs	r2, #178	; 0xb2
 8004de6:	5499      	strb	r1, [r3, r2]
        initJoinLoop();
 8004de8:	f7fe fbe0 	bl	80035ac <initJoinLoop>
        LMIC.opmode |= OP_JOINING;
 8004dec:	4b0a      	ldr	r3, [pc, #40]	; (8004e18 <LMIC_startJoining+0x90>)
 8004dee:	22ac      	movs	r2, #172	; 0xac
 8004df0:	5a9b      	ldrh	r3, [r3, r2]
 8004df2:	2204      	movs	r2, #4
 8004df4:	4313      	orrs	r3, r2
 8004df6:	b299      	uxth	r1, r3
 8004df8:	4b07      	ldr	r3, [pc, #28]	; (8004e18 <LMIC_startJoining+0x90>)
 8004dfa:	22ac      	movs	r2, #172	; 0xac
 8004dfc:	5299      	strh	r1, [r3, r2]
        // reportEvent will call engineUpdate which then starts sending JOIN REQUESTS
        os_setCallback(&LMIC.osjob, FUNC_ADDR(startJoining));
 8004dfe:	4a08      	ldr	r2, [pc, #32]	; (8004e20 <LMIC_startJoining+0x98>)
 8004e00:	4b08      	ldr	r3, [pc, #32]	; (8004e24 <LMIC_startJoining+0x9c>)
 8004e02:	0011      	movs	r1, r2
 8004e04:	0018      	movs	r0, r3
 8004e06:	f001 faa9 	bl	800635c <os_setCallback>
        return 1;
 8004e0a:	2301      	movs	r3, #1
 8004e0c:	e000      	b.n	8004e10 <LMIC_startJoining+0x88>
    }
    return 0; // already joined
 8004e0e:	2300      	movs	r3, #0
}
 8004e10:	0018      	movs	r0, r3
 8004e12:	46bd      	mov	sp, r7
 8004e14:	bd80      	pop	{r7, pc}
 8004e16:	46c0      	nop			; (mov r8, r8)
 8004e18:	20000324 	.word	0x20000324
 8004e1c:	ffffe7de 	.word	0xffffe7de
 8004e20:	08004d71 	.word	0x08004d71
 8004e24:	20000338 	.word	0x20000338

08004e28 <processPingRx>:
//
//
//
// ================================================================================

static void processPingRx (xref2osjob_t osjob) {
 8004e28:	b580      	push	{r7, lr}
 8004e2a:	b082      	sub	sp, #8
 8004e2c:	af00      	add	r7, sp, #0
 8004e2e:	6078      	str	r0, [r7, #4]
    if( LMIC.dataLen != 0 ) {
 8004e30:	4a0b      	ldr	r2, [pc, #44]	; (8004e60 <processPingRx+0x38>)
 8004e32:	2348      	movs	r3, #72	; 0x48
 8004e34:	33ff      	adds	r3, #255	; 0xff
 8004e36:	5cd3      	ldrb	r3, [r2, r3]
 8004e38:	2b00      	cmp	r3, #0
 8004e3a:	d00c      	beq.n	8004e56 <processPingRx+0x2e>
        LMIC.txrxFlags = TXRX_PING;
 8004e3c:	4a08      	ldr	r2, [pc, #32]	; (8004e60 <processPingRx+0x38>)
 8004e3e:	2346      	movs	r3, #70	; 0x46
 8004e40:	33ff      	adds	r3, #255	; 0xff
 8004e42:	2104      	movs	r1, #4
 8004e44:	54d1      	strb	r1, [r2, r3]
        if( decodeFrame() ) {
 8004e46:	f7fe fd9f 	bl	8003988 <decodeFrame>
 8004e4a:	1e03      	subs	r3, r0, #0
 8004e4c:	d003      	beq.n	8004e56 <processPingRx+0x2e>
            reportEvent(EV_RXCOMPLETE);
 8004e4e:	200d      	movs	r0, #13
 8004e50:	f7fe fc58 	bl	8003704 <reportEvent>
            return;
 8004e54:	e001      	b.n	8004e5a <processPingRx+0x32>
        }
    }
    // Pick next ping slot
    engineUpdate();
 8004e56:	f000 fa83 	bl	8005360 <engineUpdate>
}
 8004e5a:	46bd      	mov	sp, r7
 8004e5c:	b002      	add	sp, #8
 8004e5e:	bd80      	pop	{r7, pc}
 8004e60:	20000324 	.word	0x20000324

08004e64 <processDnData>:


static bit_t processDnData (void) {
 8004e64:	b580      	push	{r7, lr}
 8004e66:	af00      	add	r7, sp, #0
    ASSERT((LMIC.opmode & OP_TXRXPEND)!=0);
 8004e68:	4b83      	ldr	r3, [pc, #524]	; (8005078 <processDnData+0x214>)
 8004e6a:	22ac      	movs	r2, #172	; 0xac
 8004e6c:	5a9b      	ldrh	r3, [r3, r2]
 8004e6e:	001a      	movs	r2, r3
 8004e70:	2380      	movs	r3, #128	; 0x80
 8004e72:	4013      	ands	r3, r2
 8004e74:	d101      	bne.n	8004e7a <processDnData+0x16>
 8004e76:	f7fd f9e9 	bl	800224c <hal_failed>

    if( LMIC.dataLen == 0 ) {
 8004e7a:	4a7f      	ldr	r2, [pc, #508]	; (8005078 <processDnData+0x214>)
 8004e7c:	2348      	movs	r3, #72	; 0x48
 8004e7e:	33ff      	adds	r3, #255	; 0xff
 8004e80:	5cd3      	ldrb	r3, [r2, r3]
 8004e82:	2b00      	cmp	r3, #0
 8004e84:	d000      	beq.n	8004e88 <processDnData+0x24>
 8004e86:	e0e4      	b.n	8005052 <processDnData+0x1ee>
      norx:
 8004e88:	46c0      	nop			; (mov r8, r8)
 8004e8a:	e000      	b.n	8004e8e <processDnData+0x2a>
        return 1;
    }
    if( !decodeFrame() ) {
        if( (LMIC.txrxFlags & TXRX_DNW1) != 0 )
            return 0;
        goto norx;
 8004e8c:	46c0      	nop			; (mov r8, r8)
        if( LMIC.txCnt != 0 ) {
 8004e8e:	4a7a      	ldr	r2, [pc, #488]	; (8005078 <processDnData+0x214>)
 8004e90:	23a2      	movs	r3, #162	; 0xa2
 8004e92:	005b      	lsls	r3, r3, #1
 8004e94:	5cd3      	ldrb	r3, [r2, r3]
 8004e96:	2b00      	cmp	r3, #0
 8004e98:	d03d      	beq.n	8004f16 <processDnData+0xb2>
            if( LMIC.txCnt < TXCONF_ATTEMPTS ) {
 8004e9a:	4a77      	ldr	r2, [pc, #476]	; (8005078 <processDnData+0x214>)
 8004e9c:	23a2      	movs	r3, #162	; 0xa2
 8004e9e:	005b      	lsls	r3, r3, #1
 8004ea0:	5cd3      	ldrb	r3, [r2, r3]
 8004ea2:	2b07      	cmp	r3, #7
 8004ea4:	d831      	bhi.n	8004f0a <processDnData+0xa6>
                LMIC.txCnt += 1;
 8004ea6:	4a74      	ldr	r2, [pc, #464]	; (8005078 <processDnData+0x214>)
 8004ea8:	23a2      	movs	r3, #162	; 0xa2
 8004eaa:	005b      	lsls	r3, r3, #1
 8004eac:	5cd3      	ldrb	r3, [r2, r3]
 8004eae:	3301      	adds	r3, #1
 8004eb0:	b2d9      	uxtb	r1, r3
 8004eb2:	4a71      	ldr	r2, [pc, #452]	; (8005078 <processDnData+0x214>)
 8004eb4:	23a2      	movs	r3, #162	; 0xa2
 8004eb6:	005b      	lsls	r3, r3, #1
 8004eb8:	54d1      	strb	r1, [r2, r3]
                setDrTxpow(DRCHG_NOACK, lowerDR(LMIC.datarate, DRADJUST[LMIC.txCnt]), KEEP_TXPOW);
 8004eba:	4b6f      	ldr	r3, [pc, #444]	; (8005078 <processDnData+0x214>)
 8004ebc:	22b0      	movs	r2, #176	; 0xb0
 8004ebe:	5c98      	ldrb	r0, [r3, r2]
 8004ec0:	4a6d      	ldr	r2, [pc, #436]	; (8005078 <processDnData+0x214>)
 8004ec2:	23a2      	movs	r3, #162	; 0xa2
 8004ec4:	005b      	lsls	r3, r3, #1
 8004ec6:	5cd3      	ldrb	r3, [r2, r3]
 8004ec8:	001a      	movs	r2, r3
 8004eca:	4b6c      	ldr	r3, [pc, #432]	; (800507c <processDnData+0x218>)
 8004ecc:	5c9b      	ldrb	r3, [r3, r2]
 8004ece:	0019      	movs	r1, r3
 8004ed0:	f7fd faba 	bl	8002448 <lowerDR>
 8004ed4:	0003      	movs	r3, r0
 8004ed6:	0019      	movs	r1, r3
 8004ed8:	2380      	movs	r3, #128	; 0x80
 8004eda:	425b      	negs	r3, r3
 8004edc:	001a      	movs	r2, r3
 8004ede:	2002      	movs	r0, #2
 8004ee0:	f7fe f848 	bl	8002f74 <setDrTxpow>
                txDelay(LMIC.rxtime, RETRY_PERIOD_secs);
 8004ee4:	4b64      	ldr	r3, [pc, #400]	; (8005078 <processDnData+0x214>)
 8004ee6:	685b      	ldr	r3, [r3, #4]
 8004ee8:	2103      	movs	r1, #3
 8004eea:	0018      	movs	r0, r3
 8004eec:	f7fd fffe 	bl	8002eec <txDelay>
                LMIC.opmode &= ~OP_TXRXPEND;
 8004ef0:	4b61      	ldr	r3, [pc, #388]	; (8005078 <processDnData+0x214>)
 8004ef2:	22ac      	movs	r2, #172	; 0xac
 8004ef4:	5a9b      	ldrh	r3, [r3, r2]
 8004ef6:	2280      	movs	r2, #128	; 0x80
 8004ef8:	4393      	bics	r3, r2
 8004efa:	b299      	uxth	r1, r3
 8004efc:	4b5e      	ldr	r3, [pc, #376]	; (8005078 <processDnData+0x214>)
 8004efe:	22ac      	movs	r2, #172	; 0xac
 8004f00:	5299      	strh	r1, [r3, r2]
                engineUpdate();
 8004f02:	f000 fa2d 	bl	8005360 <engineUpdate>
                return 1;
 8004f06:	2301      	movs	r3, #1
 8004f08:	e0b2      	b.n	8005070 <processDnData+0x20c>
            LMIC.txrxFlags = TXRX_NACK | TXRX_NOPORT;
 8004f0a:	4a5b      	ldr	r2, [pc, #364]	; (8005078 <processDnData+0x214>)
 8004f0c:	2346      	movs	r3, #70	; 0x46
 8004f0e:	33ff      	adds	r3, #255	; 0xff
 8004f10:	2160      	movs	r1, #96	; 0x60
 8004f12:	54d1      	strb	r1, [r2, r3]
 8004f14:	e004      	b.n	8004f20 <processDnData+0xbc>
            LMIC.txrxFlags = TXRX_NOPORT;
 8004f16:	4a58      	ldr	r2, [pc, #352]	; (8005078 <processDnData+0x214>)
 8004f18:	2346      	movs	r3, #70	; 0x46
 8004f1a:	33ff      	adds	r3, #255	; 0xff
 8004f1c:	2120      	movs	r1, #32
 8004f1e:	54d1      	strb	r1, [r2, r3]
        if( LMIC.adrAckReq != LINK_CHECK_OFF )
 8004f20:	4a55      	ldr	r2, [pc, #340]	; (8005078 <processDnData+0x214>)
 8004f22:	2322      	movs	r3, #34	; 0x22
 8004f24:	33ff      	adds	r3, #255	; 0xff
 8004f26:	56d3      	ldrsb	r3, [r2, r3]
 8004f28:	3380      	adds	r3, #128	; 0x80
 8004f2a:	d00b      	beq.n	8004f44 <processDnData+0xe0>
            LMIC.adrAckReq += 1;
 8004f2c:	4a52      	ldr	r2, [pc, #328]	; (8005078 <processDnData+0x214>)
 8004f2e:	2322      	movs	r3, #34	; 0x22
 8004f30:	33ff      	adds	r3, #255	; 0xff
 8004f32:	56d3      	ldrsb	r3, [r2, r3]
 8004f34:	b2db      	uxtb	r3, r3
 8004f36:	3301      	adds	r3, #1
 8004f38:	b2db      	uxtb	r3, r3
 8004f3a:	b259      	sxtb	r1, r3
 8004f3c:	4a4e      	ldr	r2, [pc, #312]	; (8005078 <processDnData+0x214>)
 8004f3e:	2322      	movs	r3, #34	; 0x22
 8004f40:	33ff      	adds	r3, #255	; 0xff
 8004f42:	54d1      	strb	r1, [r2, r3]
        LMIC.dataBeg = LMIC.dataLen = 0;
 8004f44:	4a4c      	ldr	r2, [pc, #304]	; (8005078 <processDnData+0x214>)
 8004f46:	2348      	movs	r3, #72	; 0x48
 8004f48:	33ff      	adds	r3, #255	; 0xff
 8004f4a:	2100      	movs	r1, #0
 8004f4c:	54d1      	strb	r1, [r2, r3]
 8004f4e:	4a4a      	ldr	r2, [pc, #296]	; (8005078 <processDnData+0x214>)
 8004f50:	2348      	movs	r3, #72	; 0x48
 8004f52:	33ff      	adds	r3, #255	; 0xff
 8004f54:	5cd1      	ldrb	r1, [r2, r3]
 8004f56:	4a48      	ldr	r2, [pc, #288]	; (8005078 <processDnData+0x214>)
 8004f58:	23a3      	movs	r3, #163	; 0xa3
 8004f5a:	005b      	lsls	r3, r3, #1
 8004f5c:	54d1      	strb	r1, [r2, r3]
 8004f5e:	e000      	b.n	8004f62 <processDnData+0xfe>
    }
    goto txcomplete;
 8004f60:	46c0      	nop			; (mov r8, r8)
        LMIC.opmode &= ~(OP_TXDATA|OP_TXRXPEND);
 8004f62:	4b45      	ldr	r3, [pc, #276]	; (8005078 <processDnData+0x214>)
 8004f64:	22ac      	movs	r2, #172	; 0xac
 8004f66:	5a9b      	ldrh	r3, [r3, r2]
 8004f68:	2288      	movs	r2, #136	; 0x88
 8004f6a:	4393      	bics	r3, r2
 8004f6c:	b299      	uxth	r1, r3
 8004f6e:	4b42      	ldr	r3, [pc, #264]	; (8005078 <processDnData+0x214>)
 8004f70:	22ac      	movs	r2, #172	; 0xac
 8004f72:	5299      	strh	r1, [r3, r2]
        if( (LMIC.txrxFlags & (TXRX_DNW1|TXRX_DNW2|TXRX_PING)) != 0  &&  (LMIC.opmode & OP_LINKDEAD) != 0 ) {
 8004f74:	4a40      	ldr	r2, [pc, #256]	; (8005078 <processDnData+0x214>)
 8004f76:	2346      	movs	r3, #70	; 0x46
 8004f78:	33ff      	adds	r3, #255	; 0xff
 8004f7a:	5cd3      	ldrb	r3, [r2, r3]
 8004f7c:	001a      	movs	r2, r3
 8004f7e:	2307      	movs	r3, #7
 8004f80:	4013      	ands	r3, r2
 8004f82:	d013      	beq.n	8004fac <processDnData+0x148>
 8004f84:	4b3c      	ldr	r3, [pc, #240]	; (8005078 <processDnData+0x214>)
 8004f86:	22ac      	movs	r2, #172	; 0xac
 8004f88:	5a9b      	ldrh	r3, [r3, r2]
 8004f8a:	001a      	movs	r2, r3
 8004f8c:	2380      	movs	r3, #128	; 0x80
 8004f8e:	015b      	lsls	r3, r3, #5
 8004f90:	4013      	ands	r3, r2
 8004f92:	d00b      	beq.n	8004fac <processDnData+0x148>
            LMIC.opmode &= ~OP_LINKDEAD;
 8004f94:	4b38      	ldr	r3, [pc, #224]	; (8005078 <processDnData+0x214>)
 8004f96:	22ac      	movs	r2, #172	; 0xac
 8004f98:	5a9b      	ldrh	r3, [r3, r2]
 8004f9a:	4a39      	ldr	r2, [pc, #228]	; (8005080 <processDnData+0x21c>)
 8004f9c:	4013      	ands	r3, r2
 8004f9e:	b299      	uxth	r1, r3
 8004fa0:	4b35      	ldr	r3, [pc, #212]	; (8005078 <processDnData+0x214>)
 8004fa2:	22ac      	movs	r2, #172	; 0xac
 8004fa4:	5299      	strh	r1, [r3, r2]
            reportEvent(EV_LINK_ALIVE);
 8004fa6:	200f      	movs	r0, #15
 8004fa8:	f7fe fbac 	bl	8003704 <reportEvent>
        reportEvent(EV_TXCOMPLETE);
 8004fac:	200a      	movs	r0, #10
 8004fae:	f7fe fba9 	bl	8003704 <reportEvent>
        if( LMIC.adrAckReq > LINK_CHECK_DEAD ) {
 8004fb2:	4a31      	ldr	r2, [pc, #196]	; (8005078 <processDnData+0x214>)
 8004fb4:	2322      	movs	r3, #34	; 0x22
 8004fb6:	33ff      	adds	r3, #255	; 0xff
 8004fb8:	56d3      	ldrsb	r3, [r2, r3]
 8004fba:	2b18      	cmp	r3, #24
 8004fbc:	dd1f      	ble.n	8004ffe <processDnData+0x19a>
            setDrTxpow(DRCHG_NOADRACK, decDR((dr_t)LMIC.datarate), KEEP_TXPOW);
 8004fbe:	4b2e      	ldr	r3, [pc, #184]	; (8005078 <processDnData+0x214>)
 8004fc0:	22b0      	movs	r2, #176	; 0xb0
 8004fc2:	5c9b      	ldrb	r3, [r3, r2]
 8004fc4:	0018      	movs	r0, r3
 8004fc6:	f7fd fa0f 	bl	80023e8 <decDR>
 8004fca:	0003      	movs	r3, r0
 8004fcc:	0019      	movs	r1, r3
 8004fce:	2380      	movs	r3, #128	; 0x80
 8004fd0:	425b      	negs	r3, r3
 8004fd2:	001a      	movs	r2, r3
 8004fd4:	2003      	movs	r0, #3
 8004fd6:	f7fd ffcd 	bl	8002f74 <setDrTxpow>
            LMIC.adrAckReq = LINK_CHECK_CONT;
 8004fda:	4a27      	ldr	r2, [pc, #156]	; (8005078 <processDnData+0x214>)
 8004fdc:	2322      	movs	r3, #34	; 0x22
 8004fde:	33ff      	adds	r3, #255	; 0xff
 8004fe0:	210c      	movs	r1, #12
 8004fe2:	54d1      	strb	r1, [r2, r3]
            LMIC.opmode |= OP_REJOIN|OP_LINKDEAD;
 8004fe4:	4b24      	ldr	r3, [pc, #144]	; (8005078 <processDnData+0x214>)
 8004fe6:	22ac      	movs	r2, #172	; 0xac
 8004fe8:	5a9b      	ldrh	r3, [r3, r2]
 8004fea:	2281      	movs	r2, #129	; 0x81
 8004fec:	0152      	lsls	r2, r2, #5
 8004fee:	4313      	orrs	r3, r2
 8004ff0:	b299      	uxth	r1, r3
 8004ff2:	4b21      	ldr	r3, [pc, #132]	; (8005078 <processDnData+0x214>)
 8004ff4:	22ac      	movs	r2, #172	; 0xac
 8004ff6:	5299      	strh	r1, [r3, r2]
            reportEvent(EV_LINK_DEAD);
 8004ff8:	200e      	movs	r0, #14
 8004ffa:	f7fe fb83 	bl	8003704 <reportEvent>
        if( LMIC.bcninfoTries > 0 ) {
 8004ffe:	4a1e      	ldr	r2, [pc, #120]	; (8005078 <processDnData+0x214>)
 8005000:	2399      	movs	r3, #153	; 0x99
 8005002:	005b      	lsls	r3, r3, #1
 8005004:	5cd3      	ldrb	r3, [r2, r3]
 8005006:	2b00      	cmp	r3, #0
 8005008:	d021      	beq.n	800504e <processDnData+0x1ea>
            if( (LMIC.opmode & OP_TRACK) != 0 ) {
 800500a:	4b1b      	ldr	r3, [pc, #108]	; (8005078 <processDnData+0x214>)
 800500c:	22ac      	movs	r2, #172	; 0xac
 800500e:	5a9b      	ldrh	r3, [r3, r2]
 8005010:	001a      	movs	r2, r3
 8005012:	2302      	movs	r3, #2
 8005014:	4013      	ands	r3, r2
 8005016:	d008      	beq.n	800502a <processDnData+0x1c6>
                reportEvent(EV_BEACON_FOUND);
 8005018:	2002      	movs	r0, #2
 800501a:	f7fe fb73 	bl	8003704 <reportEvent>
                LMIC.bcninfoTries = 0;
 800501e:	4a16      	ldr	r2, [pc, #88]	; (8005078 <processDnData+0x214>)
 8005020:	2399      	movs	r3, #153	; 0x99
 8005022:	005b      	lsls	r3, r3, #1
 8005024:	2100      	movs	r1, #0
 8005026:	54d1      	strb	r1, [r2, r3]
 8005028:	e011      	b.n	800504e <processDnData+0x1ea>
            else if( --LMIC.bcninfoTries == 0 ) {
 800502a:	4a13      	ldr	r2, [pc, #76]	; (8005078 <processDnData+0x214>)
 800502c:	2399      	movs	r3, #153	; 0x99
 800502e:	005b      	lsls	r3, r3, #1
 8005030:	5cd3      	ldrb	r3, [r2, r3]
 8005032:	3b01      	subs	r3, #1
 8005034:	b2d9      	uxtb	r1, r3
 8005036:	4a10      	ldr	r2, [pc, #64]	; (8005078 <processDnData+0x214>)
 8005038:	2399      	movs	r3, #153	; 0x99
 800503a:	005b      	lsls	r3, r3, #1
 800503c:	54d1      	strb	r1, [r2, r3]
 800503e:	4a0e      	ldr	r2, [pc, #56]	; (8005078 <processDnData+0x214>)
 8005040:	2399      	movs	r3, #153	; 0x99
 8005042:	005b      	lsls	r3, r3, #1
 8005044:	5cd3      	ldrb	r3, [r2, r3]
 8005046:	2b00      	cmp	r3, #0
 8005048:	d101      	bne.n	800504e <processDnData+0x1ea>
                startScan();   // NWK did not answer - try scan
 800504a:	f7ff fdf7 	bl	8004c3c <startScan>
        return 1;
 800504e:	2301      	movs	r3, #1
 8005050:	e00e      	b.n	8005070 <processDnData+0x20c>
    if( !decodeFrame() ) {
 8005052:	f7fe fc99 	bl	8003988 <decodeFrame>
 8005056:	1e03      	subs	r3, r0, #0
 8005058:	d000      	beq.n	800505c <processDnData+0x1f8>
 800505a:	e781      	b.n	8004f60 <processDnData+0xfc>
        if( (LMIC.txrxFlags & TXRX_DNW1) != 0 )
 800505c:	4a06      	ldr	r2, [pc, #24]	; (8005078 <processDnData+0x214>)
 800505e:	2346      	movs	r3, #70	; 0x46
 8005060:	33ff      	adds	r3, #255	; 0xff
 8005062:	5cd3      	ldrb	r3, [r2, r3]
 8005064:	001a      	movs	r2, r3
 8005066:	2301      	movs	r3, #1
 8005068:	4013      	ands	r3, r2
 800506a:	d100      	bne.n	800506e <processDnData+0x20a>
 800506c:	e70e      	b.n	8004e8c <processDnData+0x28>
            return 0;
 800506e:	2300      	movs	r3, #0
}
 8005070:	0018      	movs	r0, r3
 8005072:	46bd      	mov	sp, r7
 8005074:	bd80      	pop	{r7, pc}
 8005076:	46c0      	nop			; (mov r8, r8)
 8005078:	20000324 	.word	0x20000324
 800507c:	0800f118 	.word	0x0800f118
 8005080:	ffffefff 	.word	0xffffefff

08005084 <processBeacon>:


static void processBeacon (xref2osjob_t osjob) {
 8005084:	b5b0      	push	{r4, r5, r7, lr}
 8005086:	b086      	sub	sp, #24
 8005088:	af00      	add	r7, sp, #0
 800508a:	6078      	str	r0, [r7, #4]
    ostime_t lasttx = LMIC.bcninfo.txtime;   // save here - decodeBeacon might overwrite
 800508c:	4a9d      	ldr	r2, [pc, #628]	; (8005304 <processBeacon+0x280>)
 800508e:	23c8      	movs	r3, #200	; 0xc8
 8005090:	005b      	lsls	r3, r3, #1
 8005092:	58d3      	ldr	r3, [r2, r3]
 8005094:	60fb      	str	r3, [r7, #12]
    u1_t flags = LMIC.bcninfo.flags;
 8005096:	240b      	movs	r4, #11
 8005098:	193b      	adds	r3, r7, r4
 800509a:	499a      	ldr	r1, [pc, #616]	; (8005304 <processBeacon+0x280>)
 800509c:	22cb      	movs	r2, #203	; 0xcb
 800509e:	0052      	lsls	r2, r2, #1
 80050a0:	5c8a      	ldrb	r2, [r1, r2]
 80050a2:	701a      	strb	r2, [r3, #0]
    ev_t ev;

    if( LMIC.dataLen != 0 && decodeBeacon() >= 1 ) {
 80050a4:	4a97      	ldr	r2, [pc, #604]	; (8005304 <processBeacon+0x280>)
 80050a6:	2348      	movs	r3, #72	; 0x48
 80050a8:	33ff      	adds	r3, #255	; 0xff
 80050aa:	5cd3      	ldrb	r3, [r2, r3]
 80050ac:	2b00      	cmp	r3, #0
 80050ae:	d100      	bne.n	80050b2 <processBeacon+0x2e>
 80050b0:	e0a5      	b.n	80051fe <processBeacon+0x17a>
 80050b2:	f7fe fbc3 	bl	800383c <decodeBeacon>
 80050b6:	1e03      	subs	r3, r0, #0
 80050b8:	dc00      	bgt.n	80050bc <processBeacon+0x38>
 80050ba:	e0a0      	b.n	80051fe <processBeacon+0x17a>
        ev = EV_BEACON_TRACKED;
 80050bc:	2317      	movs	r3, #23
 80050be:	18fb      	adds	r3, r7, r3
 80050c0:	2204      	movs	r2, #4
 80050c2:	701a      	strb	r2, [r3, #0]
        if( (flags & (BCN_PARTIAL|BCN_FULL)) == 0 ) {
 80050c4:	193b      	adds	r3, r7, r4
 80050c6:	781b      	ldrb	r3, [r3, #0]
 80050c8:	2203      	movs	r2, #3
 80050ca:	4013      	ands	r3, r2
 80050cc:	d104      	bne.n	80050d8 <processBeacon+0x54>
            // We don't have a previous beacon to calc some drift - assume
            // an max error of 13ms = 128sec*100ppm which is roughly +/-100ppm
            calcBcnRxWindowFromMillis(13,0);
 80050ce:	2100      	movs	r1, #0
 80050d0:	200d      	movs	r0, #13
 80050d2:	f7fd fd81 	bl	8002bd8 <calcBcnRxWindowFromMillis>
            goto rev;
 80050d6:	e0ff      	b.n	80052d8 <processBeacon+0x254>
        }
        // We have a previous BEACON to calculate some drift
        s2_t drift = BCN_INTV_osticks - (LMIC.bcninfo.txtime - lasttx);
 80050d8:	68fb      	ldr	r3, [r7, #12]
 80050da:	b29a      	uxth	r2, r3
 80050dc:	4989      	ldr	r1, [pc, #548]	; (8005304 <processBeacon+0x280>)
 80050de:	23c8      	movs	r3, #200	; 0xc8
 80050e0:	005b      	lsls	r3, r3, #1
 80050e2:	58cb      	ldr	r3, [r1, r3]
 80050e4:	b29b      	uxth	r3, r3
 80050e6:	1ad3      	subs	r3, r2, r3
 80050e8:	b29b      	uxth	r3, r3
 80050ea:	4a87      	ldr	r2, [pc, #540]	; (8005308 <processBeacon+0x284>)
 80050ec:	4694      	mov	ip, r2
 80050ee:	4463      	add	r3, ip
 80050f0:	b29a      	uxth	r2, r3
 80050f2:	2514      	movs	r5, #20
 80050f4:	197b      	adds	r3, r7, r5
 80050f6:	801a      	strh	r2, [r3, #0]
        if( LMIC.missedBcns > 0 ) {
 80050f8:	4a82      	ldr	r2, [pc, #520]	; (8005304 <processBeacon+0x280>)
 80050fa:	2332      	movs	r3, #50	; 0x32
 80050fc:	33ff      	adds	r3, #255	; 0xff
 80050fe:	5cd3      	ldrb	r3, [r2, r3]
 8005100:	2b00      	cmp	r3, #0
 8005102:	d018      	beq.n	8005136 <processBeacon+0xb2>
            drift = LMIC.drift + (drift - LMIC.drift) / (LMIC.missedBcns+1);
 8005104:	4b7f      	ldr	r3, [pc, #508]	; (8005304 <processBeacon+0x280>)
 8005106:	22b4      	movs	r2, #180	; 0xb4
 8005108:	5e9b      	ldrsh	r3, [r3, r2]
 800510a:	b29c      	uxth	r4, r3
 800510c:	197b      	adds	r3, r7, r5
 800510e:	2200      	movs	r2, #0
 8005110:	5e9b      	ldrsh	r3, [r3, r2]
 8005112:	4a7c      	ldr	r2, [pc, #496]	; (8005304 <processBeacon+0x280>)
 8005114:	21b4      	movs	r1, #180	; 0xb4
 8005116:	5e52      	ldrsh	r2, [r2, r1]
 8005118:	1a98      	subs	r0, r3, r2
 800511a:	4a7a      	ldr	r2, [pc, #488]	; (8005304 <processBeacon+0x280>)
 800511c:	2332      	movs	r3, #50	; 0x32
 800511e:	33ff      	adds	r3, #255	; 0xff
 8005120:	5cd3      	ldrb	r3, [r2, r3]
 8005122:	3301      	adds	r3, #1
 8005124:	0019      	movs	r1, r3
 8005126:	f7fb f879 	bl	800021c <__divsi3>
 800512a:	0003      	movs	r3, r0
 800512c:	b29b      	uxth	r3, r3
 800512e:	18e3      	adds	r3, r4, r3
 8005130:	b29a      	uxth	r2, r3
 8005132:	197b      	adds	r3, r7, r5
 8005134:	801a      	strh	r2, [r3, #0]
        }
        if( (LMIC.bcninfo.flags & BCN_NODRIFT) == 0 ) {
 8005136:	4a73      	ldr	r2, [pc, #460]	; (8005304 <processBeacon+0x280>)
 8005138:	23cb      	movs	r3, #203	; 0xcb
 800513a:	005b      	lsls	r3, r3, #1
 800513c:	5cd3      	ldrb	r3, [r2, r3]
 800513e:	001a      	movs	r2, r3
 8005140:	2304      	movs	r3, #4
 8005142:	4013      	ands	r3, r2
 8005144:	d134      	bne.n	80051b0 <processBeacon+0x12c>
            s2_t diff = LMIC.drift - drift;
 8005146:	4b6f      	ldr	r3, [pc, #444]	; (8005304 <processBeacon+0x280>)
 8005148:	22b4      	movs	r2, #180	; 0xb4
 800514a:	5e9b      	ldrsh	r3, [r3, r2]
 800514c:	b29a      	uxth	r2, r3
 800514e:	2314      	movs	r3, #20
 8005150:	18fb      	adds	r3, r7, r3
 8005152:	881b      	ldrh	r3, [r3, #0]
 8005154:	1ad3      	subs	r3, r2, r3
 8005156:	b29a      	uxth	r2, r3
 8005158:	2112      	movs	r1, #18
 800515a:	187b      	adds	r3, r7, r1
 800515c:	801a      	strh	r2, [r3, #0]
            if( diff < 0 ) diff = -diff;
 800515e:	187b      	adds	r3, r7, r1
 8005160:	2200      	movs	r2, #0
 8005162:	5e9b      	ldrsh	r3, [r3, r2]
 8005164:	2b00      	cmp	r3, #0
 8005166:	da05      	bge.n	8005174 <processBeacon+0xf0>
 8005168:	187b      	adds	r3, r7, r1
 800516a:	881b      	ldrh	r3, [r3, #0]
 800516c:	425b      	negs	r3, r3
 800516e:	b29a      	uxth	r2, r3
 8005170:	187b      	adds	r3, r7, r1
 8005172:	801a      	strh	r2, [r3, #0]
            LMIC.lastDriftDiff = diff;
 8005174:	4b63      	ldr	r3, [pc, #396]	; (8005304 <processBeacon+0x280>)
 8005176:	2012      	movs	r0, #18
 8005178:	183a      	adds	r2, r7, r0
 800517a:	21b6      	movs	r1, #182	; 0xb6
 800517c:	8812      	ldrh	r2, [r2, #0]
 800517e:	525a      	strh	r2, [r3, r1]
            if( LMIC.maxDriftDiff < diff )
 8005180:	4b60      	ldr	r3, [pc, #384]	; (8005304 <processBeacon+0x280>)
 8005182:	22b8      	movs	r2, #184	; 0xb8
 8005184:	5e9b      	ldrsh	r3, [r3, r2]
 8005186:	183a      	adds	r2, r7, r0
 8005188:	2100      	movs	r1, #0
 800518a:	5e52      	ldrsh	r2, [r2, r1]
 800518c:	429a      	cmp	r2, r3
 800518e:	dd04      	ble.n	800519a <processBeacon+0x116>
                LMIC.maxDriftDiff = diff;
 8005190:	4b5c      	ldr	r3, [pc, #368]	; (8005304 <processBeacon+0x280>)
 8005192:	183a      	adds	r2, r7, r0
 8005194:	21b8      	movs	r1, #184	; 0xb8
 8005196:	8812      	ldrh	r2, [r2, #0]
 8005198:	525a      	strh	r2, [r3, r1]
            LMIC.bcninfo.flags &= ~BCN_NODDIFF;
 800519a:	4a5a      	ldr	r2, [pc, #360]	; (8005304 <processBeacon+0x280>)
 800519c:	23cb      	movs	r3, #203	; 0xcb
 800519e:	005b      	lsls	r3, r3, #1
 80051a0:	5cd3      	ldrb	r3, [r2, r3]
 80051a2:	2208      	movs	r2, #8
 80051a4:	4393      	bics	r3, r2
 80051a6:	b2d9      	uxtb	r1, r3
 80051a8:	4a56      	ldr	r2, [pc, #344]	; (8005304 <processBeacon+0x280>)
 80051aa:	23cb      	movs	r3, #203	; 0xcb
 80051ac:	005b      	lsls	r3, r3, #1
 80051ae:	54d1      	strb	r1, [r2, r3]
        }
        LMIC.drift = drift;
 80051b0:	4b54      	ldr	r3, [pc, #336]	; (8005304 <processBeacon+0x280>)
 80051b2:	2214      	movs	r2, #20
 80051b4:	18ba      	adds	r2, r7, r2
 80051b6:	21b4      	movs	r1, #180	; 0xb4
 80051b8:	8812      	ldrh	r2, [r2, #0]
 80051ba:	525a      	strh	r2, [r3, r1]
        LMIC.missedBcns = LMIC.rejoinCnt = 0;
 80051bc:	4b51      	ldr	r3, [pc, #324]	; (8005304 <processBeacon+0x280>)
 80051be:	22b2      	movs	r2, #178	; 0xb2
 80051c0:	2100      	movs	r1, #0
 80051c2:	5499      	strb	r1, [r3, r2]
 80051c4:	4b4f      	ldr	r3, [pc, #316]	; (8005304 <processBeacon+0x280>)
 80051c6:	22b2      	movs	r2, #178	; 0xb2
 80051c8:	5c99      	ldrb	r1, [r3, r2]
 80051ca:	4a4e      	ldr	r2, [pc, #312]	; (8005304 <processBeacon+0x280>)
 80051cc:	2332      	movs	r3, #50	; 0x32
 80051ce:	33ff      	adds	r3, #255	; 0xff
 80051d0:	54d1      	strb	r1, [r2, r3]
        LMIC.bcninfo.flags &= ~BCN_NODRIFT;
 80051d2:	4a4c      	ldr	r2, [pc, #304]	; (8005304 <processBeacon+0x280>)
 80051d4:	23cb      	movs	r3, #203	; 0xcb
 80051d6:	005b      	lsls	r3, r3, #1
 80051d8:	5cd3      	ldrb	r3, [r2, r3]
 80051da:	2204      	movs	r2, #4
 80051dc:	4393      	bics	r3, r2
 80051de:	b2d9      	uxtb	r1, r3
 80051e0:	4a48      	ldr	r2, [pc, #288]	; (8005304 <processBeacon+0x280>)
 80051e2:	23cb      	movs	r3, #203	; 0xcb
 80051e4:	005b      	lsls	r3, r3, #1
 80051e6:	54d1      	strb	r1, [r2, r3]
        EV(devCond,INFO,(e_.reason = EV::devCond_t::CLOCK_DRIFT,
                         e_.eui    = MAIN::CDEV->getEui(),
                         e_.info   = drift,
                         e_.info2  = /*occasion BEACON*/0));
        ASSERT((LMIC.bcninfo.flags & (BCN_PARTIAL|BCN_FULL)) != 0);
 80051e8:	4a46      	ldr	r2, [pc, #280]	; (8005304 <processBeacon+0x280>)
 80051ea:	23cb      	movs	r3, #203	; 0xcb
 80051ec:	005b      	lsls	r3, r3, #1
 80051ee:	5cd3      	ldrb	r3, [r2, r3]
 80051f0:	001a      	movs	r2, r3
 80051f2:	2303      	movs	r3, #3
 80051f4:	4013      	ands	r3, r2
 80051f6:	d157      	bne.n	80052a8 <processBeacon+0x224>
 80051f8:	f7fd f828 	bl	800224c <hal_failed>
    if( LMIC.dataLen != 0 && decodeBeacon() >= 1 ) {
 80051fc:	e054      	b.n	80052a8 <processBeacon+0x224>
    } else {
        ev = EV_BEACON_MISSED;
 80051fe:	2317      	movs	r3, #23
 8005200:	18fb      	adds	r3, r7, r3
 8005202:	2203      	movs	r2, #3
 8005204:	701a      	strb	r2, [r3, #0]
        LMIC.bcninfo.txtime += BCN_INTV_osticks - LMIC.drift;
 8005206:	4a3f      	ldr	r2, [pc, #252]	; (8005304 <processBeacon+0x280>)
 8005208:	23c8      	movs	r3, #200	; 0xc8
 800520a:	005b      	lsls	r3, r3, #1
 800520c:	58d2      	ldr	r2, [r2, r3]
 800520e:	4b3d      	ldr	r3, [pc, #244]	; (8005304 <processBeacon+0x280>)
 8005210:	21b4      	movs	r1, #180	; 0xb4
 8005212:	5e5b      	ldrsh	r3, [r3, r1]
 8005214:	0019      	movs	r1, r3
 8005216:	23fa      	movs	r3, #250	; 0xfa
 8005218:	039b      	lsls	r3, r3, #14
 800521a:	1a5b      	subs	r3, r3, r1
 800521c:	18d1      	adds	r1, r2, r3
 800521e:	4a39      	ldr	r2, [pc, #228]	; (8005304 <processBeacon+0x280>)
 8005220:	23c8      	movs	r3, #200	; 0xc8
 8005222:	005b      	lsls	r3, r3, #1
 8005224:	50d1      	str	r1, [r2, r3]
        LMIC.bcninfo.time   += BCN_INTV_sec;
 8005226:	4a37      	ldr	r2, [pc, #220]	; (8005304 <processBeacon+0x280>)
 8005228:	23cc      	movs	r3, #204	; 0xcc
 800522a:	005b      	lsls	r3, r3, #1
 800522c:	58d3      	ldr	r3, [r2, r3]
 800522e:	3380      	adds	r3, #128	; 0x80
 8005230:	0019      	movs	r1, r3
 8005232:	4a34      	ldr	r2, [pc, #208]	; (8005304 <processBeacon+0x280>)
 8005234:	23cc      	movs	r3, #204	; 0xcc
 8005236:	005b      	lsls	r3, r3, #1
 8005238:	50d1      	str	r1, [r2, r3]
        LMIC.missedBcns++;
 800523a:	4a32      	ldr	r2, [pc, #200]	; (8005304 <processBeacon+0x280>)
 800523c:	2332      	movs	r3, #50	; 0x32
 800523e:	33ff      	adds	r3, #255	; 0xff
 8005240:	5cd3      	ldrb	r3, [r2, r3]
 8005242:	3301      	adds	r3, #1
 8005244:	b2d9      	uxtb	r1, r3
 8005246:	4a2f      	ldr	r2, [pc, #188]	; (8005304 <processBeacon+0x280>)
 8005248:	2332      	movs	r3, #50	; 0x32
 800524a:	33ff      	adds	r3, #255	; 0xff
 800524c:	54d1      	strb	r1, [r2, r3]
        // Delay any possible TX after surmised beacon - it's there although we missed it
        txDelay(LMIC.bcninfo.txtime + BCN_RESERVE_osticks, 4);
 800524e:	4a2d      	ldr	r2, [pc, #180]	; (8005304 <processBeacon+0x280>)
 8005250:	23c8      	movs	r3, #200	; 0xc8
 8005252:	005b      	lsls	r3, r3, #1
 8005254:	58d3      	ldr	r3, [r2, r3]
 8005256:	4a2d      	ldr	r2, [pc, #180]	; (800530c <processBeacon+0x288>)
 8005258:	4694      	mov	ip, r2
 800525a:	4463      	add	r3, ip
 800525c:	2104      	movs	r1, #4
 800525e:	0018      	movs	r0, r3
 8005260:	f7fd fe44 	bl	8002eec <txDelay>
        if( LMIC.missedBcns > MAX_MISSED_BCNS )
 8005264:	4a27      	ldr	r2, [pc, #156]	; (8005304 <processBeacon+0x280>)
 8005266:	2332      	movs	r3, #50	; 0x32
 8005268:	33ff      	adds	r3, #255	; 0xff
 800526a:	5cd3      	ldrb	r3, [r2, r3]
 800526c:	2b14      	cmp	r3, #20
 800526e:	d908      	bls.n	8005282 <processBeacon+0x1fe>
            LMIC.opmode |= OP_REJOIN;  // try if we can roam to another network
 8005270:	4b24      	ldr	r3, [pc, #144]	; (8005304 <processBeacon+0x280>)
 8005272:	22ac      	movs	r2, #172	; 0xac
 8005274:	5a9b      	ldrh	r3, [r3, r2]
 8005276:	2220      	movs	r2, #32
 8005278:	4313      	orrs	r3, r2
 800527a:	b299      	uxth	r1, r3
 800527c:	4b21      	ldr	r3, [pc, #132]	; (8005304 <processBeacon+0x280>)
 800527e:	22ac      	movs	r2, #172	; 0xac
 8005280:	5299      	strh	r1, [r3, r2]
        if( LMIC.bcnRxsyms > MAX_RXSYMS ) {
 8005282:	4a20      	ldr	r2, [pc, #128]	; (8005304 <processBeacon+0x280>)
 8005284:	238a      	movs	r3, #138	; 0x8a
 8005286:	33ff      	adds	r3, #255	; 0xff
 8005288:	5cd3      	ldrb	r3, [r2, r3]
 800528a:	2b64      	cmp	r3, #100	; 0x64
 800528c:	d90d      	bls.n	80052aa <processBeacon+0x226>
            LMIC.opmode &= ~(OP_TRACK|OP_PINGABLE|OP_PINGINI|OP_REJOIN);
 800528e:	4b1d      	ldr	r3, [pc, #116]	; (8005304 <processBeacon+0x280>)
 8005290:	22ac      	movs	r2, #172	; 0xac
 8005292:	5a9b      	ldrh	r3, [r3, r2]
 8005294:	4a1e      	ldr	r2, [pc, #120]	; (8005310 <processBeacon+0x28c>)
 8005296:	4013      	ands	r3, r2
 8005298:	b299      	uxth	r1, r3
 800529a:	4b1a      	ldr	r3, [pc, #104]	; (8005304 <processBeacon+0x280>)
 800529c:	22ac      	movs	r2, #172	; 0xac
 800529e:	5299      	strh	r1, [r3, r2]
            reportEvent(EV_LOST_TSYNC);
 80052a0:	200b      	movs	r0, #11
 80052a2:	f7fe fa2f 	bl	8003704 <reportEvent>
            return;
 80052a6:	e029      	b.n	80052fc <processBeacon+0x278>
    if( LMIC.dataLen != 0 && decodeBeacon() >= 1 ) {
 80052a8:	46c0      	nop			; (mov r8, r8)
        }
    }
    LMIC.bcnRxtime = LMIC.bcninfo.txtime + BCN_INTV_osticks - calcRxWindow(0,DR_BCN);
 80052aa:	4a16      	ldr	r2, [pc, #88]	; (8005304 <processBeacon+0x280>)
 80052ac:	23c8      	movs	r3, #200	; 0xc8
 80052ae:	005b      	lsls	r3, r3, #1
 80052b0:	58d3      	ldr	r3, [r2, r3]
 80052b2:	22fa      	movs	r2, #250	; 0xfa
 80052b4:	0392      	lsls	r2, r2, #14
 80052b6:	189c      	adds	r4, r3, r2
 80052b8:	2103      	movs	r1, #3
 80052ba:	2000      	movs	r0, #0
 80052bc:	f7fd fc32 	bl	8002b24 <calcRxWindow>
 80052c0:	0003      	movs	r3, r0
 80052c2:	1ae1      	subs	r1, r4, r3
 80052c4:	4a0f      	ldr	r2, [pc, #60]	; (8005304 <processBeacon+0x280>)
 80052c6:	23c6      	movs	r3, #198	; 0xc6
 80052c8:	005b      	lsls	r3, r3, #1
 80052ca:	50d1      	str	r1, [r2, r3]
    LMIC.bcnRxsyms = LMIC.rxsyms;    
 80052cc:	4b0d      	ldr	r3, [pc, #52]	; (8005304 <processBeacon+0x280>)
 80052ce:	7c19      	ldrb	r1, [r3, #16]
 80052d0:	4a0c      	ldr	r2, [pc, #48]	; (8005304 <processBeacon+0x280>)
 80052d2:	238a      	movs	r3, #138	; 0x8a
 80052d4:	33ff      	adds	r3, #255	; 0xff
 80052d6:	54d1      	strb	r1, [r2, r3]
  rev:
#if CFG_us915
    LMIC.bcnChnl = (LMIC.bcnChnl+1) & 7;
#endif
    if( (LMIC.opmode & OP_PINGINI) != 0 )
 80052d8:	4b0a      	ldr	r3, [pc, #40]	; (8005304 <processBeacon+0x280>)
 80052da:	22ac      	movs	r2, #172	; 0xac
 80052dc:	5a9b      	ldrh	r3, [r3, r2]
 80052de:	001a      	movs	r2, r3
 80052e0:	2380      	movs	r3, #128	; 0x80
 80052e2:	009b      	lsls	r3, r3, #2
 80052e4:	4013      	ands	r3, r2
 80052e6:	d003      	beq.n	80052f0 <processBeacon+0x26c>
        rxschedInit(&LMIC.ping);  // note: reuses LMIC.frame buffer!
 80052e8:	4b0a      	ldr	r3, [pc, #40]	; (8005314 <processBeacon+0x290>)
 80052ea:	0018      	movs	r0, r3
 80052ec:	f7fd fce0 	bl	8002cb0 <rxschedInit>
    reportEvent(ev);
 80052f0:	2317      	movs	r3, #23
 80052f2:	18fb      	adds	r3, r7, r3
 80052f4:	781b      	ldrb	r3, [r3, #0]
 80052f6:	0018      	movs	r0, r3
 80052f8:	f7fe fa04 	bl	8003704 <reportEvent>
}
 80052fc:	46bd      	mov	sp, r7
 80052fe:	b006      	add	sp, #24
 8005300:	bdb0      	pop	{r4, r5, r7, pc}
 8005302:	46c0      	nop			; (mov r8, r8)
 8005304:	20000324 	.word	0x20000324
 8005308:	ffff8000 	.word	0xffff8000
 800530c:	00010900 	.word	0x00010900
 8005310:	fffff9dd 	.word	0xfffff9dd
 8005314:	20000458 	.word	0x20000458

08005318 <startRxBcn>:


static void startRxBcn (xref2osjob_t osjob) {
 8005318:	b580      	push	{r7, lr}
 800531a:	b082      	sub	sp, #8
 800531c:	af00      	add	r7, sp, #0
 800531e:	6078      	str	r0, [r7, #4]
    LMIC.osjob.func = FUNC_ADDR(processBeacon);
 8005320:	4b04      	ldr	r3, [pc, #16]	; (8005334 <startRxBcn+0x1c>)
 8005322:	4a05      	ldr	r2, [pc, #20]	; (8005338 <startRxBcn+0x20>)
 8005324:	61da      	str	r2, [r3, #28]
    os_radio(RADIO_RX);
 8005326:	2002      	movs	r0, #2
 8005328:	f001 fe86 	bl	8007038 <os_radio>
}
 800532c:	46c0      	nop			; (mov r8, r8)
 800532e:	46bd      	mov	sp, r7
 8005330:	b002      	add	sp, #8
 8005332:	bd80      	pop	{r7, pc}
 8005334:	20000324 	.word	0x20000324
 8005338:	08005085 	.word	0x08005085

0800533c <startRxPing>:


static void startRxPing (xref2osjob_t osjob) {
 800533c:	b580      	push	{r7, lr}
 800533e:	b082      	sub	sp, #8
 8005340:	af00      	add	r7, sp, #0
 8005342:	6078      	str	r0, [r7, #4]
    LMIC.osjob.func = FUNC_ADDR(processPingRx);
 8005344:	4b04      	ldr	r3, [pc, #16]	; (8005358 <startRxPing+0x1c>)
 8005346:	4a05      	ldr	r2, [pc, #20]	; (800535c <startRxPing+0x20>)
 8005348:	61da      	str	r2, [r3, #28]
    os_radio(RADIO_RX);
 800534a:	2002      	movs	r0, #2
 800534c:	f001 fe74 	bl	8007038 <os_radio>
}
 8005350:	46c0      	nop			; (mov r8, r8)
 8005352:	46bd      	mov	sp, r7
 8005354:	b002      	add	sp, #8
 8005356:	bd80      	pop	{r7, pc}
 8005358:	20000324 	.word	0x20000324
 800535c:	08004e29 	.word	0x08004e29

08005360 <engineUpdate>:


// Decide what to do next for the MAC layer of a device
static void engineUpdate (void) {
 8005360:	b590      	push	{r4, r7, lr}
 8005362:	b087      	sub	sp, #28
 8005364:	af00      	add	r7, sp, #0
    // Check for ongoing state: scan or TX/RX transaction
    if( (LMIC.opmode & (OP_SCAN|OP_TXRXPEND|OP_SHUTDOWN)) != 0 ) 
 8005366:	4bc9      	ldr	r3, [pc, #804]	; (800568c <engineUpdate+0x32c>)
 8005368:	22ac      	movs	r2, #172	; 0xac
 800536a:	5a9b      	ldrh	r3, [r3, r2]
 800536c:	001a      	movs	r2, r3
 800536e:	23c1      	movs	r3, #193	; 0xc1
 8005370:	4013      	ands	r3, r2
 8005372:	d000      	beq.n	8005376 <engineUpdate+0x16>
 8005374:	e1d7      	b.n	8005726 <engineUpdate+0x3c6>
        return;

    if( LMIC.devaddr == 0 && (LMIC.opmode & OP_JOINING) == 0 ) {
 8005376:	4ac5      	ldr	r2, [pc, #788]	; (800568c <engineUpdate+0x32c>)
 8005378:	238a      	movs	r3, #138	; 0x8a
 800537a:	005b      	lsls	r3, r3, #1
 800537c:	58d3      	ldr	r3, [r2, r3]
 800537e:	2b00      	cmp	r3, #0
 8005380:	d109      	bne.n	8005396 <engineUpdate+0x36>
 8005382:	4bc2      	ldr	r3, [pc, #776]	; (800568c <engineUpdate+0x32c>)
 8005384:	22ac      	movs	r2, #172	; 0xac
 8005386:	5a9b      	ldrh	r3, [r3, r2]
 8005388:	001a      	movs	r2, r3
 800538a:	2304      	movs	r3, #4
 800538c:	4013      	ands	r3, r2
 800538e:	d102      	bne.n	8005396 <engineUpdate+0x36>
        LMIC_startJoining();
 8005390:	f7ff fcfa 	bl	8004d88 <LMIC_startJoining>
        return;
 8005394:	e1ca      	b.n	800572c <engineUpdate+0x3cc>
    }

    ostime_t now    = os_getTime();
 8005396:	f000 ff9b 	bl	80062d0 <os_getTime>
 800539a:	0003      	movs	r3, r0
 800539c:	60bb      	str	r3, [r7, #8]
    ostime_t rxtime = 0;
 800539e:	2300      	movs	r3, #0
 80053a0:	617b      	str	r3, [r7, #20]
    ostime_t txbeg  = 0;
 80053a2:	2300      	movs	r3, #0
 80053a4:	613b      	str	r3, [r7, #16]

    if( (LMIC.opmode & OP_TRACK) != 0 ) {
 80053a6:	4bb9      	ldr	r3, [pc, #740]	; (800568c <engineUpdate+0x32c>)
 80053a8:	22ac      	movs	r2, #172	; 0xac
 80053aa:	5a9b      	ldrh	r3, [r3, r2]
 80053ac:	001a      	movs	r2, r3
 80053ae:	2302      	movs	r3, #2
 80053b0:	4013      	ands	r3, r2
 80053b2:	d011      	beq.n	80053d8 <engineUpdate+0x78>
        // We are tracking a beacon
        ASSERT( now + RX_RAMPUP - LMIC.bcnRxtime <= 0 );
 80053b4:	68bb      	ldr	r3, [r7, #8]
 80053b6:	3340      	adds	r3, #64	; 0x40
 80053b8:	001a      	movs	r2, r3
 80053ba:	49b4      	ldr	r1, [pc, #720]	; (800568c <engineUpdate+0x32c>)
 80053bc:	23c6      	movs	r3, #198	; 0xc6
 80053be:	005b      	lsls	r3, r3, #1
 80053c0:	58cb      	ldr	r3, [r1, r3]
 80053c2:	1ad3      	subs	r3, r2, r3
 80053c4:	2b00      	cmp	r3, #0
 80053c6:	dd01      	ble.n	80053cc <engineUpdate+0x6c>
 80053c8:	f7fc ff40 	bl	800224c <hal_failed>
        rxtime = LMIC.bcnRxtime - RX_RAMPUP;
 80053cc:	4aaf      	ldr	r2, [pc, #700]	; (800568c <engineUpdate+0x32c>)
 80053ce:	23c6      	movs	r3, #198	; 0xc6
 80053d0:	005b      	lsls	r3, r3, #1
 80053d2:	58d3      	ldr	r3, [r2, r3]
 80053d4:	3b40      	subs	r3, #64	; 0x40
 80053d6:	617b      	str	r3, [r7, #20]
    }

    if( (LMIC.opmode & (OP_JOINING|OP_REJOIN|OP_TXDATA|OP_POLL)) != 0 ) {
 80053d8:	4bac      	ldr	r3, [pc, #688]	; (800568c <engineUpdate+0x32c>)
 80053da:	22ac      	movs	r2, #172	; 0xac
 80053dc:	5a9b      	ldrh	r3, [r3, r2]
 80053de:	001a      	movs	r2, r3
 80053e0:	233c      	movs	r3, #60	; 0x3c
 80053e2:	4013      	ands	r3, r2
 80053e4:	d100      	bne.n	80053e8 <engineUpdate+0x88>
 80053e6:	e0f7      	b.n	80055d8 <engineUpdate+0x278>
        // Need to TX some data...
        // Assuming txChnl points to channel which first becomes available again.
        bit_t jacc = ((LMIC.opmode & (OP_JOINING|OP_REJOIN)) != 0 ? 1 : 0);
 80053e8:	4ba8      	ldr	r3, [pc, #672]	; (800568c <engineUpdate+0x32c>)
 80053ea:	22ac      	movs	r2, #172	; 0xac
 80053ec:	5a9b      	ldrh	r3, [r3, r2]
 80053ee:	001a      	movs	r2, r3
 80053f0:	2324      	movs	r3, #36	; 0x24
 80053f2:	4013      	ands	r3, r2
 80053f4:	1e5a      	subs	r2, r3, #1
 80053f6:	4193      	sbcs	r3, r2
 80053f8:	b2da      	uxtb	r2, r3
 80053fa:	1dfb      	adds	r3, r7, #7
 80053fc:	701a      	strb	r2, [r3, #0]
        // Find next suitable channel and return availability time
        if( (LMIC.opmode & OP_NEXTCHNL) != 0 ) {
 80053fe:	4ba3      	ldr	r3, [pc, #652]	; (800568c <engineUpdate+0x32c>)
 8005400:	22ac      	movs	r2, #172	; 0xac
 8005402:	5a9b      	ldrh	r3, [r3, r2]
 8005404:	001a      	movs	r2, r3
 8005406:	2380      	movs	r3, #128	; 0x80
 8005408:	011b      	lsls	r3, r3, #4
 800540a:	4013      	ands	r3, r2
 800540c:	d013      	beq.n	8005436 <engineUpdate+0xd6>
            txbeg = LMIC.txend = nextTx(now);
 800540e:	68bb      	ldr	r3, [r7, #8]
 8005410:	0018      	movs	r0, r3
 8005412:	f7fd ffcf 	bl	80033b4 <nextTx>
 8005416:	0002      	movs	r2, r0
 8005418:	4b9c      	ldr	r3, [pc, #624]	; (800568c <engineUpdate+0x32c>)
 800541a:	601a      	str	r2, [r3, #0]
 800541c:	4b9b      	ldr	r3, [pc, #620]	; (800568c <engineUpdate+0x32c>)
 800541e:	681b      	ldr	r3, [r3, #0]
 8005420:	613b      	str	r3, [r7, #16]
            LMIC.opmode &= ~OP_NEXTCHNL;
 8005422:	4b9a      	ldr	r3, [pc, #616]	; (800568c <engineUpdate+0x32c>)
 8005424:	22ac      	movs	r2, #172	; 0xac
 8005426:	5a9b      	ldrh	r3, [r3, r2]
 8005428:	4a99      	ldr	r2, [pc, #612]	; (8005690 <engineUpdate+0x330>)
 800542a:	4013      	ands	r3, r2
 800542c:	b299      	uxth	r1, r3
 800542e:	4b97      	ldr	r3, [pc, #604]	; (800568c <engineUpdate+0x32c>)
 8005430:	22ac      	movs	r2, #172	; 0xac
 8005432:	5299      	strh	r1, [r3, r2]
 8005434:	e002      	b.n	800543c <engineUpdate+0xdc>
        } else {
            txbeg = LMIC.txend;
 8005436:	4b95      	ldr	r3, [pc, #596]	; (800568c <engineUpdate+0x32c>)
 8005438:	681b      	ldr	r3, [r3, #0]
 800543a:	613b      	str	r3, [r7, #16]
        }
        // Delayed TX or waiting for duty cycle?
        if( (LMIC.globalDutyRate != 0 || (LMIC.opmode & OP_RNDTX) != 0)  &&  (txbeg - LMIC.globalDutyAvail) < 0 )
 800543c:	4b93      	ldr	r3, [pc, #588]	; (800568c <engineUpdate+0x32c>)
 800543e:	22a3      	movs	r2, #163	; 0xa3
 8005440:	5c9b      	ldrb	r3, [r3, r2]
 8005442:	2b00      	cmp	r3, #0
 8005444:	d107      	bne.n	8005456 <engineUpdate+0xf6>
 8005446:	4b91      	ldr	r3, [pc, #580]	; (800568c <engineUpdate+0x32c>)
 8005448:	22ac      	movs	r2, #172	; 0xac
 800544a:	5a9b      	ldrh	r3, [r3, r2]
 800544c:	001a      	movs	r2, r3
 800544e:	2380      	movs	r3, #128	; 0x80
 8005450:	005b      	lsls	r3, r3, #1
 8005452:	4013      	ands	r3, r2
 8005454:	d009      	beq.n	800546a <engineUpdate+0x10a>
 8005456:	4b8d      	ldr	r3, [pc, #564]	; (800568c <engineUpdate+0x32c>)
 8005458:	22a4      	movs	r2, #164	; 0xa4
 800545a:	589b      	ldr	r3, [r3, r2]
 800545c:	693a      	ldr	r2, [r7, #16]
 800545e:	1ad3      	subs	r3, r2, r3
 8005460:	d503      	bpl.n	800546a <engineUpdate+0x10a>
            txbeg = LMIC.globalDutyAvail;
 8005462:	4b8a      	ldr	r3, [pc, #552]	; (800568c <engineUpdate+0x32c>)
 8005464:	22a4      	movs	r2, #164	; 0xa4
 8005466:	589b      	ldr	r3, [r3, r2]
 8005468:	613b      	str	r3, [r7, #16]
        // If we're tracking a beacon...
        // then make sure TX-RX transaction is complete before beacon
        if( (LMIC.opmode & OP_TRACK) != 0 &&
 800546a:	4b88      	ldr	r3, [pc, #544]	; (800568c <engineUpdate+0x32c>)
 800546c:	22ac      	movs	r2, #172	; 0xac
 800546e:	5a9b      	ldrh	r3, [r3, r2]
 8005470:	001a      	movs	r2, r3
 8005472:	2302      	movs	r3, #2
 8005474:	4013      	ands	r3, r2
 8005476:	d017      	beq.n	80054a8 <engineUpdate+0x148>
            txbeg + (jacc ? JOIN_GUARD_osticks : TXRX_GUARD_osticks) - rxtime > 0 ) {
 8005478:	1dfb      	adds	r3, r7, #7
 800547a:	781b      	ldrb	r3, [r3, #0]
 800547c:	2b00      	cmp	r3, #0
 800547e:	d001      	beq.n	8005484 <engineUpdate+0x124>
 8005480:	4b84      	ldr	r3, [pc, #528]	; (8005694 <engineUpdate+0x334>)
 8005482:	e000      	b.n	8005486 <engineUpdate+0x126>
 8005484:	4b84      	ldr	r3, [pc, #528]	; (8005698 <engineUpdate+0x338>)
 8005486:	693a      	ldr	r2, [r7, #16]
 8005488:	189a      	adds	r2, r3, r2
 800548a:	697b      	ldr	r3, [r7, #20]
 800548c:	1ad3      	subs	r3, r2, r3
        if( (LMIC.opmode & OP_TRACK) != 0 &&
 800548e:	2b00      	cmp	r3, #0
 8005490:	dd0a      	ble.n	80054a8 <engineUpdate+0x148>
            // Not enough time to complete TX-RX before beacon - postpone after beacon.
            // In order to avoid clustering of postponed TX right after beacon randomize start!
            txDelay(rxtime + BCN_RESERVE_osticks, 16);
 8005492:	697b      	ldr	r3, [r7, #20]
 8005494:	4a81      	ldr	r2, [pc, #516]	; (800569c <engineUpdate+0x33c>)
 8005496:	4694      	mov	ip, r2
 8005498:	4463      	add	r3, ip
 800549a:	2110      	movs	r1, #16
 800549c:	0018      	movs	r0, r3
 800549e:	f7fd fd25 	bl	8002eec <txDelay>
            txbeg = 0;
 80054a2:	2300      	movs	r3, #0
 80054a4:	613b      	str	r3, [r7, #16]
            goto checkrx;
 80054a6:	e0a0      	b.n	80055ea <engineUpdate+0x28a>
        }
        // Earliest possible time vs overhead to setup radio
        if( txbeg - (now + TX_RAMPUP) < 0 ) {
 80054a8:	68bb      	ldr	r3, [r7, #8]
 80054aa:	3340      	adds	r3, #64	; 0x40
 80054ac:	693a      	ldr	r2, [r7, #16]
 80054ae:	1ad3      	subs	r3, r2, r3
 80054b0:	d400      	bmi.n	80054b4 <engineUpdate+0x154>
 80054b2:	e082      	b.n	80055ba <engineUpdate+0x25a>
            // We could send right now!
        txbeg = now;
 80054b4:	68bb      	ldr	r3, [r7, #8]
 80054b6:	613b      	str	r3, [r7, #16]
            dr_t txdr = (dr_t)LMIC.datarate;
 80054b8:	200f      	movs	r0, #15
 80054ba:	183b      	adds	r3, r7, r0
 80054bc:	4a73      	ldr	r2, [pc, #460]	; (800568c <engineUpdate+0x32c>)
 80054be:	21b0      	movs	r1, #176	; 0xb0
 80054c0:	5c52      	ldrb	r2, [r2, r1]
 80054c2:	701a      	strb	r2, [r3, #0]
            if( jacc ) {
 80054c4:	1dfb      	adds	r3, r7, #7
 80054c6:	781b      	ldrb	r3, [r3, #0]
 80054c8:	2b00      	cmp	r3, #0
 80054ca:	d025      	beq.n	8005518 <engineUpdate+0x1b8>
                u1_t ftype;
                if( (LMIC.opmode & OP_REJOIN) != 0 ) {
 80054cc:	4b6f      	ldr	r3, [pc, #444]	; (800568c <engineUpdate+0x32c>)
 80054ce:	22ac      	movs	r2, #172	; 0xac
 80054d0:	5a9b      	ldrh	r3, [r3, r2]
 80054d2:	001a      	movs	r2, r3
 80054d4:	2320      	movs	r3, #32
 80054d6:	4013      	ands	r3, r2
 80054d8:	d010      	beq.n	80054fc <engineUpdate+0x19c>
                    txdr = lowerDR(txdr, LMIC.rejoinCnt);
 80054da:	4b6c      	ldr	r3, [pc, #432]	; (800568c <engineUpdate+0x32c>)
 80054dc:	22b2      	movs	r2, #178	; 0xb2
 80054de:	5c9a      	ldrb	r2, [r3, r2]
 80054e0:	183c      	adds	r4, r7, r0
 80054e2:	183b      	adds	r3, r7, r0
 80054e4:	781b      	ldrb	r3, [r3, #0]
 80054e6:	0011      	movs	r1, r2
 80054e8:	0018      	movs	r0, r3
 80054ea:	f7fc ffad 	bl	8002448 <lowerDR>
 80054ee:	0003      	movs	r3, r0
 80054f0:	7023      	strb	r3, [r4, #0]
                    ftype = HDR_FTYPE_REJOIN;
 80054f2:	230e      	movs	r3, #14
 80054f4:	18fb      	adds	r3, r7, r3
 80054f6:	22c0      	movs	r2, #192	; 0xc0
 80054f8:	701a      	strb	r2, [r3, #0]
 80054fa:	e003      	b.n	8005504 <engineUpdate+0x1a4>
                } else {
                    ftype = HDR_FTYPE_JREQ;
 80054fc:	230e      	movs	r3, #14
 80054fe:	18fb      	adds	r3, r7, r3
 8005500:	2200      	movs	r2, #0
 8005502:	701a      	strb	r2, [r3, #0]
                }
                buildJoinRequest(ftype);
 8005504:	230e      	movs	r3, #14
 8005506:	18fb      	adds	r3, r7, r3
 8005508:	781b      	ldrb	r3, [r3, #0]
 800550a:	0018      	movs	r0, r3
 800550c:	f7ff fbf6 	bl	8004cfc <buildJoinRequest>
                LMIC.osjob.func = FUNC_ADDR(jreqDone);
 8005510:	4b5e      	ldr	r3, [pc, #376]	; (800568c <engineUpdate+0x32c>)
 8005512:	4a63      	ldr	r2, [pc, #396]	; (80056a0 <engineUpdate+0x340>)
 8005514:	61da      	str	r2, [r3, #28]
 8005516:	e020      	b.n	800555a <engineUpdate+0x1fa>
            } else {
                if( LMIC.seqnoDn >= 0xFFFFFF80 ) {
 8005518:	4a5c      	ldr	r2, [pc, #368]	; (800568c <engineUpdate+0x32c>)
 800551a:	238c      	movs	r3, #140	; 0x8c
 800551c:	005b      	lsls	r3, r3, #1
 800551e:	58d3      	ldr	r3, [r2, r3]
 8005520:	3381      	adds	r3, #129	; 0x81
 8005522:	d909      	bls.n	8005538 <engineUpdate+0x1d8>
                                        e_.eui    = MAIN::CDEV->getEui(),
                                        e_.info   = LMIC.seqnoDn, 
                                        e_.info2  = 0));
                    // Device has to react! NWK will not roll over and just stop sending.
                    // Thus, we have N frames to detect a possible lock up.
                  reset:
 8005524:	46c0      	nop			; (mov r8, r8)
 8005526:	e000      	b.n	800552a <engineUpdate+0x1ca>
                    EV(specCond, ERR, (e_.reason = EV::specCond_t::UPSEQNO_ROLL_OVER,
                                       e_.eui    = MAIN::CDEV->getEui(),
                                       e_.info2  = LMIC.seqnoUp));
                    // Do not run RESET event callback from here!
                    // App code might do some stuff after send unaware of RESET.
                    goto reset;
 8005528:	46c0      	nop			; (mov r8, r8)
                    os_setCallback(&LMIC.osjob, FUNC_ADDR(runReset));
 800552a:	4a5e      	ldr	r2, [pc, #376]	; (80056a4 <engineUpdate+0x344>)
 800552c:	4b5e      	ldr	r3, [pc, #376]	; (80056a8 <engineUpdate+0x348>)
 800552e:	0011      	movs	r1, r2
 8005530:	0018      	movs	r0, r3
 8005532:	f000 ff13 	bl	800635c <os_setCallback>
                    return;
 8005536:	e0f9      	b.n	800572c <engineUpdate+0x3cc>
                if( (LMIC.txCnt==0 && LMIC.seqnoUp == 0xFFFFFFFF) ) {
 8005538:	4a54      	ldr	r2, [pc, #336]	; (800568c <engineUpdate+0x32c>)
 800553a:	23a2      	movs	r3, #162	; 0xa2
 800553c:	005b      	lsls	r3, r3, #1
 800553e:	5cd3      	ldrb	r3, [r2, r3]
 8005540:	2b00      	cmp	r3, #0
 8005542:	d105      	bne.n	8005550 <engineUpdate+0x1f0>
 8005544:	4a51      	ldr	r2, [pc, #324]	; (800568c <engineUpdate+0x32c>)
 8005546:	238e      	movs	r3, #142	; 0x8e
 8005548:	005b      	lsls	r3, r3, #1
 800554a:	58d3      	ldr	r3, [r2, r3]
 800554c:	3301      	adds	r3, #1
 800554e:	d0eb      	beq.n	8005528 <engineUpdate+0x1c8>
                }
                buildDataFrame();
 8005550:	f7ff f8e4 	bl	800471c <buildDataFrame>
                LMIC.osjob.func = FUNC_ADDR(updataDone);
 8005554:	4b4d      	ldr	r3, [pc, #308]	; (800568c <engineUpdate+0x32c>)
 8005556:	4a55      	ldr	r2, [pc, #340]	; (80056ac <engineUpdate+0x34c>)
 8005558:	61da      	str	r2, [r3, #28]
            }
            LMIC.rps    = setCr(updr2rps(txdr), (cr_t)LMIC.errcr);
 800555a:	240f      	movs	r4, #15
 800555c:	193b      	adds	r3, r7, r4
 800555e:	781b      	ldrb	r3, [r3, #0]
 8005560:	0018      	movs	r0, r3
 8005562:	f7fc ff19 	bl	8002398 <updr2rps>
 8005566:	0003      	movs	r3, r0
 8005568:	0018      	movs	r0, r3
 800556a:	4b48      	ldr	r3, [pc, #288]	; (800568c <engineUpdate+0x32c>)
 800556c:	22b1      	movs	r2, #177	; 0xb1
 800556e:	5c9b      	ldrb	r3, [r3, r2]
 8005570:	0019      	movs	r1, r3
 8005572:	f7fc fea6 	bl	80022c2 <setCr>
 8005576:	0003      	movs	r3, r0
 8005578:	001a      	movs	r2, r3
 800557a:	4b44      	ldr	r3, [pc, #272]	; (800568c <engineUpdate+0x32c>)
 800557c:	81da      	strh	r2, [r3, #14]
            LMIC.dndr   = txdr;  // carry TX datarate (can be != LMIC.datarate) over to txDone/setupRx1
 800557e:	4b43      	ldr	r3, [pc, #268]	; (800568c <engineUpdate+0x32c>)
 8005580:	193a      	adds	r2, r7, r4
 8005582:	7812      	ldrb	r2, [r2, #0]
 8005584:	745a      	strb	r2, [r3, #17]
            LMIC.opmode = (LMIC.opmode & ~(OP_POLL|OP_RNDTX)) | OP_TXRXPEND | OP_NEXTCHNL;
 8005586:	4b41      	ldr	r3, [pc, #260]	; (800568c <engineUpdate+0x32c>)
 8005588:	22ac      	movs	r2, #172	; 0xac
 800558a:	5a9b      	ldrh	r3, [r3, r2]
 800558c:	b21b      	sxth	r3, r3
 800558e:	4a48      	ldr	r2, [pc, #288]	; (80056b0 <engineUpdate+0x350>)
 8005590:	4013      	ands	r3, r2
 8005592:	b21b      	sxth	r3, r3
 8005594:	2288      	movs	r2, #136	; 0x88
 8005596:	0112      	lsls	r2, r2, #4
 8005598:	4313      	orrs	r3, r2
 800559a:	b21b      	sxth	r3, r3
 800559c:	b299      	uxth	r1, r3
 800559e:	4b3b      	ldr	r3, [pc, #236]	; (800568c <engineUpdate+0x32c>)
 80055a0:	22ac      	movs	r2, #172	; 0xac
 80055a2:	5299      	strh	r1, [r3, r2]
            updateTx(txbeg);
 80055a4:	693b      	ldr	r3, [r7, #16]
 80055a6:	0018      	movs	r0, r3
 80055a8:	f7fd feb8 	bl	800331c <updateTx>
            reportEvent(EV_TXSTART);
 80055ac:	2011      	movs	r0, #17
 80055ae:	f7fe f8a9 	bl	8003704 <reportEvent>
            os_radio(RADIO_TX);
 80055b2:	2001      	movs	r0, #1
 80055b4:	f001 fd40 	bl	8007038 <os_radio>
            return;
 80055b8:	e0b8      	b.n	800572c <engineUpdate+0x3cc>
        }
        // Cannot yet TX
        if( (LMIC.opmode & OP_TRACK) == 0 )
 80055ba:	4b34      	ldr	r3, [pc, #208]	; (800568c <engineUpdate+0x32c>)
 80055bc:	22ac      	movs	r2, #172	; 0xac
 80055be:	5a9b      	ldrh	r3, [r3, r2]
 80055c0:	001a      	movs	r2, r3
 80055c2:	2302      	movs	r3, #2
 80055c4:	4013      	ands	r3, r2
 80055c6:	d100      	bne.n	80055ca <engineUpdate+0x26a>
 80055c8:	e09f      	b.n	800570a <engineUpdate+0x3aa>
            goto txdelay; // We don't track the beacon - nothing else to do - so wait for the time to TX
        // Consider RX tasks
        if( txbeg == 0 ) // zero indicates no TX pending
 80055ca:	693b      	ldr	r3, [r7, #16]
 80055cc:	2b00      	cmp	r3, #0
 80055ce:	d10c      	bne.n	80055ea <engineUpdate+0x28a>
            txbeg += 1;  // TX delayed by one tick (insignificant amount of time)
 80055d0:	693b      	ldr	r3, [r7, #16]
 80055d2:	3301      	adds	r3, #1
 80055d4:	613b      	str	r3, [r7, #16]
 80055d6:	e008      	b.n	80055ea <engineUpdate+0x28a>
    } else {
        // No TX pending - no scheduled RX
        if( (LMIC.opmode & OP_TRACK) == 0 )
 80055d8:	4b2c      	ldr	r3, [pc, #176]	; (800568c <engineUpdate+0x32c>)
 80055da:	22ac      	movs	r2, #172	; 0xac
 80055dc:	5a9b      	ldrh	r3, [r3, r2]
 80055de:	001a      	movs	r2, r3
 80055e0:	2302      	movs	r3, #2
 80055e2:	4013      	ands	r3, r2
 80055e4:	d100      	bne.n	80055e8 <engineUpdate+0x288>
 80055e6:	e0a0      	b.n	800572a <engineUpdate+0x3ca>
            return;
    }

    // Are we pingable?
  checkrx:
 80055e8:	46c0      	nop			; (mov r8, r8)
    if( (LMIC.opmode & OP_PINGINI) != 0 ) {
 80055ea:	4b28      	ldr	r3, [pc, #160]	; (800568c <engineUpdate+0x32c>)
 80055ec:	22ac      	movs	r2, #172	; 0xac
 80055ee:	5a9b      	ldrh	r3, [r3, r2]
 80055f0:	001a      	movs	r2, r3
 80055f2:	2380      	movs	r3, #128	; 0x80
 80055f4:	009b      	lsls	r3, r3, #2
 80055f6:	4013      	ands	r3, r2
 80055f8:	d060      	beq.n	80056bc <engineUpdate+0x35c>
        // One more RX slot in this beacon period?
        if( rxschedNext(&LMIC.ping, now+RX_RAMPUP) ) {
 80055fa:	68bb      	ldr	r3, [r7, #8]
 80055fc:	3340      	adds	r3, #64	; 0x40
 80055fe:	001a      	movs	r2, r3
 8005600:	4b2c      	ldr	r3, [pc, #176]	; (80056b4 <engineUpdate+0x354>)
 8005602:	0011      	movs	r1, r2
 8005604:	0018      	movs	r0, r3
 8005606:	f7fd fbcd 	bl	8002da4 <rxschedNext>
 800560a:	1e03      	subs	r3, r0, #0
 800560c:	d056      	beq.n	80056bc <engineUpdate+0x35c>
            if( txbeg != 0  &&  (txbeg - LMIC.ping.rxtime) < 0 )
 800560e:	693b      	ldr	r3, [r7, #16]
 8005610:	2b00      	cmp	r3, #0
 8005612:	d007      	beq.n	8005624 <engineUpdate+0x2c4>
 8005614:	4a1d      	ldr	r2, [pc, #116]	; (800568c <engineUpdate+0x32c>)
 8005616:	239e      	movs	r3, #158	; 0x9e
 8005618:	005b      	lsls	r3, r3, #1
 800561a:	58d3      	ldr	r3, [r2, r3]
 800561c:	693a      	ldr	r2, [r7, #16]
 800561e:	1ad3      	subs	r3, r2, r3
 8005620:	d500      	bpl.n	8005624 <engineUpdate+0x2c4>
 8005622:	e074      	b.n	800570e <engineUpdate+0x3ae>
                goto txdelay;
            LMIC.rxsyms  = LMIC.ping.rxsyms;
 8005624:	4a19      	ldr	r2, [pc, #100]	; (800568c <engineUpdate+0x32c>)
 8005626:	2338      	movs	r3, #56	; 0x38
 8005628:	33ff      	adds	r3, #255	; 0xff
 800562a:	5cd2      	ldrb	r2, [r2, r3]
 800562c:	4b17      	ldr	r3, [pc, #92]	; (800568c <engineUpdate+0x32c>)
 800562e:	741a      	strb	r2, [r3, #16]
            LMIC.rxtime  = LMIC.ping.rxtime;
 8005630:	4a16      	ldr	r2, [pc, #88]	; (800568c <engineUpdate+0x32c>)
 8005632:	239e      	movs	r3, #158	; 0x9e
 8005634:	005b      	lsls	r3, r3, #1
 8005636:	58d2      	ldr	r2, [r2, r3]
 8005638:	4b14      	ldr	r3, [pc, #80]	; (800568c <engineUpdate+0x32c>)
 800563a:	605a      	str	r2, [r3, #4]
            LMIC.freq    = LMIC.ping.freq;
 800563c:	4a13      	ldr	r2, [pc, #76]	; (800568c <engineUpdate+0x32c>)
 800563e:	23a0      	movs	r3, #160	; 0xa0
 8005640:	005b      	lsls	r3, r3, #1
 8005642:	58d2      	ldr	r2, [r2, r3]
 8005644:	4b11      	ldr	r3, [pc, #68]	; (800568c <engineUpdate+0x32c>)
 8005646:	609a      	str	r2, [r3, #8]
            LMIC.rps     = dndr2rps(LMIC.ping.dr);
 8005648:	4a10      	ldr	r2, [pc, #64]	; (800568c <engineUpdate+0x32c>)
 800564a:	239a      	movs	r3, #154	; 0x9a
 800564c:	005b      	lsls	r3, r3, #1
 800564e:	5cd3      	ldrb	r3, [r2, r3]
 8005650:	0018      	movs	r0, r3
 8005652:	f7fc feb3 	bl	80023bc <dndr2rps>
 8005656:	0003      	movs	r3, r0
 8005658:	001a      	movs	r2, r3
 800565a:	4b0c      	ldr	r3, [pc, #48]	; (800568c <engineUpdate+0x32c>)
 800565c:	81da      	strh	r2, [r3, #14]
            LMIC.dataLen = 0;
 800565e:	4a0b      	ldr	r2, [pc, #44]	; (800568c <engineUpdate+0x32c>)
 8005660:	2348      	movs	r3, #72	; 0x48
 8005662:	33ff      	adds	r3, #255	; 0xff
 8005664:	2100      	movs	r1, #0
 8005666:	54d1      	strb	r1, [r2, r3]
            ASSERT(LMIC.rxtime - now+RX_RAMPUP >= 0 );
 8005668:	4b08      	ldr	r3, [pc, #32]	; (800568c <engineUpdate+0x32c>)
 800566a:	685a      	ldr	r2, [r3, #4]
 800566c:	68bb      	ldr	r3, [r7, #8]
 800566e:	1ad3      	subs	r3, r2, r3
 8005670:	3340      	adds	r3, #64	; 0x40
 8005672:	da01      	bge.n	8005678 <engineUpdate+0x318>
 8005674:	f7fc fdea 	bl	800224c <hal_failed>
            os_setTimedCallback(&LMIC.osjob, LMIC.rxtime - RX_RAMPUP, FUNC_ADDR(startRxPing));
 8005678:	4b04      	ldr	r3, [pc, #16]	; (800568c <engineUpdate+0x32c>)
 800567a:	685b      	ldr	r3, [r3, #4]
 800567c:	3b40      	subs	r3, #64	; 0x40
 800567e:	0019      	movs	r1, r3
 8005680:	4a0d      	ldr	r2, [pc, #52]	; (80056b8 <engineUpdate+0x358>)
 8005682:	4b09      	ldr	r3, [pc, #36]	; (80056a8 <engineUpdate+0x348>)
 8005684:	0018      	movs	r0, r3
 8005686:	f000 fe91 	bl	80063ac <os_setTimedCallback>
            return;
 800568a:	e04f      	b.n	800572c <engineUpdate+0x3cc>
 800568c:	20000324 	.word	0x20000324
 8005690:	fffff7ff 	.word	0xfffff7ff
 8005694:	00046500 	.word	0x00046500
 8005698:	0002ee00 	.word	0x0002ee00
 800569c:	00010900 	.word	0x00010900
 80056a0:	080045c1 	.word	0x080045c1
 80056a4:	08003727 	.word	0x08003727
 80056a8:	20000338 	.word	0x20000338
 80056ac:	080046e1 	.word	0x080046e1
 80056b0:	fffff66f 	.word	0xfffff66f
 80056b4:	20000458 	.word	0x20000458
 80056b8:	0800533d 	.word	0x0800533d
        }
        // no - just wait for the beacon
    }

    if( txbeg != 0  &&  (txbeg - rxtime) < 0 )
 80056bc:	693b      	ldr	r3, [r7, #16]
 80056be:	2b00      	cmp	r3, #0
 80056c0:	d003      	beq.n	80056ca <engineUpdate+0x36a>
 80056c2:	693a      	ldr	r2, [r7, #16]
 80056c4:	697b      	ldr	r3, [r7, #20]
 80056c6:	1ad3      	subs	r3, r2, r3
 80056c8:	d423      	bmi.n	8005712 <engineUpdate+0x3b2>
        goto txdelay;

    setBcnRxParams();
 80056ca:	f7fd ff43 	bl	8003554 <setBcnRxParams>
    LMIC.rxsyms = LMIC.bcnRxsyms;
 80056ce:	4a19      	ldr	r2, [pc, #100]	; (8005734 <engineUpdate+0x3d4>)
 80056d0:	238a      	movs	r3, #138	; 0x8a
 80056d2:	33ff      	adds	r3, #255	; 0xff
 80056d4:	5cd2      	ldrb	r2, [r2, r3]
 80056d6:	4b17      	ldr	r3, [pc, #92]	; (8005734 <engineUpdate+0x3d4>)
 80056d8:	741a      	strb	r2, [r3, #16]
    LMIC.rxtime = LMIC.bcnRxtime;
 80056da:	4a16      	ldr	r2, [pc, #88]	; (8005734 <engineUpdate+0x3d4>)
 80056dc:	23c6      	movs	r3, #198	; 0xc6
 80056de:	005b      	lsls	r3, r3, #1
 80056e0:	58d2      	ldr	r2, [r2, r3]
 80056e2:	4b14      	ldr	r3, [pc, #80]	; (8005734 <engineUpdate+0x3d4>)
 80056e4:	605a      	str	r2, [r3, #4]
    if( now - rxtime >= 0 ) {
 80056e6:	68ba      	ldr	r2, [r7, #8]
 80056e8:	697b      	ldr	r3, [r7, #20]
 80056ea:	1ad3      	subs	r3, r2, r3
 80056ec:	d406      	bmi.n	80056fc <engineUpdate+0x39c>
        LMIC.osjob.func = FUNC_ADDR(processBeacon);
 80056ee:	4b11      	ldr	r3, [pc, #68]	; (8005734 <engineUpdate+0x3d4>)
 80056f0:	4a11      	ldr	r2, [pc, #68]	; (8005738 <engineUpdate+0x3d8>)
 80056f2:	61da      	str	r2, [r3, #28]
        os_radio(RADIO_RX);
 80056f4:	2002      	movs	r0, #2
 80056f6:	f001 fc9f 	bl	8007038 <os_radio>
        return;
 80056fa:	e017      	b.n	800572c <engineUpdate+0x3cc>
    }
    os_setTimedCallback(&LMIC.osjob, rxtime, FUNC_ADDR(startRxBcn));
 80056fc:	4a0f      	ldr	r2, [pc, #60]	; (800573c <engineUpdate+0x3dc>)
 80056fe:	6979      	ldr	r1, [r7, #20]
 8005700:	4b0f      	ldr	r3, [pc, #60]	; (8005740 <engineUpdate+0x3e0>)
 8005702:	0018      	movs	r0, r3
 8005704:	f000 fe52 	bl	80063ac <os_setTimedCallback>
    return;
 8005708:	e010      	b.n	800572c <engineUpdate+0x3cc>
            goto txdelay; // We don't track the beacon - nothing else to do - so wait for the time to TX
 800570a:	46c0      	nop			; (mov r8, r8)
 800570c:	e002      	b.n	8005714 <engineUpdate+0x3b4>
                goto txdelay;
 800570e:	46c0      	nop			; (mov r8, r8)
 8005710:	e000      	b.n	8005714 <engineUpdate+0x3b4>
        goto txdelay;
 8005712:	46c0      	nop			; (mov r8, r8)
  txdelay:
    EV(devCond, INFO, (e_.reason = EV::devCond_t::TX_DELAY,
                       e_.eui    = MAIN::CDEV->getEui(),
                       e_.info   = osticks2ms(txbeg-now),
                       e_.info2  = LMIC.seqnoUp-1));
    os_setTimedCallback(&LMIC.osjob, txbeg-TX_RAMPUP, FUNC_ADDR(runEngineUpdate));
 8005714:	693b      	ldr	r3, [r7, #16]
 8005716:	3b40      	subs	r3, #64	; 0x40
 8005718:	0019      	movs	r1, r3
 800571a:	4a0a      	ldr	r2, [pc, #40]	; (8005744 <engineUpdate+0x3e4>)
 800571c:	4b08      	ldr	r3, [pc, #32]	; (8005740 <engineUpdate+0x3e0>)
 800571e:	0018      	movs	r0, r3
 8005720:	f000 fe44 	bl	80063ac <os_setTimedCallback>
 8005724:	e002      	b.n	800572c <engineUpdate+0x3cc>
        return;
 8005726:	46c0      	nop			; (mov r8, r8)
 8005728:	e000      	b.n	800572c <engineUpdate+0x3cc>
            return;
 800572a:	46c0      	nop			; (mov r8, r8)
}
 800572c:	46bd      	mov	sp, r7
 800572e:	b007      	add	sp, #28
 8005730:	bd90      	pop	{r4, r7, pc}
 8005732:	46c0      	nop			; (mov r8, r8)
 8005734:	20000324 	.word	0x20000324
 8005738:	08005085 	.word	0x08005085
 800573c:	08005319 	.word	0x08005319
 8005740:	20000338 	.word	0x20000338
 8005744:	080036f1 	.word	0x080036f1

08005748 <LMIC_reset>:
    os_radio(RADIO_RST);
    LMIC.opmode |= OP_SHUTDOWN;
}


void LMIC_reset (void) {
 8005748:	b5b0      	push	{r4, r5, r7, lr}
 800574a:	af00      	add	r7, sp, #0
    EV(devCond, INFO, (e_.reason = EV::devCond_t::LMIC_EV,
                       e_.eui    = MAIN::CDEV->getEui(),
                       e_.info   = EV_RESET));
    os_radio(RADIO_RST);
 800574c:	2000      	movs	r0, #0
 800574e:	f001 fc73 	bl	8007038 <os_radio>
    os_clearCallback(&LMIC.osjob);
 8005752:	4b26      	ldr	r3, [pc, #152]	; (80057ec <LMIC_reset+0xa4>)
 8005754:	0018      	movs	r0, r3
 8005756:	f000 fde1 	bl	800631c <os_clearCallback>

    os_clearMem((xref2u1_t)&LMIC,SIZEOFEXPR(LMIC));
 800575a:	23d6      	movs	r3, #214	; 0xd6
 800575c:	005a      	lsls	r2, r3, #1
 800575e:	4b24      	ldr	r3, [pc, #144]	; (80057f0 <LMIC_reset+0xa8>)
 8005760:	2100      	movs	r1, #0
 8005762:	0018      	movs	r0, r3
 8005764:	f008 f967 	bl	800da36 <memset>
    LMIC.devaddr      =  0;
 8005768:	4a21      	ldr	r2, [pc, #132]	; (80057f0 <LMIC_reset+0xa8>)
 800576a:	238a      	movs	r3, #138	; 0x8a
 800576c:	005b      	lsls	r3, r3, #1
 800576e:	2100      	movs	r1, #0
 8005770:	50d1      	str	r1, [r2, r3]
    LMIC.devNonce     =  os_getRndU2();
 8005772:	f001 fb47 	bl	8006e04 <radio_rand1>
 8005776:	0003      	movs	r3, r0
 8005778:	021b      	lsls	r3, r3, #8
 800577a:	b21c      	sxth	r4, r3
 800577c:	f001 fb42 	bl	8006e04 <radio_rand1>
 8005780:	0003      	movs	r3, r0
 8005782:	b21b      	sxth	r3, r3
 8005784:	4323      	orrs	r3, r4
 8005786:	b21b      	sxth	r3, r3
 8005788:	b299      	uxth	r1, r3
 800578a:	4b19      	ldr	r3, [pc, #100]	; (80057f0 <LMIC_reset+0xa8>)
 800578c:	22f2      	movs	r2, #242	; 0xf2
 800578e:	5299      	strh	r1, [r3, r2]
    LMIC.opmode       =  OP_NONE;
 8005790:	4b17      	ldr	r3, [pc, #92]	; (80057f0 <LMIC_reset+0xa8>)
 8005792:	22ac      	movs	r2, #172	; 0xac
 8005794:	2100      	movs	r1, #0
 8005796:	5299      	strh	r1, [r3, r2]
    LMIC.errcr        =  CR_4_5;
 8005798:	4b15      	ldr	r3, [pc, #84]	; (80057f0 <LMIC_reset+0xa8>)
 800579a:	22b1      	movs	r2, #177	; 0xb1
 800579c:	2100      	movs	r1, #0
 800579e:	5499      	strb	r1, [r3, r2]
    LMIC.adrEnabled   =  FCT_ADREN;
 80057a0:	4a13      	ldr	r2, [pc, #76]	; (80057f0 <LMIC_reset+0xa8>)
 80057a2:	2328      	movs	r3, #40	; 0x28
 80057a4:	33ff      	adds	r3, #255	; 0xff
 80057a6:	2180      	movs	r1, #128	; 0x80
 80057a8:	54d1      	strb	r1, [r2, r3]
    LMIC.dn2Dr        =  DR_DNW2;   // we need this for 2nd DN window of join accept
 80057aa:	4a11      	ldr	r2, [pc, #68]	; (80057f0 <LMIC_reset+0xa8>)
 80057ac:	232c      	movs	r3, #44	; 0x2c
 80057ae:	33ff      	adds	r3, #255	; 0xff
 80057b0:	2100      	movs	r1, #0
 80057b2:	54d1      	strb	r1, [r2, r3]
    LMIC.dn2Freq      =  FREQ_DNW2; // ditto
 80057b4:	4a0e      	ldr	r2, [pc, #56]	; (80057f0 <LMIC_reset+0xa8>)
 80057b6:	2396      	movs	r3, #150	; 0x96
 80057b8:	005b      	lsls	r3, r3, #1
 80057ba:	490e      	ldr	r1, [pc, #56]	; (80057f4 <LMIC_reset+0xac>)
 80057bc:	50d1      	str	r1, [r2, r3]
    LMIC.rxDelay      =  DELAY_DNW1;
 80057be:	4a0c      	ldr	r2, [pc, #48]	; (80057f0 <LMIC_reset+0xa8>)
 80057c0:	2324      	movs	r3, #36	; 0x24
 80057c2:	33ff      	adds	r3, #255	; 0xff
 80057c4:	2101      	movs	r1, #1
 80057c6:	54d1      	strb	r1, [r2, r3]
    LMIC.ping.freq    =  FREQ_PING; // defaults for ping
 80057c8:	4a09      	ldr	r2, [pc, #36]	; (80057f0 <LMIC_reset+0xa8>)
 80057ca:	23a0      	movs	r3, #160	; 0xa0
 80057cc:	005b      	lsls	r3, r3, #1
 80057ce:	4909      	ldr	r1, [pc, #36]	; (80057f4 <LMIC_reset+0xac>)
 80057d0:	50d1      	str	r1, [r2, r3]
    LMIC.ping.dr      =  DR_PING;   // ditto
 80057d2:	4a07      	ldr	r2, [pc, #28]	; (80057f0 <LMIC_reset+0xa8>)
 80057d4:	239a      	movs	r3, #154	; 0x9a
 80057d6:	005b      	lsls	r3, r3, #1
 80057d8:	2103      	movs	r1, #3
 80057da:	54d1      	strb	r1, [r2, r3]
    LMIC.ping.intvExp =  0xFF;
 80057dc:	4a04      	ldr	r2, [pc, #16]	; (80057f0 <LMIC_reset+0xa8>)
 80057de:	2336      	movs	r3, #54	; 0x36
 80057e0:	33ff      	adds	r3, #255	; 0xff
 80057e2:	21ff      	movs	r1, #255	; 0xff
 80057e4:	54d1      	strb	r1, [r2, r3]
    DO_DEVDB(LMIC.dn2Dr,        dn2Dr);
    DO_DEVDB(LMIC.dn2Freq,      dn2Freq);
    DO_DEVDB(LMIC.ping.freq,    pingFreq);
    DO_DEVDB(LMIC.ping.dr,      pingDr);
    DO_DEVDB(LMIC.ping.intvExp, pingIntvExp);
}
 80057e6:	46c0      	nop			; (mov r8, r8)
 80057e8:	46bd      	mov	sp, r7
 80057ea:	bdb0      	pop	{r4, r5, r7, pc}
 80057ec:	20000338 	.word	0x20000338
 80057f0:	20000324 	.word	0x20000324
 80057f4:	33d3e608 	.word	0x33d3e608

080057f8 <LMIC_init>:


void LMIC_init (void) {
 80057f8:	b580      	push	{r7, lr}
 80057fa:	af00      	add	r7, sp, #0
    LMIC.opmode = OP_SHUTDOWN;
 80057fc:	4b03      	ldr	r3, [pc, #12]	; (800580c <LMIC_init+0x14>)
 80057fe:	22ac      	movs	r2, #172	; 0xac
 8005800:	2140      	movs	r1, #64	; 0x40
 8005802:	5299      	strh	r1, [r3, r2]
}
 8005804:	46c0      	nop			; (mov r8, r8)
 8005806:	46bd      	mov	sp, r7
 8005808:	bd80      	pop	{r7, pc}
 800580a:	46c0      	nop			; (mov r8, r8)
 800580c:	20000324 	.word	0x20000324

08005810 <LMIC_setTxData>:
    os_radio(RADIO_RST);
    engineUpdate();
}


void LMIC_setTxData (void) {
 8005810:	b580      	push	{r7, lr}
 8005812:	af00      	add	r7, sp, #0
    LMIC.opmode |= OP_TXDATA;
 8005814:	4b0c      	ldr	r3, [pc, #48]	; (8005848 <LMIC_setTxData+0x38>)
 8005816:	22ac      	movs	r2, #172	; 0xac
 8005818:	5a9b      	ldrh	r3, [r3, r2]
 800581a:	2208      	movs	r2, #8
 800581c:	4313      	orrs	r3, r2
 800581e:	b299      	uxth	r1, r3
 8005820:	4b09      	ldr	r3, [pc, #36]	; (8005848 <LMIC_setTxData+0x38>)
 8005822:	22ac      	movs	r2, #172	; 0xac
 8005824:	5299      	strh	r1, [r3, r2]
    if( (LMIC.opmode & OP_JOINING) == 0 )
 8005826:	4b08      	ldr	r3, [pc, #32]	; (8005848 <LMIC_setTxData+0x38>)
 8005828:	22ac      	movs	r2, #172	; 0xac
 800582a:	5a9b      	ldrh	r3, [r3, r2]
 800582c:	001a      	movs	r2, r3
 800582e:	2304      	movs	r3, #4
 8005830:	4013      	ands	r3, r2
 8005832:	d104      	bne.n	800583e <LMIC_setTxData+0x2e>
        LMIC.txCnt = 0;             // cancel any ongoing TX/RX retries
 8005834:	4a04      	ldr	r2, [pc, #16]	; (8005848 <LMIC_setTxData+0x38>)
 8005836:	23a2      	movs	r3, #162	; 0xa2
 8005838:	005b      	lsls	r3, r3, #1
 800583a:	2100      	movs	r1, #0
 800583c:	54d1      	strb	r1, [r2, r3]
    engineUpdate();
 800583e:	f7ff fd8f 	bl	8005360 <engineUpdate>
}
 8005842:	46c0      	nop			; (mov r8, r8)
 8005844:	46bd      	mov	sp, r7
 8005846:	bd80      	pop	{r7, pc}
 8005848:	20000324 	.word	0x20000324

0800584c <LMIC_setTxData2>:


//
int LMIC_setTxData2 (u1_t port, xref2u1_t data, u1_t dlen, u1_t confirmed) {
 800584c:	b590      	push	{r4, r7, lr}
 800584e:	b083      	sub	sp, #12
 8005850:	af00      	add	r7, sp, #0
 8005852:	0004      	movs	r4, r0
 8005854:	6039      	str	r1, [r7, #0]
 8005856:	0010      	movs	r0, r2
 8005858:	0019      	movs	r1, r3
 800585a:	1dfb      	adds	r3, r7, #7
 800585c:	1c22      	adds	r2, r4, #0
 800585e:	701a      	strb	r2, [r3, #0]
 8005860:	1dbb      	adds	r3, r7, #6
 8005862:	1c02      	adds	r2, r0, #0
 8005864:	701a      	strb	r2, [r3, #0]
 8005866:	1d7b      	adds	r3, r7, #5
 8005868:	1c0a      	adds	r2, r1, #0
 800586a:	701a      	strb	r2, [r3, #0]
    if( dlen > SIZEOFEXPR(LMIC.pendTxData) )
 800586c:	1dbb      	adds	r3, r7, #6
 800586e:	781b      	ldrb	r3, [r3, #0]
 8005870:	2b34      	cmp	r3, #52	; 0x34
 8005872:	d902      	bls.n	800587a <LMIC_setTxData2+0x2e>
        return -2;
 8005874:	2302      	movs	r3, #2
 8005876:	425b      	negs	r3, r3
 8005878:	e01b      	b.n	80058b2 <LMIC_setTxData2+0x66>
    if( data != (xref2u1_t)0 )
 800587a:	683b      	ldr	r3, [r7, #0]
 800587c:	2b00      	cmp	r3, #0
 800587e:	d006      	beq.n	800588e <LMIC_setTxData2+0x42>
        os_copyMem(LMIC.pendTxData, data, dlen);
 8005880:	1dbb      	adds	r3, r7, #6
 8005882:	781a      	ldrb	r2, [r3, #0]
 8005884:	6839      	ldr	r1, [r7, #0]
 8005886:	4b0d      	ldr	r3, [pc, #52]	; (80058bc <LMIC_setTxData2+0x70>)
 8005888:	0018      	movs	r0, r3
 800588a:	f008 f8cb 	bl	800da24 <memcpy>
    LMIC.pendTxConf = confirmed;
 800588e:	4b0c      	ldr	r3, [pc, #48]	; (80058c0 <LMIC_setTxData2+0x74>)
 8005890:	1d7a      	adds	r2, r7, #5
 8005892:	21bb      	movs	r1, #187	; 0xbb
 8005894:	7812      	ldrb	r2, [r2, #0]
 8005896:	545a      	strb	r2, [r3, r1]
    LMIC.pendTxPort = port;
 8005898:	4b09      	ldr	r3, [pc, #36]	; (80058c0 <LMIC_setTxData2+0x74>)
 800589a:	1dfa      	adds	r2, r7, #7
 800589c:	21ba      	movs	r1, #186	; 0xba
 800589e:	7812      	ldrb	r2, [r2, #0]
 80058a0:	545a      	strb	r2, [r3, r1]
    LMIC.pendTxLen  = dlen;
 80058a2:	4b07      	ldr	r3, [pc, #28]	; (80058c0 <LMIC_setTxData2+0x74>)
 80058a4:	1dba      	adds	r2, r7, #6
 80058a6:	21bc      	movs	r1, #188	; 0xbc
 80058a8:	7812      	ldrb	r2, [r2, #0]
 80058aa:	545a      	strb	r2, [r3, r1]
    LMIC_setTxData();
 80058ac:	f7ff ffb0 	bl	8005810 <LMIC_setTxData>
    return 0;
 80058b0:	2300      	movs	r3, #0
}
 80058b2:	0018      	movs	r0, r3
 80058b4:	46bd      	mov	sp, r7
 80058b6:	b003      	add	sp, #12
 80058b8:	bd90      	pop	{r4, r7, pc}
 80058ba:	46c0      	nop			; (mov r8, r8)
 80058bc:	200003e1 	.word	0x200003e1
 80058c0:	20000324 	.word	0x20000324

080058c4 <os_getArtEui>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
// provide application router ID (8 bytes, LSBF)
void os_getArtEui (u1_t* buf) {
 80058c4:	b580      	push	{r7, lr}
 80058c6:	b082      	sub	sp, #8
 80058c8:	af00      	add	r7, sp, #0
 80058ca:	6078      	str	r0, [r7, #4]
    memcpy(buf, APPEUI, 8);
 80058cc:	687a      	ldr	r2, [r7, #4]
 80058ce:	4b05      	ldr	r3, [pc, #20]	; (80058e4 <os_getArtEui+0x20>)
 80058d0:	0010      	movs	r0, r2
 80058d2:	0019      	movs	r1, r3
 80058d4:	2308      	movs	r3, #8
 80058d6:	001a      	movs	r2, r3
 80058d8:	f008 f8a4 	bl	800da24 <memcpy>
}
 80058dc:	46c0      	nop			; (mov r8, r8)
 80058de:	46bd      	mov	sp, r7
 80058e0:	b002      	add	sp, #8
 80058e2:	bd80      	pop	{r7, pc}
 80058e4:	0800f1c0 	.word	0x0800f1c0

080058e8 <os_getDevEui>:

// provide device ID (8 bytes, LSBF)
void os_getDevEui (u1_t* buf) {
 80058e8:	b580      	push	{r7, lr}
 80058ea:	b082      	sub	sp, #8
 80058ec:	af00      	add	r7, sp, #0
 80058ee:	6078      	str	r0, [r7, #4]
    memcpy(buf, DEVEUI, 8);
 80058f0:	687a      	ldr	r2, [r7, #4]
 80058f2:	4b05      	ldr	r3, [pc, #20]	; (8005908 <os_getDevEui+0x20>)
 80058f4:	0010      	movs	r0, r2
 80058f6:	0019      	movs	r1, r3
 80058f8:	2308      	movs	r3, #8
 80058fa:	001a      	movs	r2, r3
 80058fc:	f008 f892 	bl	800da24 <memcpy>
}
 8005900:	46c0      	nop			; (mov r8, r8)
 8005902:	46bd      	mov	sp, r7
 8005904:	b002      	add	sp, #8
 8005906:	bd80      	pop	{r7, pc}
 8005908:	0800f1c8 	.word	0x0800f1c8

0800590c <os_getDevKey>:

// provide device key (16 bytes)
void os_getDevKey (u1_t* buf) {
 800590c:	b580      	push	{r7, lr}
 800590e:	b082      	sub	sp, #8
 8005910:	af00      	add	r7, sp, #0
 8005912:	6078      	str	r0, [r7, #4]
    memcpy(buf, DEVKEY, 16);
 8005914:	687a      	ldr	r2, [r7, #4]
 8005916:	4b05      	ldr	r3, [pc, #20]	; (800592c <os_getDevKey+0x20>)
 8005918:	0010      	movs	r0, r2
 800591a:	0019      	movs	r1, r3
 800591c:	2310      	movs	r3, #16
 800591e:	001a      	movs	r2, r3
 8005920:	f008 f880 	bl	800da24 <memcpy>
}
 8005924:	46c0      	nop			; (mov r8, r8)
 8005926:	46bd      	mov	sp, r7
 8005928:	b002      	add	sp, #8
 800592a:	bd80      	pop	{r7, pc}
 800592c:	0800f1d0 	.word	0x0800f1d0

08005930 <initsensor>:

void initsensor(){
 8005930:	b580      	push	{r7, lr}
 8005932:	af00      	add	r7, sp, #0
	 // init sensors
	bmp280_init_default_params(&bmp280.params);
 8005934:	4b13      	ldr	r3, [pc, #76]	; (8005984 <initsensor+0x54>)
 8005936:	0018      	movs	r0, r3
 8005938:	f7fa ffc2 	bl	80008c0 <bmp280_init_default_params>
	bmp280.addr = BMP280_I2C_ADDRESS_0;
 800593c:	4b12      	ldr	r3, [pc, #72]	; (8005988 <initsensor+0x58>)
 800593e:	2276      	movs	r2, #118	; 0x76
 8005940:	849a      	strh	r2, [r3, #36]	; 0x24
	bmp280.i2c = &hi2c1;
 8005942:	4b11      	ldr	r3, [pc, #68]	; (8005988 <initsensor+0x58>)
 8005944:	4a11      	ldr	r2, [pc, #68]	; (800598c <initsensor+0x5c>)
 8005946:	629a      	str	r2, [r3, #40]	; 0x28

	while (!bmp280_init(&bmp280, &bmp280.params)) {
 8005948:	e008      	b.n	800595c <initsensor+0x2c>
		debug_str("BMP280 initialization failed\n\r");
 800594a:	4b11      	ldr	r3, [pc, #68]	; (8005990 <initsensor+0x60>)
 800594c:	0018      	movs	r0, r3
 800594e:	f7fc fa87 	bl	8001e60 <debug_str>
		HAL_Delay(1000);
 8005952:	23fa      	movs	r3, #250	; 0xfa
 8005954:	009b      	lsls	r3, r3, #2
 8005956:	0018      	movs	r0, r3
 8005958:	f001 fdce 	bl	80074f8 <HAL_Delay>
	while (!bmp280_init(&bmp280, &bmp280.params)) {
 800595c:	4a09      	ldr	r2, [pc, #36]	; (8005984 <initsensor+0x54>)
 800595e:	4b0a      	ldr	r3, [pc, #40]	; (8005988 <initsensor+0x58>)
 8005960:	0011      	movs	r1, r2
 8005962:	0018      	movs	r0, r3
 8005964:	f7fb f940 	bl	8000be8 <bmp280_init>
 8005968:	0003      	movs	r3, r0
 800596a:	001a      	movs	r2, r3
 800596c:	2301      	movs	r3, #1
 800596e:	4053      	eors	r3, r2
 8005970:	b2db      	uxtb	r3, r3
 8005972:	2b00      	cmp	r3, #0
 8005974:	d1e9      	bne.n	800594a <initsensor+0x1a>
	}
	debug_str("BME280 found\n\r");
 8005976:	4b07      	ldr	r3, [pc, #28]	; (8005994 <initsensor+0x64>)
 8005978:	0018      	movs	r0, r3
 800597a:	f7fc fa71 	bl	8001e60 <debug_str>
}
 800597e:	46c0      	nop			; (mov r8, r8)
 8005980:	46bd      	mov	sp, r7
 8005982:	bd80      	pop	{r7, pc}
 8005984:	2000050c 	.word	0x2000050c
 8005988:	200004e0 	.word	0x200004e0
 800598c:	20000160 	.word	0x20000160
 8005990:	0800db88 	.word	0x0800db88
 8005994:	0800dba8 	.word	0x0800dba8

08005998 <initfunc>:

void initfunc (osjob_t* j) {
 8005998:	b580      	push	{r7, lr}
 800599a:	b082      	sub	sp, #8
 800599c:	af00      	add	r7, sp, #0
 800599e:	6078      	str	r0, [r7, #4]
    // intialize sensor hardware
    initsensor();
 80059a0:	f7ff ffc6 	bl	8005930 <initsensor>
    // reset MAC state
    LMIC_reset();
 80059a4:	f7ff fed0 	bl	8005748 <LMIC_reset>
    // start joining
    LMIC_startJoining();
 80059a8:	f7ff f9ee 	bl	8004d88 <LMIC_startJoining>
    // init done - onEvent() callback will be invoked...
}
 80059ac:	46c0      	nop			; (mov r8, r8)
 80059ae:	46bd      	mov	sp, r7
 80059b0:	b002      	add	sp, #8
 80059b2:	bd80      	pop	{r7, pc}

080059b4 <readsensor>:

bool readsensor(){
 80059b4:	b580      	push	{r7, lr}
 80059b6:	af00      	add	r7, sp, #0
	HAL_ADC_Start(&hadc);
 80059b8:	4b10      	ldr	r3, [pc, #64]	; (80059fc <readsensor+0x48>)
 80059ba:	0018      	movs	r0, r3
 80059bc:	f002 f95e 	bl	8007c7c <HAL_ADC_Start>
	HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
 80059c0:	2301      	movs	r3, #1
 80059c2:	425a      	negs	r2, r3
 80059c4:	4b0d      	ldr	r3, [pc, #52]	; (80059fc <readsensor+0x48>)
 80059c6:	0011      	movs	r1, r2
 80059c8:	0018      	movs	r0, r3
 80059ca:	f002 f9bd 	bl	8007d48 <HAL_ADC_PollForConversion>
	battery_level = HAL_ADC_GetValue(&hadc);
 80059ce:	4b0b      	ldr	r3, [pc, #44]	; (80059fc <readsensor+0x48>)
 80059d0:	0018      	movs	r0, r3
 80059d2:	f002 fa61 	bl	8007e98 <HAL_ADC_GetValue>
 80059d6:	0003      	movs	r3, r0
 80059d8:	b29a      	uxth	r2, r3
 80059da:	4b09      	ldr	r3, [pc, #36]	; (8005a00 <readsensor+0x4c>)
 80059dc:	801a      	strh	r2, [r3, #0]

	if (bmp280_read_fixed(&bmp280, &temperature, &pressure, &humidity)) {
 80059de:	4b09      	ldr	r3, [pc, #36]	; (8005a04 <readsensor+0x50>)
 80059e0:	4a09      	ldr	r2, [pc, #36]	; (8005a08 <readsensor+0x54>)
 80059e2:	490a      	ldr	r1, [pc, #40]	; (8005a0c <readsensor+0x58>)
 80059e4:	480a      	ldr	r0, [pc, #40]	; (8005a10 <readsensor+0x5c>)
 80059e6:	f7fb fbff 	bl	80011e8 <bmp280_read_fixed>
 80059ea:	1e03      	subs	r3, r0, #0
 80059ec:	d001      	beq.n	80059f2 <readsensor+0x3e>
		return true;
 80059ee:	2301      	movs	r3, #1
 80059f0:	e000      	b.n	80059f4 <readsensor+0x40>
	}
	return false;
 80059f2:	2300      	movs	r3, #0
}
 80059f4:	0018      	movs	r0, r3
 80059f6:	46bd      	mov	sp, r7
 80059f8:	bd80      	pop	{r7, pc}
 80059fa:	46c0      	nop			; (mov r8, r8)
 80059fc:	20000288 	.word	0x20000288
 8005a00:	200004d0 	.word	0x200004d0
 8005a04:	200004dc 	.word	0x200004dc
 8005a08:	200004d8 	.word	0x200004d8
 8005a0c:	200004d4 	.word	0x200004d4
 8005a10:	200004e0 	.word	0x200004e0

08005a14 <reportfunc>:

static osjob_t reportjob;

// report sensor value every minute
static void reportfunc (osjob_t* j) {
 8005a14:	b580      	push	{r7, lr}
 8005a16:	b084      	sub	sp, #16
 8005a18:	af00      	add	r7, sp, #0
 8005a1a:	6078      	str	r0, [r7, #4]
	// read sensor
	if (readsensor()) {
 8005a1c:	f7ff ffca 	bl	80059b4 <readsensor>
 8005a20:	1e03      	subs	r3, r0, #0
 8005a22:	d06a      	beq.n	8005afa <reportfunc+0xe6>
		// if reading was successful
		debug_val("temp = ", temperature);
 8005a24:	4b4e      	ldr	r3, [pc, #312]	; (8005b60 <reportfunc+0x14c>)
 8005a26:	681b      	ldr	r3, [r3, #0]
 8005a28:	001a      	movs	r2, r3
 8005a2a:	4b4e      	ldr	r3, [pc, #312]	; (8005b64 <reportfunc+0x150>)
 8005a2c:	0011      	movs	r1, r2
 8005a2e:	0018      	movs	r0, r3
 8005a30:	f7fc fa2b 	bl	8001e8a <debug_val>
		debug_val("pres = ", pressure);
 8005a34:	4b4c      	ldr	r3, [pc, #304]	; (8005b68 <reportfunc+0x154>)
 8005a36:	681a      	ldr	r2, [r3, #0]
 8005a38:	4b4c      	ldr	r3, [pc, #304]	; (8005b6c <reportfunc+0x158>)
 8005a3a:	0011      	movs	r1, r2
 8005a3c:	0018      	movs	r0, r3
 8005a3e:	f7fc fa24 	bl	8001e8a <debug_val>
		debug_val("hum = ", humidity);
 8005a42:	4b4b      	ldr	r3, [pc, #300]	; (8005b70 <reportfunc+0x15c>)
 8005a44:	681a      	ldr	r2, [r3, #0]
 8005a46:	4b4b      	ldr	r3, [pc, #300]	; (8005b74 <reportfunc+0x160>)
 8005a48:	0011      	movs	r1, r2
 8005a4a:	0018      	movs	r0, r3
 8005a4c:	f7fc fa1d 	bl	8001e8a <debug_val>
		debug_val("volt = ", battery_level);
 8005a50:	4b49      	ldr	r3, [pc, #292]	; (8005b78 <reportfunc+0x164>)
 8005a52:	881b      	ldrh	r3, [r3, #0]
 8005a54:	001a      	movs	r2, r3
 8005a56:	4b49      	ldr	r3, [pc, #292]	; (8005b7c <reportfunc+0x168>)
 8005a58:	0011      	movs	r1, r2
 8005a5a:	0018      	movs	r0, r3
 8005a5c:	f7fc fa15 	bl	8001e8a <debug_val>

		// prepare and schedule data for transmission
		LMIC.frame[1] = battery_level;
 8005a60:	4b45      	ldr	r3, [pc, #276]	; (8005b78 <reportfunc+0x164>)
 8005a62:	881b      	ldrh	r3, [r3, #0]
 8005a64:	b2d9      	uxtb	r1, r3
 8005a66:	4a46      	ldr	r2, [pc, #280]	; (8005b80 <reportfunc+0x16c>)
 8005a68:	234a      	movs	r3, #74	; 0x4a
 8005a6a:	33ff      	adds	r3, #255	; 0xff
 8005a6c:	54d1      	strb	r1, [r2, r3]
		LMIC.frame[0] = battery_level >> 8;
 8005a6e:	4b42      	ldr	r3, [pc, #264]	; (8005b78 <reportfunc+0x164>)
 8005a70:	881b      	ldrh	r3, [r3, #0]
 8005a72:	0a1b      	lsrs	r3, r3, #8
 8005a74:	b29b      	uxth	r3, r3
 8005a76:	b2d9      	uxtb	r1, r3
 8005a78:	4a41      	ldr	r2, [pc, #260]	; (8005b80 <reportfunc+0x16c>)
 8005a7a:	23a4      	movs	r3, #164	; 0xa4
 8005a7c:	005b      	lsls	r3, r3, #1
 8005a7e:	54d1      	strb	r1, [r2, r3]

		for (int i = 0; i < 4; i++) {
 8005a80:	2300      	movs	r3, #0
 8005a82:	60fb      	str	r3, [r7, #12]
 8005a84:	e035      	b.n	8005af2 <reportfunc+0xde>
			LMIC.frame[13 - i] = temperature >> i * 8; // temperature -> bytes 8 - 11
 8005a86:	4b36      	ldr	r3, [pc, #216]	; (8005b60 <reportfunc+0x14c>)
 8005a88:	681a      	ldr	r2, [r3, #0]
 8005a8a:	68fb      	ldr	r3, [r7, #12]
 8005a8c:	00db      	lsls	r3, r3, #3
 8005a8e:	411a      	asrs	r2, r3
 8005a90:	0011      	movs	r1, r2
 8005a92:	68fb      	ldr	r3, [r7, #12]
 8005a94:	220d      	movs	r2, #13
 8005a96:	1ad2      	subs	r2, r2, r3
 8005a98:	b2c8      	uxtb	r0, r1
 8005a9a:	4939      	ldr	r1, [pc, #228]	; (8005b80 <reportfunc+0x16c>)
 8005a9c:	23a4      	movs	r3, #164	; 0xa4
 8005a9e:	005b      	lsls	r3, r3, #1
 8005aa0:	188a      	adds	r2, r1, r2
 8005aa2:	18d3      	adds	r3, r2, r3
 8005aa4:	1c02      	adds	r2, r0, #0
 8005aa6:	701a      	strb	r2, [r3, #0]
			LMIC.frame[9 - i] = pressure >> i * 8; // pressure -> bytes 4 - 7
 8005aa8:	4b2f      	ldr	r3, [pc, #188]	; (8005b68 <reportfunc+0x154>)
 8005aaa:	681a      	ldr	r2, [r3, #0]
 8005aac:	68fb      	ldr	r3, [r7, #12]
 8005aae:	00db      	lsls	r3, r3, #3
 8005ab0:	40da      	lsrs	r2, r3
 8005ab2:	0011      	movs	r1, r2
 8005ab4:	68fb      	ldr	r3, [r7, #12]
 8005ab6:	2209      	movs	r2, #9
 8005ab8:	1ad2      	subs	r2, r2, r3
 8005aba:	b2c8      	uxtb	r0, r1
 8005abc:	4930      	ldr	r1, [pc, #192]	; (8005b80 <reportfunc+0x16c>)
 8005abe:	23a4      	movs	r3, #164	; 0xa4
 8005ac0:	005b      	lsls	r3, r3, #1
 8005ac2:	188a      	adds	r2, r1, r2
 8005ac4:	18d3      	adds	r3, r2, r3
 8005ac6:	1c02      	adds	r2, r0, #0
 8005ac8:	701a      	strb	r2, [r3, #0]
			LMIC.frame[5 - i] = humidity >> i * 8; // humidity -> bytes 0 - 3
 8005aca:	4b29      	ldr	r3, [pc, #164]	; (8005b70 <reportfunc+0x15c>)
 8005acc:	681a      	ldr	r2, [r3, #0]
 8005ace:	68fb      	ldr	r3, [r7, #12]
 8005ad0:	00db      	lsls	r3, r3, #3
 8005ad2:	40da      	lsrs	r2, r3
 8005ad4:	0011      	movs	r1, r2
 8005ad6:	68fb      	ldr	r3, [r7, #12]
 8005ad8:	2205      	movs	r2, #5
 8005ada:	1ad2      	subs	r2, r2, r3
 8005adc:	b2c8      	uxtb	r0, r1
 8005ade:	4928      	ldr	r1, [pc, #160]	; (8005b80 <reportfunc+0x16c>)
 8005ae0:	23a4      	movs	r3, #164	; 0xa4
 8005ae2:	005b      	lsls	r3, r3, #1
 8005ae4:	188a      	adds	r2, r1, r2
 8005ae6:	18d3      	adds	r3, r2, r3
 8005ae8:	1c02      	adds	r2, r0, #0
 8005aea:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 4; i++) {
 8005aec:	68fb      	ldr	r3, [r7, #12]
 8005aee:	3301      	adds	r3, #1
 8005af0:	60fb      	str	r3, [r7, #12]
 8005af2:	68fb      	ldr	r3, [r7, #12]
 8005af4:	2b03      	cmp	r3, #3
 8005af6:	ddc6      	ble.n	8005a86 <reportfunc+0x72>
 8005af8:	e015      	b.n	8005b26 <reportfunc+0x112>
		}
	} else {
		// if reading was unsuccessful
		debug_str("Reading failed\n\r");
 8005afa:	4b22      	ldr	r3, [pc, #136]	; (8005b84 <reportfunc+0x170>)
 8005afc:	0018      	movs	r0, r3
 8005afe:	f7fc f9af 	bl	8001e60 <debug_str>

		for (int i = 0; i < 12; i++) {
 8005b02:	2300      	movs	r3, #0
 8005b04:	60bb      	str	r3, [r7, #8]
 8005b06:	e00b      	b.n	8005b20 <reportfunc+0x10c>
			LMIC.frame[i + 2] = 0xff; // error value
 8005b08:	68bb      	ldr	r3, [r7, #8]
 8005b0a:	1c9a      	adds	r2, r3, #2
 8005b0c:	491c      	ldr	r1, [pc, #112]	; (8005b80 <reportfunc+0x16c>)
 8005b0e:	23a4      	movs	r3, #164	; 0xa4
 8005b10:	005b      	lsls	r3, r3, #1
 8005b12:	188a      	adds	r2, r1, r2
 8005b14:	18d3      	adds	r3, r2, r3
 8005b16:	22ff      	movs	r2, #255	; 0xff
 8005b18:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 12; i++) {
 8005b1a:	68bb      	ldr	r3, [r7, #8]
 8005b1c:	3301      	adds	r3, #1
 8005b1e:	60bb      	str	r3, [r7, #8]
 8005b20:	68bb      	ldr	r3, [r7, #8]
 8005b22:	2b0b      	cmp	r3, #11
 8005b24:	ddf0      	ble.n	8005b08 <reportfunc+0xf4>
		}
	}

    LMIC_setTxData2(1, LMIC.frame, 14, 0); // (port 1, 14 bytes, unconfirmed)
 8005b26:	4918      	ldr	r1, [pc, #96]	; (8005b88 <reportfunc+0x174>)
 8005b28:	2300      	movs	r3, #0
 8005b2a:	220e      	movs	r2, #14
 8005b2c:	2001      	movs	r0, #1
 8005b2e:	f7ff fe8d 	bl	800584c <LMIC_setTxData2>
    // reschedule job in 60 seconds
    os_setTimedCallback(j, os_getTime()+sec2osticks(repeat_period), reportfunc);
 8005b32:	f000 fbcd 	bl	80062d0 <os_getTime>
 8005b36:	0001      	movs	r1, r0
 8005b38:	4b14      	ldr	r3, [pc, #80]	; (8005b8c <reportfunc+0x178>)
 8005b3a:	781b      	ldrb	r3, [r3, #0]
 8005b3c:	001a      	movs	r2, r3
 8005b3e:	0013      	movs	r3, r2
 8005b40:	015b      	lsls	r3, r3, #5
 8005b42:	1a9b      	subs	r3, r3, r2
 8005b44:	009b      	lsls	r3, r3, #2
 8005b46:	189b      	adds	r3, r3, r2
 8005b48:	021b      	lsls	r3, r3, #8
 8005b4a:	18c9      	adds	r1, r1, r3
 8005b4c:	4a10      	ldr	r2, [pc, #64]	; (8005b90 <reportfunc+0x17c>)
 8005b4e:	687b      	ldr	r3, [r7, #4]
 8005b50:	0018      	movs	r0, r3
 8005b52:	f000 fc2b 	bl	80063ac <os_setTimedCallback>
}
 8005b56:	46c0      	nop			; (mov r8, r8)
 8005b58:	46bd      	mov	sp, r7
 8005b5a:	b004      	add	sp, #16
 8005b5c:	bd80      	pop	{r7, pc}
 8005b5e:	46c0      	nop			; (mov r8, r8)
 8005b60:	200004d4 	.word	0x200004d4
 8005b64:	0800dbb8 	.word	0x0800dbb8
 8005b68:	200004d8 	.word	0x200004d8
 8005b6c:	0800dbc0 	.word	0x0800dbc0
 8005b70:	200004dc 	.word	0x200004dc
 8005b74:	0800dbc8 	.word	0x0800dbc8
 8005b78:	200004d0 	.word	0x200004d0
 8005b7c:	0800dbd0 	.word	0x0800dbd0
 8005b80:	20000324 	.word	0x20000324
 8005b84:	0800dbd8 	.word	0x0800dbd8
 8005b88:	2000046c 	.word	0x2000046c
 8005b8c:	20000048 	.word	0x20000048
 8005b90:	08005a15 	.word	0x08005a15

08005b94 <onEvent>:

//////////////////////////////////////////////////
// LMIC EVENT CALLBACK
//////////////////////////////////////////////////

void onEvent (ev_t ev) {
 8005b94:	b580      	push	{r7, lr}
 8005b96:	b082      	sub	sp, #8
 8005b98:	af00      	add	r7, sp, #0
 8005b9a:	0002      	movs	r2, r0
 8005b9c:	1dfb      	adds	r3, r7, #7
 8005b9e:	701a      	strb	r2, [r3, #0]
    debug_event(ev);
 8005ba0:	1dfb      	adds	r3, r7, #7
 8005ba2:	781b      	ldrb	r3, [r3, #0]
 8005ba4:	0018      	movs	r0, r3
 8005ba6:	f7fc f987 	bl	8001eb8 <debug_event>

    switch(ev) {
 8005baa:	1dfb      	adds	r3, r7, #7
 8005bac:	781b      	ldrb	r3, [r3, #0]
 8005bae:	2b0f      	cmp	r3, #15
 8005bb0:	d900      	bls.n	8005bb4 <onEvent+0x20>
 8005bb2:	e072      	b.n	8005c9a <onEvent+0x106>
 8005bb4:	009a      	lsls	r2, r3, #2
 8005bb6:	4b3e      	ldr	r3, [pc, #248]	; (8005cb0 <onEvent+0x11c>)
 8005bb8:	18d3      	adds	r3, r2, r3
 8005bba:	681b      	ldr	r3, [r3, #0]
 8005bbc:	469f      	mov	pc, r3

      // network joined, session established
      case EV_JOINING:
       	  debug_str("try joining\r\n");
 8005bbe:	4b3d      	ldr	r3, [pc, #244]	; (8005cb4 <onEvent+0x120>)
 8005bc0:	0018      	movs	r0, r3
 8005bc2:	f7fc f94d 	bl	8001e60 <debug_str>
       	  break;
 8005bc6:	e06e      	b.n	8005ca6 <onEvent+0x112>
      case EV_JOINED:
          debug_led(1);
 8005bc8:	2001      	movs	r0, #1
 8005bca:	f7fc f8d7 	bl	8001d7c <debug_led>
          // kick-off periodic sensor job
          reportfunc(&reportjob);
 8005bce:	4b3a      	ldr	r3, [pc, #232]	; (8005cb8 <onEvent+0x124>)
 8005bd0:	0018      	movs	r0, r3
 8005bd2:	f7ff ff1f 	bl	8005a14 <reportfunc>
          break;
 8005bd6:	e066      	b.n	8005ca6 <onEvent+0x112>
      case EV_JOIN_FAILED:
    	  debug_str("join failed\r\n");
 8005bd8:	4b38      	ldr	r3, [pc, #224]	; (8005cbc <onEvent+0x128>)
 8005bda:	0018      	movs	r0, r3
 8005bdc:	f7fc f940 	bl	8001e60 <debug_str>
    	  break;
 8005be0:	e061      	b.n	8005ca6 <onEvent+0x112>
      case EV_SCAN_TIMEOUT:
    	  debug_str("EV_SCAN_TIMEOUT\r\n");
 8005be2:	4b37      	ldr	r3, [pc, #220]	; (8005cc0 <onEvent+0x12c>)
 8005be4:	0018      	movs	r0, r3
 8005be6:	f7fc f93b 	bl	8001e60 <debug_str>
		  break;
 8005bea:	e05c      	b.n	8005ca6 <onEvent+0x112>
	  case EV_BEACON_FOUND:
		  debug_str("EV_BEACON_FOUND\r\n");
 8005bec:	4b35      	ldr	r3, [pc, #212]	; (8005cc4 <onEvent+0x130>)
 8005bee:	0018      	movs	r0, r3
 8005bf0:	f7fc f936 	bl	8001e60 <debug_str>
		  break;
 8005bf4:	e057      	b.n	8005ca6 <onEvent+0x112>
	  case EV_BEACON_MISSED:
		  debug_str("EV_BEACON_MISSED\r\n");
 8005bf6:	4b34      	ldr	r3, [pc, #208]	; (8005cc8 <onEvent+0x134>)
 8005bf8:	0018      	movs	r0, r3
 8005bfa:	f7fc f931 	bl	8001e60 <debug_str>
		  break;
 8005bfe:	e052      	b.n	8005ca6 <onEvent+0x112>
	  case EV_BEACON_TRACKED:
		  debug_str("EV_BEACON_TRACKED\r\n");
 8005c00:	4b32      	ldr	r3, [pc, #200]	; (8005ccc <onEvent+0x138>)
 8005c02:	0018      	movs	r0, r3
 8005c04:	f7fc f92c 	bl	8001e60 <debug_str>
		  break;
 8005c08:	e04d      	b.n	8005ca6 <onEvent+0x112>
	  case EV_RFU1:
		  debug_str("EV_RFU1\r\n");
 8005c0a:	4b31      	ldr	r3, [pc, #196]	; (8005cd0 <onEvent+0x13c>)
 8005c0c:	0018      	movs	r0, r3
 8005c0e:	f7fc f927 	bl	8001e60 <debug_str>
		  break;
 8005c12:	e048      	b.n	8005ca6 <onEvent+0x112>
	  case EV_REJOIN_FAILED:
		  debug_str("EV_REJOIN_FAILED\r\n");
 8005c14:	4b2f      	ldr	r3, [pc, #188]	; (8005cd4 <onEvent+0x140>)
 8005c16:	0018      	movs	r0, r3
 8005c18:	f7fc f922 	bl	8001e60 <debug_str>
		  break;
 8005c1c:	e043      	b.n	8005ca6 <onEvent+0x112>
	  case EV_TXCOMPLETE:
		  debug_str("EV_TXCOMPLETE (includes waiting for RX windows)\r\n");
 8005c1e:	4b2e      	ldr	r3, [pc, #184]	; (8005cd8 <onEvent+0x144>)
 8005c20:	0018      	movs	r0, r3
 8005c22:	f7fc f91d 	bl	8001e60 <debug_str>
		  if (LMIC.txrxFlags & TXRX_ACK)
 8005c26:	4a2d      	ldr	r2, [pc, #180]	; (8005cdc <onEvent+0x148>)
 8005c28:	2346      	movs	r3, #70	; 0x46
 8005c2a:	33ff      	adds	r3, #255	; 0xff
 8005c2c:	5cd3      	ldrb	r3, [r2, r3]
 8005c2e:	b25b      	sxtb	r3, r3
 8005c30:	2b00      	cmp	r3, #0
 8005c32:	da03      	bge.n	8005c3c <onEvent+0xa8>
			  debug_str("Received ack\r\n");
 8005c34:	4b2a      	ldr	r3, [pc, #168]	; (8005ce0 <onEvent+0x14c>)
 8005c36:	0018      	movs	r0, r3
 8005c38:	f7fc f912 	bl	8001e60 <debug_str>
		  if (LMIC.dataLen) {
 8005c3c:	4a27      	ldr	r2, [pc, #156]	; (8005cdc <onEvent+0x148>)
 8005c3e:	2348      	movs	r3, #72	; 0x48
 8005c40:	33ff      	adds	r3, #255	; 0xff
 8005c42:	5cd3      	ldrb	r3, [r2, r3]
 8005c44:	2b00      	cmp	r3, #0
 8005c46:	d02d      	beq.n	8005ca4 <onEvent+0x110>
			  debug_str("Received ");
 8005c48:	4b26      	ldr	r3, [pc, #152]	; (8005ce4 <onEvent+0x150>)
 8005c4a:	0018      	movs	r0, r3
 8005c4c:	f7fc f908 	bl	8001e60 <debug_str>
			  debug_str(LMIC.dataLen);
 8005c50:	4a22      	ldr	r2, [pc, #136]	; (8005cdc <onEvent+0x148>)
 8005c52:	2348      	movs	r3, #72	; 0x48
 8005c54:	33ff      	adds	r3, #255	; 0xff
 8005c56:	5cd3      	ldrb	r3, [r2, r3]
 8005c58:	0018      	movs	r0, r3
 8005c5a:	f7fc f901 	bl	8001e60 <debug_str>
			  debug_str(" bytes of payload\r\n");
 8005c5e:	4b22      	ldr	r3, [pc, #136]	; (8005ce8 <onEvent+0x154>)
 8005c60:	0018      	movs	r0, r3
 8005c62:	f7fc f8fd 	bl	8001e60 <debug_str>
		  }
		  break;
 8005c66:	e01d      	b.n	8005ca4 <onEvent+0x110>
	  case EV_LOST_TSYNC:
		  debug_str("EV_LOST_TSYNC\r\n");
 8005c68:	4b20      	ldr	r3, [pc, #128]	; (8005cec <onEvent+0x158>)
 8005c6a:	0018      	movs	r0, r3
 8005c6c:	f7fc f8f8 	bl	8001e60 <debug_str>
		  break;
 8005c70:	e019      	b.n	8005ca6 <onEvent+0x112>
	  case EV_RESET:
		  debug_str("EV_RESET\r\n");
 8005c72:	4b1f      	ldr	r3, [pc, #124]	; (8005cf0 <onEvent+0x15c>)
 8005c74:	0018      	movs	r0, r3
 8005c76:	f7fc f8f3 	bl	8001e60 <debug_str>
		  break;
 8005c7a:	e014      	b.n	8005ca6 <onEvent+0x112>
	  case EV_RXCOMPLETE:
		  // data received in ping slot
		  debug_str("EV_RXCOMPLETE\r\n");
 8005c7c:	4b1d      	ldr	r3, [pc, #116]	; (8005cf4 <onEvent+0x160>)
 8005c7e:	0018      	movs	r0, r3
 8005c80:	f7fc f8ee 	bl	8001e60 <debug_str>
		  break;
 8005c84:	e00f      	b.n	8005ca6 <onEvent+0x112>
	  case EV_LINK_DEAD:
		  debug_str("EV_LINK_DEAD\r\n");
 8005c86:	4b1c      	ldr	r3, [pc, #112]	; (8005cf8 <onEvent+0x164>)
 8005c88:	0018      	movs	r0, r3
 8005c8a:	f7fc f8e9 	bl	8001e60 <debug_str>
		  break;
 8005c8e:	e00a      	b.n	8005ca6 <onEvent+0x112>
	  case EV_LINK_ALIVE:
		  debug_str("EV_LINK_ALIVE\r\n");
 8005c90:	4b1a      	ldr	r3, [pc, #104]	; (8005cfc <onEvent+0x168>)
 8005c92:	0018      	movs	r0, r3
 8005c94:	f7fc f8e4 	bl	8001e60 <debug_str>
		  break;
 8005c98:	e005      	b.n	8005ca6 <onEvent+0x112>
	  default:
		   debug_str("Unknown event\r\n");
 8005c9a:	4b19      	ldr	r3, [pc, #100]	; (8005d00 <onEvent+0x16c>)
 8005c9c:	0018      	movs	r0, r3
 8005c9e:	f7fc f8df 	bl	8001e60 <debug_str>
		  break;
 8005ca2:	e000      	b.n	8005ca6 <onEvent+0x112>
		  break;
 8005ca4:	46c0      	nop			; (mov r8, r8)
    }
}
 8005ca6:	46c0      	nop			; (mov r8, r8)
 8005ca8:	46bd      	mov	sp, r7
 8005caa:	b002      	add	sp, #8
 8005cac:	bd80      	pop	{r7, pc}
 8005cae:	46c0      	nop			; (mov r8, r8)
 8005cb0:	0800f1e0 	.word	0x0800f1e0
 8005cb4:	0800dbec 	.word	0x0800dbec
 8005cb8:	2000007c 	.word	0x2000007c
 8005cbc:	0800dbfc 	.word	0x0800dbfc
 8005cc0:	0800dc0c 	.word	0x0800dc0c
 8005cc4:	0800dc20 	.word	0x0800dc20
 8005cc8:	0800dc34 	.word	0x0800dc34
 8005ccc:	0800dc48 	.word	0x0800dc48
 8005cd0:	0800dc5c 	.word	0x0800dc5c
 8005cd4:	0800dc68 	.word	0x0800dc68
 8005cd8:	0800dc7c 	.word	0x0800dc7c
 8005cdc:	20000324 	.word	0x20000324
 8005ce0:	0800dcb0 	.word	0x0800dcb0
 8005ce4:	0800dcc0 	.word	0x0800dcc0
 8005ce8:	0800dccc 	.word	0x0800dccc
 8005cec:	0800dce0 	.word	0x0800dce0
 8005cf0:	0800dcf0 	.word	0x0800dcf0
 8005cf4:	0800dcfc 	.word	0x0800dcfc
 8005cf8:	0800dd0c 	.word	0x0800dd0c
 8005cfc:	0800dd1c 	.word	0x0800dd1c
 8005d00:	0800dd2c 	.word	0x0800dd2c

08005d04 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8005d04:	b580      	push	{r7, lr}
 8005d06:	b084      	sub	sp, #16
 8005d08:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8005d0a:	f001 fb85 	bl	8007418 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8005d0e:	f000 f82f 	bl	8005d70 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8005d12:	f000 fa2d 	bl	8006170 <MX_GPIO_Init>
  MX_USART2_UART_Init();
 8005d16:	f000 f9fb 	bl	8006110 <MX_USART2_UART_Init>
  MX_I2C1_Init();
 8005d1a:	f000 f903 	bl	8005f24 <MX_I2C1_Init>
  MX_SPI1_Init();
 8005d1e:	f000 f941 	bl	8005fa4 <MX_SPI1_Init>
  MX_TIM21_Init();
 8005d22:	f000 f977 	bl	8006014 <MX_TIM21_Init>
  MX_ADC_Init();
 8005d26:	f000 f899 	bl	8005e5c <MX_ADC_Init>
  /* USER CODE BEGIN 2 */

  HAL_TIM_Base_Start_IT(&htim21);    // <-----------  change to your setup
 8005d2a:	4b0e      	ldr	r3, [pc, #56]	; (8005d64 <main+0x60>)
 8005d2c:	0018      	movs	r0, r3
 8005d2e:	f005 fe2d 	bl	800b98c <HAL_TIM_Base_Start_IT>
   __HAL_SPI_ENABLE(&hspi1);         // <-----------  change to your setup
 8005d32:	4b0d      	ldr	r3, [pc, #52]	; (8005d68 <main+0x64>)
 8005d34:	681b      	ldr	r3, [r3, #0]
 8005d36:	681a      	ldr	r2, [r3, #0]
 8005d38:	4b0b      	ldr	r3, [pc, #44]	; (8005d68 <main+0x64>)
 8005d3a:	681b      	ldr	r3, [r3, #0]
 8005d3c:	2140      	movs	r1, #64	; 0x40
 8005d3e:	430a      	orrs	r2, r1
 8005d40:	601a      	str	r2, [r3, #0]

   osjob_t initjob;

   // initialize runtime env
   os_init();
 8005d42:	f000 fab1 	bl	80062a8 <os_init>

   // initialize debug library
   debug_init();
 8005d46:	f7fc f80b 	bl	8001d60 <debug_init>

   // setup initial job
    os_setCallback(&initjob, initfunc);
 8005d4a:	4a08      	ldr	r2, [pc, #32]	; (8005d6c <main+0x68>)
 8005d4c:	1d3b      	adds	r3, r7, #4
 8005d4e:	0011      	movs	r1, r2
 8005d50:	0018      	movs	r0, r3
 8005d52:	f000 fb03 	bl	800635c <os_setCallback>

   // execute scheduled jobs and events
   os_runloop();
 8005d56:	f000 fb61 	bl	800641c <os_runloop>

   // (not reached)
   return 0;
 8005d5a:	2300      	movs	r3, #0
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	    	  }
  /* USER CODE END 3 */
}
 8005d5c:	0018      	movs	r0, r3
 8005d5e:	46bd      	mov	sp, r7
 8005d60:	b004      	add	sp, #16
 8005d62:	bd80      	pop	{r7, pc}
 8005d64:	200002e4 	.word	0x200002e4
 8005d68:	200001ac 	.word	0x200001ac
 8005d6c:	08005999 	.word	0x08005999

08005d70 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8005d70:	b590      	push	{r4, r7, lr}
 8005d72:	b09f      	sub	sp, #124	; 0x7c
 8005d74:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8005d76:	2440      	movs	r4, #64	; 0x40
 8005d78:	193b      	adds	r3, r7, r4
 8005d7a:	0018      	movs	r0, r3
 8005d7c:	2338      	movs	r3, #56	; 0x38
 8005d7e:	001a      	movs	r2, r3
 8005d80:	2100      	movs	r1, #0
 8005d82:	f007 fe58 	bl	800da36 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8005d86:	232c      	movs	r3, #44	; 0x2c
 8005d88:	18fb      	adds	r3, r7, r3
 8005d8a:	0018      	movs	r0, r3
 8005d8c:	2314      	movs	r3, #20
 8005d8e:	001a      	movs	r2, r3
 8005d90:	2100      	movs	r1, #0
 8005d92:	f007 fe50 	bl	800da36 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8005d96:	1d3b      	adds	r3, r7, #4
 8005d98:	0018      	movs	r0, r3
 8005d9a:	2328      	movs	r3, #40	; 0x28
 8005d9c:	001a      	movs	r2, r3
 8005d9e:	2100      	movs	r1, #0
 8005da0:	f007 fe49 	bl	800da36 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8005da4:	4b2b      	ldr	r3, [pc, #172]	; (8005e54 <SystemClock_Config+0xe4>)
 8005da6:	681b      	ldr	r3, [r3, #0]
 8005da8:	4a2b      	ldr	r2, [pc, #172]	; (8005e58 <SystemClock_Config+0xe8>)
 8005daa:	401a      	ands	r2, r3
 8005dac:	4b29      	ldr	r3, [pc, #164]	; (8005e54 <SystemClock_Config+0xe4>)
 8005dae:	2180      	movs	r1, #128	; 0x80
 8005db0:	0109      	lsls	r1, r1, #4
 8005db2:	430a      	orrs	r2, r1
 8005db4:	601a      	str	r2, [r3, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8005db6:	0021      	movs	r1, r4
 8005db8:	187b      	adds	r3, r7, r1
 8005dba:	2202      	movs	r2, #2
 8005dbc:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8005dbe:	187b      	adds	r3, r7, r1
 8005dc0:	2201      	movs	r2, #1
 8005dc2:	60da      	str	r2, [r3, #12]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8005dc4:	187b      	adds	r3, r7, r1
 8005dc6:	2210      	movs	r2, #16
 8005dc8:	611a      	str	r2, [r3, #16]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8005dca:	187b      	adds	r3, r7, r1
 8005dcc:	2202      	movs	r2, #2
 8005dce:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8005dd0:	187b      	adds	r3, r7, r1
 8005dd2:	2200      	movs	r2, #0
 8005dd4:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;
 8005dd6:	187b      	adds	r3, r7, r1
 8005dd8:	2280      	movs	r2, #128	; 0x80
 8005dda:	02d2      	lsls	r2, r2, #11
 8005ddc:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;
 8005dde:	187b      	adds	r3, r7, r1
 8005de0:	2280      	movs	r2, #128	; 0x80
 8005de2:	03d2      	lsls	r2, r2, #15
 8005de4:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8005de6:	187b      	adds	r3, r7, r1
 8005de8:	0018      	movs	r0, r3
 8005dea:	f003 fd93 	bl	8009914 <HAL_RCC_OscConfig>
 8005dee:	1e03      	subs	r3, r0, #0
 8005df0:	d001      	beq.n	8005df6 <SystemClock_Config+0x86>
  {
    Error_Handler();
 8005df2:	f000 fa4b 	bl	800628c <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8005df6:	212c      	movs	r1, #44	; 0x2c
 8005df8:	187b      	adds	r3, r7, r1
 8005dfa:	220f      	movs	r2, #15
 8005dfc:	601a      	str	r2, [r3, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8005dfe:	187b      	adds	r3, r7, r1
 8005e00:	2203      	movs	r2, #3
 8005e02:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8005e04:	187b      	adds	r3, r7, r1
 8005e06:	2200      	movs	r2, #0
 8005e08:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8005e0a:	187b      	adds	r3, r7, r1
 8005e0c:	2200      	movs	r2, #0
 8005e0e:	60da      	str	r2, [r3, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8005e10:	187b      	adds	r3, r7, r1
 8005e12:	2200      	movs	r2, #0
 8005e14:	611a      	str	r2, [r3, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8005e16:	187b      	adds	r3, r7, r1
 8005e18:	2101      	movs	r1, #1
 8005e1a:	0018      	movs	r0, r3
 8005e1c:	f004 fb0e 	bl	800a43c <HAL_RCC_ClockConfig>
 8005e20:	1e03      	subs	r3, r0, #0
 8005e22:	d001      	beq.n	8005e28 <SystemClock_Config+0xb8>
  {
    Error_Handler();
 8005e24:	f000 fa32 	bl	800628c <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1;
 8005e28:	1d3b      	adds	r3, r7, #4
 8005e2a:	220a      	movs	r2, #10
 8005e2c:	601a      	str	r2, [r3, #0]
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 8005e2e:	1d3b      	adds	r3, r7, #4
 8005e30:	2200      	movs	r2, #0
 8005e32:	611a      	str	r2, [r3, #16]
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 8005e34:	1d3b      	adds	r3, r7, #4
 8005e36:	2200      	movs	r2, #0
 8005e38:	619a      	str	r2, [r3, #24]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8005e3a:	1d3b      	adds	r3, r7, #4
 8005e3c:	0018      	movs	r0, r3
 8005e3e:	f004 fddb 	bl	800a9f8 <HAL_RCCEx_PeriphCLKConfig>
 8005e42:	1e03      	subs	r3, r0, #0
 8005e44:	d001      	beq.n	8005e4a <SystemClock_Config+0xda>
  {
    Error_Handler();
 8005e46:	f000 fa21 	bl	800628c <Error_Handler>
  }
}
 8005e4a:	46c0      	nop			; (mov r8, r8)
 8005e4c:	46bd      	mov	sp, r7
 8005e4e:	b01f      	add	sp, #124	; 0x7c
 8005e50:	bd90      	pop	{r4, r7, pc}
 8005e52:	46c0      	nop			; (mov r8, r8)
 8005e54:	40007000 	.word	0x40007000
 8005e58:	ffffe7ff 	.word	0xffffe7ff

08005e5c <MX_ADC_Init>:
  * @brief ADC Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC_Init(void)
{
 8005e5c:	b580      	push	{r7, lr}
 8005e5e:	b082      	sub	sp, #8
 8005e60:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC_Init 0 */

  /* USER CODE END ADC_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 8005e62:	003b      	movs	r3, r7
 8005e64:	0018      	movs	r0, r3
 8005e66:	2308      	movs	r3, #8
 8005e68:	001a      	movs	r2, r3
 8005e6a:	2100      	movs	r1, #0
 8005e6c:	f007 fde3 	bl	800da36 <memset>
  /* USER CODE BEGIN ADC_Init 1 */

  /* USER CODE END ADC_Init 1 */
  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc.Instance = ADC1;
 8005e70:	4b2a      	ldr	r3, [pc, #168]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005e72:	4a2b      	ldr	r2, [pc, #172]	; (8005f20 <MX_ADC_Init+0xc4>)
 8005e74:	601a      	str	r2, [r3, #0]
  hadc.Init.OversamplingMode = DISABLE;
 8005e76:	4b29      	ldr	r3, [pc, #164]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005e78:	2200      	movs	r2, #0
 8005e7a:	63da      	str	r2, [r3, #60]	; 0x3c
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;
 8005e7c:	4b27      	ldr	r3, [pc, #156]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005e7e:	2280      	movs	r2, #128	; 0x80
 8005e80:	05d2      	lsls	r2, r2, #23
 8005e82:	605a      	str	r2, [r3, #4]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 8005e84:	4b25      	ldr	r3, [pc, #148]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005e86:	2200      	movs	r2, #0
 8005e88:	609a      	str	r2, [r3, #8]
  hadc.Init.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8005e8a:	4b24      	ldr	r3, [pc, #144]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005e8c:	2200      	movs	r2, #0
 8005e8e:	639a      	str	r2, [r3, #56]	; 0x38
  hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 8005e90:	4b22      	ldr	r3, [pc, #136]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005e92:	2201      	movs	r2, #1
 8005e94:	611a      	str	r2, [r3, #16]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8005e96:	4b21      	ldr	r3, [pc, #132]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005e98:	2200      	movs	r2, #0
 8005e9a:	60da      	str	r2, [r3, #12]
  hadc.Init.ContinuousConvMode = DISABLE;
 8005e9c:	4b1f      	ldr	r3, [pc, #124]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005e9e:	2220      	movs	r2, #32
 8005ea0:	2100      	movs	r1, #0
 8005ea2:	5499      	strb	r1, [r3, r2]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 8005ea4:	4b1d      	ldr	r3, [pc, #116]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005ea6:	2221      	movs	r2, #33	; 0x21
 8005ea8:	2100      	movs	r1, #0
 8005eaa:	5499      	strb	r1, [r3, r2]
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8005eac:	4b1b      	ldr	r3, [pc, #108]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005eae:	2200      	movs	r2, #0
 8005eb0:	629a      	str	r2, [r3, #40]	; 0x28
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8005eb2:	4b1a      	ldr	r3, [pc, #104]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005eb4:	22c2      	movs	r2, #194	; 0xc2
 8005eb6:	32ff      	adds	r2, #255	; 0xff
 8005eb8:	625a      	str	r2, [r3, #36]	; 0x24
  hadc.Init.DMAContinuousRequests = DISABLE;
 8005eba:	4b18      	ldr	r3, [pc, #96]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005ebc:	222c      	movs	r2, #44	; 0x2c
 8005ebe:	2100      	movs	r1, #0
 8005ec0:	5499      	strb	r1, [r3, r2]
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8005ec2:	4b16      	ldr	r3, [pc, #88]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005ec4:	2204      	movs	r2, #4
 8005ec6:	615a      	str	r2, [r3, #20]
  hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8005ec8:	4b14      	ldr	r3, [pc, #80]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005eca:	2200      	movs	r2, #0
 8005ecc:	631a      	str	r2, [r3, #48]	; 0x30
  hadc.Init.LowPowerAutoWait = DISABLE;
 8005ece:	4b13      	ldr	r3, [pc, #76]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005ed0:	2200      	movs	r2, #0
 8005ed2:	619a      	str	r2, [r3, #24]
  hadc.Init.LowPowerFrequencyMode = DISABLE;
 8005ed4:	4b11      	ldr	r3, [pc, #68]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005ed6:	2200      	movs	r2, #0
 8005ed8:	635a      	str	r2, [r3, #52]	; 0x34
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
 8005eda:	4b10      	ldr	r3, [pc, #64]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005edc:	2200      	movs	r2, #0
 8005ede:	61da      	str	r2, [r3, #28]
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 8005ee0:	4b0e      	ldr	r3, [pc, #56]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005ee2:	0018      	movs	r0, r3
 8005ee4:	f001 fb2c 	bl	8007540 <HAL_ADC_Init>
 8005ee8:	1e03      	subs	r3, r0, #0
 8005eea:	d001      	beq.n	8005ef0 <MX_ADC_Init+0x94>
  {
    Error_Handler();
 8005eec:	f000 f9ce 	bl	800628c <Error_Handler>
  }
  /** Configure for the selected ADC regular channel to be converted.
  */
  sConfig.Channel = ADC_CHANNEL_0;
 8005ef0:	003b      	movs	r3, r7
 8005ef2:	2201      	movs	r2, #1
 8005ef4:	601a      	str	r2, [r3, #0]
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 8005ef6:	003b      	movs	r3, r7
 8005ef8:	2280      	movs	r2, #128	; 0x80
 8005efa:	0152      	lsls	r2, r2, #5
 8005efc:	605a      	str	r2, [r3, #4]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8005efe:	003a      	movs	r2, r7
 8005f00:	4b06      	ldr	r3, [pc, #24]	; (8005f1c <MX_ADC_Init+0xc0>)
 8005f02:	0011      	movs	r1, r2
 8005f04:	0018      	movs	r0, r3
 8005f06:	f001 ffe3 	bl	8007ed0 <HAL_ADC_ConfigChannel>
 8005f0a:	1e03      	subs	r3, r0, #0
 8005f0c:	d001      	beq.n	8005f12 <MX_ADC_Init+0xb6>
  {
    Error_Handler();
 8005f0e:	f000 f9bd 	bl	800628c <Error_Handler>
  }
  /* USER CODE BEGIN ADC_Init 2 */

  /* USER CODE END ADC_Init 2 */

}
 8005f12:	46c0      	nop			; (mov r8, r8)
 8005f14:	46bd      	mov	sp, r7
 8005f16:	b002      	add	sp, #8
 8005f18:	bd80      	pop	{r7, pc}
 8005f1a:	46c0      	nop			; (mov r8, r8)
 8005f1c:	20000288 	.word	0x20000288
 8005f20:	40012400 	.word	0x40012400

08005f24 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 8005f24:	b580      	push	{r7, lr}
 8005f26:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 8005f28:	4b1b      	ldr	r3, [pc, #108]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f2a:	4a1c      	ldr	r2, [pc, #112]	; (8005f9c <MX_I2C1_Init+0x78>)
 8005f2c:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x00707CBB;
 8005f2e:	4b1a      	ldr	r3, [pc, #104]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f30:	4a1b      	ldr	r2, [pc, #108]	; (8005fa0 <MX_I2C1_Init+0x7c>)
 8005f32:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
 8005f34:	4b18      	ldr	r3, [pc, #96]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f36:	2200      	movs	r2, #0
 8005f38:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8005f3a:	4b17      	ldr	r3, [pc, #92]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f3c:	2201      	movs	r2, #1
 8005f3e:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8005f40:	4b15      	ldr	r3, [pc, #84]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f42:	2200      	movs	r2, #0
 8005f44:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
 8005f46:	4b14      	ldr	r3, [pc, #80]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f48:	2200      	movs	r2, #0
 8005f4a:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8005f4c:	4b12      	ldr	r3, [pc, #72]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f4e:	2200      	movs	r2, #0
 8005f50:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8005f52:	4b11      	ldr	r3, [pc, #68]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f54:	2200      	movs	r2, #0
 8005f56:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8005f58:	4b0f      	ldr	r3, [pc, #60]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f5a:	2200      	movs	r2, #0
 8005f5c:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8005f5e:	4b0e      	ldr	r3, [pc, #56]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f60:	0018      	movs	r0, r3
 8005f62:	f002 fda3 	bl	8008aac <HAL_I2C_Init>
 8005f66:	1e03      	subs	r3, r0, #0
 8005f68:	d001      	beq.n	8005f6e <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
 8005f6a:	f000 f98f 	bl	800628c <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8005f6e:	4b0a      	ldr	r3, [pc, #40]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f70:	2100      	movs	r1, #0
 8005f72:	0018      	movs	r0, r3
 8005f74:	f003 fbea 	bl	800974c <HAL_I2CEx_ConfigAnalogFilter>
 8005f78:	1e03      	subs	r3, r0, #0
 8005f7a:	d001      	beq.n	8005f80 <MX_I2C1_Init+0x5c>
  {
    Error_Handler();
 8005f7c:	f000 f986 	bl	800628c <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8005f80:	4b05      	ldr	r3, [pc, #20]	; (8005f98 <MX_I2C1_Init+0x74>)
 8005f82:	2100      	movs	r1, #0
 8005f84:	0018      	movs	r0, r3
 8005f86:	f003 fc55 	bl	8009834 <HAL_I2CEx_ConfigDigitalFilter>
 8005f8a:	1e03      	subs	r3, r0, #0
 8005f8c:	d001      	beq.n	8005f92 <MX_I2C1_Init+0x6e>
  {
    Error_Handler();
 8005f8e:	f000 f97d 	bl	800628c <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 8005f92:	46c0      	nop			; (mov r8, r8)
 8005f94:	46bd      	mov	sp, r7
 8005f96:	bd80      	pop	{r7, pc}
 8005f98:	20000160 	.word	0x20000160
 8005f9c:	40005400 	.word	0x40005400
 8005fa0:	00707cbb 	.word	0x00707cbb

08005fa4 <MX_SPI1_Init>:
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{
 8005fa4:	b580      	push	{r7, lr}
 8005fa6:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 8005fa8:	4b18      	ldr	r3, [pc, #96]	; (800600c <MX_SPI1_Init+0x68>)
 8005faa:	4a19      	ldr	r2, [pc, #100]	; (8006010 <MX_SPI1_Init+0x6c>)
 8005fac:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8005fae:	4b17      	ldr	r3, [pc, #92]	; (800600c <MX_SPI1_Init+0x68>)
 8005fb0:	2282      	movs	r2, #130	; 0x82
 8005fb2:	0052      	lsls	r2, r2, #1
 8005fb4:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8005fb6:	4b15      	ldr	r3, [pc, #84]	; (800600c <MX_SPI1_Init+0x68>)
 8005fb8:	2200      	movs	r2, #0
 8005fba:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8005fbc:	4b13      	ldr	r3, [pc, #76]	; (800600c <MX_SPI1_Init+0x68>)
 8005fbe:	2200      	movs	r2, #0
 8005fc0:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8005fc2:	4b12      	ldr	r3, [pc, #72]	; (800600c <MX_SPI1_Init+0x68>)
 8005fc4:	2200      	movs	r2, #0
 8005fc6:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8005fc8:	4b10      	ldr	r3, [pc, #64]	; (800600c <MX_SPI1_Init+0x68>)
 8005fca:	2200      	movs	r2, #0
 8005fcc:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8005fce:	4b0f      	ldr	r3, [pc, #60]	; (800600c <MX_SPI1_Init+0x68>)
 8005fd0:	2280      	movs	r2, #128	; 0x80
 8005fd2:	0092      	lsls	r2, r2, #2
 8005fd4:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
 8005fd6:	4b0d      	ldr	r3, [pc, #52]	; (800600c <MX_SPI1_Init+0x68>)
 8005fd8:	2238      	movs	r2, #56	; 0x38
 8005fda:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8005fdc:	4b0b      	ldr	r3, [pc, #44]	; (800600c <MX_SPI1_Init+0x68>)
 8005fde:	2200      	movs	r2, #0
 8005fe0:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8005fe2:	4b0a      	ldr	r3, [pc, #40]	; (800600c <MX_SPI1_Init+0x68>)
 8005fe4:	2200      	movs	r2, #0
 8005fe6:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005fe8:	4b08      	ldr	r3, [pc, #32]	; (800600c <MX_SPI1_Init+0x68>)
 8005fea:	2200      	movs	r2, #0
 8005fec:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 8005fee:	4b07      	ldr	r3, [pc, #28]	; (800600c <MX_SPI1_Init+0x68>)
 8005ff0:	2207      	movs	r2, #7
 8005ff2:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8005ff4:	4b05      	ldr	r3, [pc, #20]	; (800600c <MX_SPI1_Init+0x68>)
 8005ff6:	0018      	movs	r0, r3
 8005ff8:	f004 ff8a 	bl	800af10 <HAL_SPI_Init>
 8005ffc:	1e03      	subs	r3, r0, #0
 8005ffe:	d001      	beq.n	8006004 <MX_SPI1_Init+0x60>
  {
    Error_Handler();
 8006000:	f000 f944 	bl	800628c <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 8006004:	46c0      	nop			; (mov r8, r8)
 8006006:	46bd      	mov	sp, r7
 8006008:	bd80      	pop	{r7, pc}
 800600a:	46c0      	nop			; (mov r8, r8)
 800600c:	200001ac 	.word	0x200001ac
 8006010:	40013000 	.word	0x40013000

08006014 <MX_TIM21_Init>:
  * @brief TIM21 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM21_Init(void)
{
 8006014:	b580      	push	{r7, lr}
 8006016:	b08a      	sub	sp, #40	; 0x28
 8006018:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM21_Init 0 */

  /* USER CODE END TIM21_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800601a:	2318      	movs	r3, #24
 800601c:	18fb      	adds	r3, r7, r3
 800601e:	0018      	movs	r0, r3
 8006020:	2310      	movs	r3, #16
 8006022:	001a      	movs	r2, r3
 8006024:	2100      	movs	r1, #0
 8006026:	f007 fd06 	bl	800da36 <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800602a:	2310      	movs	r3, #16
 800602c:	18fb      	adds	r3, r7, r3
 800602e:	0018      	movs	r0, r3
 8006030:	2308      	movs	r3, #8
 8006032:	001a      	movs	r2, r3
 8006034:	2100      	movs	r1, #0
 8006036:	f007 fcfe 	bl	800da36 <memset>
  TIM_OC_InitTypeDef sConfigOC = {0};
 800603a:	003b      	movs	r3, r7
 800603c:	0018      	movs	r0, r3
 800603e:	2310      	movs	r3, #16
 8006040:	001a      	movs	r2, r3
 8006042:	2100      	movs	r1, #0
 8006044:	f007 fcf7 	bl	800da36 <memset>

  /* USER CODE BEGIN TIM21_Init 1 */

  /* USER CODE END TIM21_Init 1 */
  htim21.Instance = TIM21;
 8006048:	4b2d      	ldr	r3, [pc, #180]	; (8006100 <MX_TIM21_Init+0xec>)
 800604a:	4a2e      	ldr	r2, [pc, #184]	; (8006104 <MX_TIM21_Init+0xf0>)
 800604c:	601a      	str	r2, [r3, #0]
  htim21.Init.Prescaler = 1000 - 1;
 800604e:	4b2c      	ldr	r3, [pc, #176]	; (8006100 <MX_TIM21_Init+0xec>)
 8006050:	4a2d      	ldr	r2, [pc, #180]	; (8006108 <MX_TIM21_Init+0xf4>)
 8006052:	605a      	str	r2, [r3, #4]
  htim21.Init.CounterMode = TIM_COUNTERMODE_UP;
 8006054:	4b2a      	ldr	r3, [pc, #168]	; (8006100 <MX_TIM21_Init+0xec>)
 8006056:	2200      	movs	r2, #0
 8006058:	609a      	str	r2, [r3, #8]
  htim21.Init.Period = 65535 - 1;
 800605a:	4b29      	ldr	r3, [pc, #164]	; (8006100 <MX_TIM21_Init+0xec>)
 800605c:	4a2b      	ldr	r2, [pc, #172]	; (800610c <MX_TIM21_Init+0xf8>)
 800605e:	60da      	str	r2, [r3, #12]
  htim21.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8006060:	4b27      	ldr	r3, [pc, #156]	; (8006100 <MX_TIM21_Init+0xec>)
 8006062:	2200      	movs	r2, #0
 8006064:	611a      	str	r2, [r3, #16]
  htim21.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8006066:	4b26      	ldr	r3, [pc, #152]	; (8006100 <MX_TIM21_Init+0xec>)
 8006068:	2200      	movs	r2, #0
 800606a:	615a      	str	r2, [r3, #20]
  if (HAL_TIM_Base_Init(&htim21) != HAL_OK)
 800606c:	4b24      	ldr	r3, [pc, #144]	; (8006100 <MX_TIM21_Init+0xec>)
 800606e:	0018      	movs	r0, r3
 8006070:	f005 fbbc 	bl	800b7ec <HAL_TIM_Base_Init>
 8006074:	1e03      	subs	r3, r0, #0
 8006076:	d001      	beq.n	800607c <MX_TIM21_Init+0x68>
  {
    Error_Handler();
 8006078:	f000 f908 	bl	800628c <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800607c:	2118      	movs	r1, #24
 800607e:	187b      	adds	r3, r7, r1
 8006080:	2280      	movs	r2, #128	; 0x80
 8006082:	0152      	lsls	r2, r2, #5
 8006084:	601a      	str	r2, [r3, #0]
  if (HAL_TIM_ConfigClockSource(&htim21, &sClockSourceConfig) != HAL_OK)
 8006086:	187a      	adds	r2, r7, r1
 8006088:	4b1d      	ldr	r3, [pc, #116]	; (8006100 <MX_TIM21_Init+0xec>)
 800608a:	0011      	movs	r1, r2
 800608c:	0018      	movs	r0, r3
 800608e:	f005 ffbd 	bl	800c00c <HAL_TIM_ConfigClockSource>
 8006092:	1e03      	subs	r3, r0, #0
 8006094:	d001      	beq.n	800609a <MX_TIM21_Init+0x86>
  {
    Error_Handler();
 8006096:	f000 f8f9 	bl	800628c <Error_Handler>
  }
  if (HAL_TIM_OC_Init(&htim21) != HAL_OK)
 800609a:	4b19      	ldr	r3, [pc, #100]	; (8006100 <MX_TIM21_Init+0xec>)
 800609c:	0018      	movs	r0, r3
 800609e:	f005 fcf3 	bl	800ba88 <HAL_TIM_OC_Init>
 80060a2:	1e03      	subs	r3, r0, #0
 80060a4:	d001      	beq.n	80060aa <MX_TIM21_Init+0x96>
  {
    Error_Handler();
 80060a6:	f000 f8f1 	bl	800628c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80060aa:	2110      	movs	r1, #16
 80060ac:	187b      	adds	r3, r7, r1
 80060ae:	2200      	movs	r2, #0
 80060b0:	601a      	str	r2, [r3, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80060b2:	187b      	adds	r3, r7, r1
 80060b4:	2200      	movs	r2, #0
 80060b6:	605a      	str	r2, [r3, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim21, &sMasterConfig) != HAL_OK)
 80060b8:	187a      	adds	r2, r7, r1
 80060ba:	4b11      	ldr	r3, [pc, #68]	; (8006100 <MX_TIM21_Init+0xec>)
 80060bc:	0011      	movs	r1, r2
 80060be:	0018      	movs	r0, r3
 80060c0:	f006 fcb2 	bl	800ca28 <HAL_TIMEx_MasterConfigSynchronization>
 80060c4:	1e03      	subs	r3, r0, #0
 80060c6:	d001      	beq.n	80060cc <MX_TIM21_Init+0xb8>
  {
    Error_Handler();
 80060c8:	f000 f8e0 	bl	800628c <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
 80060cc:	003b      	movs	r3, r7
 80060ce:	2200      	movs	r2, #0
 80060d0:	601a      	str	r2, [r3, #0]
  sConfigOC.Pulse = 0;
 80060d2:	003b      	movs	r3, r7
 80060d4:	2200      	movs	r2, #0
 80060d6:	605a      	str	r2, [r3, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80060d8:	003b      	movs	r3, r7
 80060da:	2200      	movs	r2, #0
 80060dc:	609a      	str	r2, [r3, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80060de:	003b      	movs	r3, r7
 80060e0:	2200      	movs	r2, #0
 80060e2:	60da      	str	r2, [r3, #12]
  if (HAL_TIM_OC_ConfigChannel(&htim21, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80060e4:	0039      	movs	r1, r7
 80060e6:	4b06      	ldr	r3, [pc, #24]	; (8006100 <MX_TIM21_Init+0xec>)
 80060e8:	2200      	movs	r2, #0
 80060ea:	0018      	movs	r0, r3
 80060ec:	f005 fe8e 	bl	800be0c <HAL_TIM_OC_ConfigChannel>
 80060f0:	1e03      	subs	r3, r0, #0
 80060f2:	d001      	beq.n	80060f8 <MX_TIM21_Init+0xe4>
  {
    Error_Handler();
 80060f4:	f000 f8ca 	bl	800628c <Error_Handler>
  }
  /* USER CODE BEGIN TIM21_Init 2 */

  /* USER CODE END TIM21_Init 2 */

}
 80060f8:	46c0      	nop			; (mov r8, r8)
 80060fa:	46bd      	mov	sp, r7
 80060fc:	b00a      	add	sp, #40	; 0x28
 80060fe:	bd80      	pop	{r7, pc}
 8006100:	200002e4 	.word	0x200002e4
 8006104:	40010800 	.word	0x40010800
 8006108:	000003e7 	.word	0x000003e7
 800610c:	0000fffe 	.word	0x0000fffe

08006110 <MX_USART2_UART_Init>:
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{
 8006110:	b580      	push	{r7, lr}
 8006112:	af00      	add	r7, sp, #0
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 8006114:	4b14      	ldr	r3, [pc, #80]	; (8006168 <MX_USART2_UART_Init+0x58>)
 8006116:	4a15      	ldr	r2, [pc, #84]	; (800616c <MX_USART2_UART_Init+0x5c>)
 8006118:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 800611a:	4b13      	ldr	r3, [pc, #76]	; (8006168 <MX_USART2_UART_Init+0x58>)
 800611c:	22e1      	movs	r2, #225	; 0xe1
 800611e:	0252      	lsls	r2, r2, #9
 8006120:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8006122:	4b11      	ldr	r3, [pc, #68]	; (8006168 <MX_USART2_UART_Init+0x58>)
 8006124:	2200      	movs	r2, #0
 8006126:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8006128:	4b0f      	ldr	r3, [pc, #60]	; (8006168 <MX_USART2_UART_Init+0x58>)
 800612a:	2200      	movs	r2, #0
 800612c:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 800612e:	4b0e      	ldr	r3, [pc, #56]	; (8006168 <MX_USART2_UART_Init+0x58>)
 8006130:	2200      	movs	r2, #0
 8006132:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8006134:	4b0c      	ldr	r3, [pc, #48]	; (8006168 <MX_USART2_UART_Init+0x58>)
 8006136:	220c      	movs	r2, #12
 8006138:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800613a:	4b0b      	ldr	r3, [pc, #44]	; (8006168 <MX_USART2_UART_Init+0x58>)
 800613c:	2200      	movs	r2, #0
 800613e:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8006140:	4b09      	ldr	r3, [pc, #36]	; (8006168 <MX_USART2_UART_Init+0x58>)
 8006142:	2200      	movs	r2, #0
 8006144:	61da      	str	r2, [r3, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8006146:	4b08      	ldr	r3, [pc, #32]	; (8006168 <MX_USART2_UART_Init+0x58>)
 8006148:	2200      	movs	r2, #0
 800614a:	621a      	str	r2, [r3, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800614c:	4b06      	ldr	r3, [pc, #24]	; (8006168 <MX_USART2_UART_Init+0x58>)
 800614e:	2200      	movs	r2, #0
 8006150:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8006152:	4b05      	ldr	r3, [pc, #20]	; (8006168 <MX_USART2_UART_Init+0x58>)
 8006154:	0018      	movs	r0, r3
 8006156:	f006 fd21 	bl	800cb9c <HAL_UART_Init>
 800615a:	1e03      	subs	r3, r0, #0
 800615c:	d001      	beq.n	8006162 <MX_USART2_UART_Init+0x52>
  {
    Error_Handler();
 800615e:	f000 f895 	bl	800628c <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 8006162:	46c0      	nop			; (mov r8, r8)
 8006164:	46bd      	mov	sp, r7
 8006166:	bd80      	pop	{r7, pc}
 8006168:	20000204 	.word	0x20000204
 800616c:	40004400 	.word	0x40004400

08006170 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8006170:	b590      	push	{r4, r7, lr}
 8006172:	b089      	sub	sp, #36	; 0x24
 8006174:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006176:	240c      	movs	r4, #12
 8006178:	193b      	adds	r3, r7, r4
 800617a:	0018      	movs	r0, r3
 800617c:	2314      	movs	r3, #20
 800617e:	001a      	movs	r2, r3
 8006180:	2100      	movs	r1, #0
 8006182:	f007 fc58 	bl	800da36 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8006186:	4b3c      	ldr	r3, [pc, #240]	; (8006278 <MX_GPIO_Init+0x108>)
 8006188:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800618a:	4b3b      	ldr	r3, [pc, #236]	; (8006278 <MX_GPIO_Init+0x108>)
 800618c:	2104      	movs	r1, #4
 800618e:	430a      	orrs	r2, r1
 8006190:	62da      	str	r2, [r3, #44]	; 0x2c
 8006192:	4b39      	ldr	r3, [pc, #228]	; (8006278 <MX_GPIO_Init+0x108>)
 8006194:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006196:	2204      	movs	r2, #4
 8006198:	4013      	ands	r3, r2
 800619a:	60bb      	str	r3, [r7, #8]
 800619c:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800619e:	4b36      	ldr	r3, [pc, #216]	; (8006278 <MX_GPIO_Init+0x108>)
 80061a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80061a2:	4b35      	ldr	r3, [pc, #212]	; (8006278 <MX_GPIO_Init+0x108>)
 80061a4:	2101      	movs	r1, #1
 80061a6:	430a      	orrs	r2, r1
 80061a8:	62da      	str	r2, [r3, #44]	; 0x2c
 80061aa:	4b33      	ldr	r3, [pc, #204]	; (8006278 <MX_GPIO_Init+0x108>)
 80061ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80061ae:	2201      	movs	r2, #1
 80061b0:	4013      	ands	r3, r2
 80061b2:	607b      	str	r3, [r7, #4]
 80061b4:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80061b6:	4b30      	ldr	r3, [pc, #192]	; (8006278 <MX_GPIO_Init+0x108>)
 80061b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80061ba:	4b2f      	ldr	r3, [pc, #188]	; (8006278 <MX_GPIO_Init+0x108>)
 80061bc:	2102      	movs	r1, #2
 80061be:	430a      	orrs	r2, r1
 80061c0:	62da      	str	r2, [r3, #44]	; 0x2c
 80061c2:	4b2d      	ldr	r3, [pc, #180]	; (8006278 <MX_GPIO_Init+0x108>)
 80061c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80061c6:	2202      	movs	r2, #2
 80061c8:	4013      	ands	r3, r2
 80061ca:	603b      	str	r3, [r7, #0]
 80061cc:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(RST_GPIO_Port, RST_Pin, GPIO_PIN_RESET);
 80061ce:	4b2b      	ldr	r3, [pc, #172]	; (800627c <MX_GPIO_Init+0x10c>)
 80061d0:	2200      	movs	r2, #0
 80061d2:	2101      	movs	r1, #1
 80061d4:	0018      	movs	r0, r3
 80061d6:	f002 fbd1 	bl	800897c <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, LED_Pin|NSS_Pin, GPIO_PIN_RESET);
 80061da:	4929      	ldr	r1, [pc, #164]	; (8006280 <MX_GPIO_Init+0x110>)
 80061dc:	23a0      	movs	r3, #160	; 0xa0
 80061de:	05db      	lsls	r3, r3, #23
 80061e0:	2200      	movs	r2, #0
 80061e2:	0018      	movs	r0, r3
 80061e4:	f002 fbca 	bl	800897c <HAL_GPIO_WritePin>

  /*Configure GPIO pin : RST_Pin */
  GPIO_InitStruct.Pin = RST_Pin;
 80061e8:	193b      	adds	r3, r7, r4
 80061ea:	2201      	movs	r2, #1
 80061ec:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80061ee:	193b      	adds	r3, r7, r4
 80061f0:	2201      	movs	r2, #1
 80061f2:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80061f4:	193b      	adds	r3, r7, r4
 80061f6:	2200      	movs	r2, #0
 80061f8:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80061fa:	193b      	adds	r3, r7, r4
 80061fc:	2200      	movs	r2, #0
 80061fe:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(RST_GPIO_Port, &GPIO_InitStruct);
 8006200:	193b      	adds	r3, r7, r4
 8006202:	4a1e      	ldr	r2, [pc, #120]	; (800627c <MX_GPIO_Init+0x10c>)
 8006204:	0019      	movs	r1, r3
 8006206:	0010      	movs	r0, r2
 8006208:	f002 f928 	bl	800845c <HAL_GPIO_Init>

  /*Configure GPIO pins : LED_Pin NSS_Pin */
  GPIO_InitStruct.Pin = LED_Pin|NSS_Pin;
 800620c:	193b      	adds	r3, r7, r4
 800620e:	4a1c      	ldr	r2, [pc, #112]	; (8006280 <MX_GPIO_Init+0x110>)
 8006210:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006212:	193b      	adds	r3, r7, r4
 8006214:	2201      	movs	r2, #1
 8006216:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006218:	193b      	adds	r3, r7, r4
 800621a:	2200      	movs	r2, #0
 800621c:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800621e:	193b      	adds	r3, r7, r4
 8006220:	2200      	movs	r2, #0
 8006222:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006224:	193a      	adds	r2, r7, r4
 8006226:	23a0      	movs	r3, #160	; 0xa0
 8006228:	05db      	lsls	r3, r3, #23
 800622a:	0011      	movs	r1, r2
 800622c:	0018      	movs	r0, r3
 800622e:	f002 f915 	bl	800845c <HAL_GPIO_Init>

  /*Configure GPIO pins : DIO2_Pin DIO1_Pin DIO0_Pin */
  GPIO_InitStruct.Pin = DIO2_Pin|DIO1_Pin|DIO0_Pin;
 8006232:	193b      	adds	r3, r7, r4
 8006234:	2213      	movs	r2, #19
 8006236:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8006238:	193b      	adds	r3, r7, r4
 800623a:	4a12      	ldr	r2, [pc, #72]	; (8006284 <MX_GPIO_Init+0x114>)
 800623c:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800623e:	193b      	adds	r3, r7, r4
 8006240:	2200      	movs	r2, #0
 8006242:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006244:	193b      	adds	r3, r7, r4
 8006246:	4a10      	ldr	r2, [pc, #64]	; (8006288 <MX_GPIO_Init+0x118>)
 8006248:	0019      	movs	r1, r3
 800624a:	0010      	movs	r0, r2
 800624c:	f002 f906 	bl	800845c <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_1_IRQn, 0, 0);
 8006250:	2200      	movs	r2, #0
 8006252:	2100      	movs	r1, #0
 8006254:	2005      	movs	r0, #5
 8006256:	f002 f8b7 	bl	80083c8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);
 800625a:	2005      	movs	r0, #5
 800625c:	f002 f8d4 	bl	8008408 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);
 8006260:	2200      	movs	r2, #0
 8006262:	2100      	movs	r1, #0
 8006264:	2007      	movs	r0, #7
 8006266:	f002 f8af 	bl	80083c8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
 800626a:	2007      	movs	r0, #7
 800626c:	f002 f8cc 	bl	8008408 <HAL_NVIC_EnableIRQ>

}
 8006270:	46c0      	nop			; (mov r8, r8)
 8006272:	46bd      	mov	sp, r7
 8006274:	b009      	add	sp, #36	; 0x24
 8006276:	bd90      	pop	{r4, r7, pc}
 8006278:	40021000 	.word	0x40021000
 800627c:	50000800 	.word	0x50000800
 8006280:	00008020 	.word	0x00008020
 8006284:	10110000 	.word	0x10110000
 8006288:	50000400 	.word	0x50000400

0800628c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800628c:	b580      	push	{r7, lr}
 800628e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 8006290:	46c0      	nop			; (mov r8, r8)
 8006292:	46bd      	mov	sp, r7
 8006294:	bd80      	pop	{r7, pc}

08006296 <assert_failed>:
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
 8006296:	b580      	push	{r7, lr}
 8006298:	b082      	sub	sp, #8
 800629a:	af00      	add	r7, sp, #0
 800629c:	6078      	str	r0, [r7, #4]
 800629e:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
 80062a0:	46c0      	nop			; (mov r8, r8)
 80062a2:	46bd      	mov	sp, r7
 80062a4:	b002      	add	sp, #8
 80062a6:	bd80      	pop	{r7, pc}

080062a8 <os_init>:
static struct {
    osjob_t* scheduledjobs;
    osjob_t* runnablejobs;
} OS;

void os_init () {
 80062a8:	b580      	push	{r7, lr}
 80062aa:	af00      	add	r7, sp, #0
    memset(&OS, 0x00, sizeof(OS));
 80062ac:	4b07      	ldr	r3, [pc, #28]	; (80062cc <os_init+0x24>)
 80062ae:	2208      	movs	r2, #8
 80062b0:	2100      	movs	r1, #0
 80062b2:	0018      	movs	r0, r3
 80062b4:	f007 fbbf 	bl	800da36 <memset>
    hal_init();
 80062b8:	f7fb ffb0 	bl	800221c <hal_init>
    radio_init();
 80062bc:	f000 fd26 	bl	8006d0c <radio_init>
    LMIC_init();
 80062c0:	f7ff fa9a 	bl	80057f8 <LMIC_init>
}
 80062c4:	46c0      	nop			; (mov r8, r8)
 80062c6:	46bd      	mov	sp, r7
 80062c8:	bd80      	pop	{r7, pc}
 80062ca:	46c0      	nop			; (mov r8, r8)
 80062cc:	20000088 	.word	0x20000088

080062d0 <os_getTime>:

ostime_t os_getTime () {
 80062d0:	b580      	push	{r7, lr}
 80062d2:	af00      	add	r7, sp, #0
    return hal_ticks();
 80062d4:	f7fb fec0 	bl	8002058 <hal_ticks>
 80062d8:	0003      	movs	r3, r0
}
 80062da:	0018      	movs	r0, r3
 80062dc:	46bd      	mov	sp, r7
 80062de:	bd80      	pop	{r7, pc}

080062e0 <unlinkjob>:

// unlink job from queue, return if removed
static int unlinkjob (osjob_t** pnext, osjob_t* job) {
 80062e0:	b580      	push	{r7, lr}
 80062e2:	b082      	sub	sp, #8
 80062e4:	af00      	add	r7, sp, #0
 80062e6:	6078      	str	r0, [r7, #4]
 80062e8:	6039      	str	r1, [r7, #0]
    for( ; *pnext; pnext = &((*pnext)->next)) {
 80062ea:	e00d      	b.n	8006308 <unlinkjob+0x28>
        if(*pnext == job) { // unlink
 80062ec:	687b      	ldr	r3, [r7, #4]
 80062ee:	681b      	ldr	r3, [r3, #0]
 80062f0:	683a      	ldr	r2, [r7, #0]
 80062f2:	429a      	cmp	r2, r3
 80062f4:	d105      	bne.n	8006302 <unlinkjob+0x22>
            *pnext = job->next;
 80062f6:	683b      	ldr	r3, [r7, #0]
 80062f8:	681a      	ldr	r2, [r3, #0]
 80062fa:	687b      	ldr	r3, [r7, #4]
 80062fc:	601a      	str	r2, [r3, #0]
            return 1;
 80062fe:	2301      	movs	r3, #1
 8006300:	e007      	b.n	8006312 <unlinkjob+0x32>
    for( ; *pnext; pnext = &((*pnext)->next)) {
 8006302:	687b      	ldr	r3, [r7, #4]
 8006304:	681b      	ldr	r3, [r3, #0]
 8006306:	607b      	str	r3, [r7, #4]
 8006308:	687b      	ldr	r3, [r7, #4]
 800630a:	681b      	ldr	r3, [r3, #0]
 800630c:	2b00      	cmp	r3, #0
 800630e:	d1ed      	bne.n	80062ec <unlinkjob+0xc>
        }
    }
    return 0;
 8006310:	2300      	movs	r3, #0
}
 8006312:	0018      	movs	r0, r3
 8006314:	46bd      	mov	sp, r7
 8006316:	b002      	add	sp, #8
 8006318:	bd80      	pop	{r7, pc}
	...

0800631c <os_clearCallback>:

// clear scheduled job
void os_clearCallback (osjob_t* job) {
 800631c:	b580      	push	{r7, lr}
 800631e:	b082      	sub	sp, #8
 8006320:	af00      	add	r7, sp, #0
 8006322:	6078      	str	r0, [r7, #4]
    hal_disableIRQs();
 8006324:	f7fb ff54 	bl	80021d0 <hal_disableIRQs>
    unlinkjob(&OS.scheduledjobs, job) || unlinkjob(&OS.runnablejobs, job);
 8006328:	687a      	ldr	r2, [r7, #4]
 800632a:	4b0a      	ldr	r3, [pc, #40]	; (8006354 <os_clearCallback+0x38>)
 800632c:	0011      	movs	r1, r2
 800632e:	0018      	movs	r0, r3
 8006330:	f7ff ffd6 	bl	80062e0 <unlinkjob>
 8006334:	1e03      	subs	r3, r0, #0
 8006336:	d105      	bne.n	8006344 <os_clearCallback+0x28>
 8006338:	687a      	ldr	r2, [r7, #4]
 800633a:	4b07      	ldr	r3, [pc, #28]	; (8006358 <os_clearCallback+0x3c>)
 800633c:	0011      	movs	r1, r2
 800633e:	0018      	movs	r0, r3
 8006340:	f7ff ffce 	bl	80062e0 <unlinkjob>
 8006344:	46c0      	nop			; (mov r8, r8)
    hal_enableIRQs();
 8006346:	f7fb ff51 	bl	80021ec <hal_enableIRQs>
}
 800634a:	46c0      	nop			; (mov r8, r8)
 800634c:	46bd      	mov	sp, r7
 800634e:	b002      	add	sp, #8
 8006350:	bd80      	pop	{r7, pc}
 8006352:	46c0      	nop			; (mov r8, r8)
 8006354:	20000088 	.word	0x20000088
 8006358:	2000008c 	.word	0x2000008c

0800635c <os_setCallback>:

// schedule immediately runnable job
void os_setCallback (osjob_t* job, osjobcb_t cb) {
 800635c:	b580      	push	{r7, lr}
 800635e:	b084      	sub	sp, #16
 8006360:	af00      	add	r7, sp, #0
 8006362:	6078      	str	r0, [r7, #4]
 8006364:	6039      	str	r1, [r7, #0]
    osjob_t** pnext;
    hal_disableIRQs();
 8006366:	f7fb ff33 	bl	80021d0 <hal_disableIRQs>
    // remove if job was already queued
    unlinkjob(&OS.runnablejobs, job);
 800636a:	687a      	ldr	r2, [r7, #4]
 800636c:	4b0e      	ldr	r3, [pc, #56]	; (80063a8 <os_setCallback+0x4c>)
 800636e:	0011      	movs	r1, r2
 8006370:	0018      	movs	r0, r3
 8006372:	f7ff ffb5 	bl	80062e0 <unlinkjob>
    // fill-in job
    job->func = cb;
 8006376:	687b      	ldr	r3, [r7, #4]
 8006378:	683a      	ldr	r2, [r7, #0]
 800637a:	609a      	str	r2, [r3, #8]
    job->next = NULL;
 800637c:	687b      	ldr	r3, [r7, #4]
 800637e:	2200      	movs	r2, #0
 8006380:	601a      	str	r2, [r3, #0]
    // add to end of run queue
    for(pnext=&OS.runnablejobs; *pnext; pnext=&((*pnext)->next));
 8006382:	4b09      	ldr	r3, [pc, #36]	; (80063a8 <os_setCallback+0x4c>)
 8006384:	60fb      	str	r3, [r7, #12]
 8006386:	e002      	b.n	800638e <os_setCallback+0x32>
 8006388:	68fb      	ldr	r3, [r7, #12]
 800638a:	681b      	ldr	r3, [r3, #0]
 800638c:	60fb      	str	r3, [r7, #12]
 800638e:	68fb      	ldr	r3, [r7, #12]
 8006390:	681b      	ldr	r3, [r3, #0]
 8006392:	2b00      	cmp	r3, #0
 8006394:	d1f8      	bne.n	8006388 <os_setCallback+0x2c>
    *pnext = job;
 8006396:	68fb      	ldr	r3, [r7, #12]
 8006398:	687a      	ldr	r2, [r7, #4]
 800639a:	601a      	str	r2, [r3, #0]
    hal_enableIRQs();
 800639c:	f7fb ff26 	bl	80021ec <hal_enableIRQs>
}
 80063a0:	46c0      	nop			; (mov r8, r8)
 80063a2:	46bd      	mov	sp, r7
 80063a4:	b004      	add	sp, #16
 80063a6:	bd80      	pop	{r7, pc}
 80063a8:	2000008c 	.word	0x2000008c

080063ac <os_setTimedCallback>:

// schedule timed job
void os_setTimedCallback (osjob_t* job, ostime_t time, osjobcb_t cb) {
 80063ac:	b580      	push	{r7, lr}
 80063ae:	b086      	sub	sp, #24
 80063b0:	af00      	add	r7, sp, #0
 80063b2:	60f8      	str	r0, [r7, #12]
 80063b4:	60b9      	str	r1, [r7, #8]
 80063b6:	607a      	str	r2, [r7, #4]
    osjob_t** pnext;
    hal_disableIRQs();
 80063b8:	f7fb ff0a 	bl	80021d0 <hal_disableIRQs>
    // remove if job was already queued
    unlinkjob(&OS.scheduledjobs, job);
 80063bc:	68fa      	ldr	r2, [r7, #12]
 80063be:	4b16      	ldr	r3, [pc, #88]	; (8006418 <os_setTimedCallback+0x6c>)
 80063c0:	0011      	movs	r1, r2
 80063c2:	0018      	movs	r0, r3
 80063c4:	f7ff ff8c 	bl	80062e0 <unlinkjob>
    // fill-in job
    job->deadline = time;
 80063c8:	68fb      	ldr	r3, [r7, #12]
 80063ca:	68ba      	ldr	r2, [r7, #8]
 80063cc:	605a      	str	r2, [r3, #4]
    job->func = cb;
 80063ce:	68fb      	ldr	r3, [r7, #12]
 80063d0:	687a      	ldr	r2, [r7, #4]
 80063d2:	609a      	str	r2, [r3, #8]
    job->next = NULL;
 80063d4:	68fb      	ldr	r3, [r7, #12]
 80063d6:	2200      	movs	r2, #0
 80063d8:	601a      	str	r2, [r3, #0]
    // insert into schedule
    for(pnext=&OS.scheduledjobs; *pnext; pnext=&((*pnext)->next)) {
 80063da:	4b0f      	ldr	r3, [pc, #60]	; (8006418 <os_setTimedCallback+0x6c>)
 80063dc:	617b      	str	r3, [r7, #20]
 80063de:	e00e      	b.n	80063fe <os_setTimedCallback+0x52>
        if((*pnext)->deadline - time > 0) { // (cmp diff, not abs!)
 80063e0:	697b      	ldr	r3, [r7, #20]
 80063e2:	681b      	ldr	r3, [r3, #0]
 80063e4:	685a      	ldr	r2, [r3, #4]
 80063e6:	68bb      	ldr	r3, [r7, #8]
 80063e8:	1ad3      	subs	r3, r2, r3
 80063ea:	2b00      	cmp	r3, #0
 80063ec:	dd04      	ble.n	80063f8 <os_setTimedCallback+0x4c>
            // enqueue before next element and stop
            job->next = *pnext;
 80063ee:	697b      	ldr	r3, [r7, #20]
 80063f0:	681a      	ldr	r2, [r3, #0]
 80063f2:	68fb      	ldr	r3, [r7, #12]
 80063f4:	601a      	str	r2, [r3, #0]
            break;
 80063f6:	e006      	b.n	8006406 <os_setTimedCallback+0x5a>
    for(pnext=&OS.scheduledjobs; *pnext; pnext=&((*pnext)->next)) {
 80063f8:	697b      	ldr	r3, [r7, #20]
 80063fa:	681b      	ldr	r3, [r3, #0]
 80063fc:	617b      	str	r3, [r7, #20]
 80063fe:	697b      	ldr	r3, [r7, #20]
 8006400:	681b      	ldr	r3, [r3, #0]
 8006402:	2b00      	cmp	r3, #0
 8006404:	d1ec      	bne.n	80063e0 <os_setTimedCallback+0x34>
        }
    }
    *pnext = job;
 8006406:	697b      	ldr	r3, [r7, #20]
 8006408:	68fa      	ldr	r2, [r7, #12]
 800640a:	601a      	str	r2, [r3, #0]
    hal_enableIRQs();
 800640c:	f7fb feee 	bl	80021ec <hal_enableIRQs>
}
 8006410:	46c0      	nop			; (mov r8, r8)
 8006412:	46bd      	mov	sp, r7
 8006414:	b006      	add	sp, #24
 8006416:	bd80      	pop	{r7, pc}
 8006418:	20000088 	.word	0x20000088

0800641c <os_runloop>:

// execute jobs from timer and from run queue
void os_runloop () {
 800641c:	b580      	push	{r7, lr}
 800641e:	b082      	sub	sp, #8
 8006420:	af00      	add	r7, sp, #0
    while(1) {
        osjob_t* j = NULL;
 8006422:	2300      	movs	r3, #0
 8006424:	607b      	str	r3, [r7, #4]
        hal_disableIRQs();
 8006426:	f7fb fed3 	bl	80021d0 <hal_disableIRQs>
        // check for runnable jobs
        if(OS.runnablejobs) {
 800642a:	4b16      	ldr	r3, [pc, #88]	; (8006484 <os_runloop+0x68>)
 800642c:	685b      	ldr	r3, [r3, #4]
 800642e:	2b00      	cmp	r3, #0
 8006430:	d007      	beq.n	8006442 <os_runloop+0x26>
            j = OS.runnablejobs;
 8006432:	4b14      	ldr	r3, [pc, #80]	; (8006484 <os_runloop+0x68>)
 8006434:	685b      	ldr	r3, [r3, #4]
 8006436:	607b      	str	r3, [r7, #4]
            OS.runnablejobs = j->next;
 8006438:	687b      	ldr	r3, [r7, #4]
 800643a:	681a      	ldr	r2, [r3, #0]
 800643c:	4b11      	ldr	r3, [pc, #68]	; (8006484 <os_runloop+0x68>)
 800643e:	605a      	str	r2, [r3, #4]
 8006440:	e015      	b.n	800646e <os_runloop+0x52>
        } else if(OS.scheduledjobs && hal_checkTimer(OS.scheduledjobs->deadline)) { // check for expired timed jobs
 8006442:	4b10      	ldr	r3, [pc, #64]	; (8006484 <os_runloop+0x68>)
 8006444:	681b      	ldr	r3, [r3, #0]
 8006446:	2b00      	cmp	r3, #0
 8006448:	d00f      	beq.n	800646a <os_runloop+0x4e>
 800644a:	4b0e      	ldr	r3, [pc, #56]	; (8006484 <os_runloop+0x68>)
 800644c:	681b      	ldr	r3, [r3, #0]
 800644e:	685b      	ldr	r3, [r3, #4]
 8006450:	0018      	movs	r0, r3
 8006452:	f7fb fe61 	bl	8002118 <hal_checkTimer>
 8006456:	1e03      	subs	r3, r0, #0
 8006458:	d007      	beq.n	800646a <os_runloop+0x4e>
            j = OS.scheduledjobs;
 800645a:	4b0a      	ldr	r3, [pc, #40]	; (8006484 <os_runloop+0x68>)
 800645c:	681b      	ldr	r3, [r3, #0]
 800645e:	607b      	str	r3, [r7, #4]
            OS.scheduledjobs = j->next;
 8006460:	687b      	ldr	r3, [r7, #4]
 8006462:	681a      	ldr	r2, [r3, #0]
 8006464:	4b07      	ldr	r3, [pc, #28]	; (8006484 <os_runloop+0x68>)
 8006466:	601a      	str	r2, [r3, #0]
 8006468:	e001      	b.n	800646e <os_runloop+0x52>
        } else { // nothing pending
            hal_sleep(); // wake by irq (timer already restarted)
 800646a:	f7fb fed1 	bl	8002210 <hal_sleep>
        }
        hal_enableIRQs();
 800646e:	f7fb febd 	bl	80021ec <hal_enableIRQs>
        if(j) { // run job callback
 8006472:	687b      	ldr	r3, [r7, #4]
 8006474:	2b00      	cmp	r3, #0
 8006476:	d0d4      	beq.n	8006422 <os_runloop+0x6>
            j->func(j);
 8006478:	687b      	ldr	r3, [r7, #4]
 800647a:	689b      	ldr	r3, [r3, #8]
 800647c:	687a      	ldr	r2, [r7, #4]
 800647e:	0010      	movs	r0, r2
 8006480:	4798      	blx	r3
    while(1) {
 8006482:	e7ce      	b.n	8006422 <os_runloop+0x6>
 8006484:	20000088 	.word	0x20000088

08006488 <writeReg>:
#else
#error Missing CFG_sx1272_radio/CFG_sx1276_radio
#endif


static void writeReg (u1_t addr, u1_t data ) {
 8006488:	b580      	push	{r7, lr}
 800648a:	b082      	sub	sp, #8
 800648c:	af00      	add	r7, sp, #0
 800648e:	0002      	movs	r2, r0
 8006490:	1dfb      	adds	r3, r7, #7
 8006492:	701a      	strb	r2, [r3, #0]
 8006494:	1dbb      	adds	r3, r7, #6
 8006496:	1c0a      	adds	r2, r1, #0
 8006498:	701a      	strb	r2, [r3, #0]
    hal_pin_nss(0);
 800649a:	2000      	movs	r0, #0
 800649c:	f7fb fd39 	bl	8001f12 <hal_pin_nss>
    hal_spi(addr | 0x80);
 80064a0:	1dfb      	adds	r3, r7, #7
 80064a2:	781b      	ldrb	r3, [r3, #0]
 80064a4:	2280      	movs	r2, #128	; 0x80
 80064a6:	4252      	negs	r2, r2
 80064a8:	4313      	orrs	r3, r2
 80064aa:	b2db      	uxtb	r3, r3
 80064ac:	0018      	movs	r0, r3
 80064ae:	f7fb fda5 	bl	8001ffc <hal_spi>
    hal_spi(data);
 80064b2:	1dbb      	adds	r3, r7, #6
 80064b4:	781b      	ldrb	r3, [r3, #0]
 80064b6:	0018      	movs	r0, r3
 80064b8:	f7fb fda0 	bl	8001ffc <hal_spi>
    hal_pin_nss(1);
 80064bc:	2001      	movs	r0, #1
 80064be:	f7fb fd28 	bl	8001f12 <hal_pin_nss>
}
 80064c2:	46c0      	nop			; (mov r8, r8)
 80064c4:	46bd      	mov	sp, r7
 80064c6:	b002      	add	sp, #8
 80064c8:	bd80      	pop	{r7, pc}

080064ca <readReg>:

static u1_t readReg (u1_t addr) {
 80064ca:	b5b0      	push	{r4, r5, r7, lr}
 80064cc:	b084      	sub	sp, #16
 80064ce:	af00      	add	r7, sp, #0
 80064d0:	0002      	movs	r2, r0
 80064d2:	1dfb      	adds	r3, r7, #7
 80064d4:	701a      	strb	r2, [r3, #0]
    hal_pin_nss(0);
 80064d6:	2000      	movs	r0, #0
 80064d8:	f7fb fd1b 	bl	8001f12 <hal_pin_nss>
    hal_spi(addr & 0x7F);
 80064dc:	1dfb      	adds	r3, r7, #7
 80064de:	781b      	ldrb	r3, [r3, #0]
 80064e0:	227f      	movs	r2, #127	; 0x7f
 80064e2:	4013      	ands	r3, r2
 80064e4:	b2db      	uxtb	r3, r3
 80064e6:	0018      	movs	r0, r3
 80064e8:	f7fb fd88 	bl	8001ffc <hal_spi>
    u1_t val = hal_spi(0x00);
 80064ec:	250f      	movs	r5, #15
 80064ee:	197c      	adds	r4, r7, r5
 80064f0:	2000      	movs	r0, #0
 80064f2:	f7fb fd83 	bl	8001ffc <hal_spi>
 80064f6:	0003      	movs	r3, r0
 80064f8:	7023      	strb	r3, [r4, #0]
    hal_pin_nss(1);
 80064fa:	2001      	movs	r0, #1
 80064fc:	f7fb fd09 	bl	8001f12 <hal_pin_nss>
    return val;
 8006500:	197b      	adds	r3, r7, r5
 8006502:	781b      	ldrb	r3, [r3, #0]
}
 8006504:	0018      	movs	r0, r3
 8006506:	46bd      	mov	sp, r7
 8006508:	b004      	add	sp, #16
 800650a:	bdb0      	pop	{r4, r5, r7, pc}

0800650c <writeBuf>:

static void writeBuf (u1_t addr, xref2u1_t buf, u1_t len) {
 800650c:	b590      	push	{r4, r7, lr}
 800650e:	b085      	sub	sp, #20
 8006510:	af00      	add	r7, sp, #0
 8006512:	6039      	str	r1, [r7, #0]
 8006514:	0011      	movs	r1, r2
 8006516:	1dfb      	adds	r3, r7, #7
 8006518:	1c02      	adds	r2, r0, #0
 800651a:	701a      	strb	r2, [r3, #0]
 800651c:	1dbb      	adds	r3, r7, #6
 800651e:	1c0a      	adds	r2, r1, #0
 8006520:	701a      	strb	r2, [r3, #0]
    hal_pin_nss(0);
 8006522:	2000      	movs	r0, #0
 8006524:	f7fb fcf5 	bl	8001f12 <hal_pin_nss>
    hal_spi(addr | 0x80);
 8006528:	1dfb      	adds	r3, r7, #7
 800652a:	781b      	ldrb	r3, [r3, #0]
 800652c:	2280      	movs	r2, #128	; 0x80
 800652e:	4252      	negs	r2, r2
 8006530:	4313      	orrs	r3, r2
 8006532:	b2db      	uxtb	r3, r3
 8006534:	0018      	movs	r0, r3
 8006536:	f7fb fd61 	bl	8001ffc <hal_spi>
    for (u1_t i=0; i<len; i++) {
 800653a:	230f      	movs	r3, #15
 800653c:	18fb      	adds	r3, r7, r3
 800653e:	2200      	movs	r2, #0
 8006540:	701a      	strb	r2, [r3, #0]
 8006542:	e00d      	b.n	8006560 <writeBuf+0x54>
        hal_spi(buf[i]);
 8006544:	240f      	movs	r4, #15
 8006546:	193b      	adds	r3, r7, r4
 8006548:	781b      	ldrb	r3, [r3, #0]
 800654a:	683a      	ldr	r2, [r7, #0]
 800654c:	18d3      	adds	r3, r2, r3
 800654e:	781b      	ldrb	r3, [r3, #0]
 8006550:	0018      	movs	r0, r3
 8006552:	f7fb fd53 	bl	8001ffc <hal_spi>
    for (u1_t i=0; i<len; i++) {
 8006556:	193b      	adds	r3, r7, r4
 8006558:	781a      	ldrb	r2, [r3, #0]
 800655a:	193b      	adds	r3, r7, r4
 800655c:	3201      	adds	r2, #1
 800655e:	701a      	strb	r2, [r3, #0]
 8006560:	230f      	movs	r3, #15
 8006562:	18fa      	adds	r2, r7, r3
 8006564:	1dbb      	adds	r3, r7, #6
 8006566:	7812      	ldrb	r2, [r2, #0]
 8006568:	781b      	ldrb	r3, [r3, #0]
 800656a:	429a      	cmp	r2, r3
 800656c:	d3ea      	bcc.n	8006544 <writeBuf+0x38>
    }
    hal_pin_nss(1);
 800656e:	2001      	movs	r0, #1
 8006570:	f7fb fccf 	bl	8001f12 <hal_pin_nss>
}
 8006574:	46c0      	nop			; (mov r8, r8)
 8006576:	46bd      	mov	sp, r7
 8006578:	b005      	add	sp, #20
 800657a:	bd90      	pop	{r4, r7, pc}

0800657c <readBuf>:

static void readBuf (u1_t addr, xref2u1_t buf, u1_t len) {
 800657c:	b5b0      	push	{r4, r5, r7, lr}
 800657e:	b084      	sub	sp, #16
 8006580:	af00      	add	r7, sp, #0
 8006582:	6039      	str	r1, [r7, #0]
 8006584:	0011      	movs	r1, r2
 8006586:	1dfb      	adds	r3, r7, #7
 8006588:	1c02      	adds	r2, r0, #0
 800658a:	701a      	strb	r2, [r3, #0]
 800658c:	1dbb      	adds	r3, r7, #6
 800658e:	1c0a      	adds	r2, r1, #0
 8006590:	701a      	strb	r2, [r3, #0]
    hal_pin_nss(0);
 8006592:	2000      	movs	r0, #0
 8006594:	f7fb fcbd 	bl	8001f12 <hal_pin_nss>
    hal_spi(addr & 0x7F);
 8006598:	1dfb      	adds	r3, r7, #7
 800659a:	781b      	ldrb	r3, [r3, #0]
 800659c:	227f      	movs	r2, #127	; 0x7f
 800659e:	4013      	ands	r3, r2
 80065a0:	b2db      	uxtb	r3, r3
 80065a2:	0018      	movs	r0, r3
 80065a4:	f7fb fd2a 	bl	8001ffc <hal_spi>
    for (u1_t i=0; i<len; i++) {
 80065a8:	230f      	movs	r3, #15
 80065aa:	18fb      	adds	r3, r7, r3
 80065ac:	2200      	movs	r2, #0
 80065ae:	701a      	strb	r2, [r3, #0]
 80065b0:	e00e      	b.n	80065d0 <readBuf+0x54>
        buf[i] = hal_spi(0x00);
 80065b2:	250f      	movs	r5, #15
 80065b4:	197b      	adds	r3, r7, r5
 80065b6:	781b      	ldrb	r3, [r3, #0]
 80065b8:	683a      	ldr	r2, [r7, #0]
 80065ba:	18d4      	adds	r4, r2, r3
 80065bc:	2000      	movs	r0, #0
 80065be:	f7fb fd1d 	bl	8001ffc <hal_spi>
 80065c2:	0003      	movs	r3, r0
 80065c4:	7023      	strb	r3, [r4, #0]
    for (u1_t i=0; i<len; i++) {
 80065c6:	197b      	adds	r3, r7, r5
 80065c8:	781a      	ldrb	r2, [r3, #0]
 80065ca:	197b      	adds	r3, r7, r5
 80065cc:	3201      	adds	r2, #1
 80065ce:	701a      	strb	r2, [r3, #0]
 80065d0:	230f      	movs	r3, #15
 80065d2:	18fa      	adds	r2, r7, r3
 80065d4:	1dbb      	adds	r3, r7, #6
 80065d6:	7812      	ldrb	r2, [r2, #0]
 80065d8:	781b      	ldrb	r3, [r3, #0]
 80065da:	429a      	cmp	r2, r3
 80065dc:	d3e9      	bcc.n	80065b2 <readBuf+0x36>
    }
    hal_pin_nss(1);
 80065de:	2001      	movs	r0, #1
 80065e0:	f7fb fc97 	bl	8001f12 <hal_pin_nss>
}
 80065e4:	46c0      	nop			; (mov r8, r8)
 80065e6:	46bd      	mov	sp, r7
 80065e8:	b004      	add	sp, #16
 80065ea:	bdb0      	pop	{r4, r5, r7, pc}

080065ec <opmode>:

static void opmode (u1_t mode) {
 80065ec:	b580      	push	{r7, lr}
 80065ee:	b082      	sub	sp, #8
 80065f0:	af00      	add	r7, sp, #0
 80065f2:	0002      	movs	r2, r0
 80065f4:	1dfb      	adds	r3, r7, #7
 80065f6:	701a      	strb	r2, [r3, #0]
    writeReg(RegOpMode, (readReg(RegOpMode) & ~OPMODE_MASK) | mode);
 80065f8:	2001      	movs	r0, #1
 80065fa:	f7ff ff66 	bl	80064ca <readReg>
 80065fe:	0003      	movs	r3, r0
 8006600:	b25b      	sxtb	r3, r3
 8006602:	2207      	movs	r2, #7
 8006604:	4393      	bics	r3, r2
 8006606:	b25a      	sxtb	r2, r3
 8006608:	1dfb      	adds	r3, r7, #7
 800660a:	781b      	ldrb	r3, [r3, #0]
 800660c:	b25b      	sxtb	r3, r3
 800660e:	4313      	orrs	r3, r2
 8006610:	b25b      	sxtb	r3, r3
 8006612:	b2db      	uxtb	r3, r3
 8006614:	0019      	movs	r1, r3
 8006616:	2001      	movs	r0, #1
 8006618:	f7ff ff36 	bl	8006488 <writeReg>
}
 800661c:	46c0      	nop			; (mov r8, r8)
 800661e:	46bd      	mov	sp, r7
 8006620:	b002      	add	sp, #8
 8006622:	bd80      	pop	{r7, pc}

08006624 <opmodeLora>:

static void opmodeLora() {
 8006624:	b580      	push	{r7, lr}
 8006626:	b082      	sub	sp, #8
 8006628:	af00      	add	r7, sp, #0
    u1_t u = OPMODE_LORA;
 800662a:	1dfb      	adds	r3, r7, #7
 800662c:	2280      	movs	r2, #128	; 0x80
 800662e:	701a      	strb	r2, [r3, #0]
#ifdef CFG_sx1276_radio
    u |= 0x8;   // TBD: sx1276 high freq
 8006630:	1dfb      	adds	r3, r7, #7
 8006632:	1dfa      	adds	r2, r7, #7
 8006634:	7812      	ldrb	r2, [r2, #0]
 8006636:	2108      	movs	r1, #8
 8006638:	430a      	orrs	r2, r1
 800663a:	701a      	strb	r2, [r3, #0]
#endif
    writeReg(RegOpMode, u);
 800663c:	1dfb      	adds	r3, r7, #7
 800663e:	781b      	ldrb	r3, [r3, #0]
 8006640:	0019      	movs	r1, r3
 8006642:	2001      	movs	r0, #1
 8006644:	f7ff ff20 	bl	8006488 <writeReg>
}
 8006648:	46c0      	nop			; (mov r8, r8)
 800664a:	46bd      	mov	sp, r7
 800664c:	b002      	add	sp, #8
 800664e:	bd80      	pop	{r7, pc}

08006650 <opmodeFSK>:

static void opmodeFSK() {
 8006650:	b580      	push	{r7, lr}
 8006652:	b082      	sub	sp, #8
 8006654:	af00      	add	r7, sp, #0
    u1_t u = 0;
 8006656:	1dfb      	adds	r3, r7, #7
 8006658:	2200      	movs	r2, #0
 800665a:	701a      	strb	r2, [r3, #0]
#ifdef CFG_sx1276_radio
    u |= 0x8;   // TBD: sx1276 high freq
 800665c:	1dfb      	adds	r3, r7, #7
 800665e:	1dfa      	adds	r2, r7, #7
 8006660:	7812      	ldrb	r2, [r2, #0]
 8006662:	2108      	movs	r1, #8
 8006664:	430a      	orrs	r2, r1
 8006666:	701a      	strb	r2, [r3, #0]
#endif
    writeReg(RegOpMode, u);
 8006668:	1dfb      	adds	r3, r7, #7
 800666a:	781b      	ldrb	r3, [r3, #0]
 800666c:	0019      	movs	r1, r3
 800666e:	2001      	movs	r0, #1
 8006670:	f7ff ff0a 	bl	8006488 <writeReg>
}
 8006674:	46c0      	nop			; (mov r8, r8)
 8006676:	46bd      	mov	sp, r7
 8006678:	b002      	add	sp, #8
 800667a:	bd80      	pop	{r7, pc}

0800667c <configLoraModem>:

// configure LoRa modem (cfg1, cfg2)
static void configLoraModem () {
 800667c:	b590      	push	{r4, r7, lr}
 800667e:	b083      	sub	sp, #12
 8006680:	af00      	add	r7, sp, #0
    sf_t sf = getSf(LMIC.rps);
 8006682:	4b61      	ldr	r3, [pc, #388]	; (8006808 <configLoraModem+0x18c>)
 8006684:	89db      	ldrh	r3, [r3, #14]
 8006686:	1d3c      	adds	r4, r7, #4
 8006688:	0018      	movs	r0, r3
 800668a:	f7fb fde6 	bl	800225a <getSf>
 800668e:	0003      	movs	r3, r0
 8006690:	7023      	strb	r3, [r4, #0]

#ifdef CFG_sx1276_radio
        u1_t mc1 = 0, mc2 = 0, mc3 = 0;
 8006692:	1dfb      	adds	r3, r7, #7
 8006694:	2200      	movs	r2, #0
 8006696:	701a      	strb	r2, [r3, #0]
 8006698:	1dbb      	adds	r3, r7, #6
 800669a:	2200      	movs	r2, #0
 800669c:	701a      	strb	r2, [r3, #0]
 800669e:	1d7b      	adds	r3, r7, #5
 80066a0:	2200      	movs	r2, #0
 80066a2:	701a      	strb	r2, [r3, #0]

        switch (getBw(LMIC.rps)) {
 80066a4:	4b58      	ldr	r3, [pc, #352]	; (8006808 <configLoraModem+0x18c>)
 80066a6:	89db      	ldrh	r3, [r3, #14]
 80066a8:	0018      	movs	r0, r3
 80066aa:	f7fb fde6 	bl	800227a <getBw>
 80066ae:	0003      	movs	r3, r0
 80066b0:	2b02      	cmp	r3, #2
 80066b2:	d014      	beq.n	80066de <configLoraModem+0x62>
 80066b4:	dc1b      	bgt.n	80066ee <configLoraModem+0x72>
 80066b6:	2b00      	cmp	r3, #0
 80066b8:	d002      	beq.n	80066c0 <configLoraModem+0x44>
 80066ba:	2b01      	cmp	r3, #1
 80066bc:	d007      	beq.n	80066ce <configLoraModem+0x52>
 80066be:	e016      	b.n	80066ee <configLoraModem+0x72>
        case BW125: mc1 |= SX1276_MC1_BW_125; break;
 80066c0:	1dfb      	adds	r3, r7, #7
 80066c2:	1dfa      	adds	r2, r7, #7
 80066c4:	7812      	ldrb	r2, [r2, #0]
 80066c6:	2170      	movs	r1, #112	; 0x70
 80066c8:	430a      	orrs	r2, r1
 80066ca:	701a      	strb	r2, [r3, #0]
 80066cc:	e011      	b.n	80066f2 <configLoraModem+0x76>
        case BW250: mc1 |= SX1276_MC1_BW_250; break;
 80066ce:	1dfb      	adds	r3, r7, #7
 80066d0:	1dfa      	adds	r2, r7, #7
 80066d2:	7812      	ldrb	r2, [r2, #0]
 80066d4:	2180      	movs	r1, #128	; 0x80
 80066d6:	4249      	negs	r1, r1
 80066d8:	430a      	orrs	r2, r1
 80066da:	701a      	strb	r2, [r3, #0]
 80066dc:	e009      	b.n	80066f2 <configLoraModem+0x76>
        case BW500: mc1 |= SX1276_MC1_BW_500; break;
 80066de:	1dfb      	adds	r3, r7, #7
 80066e0:	1dfa      	adds	r2, r7, #7
 80066e2:	7812      	ldrb	r2, [r2, #0]
 80066e4:	2170      	movs	r1, #112	; 0x70
 80066e6:	4249      	negs	r1, r1
 80066e8:	430a      	orrs	r2, r1
 80066ea:	701a      	strb	r2, [r3, #0]
 80066ec:	e001      	b.n	80066f2 <configLoraModem+0x76>
        default:
            ASSERT(0);
 80066ee:	f7fb fdad 	bl	800224c <hal_failed>
        }
        switch( getCr(LMIC.rps) ) {
 80066f2:	4b45      	ldr	r3, [pc, #276]	; (8006808 <configLoraModem+0x18c>)
 80066f4:	89db      	ldrh	r3, [r3, #14]
 80066f6:	0018      	movs	r0, r3
 80066f8:	f7fb fdd1 	bl	800229e <getCr>
 80066fc:	0003      	movs	r3, r0
 80066fe:	2b03      	cmp	r3, #3
 8006700:	d01d      	beq.n	800673e <configLoraModem+0xc2>
 8006702:	dc23      	bgt.n	800674c <configLoraModem+0xd0>
 8006704:	2b02      	cmp	r3, #2
 8006706:	d013      	beq.n	8006730 <configLoraModem+0xb4>
 8006708:	dc20      	bgt.n	800674c <configLoraModem+0xd0>
 800670a:	2b00      	cmp	r3, #0
 800670c:	d002      	beq.n	8006714 <configLoraModem+0x98>
 800670e:	2b01      	cmp	r3, #1
 8006710:	d007      	beq.n	8006722 <configLoraModem+0xa6>
 8006712:	e01b      	b.n	800674c <configLoraModem+0xd0>
        case CR_4_5: mc1 |= SX1276_MC1_CR_4_5; break;
 8006714:	1dfb      	adds	r3, r7, #7
 8006716:	1dfa      	adds	r2, r7, #7
 8006718:	7812      	ldrb	r2, [r2, #0]
 800671a:	2102      	movs	r1, #2
 800671c:	430a      	orrs	r2, r1
 800671e:	701a      	strb	r2, [r3, #0]
 8006720:	e016      	b.n	8006750 <configLoraModem+0xd4>
        case CR_4_6: mc1 |= SX1276_MC1_CR_4_6; break;
 8006722:	1dfb      	adds	r3, r7, #7
 8006724:	1dfa      	adds	r2, r7, #7
 8006726:	7812      	ldrb	r2, [r2, #0]
 8006728:	2104      	movs	r1, #4
 800672a:	430a      	orrs	r2, r1
 800672c:	701a      	strb	r2, [r3, #0]
 800672e:	e00f      	b.n	8006750 <configLoraModem+0xd4>
        case CR_4_7: mc1 |= SX1276_MC1_CR_4_7; break;
 8006730:	1dfb      	adds	r3, r7, #7
 8006732:	1dfa      	adds	r2, r7, #7
 8006734:	7812      	ldrb	r2, [r2, #0]
 8006736:	2106      	movs	r1, #6
 8006738:	430a      	orrs	r2, r1
 800673a:	701a      	strb	r2, [r3, #0]
 800673c:	e008      	b.n	8006750 <configLoraModem+0xd4>
        case CR_4_8: mc1 |= SX1276_MC1_CR_4_8; break;
 800673e:	1dfb      	adds	r3, r7, #7
 8006740:	1dfa      	adds	r2, r7, #7
 8006742:	7812      	ldrb	r2, [r2, #0]
 8006744:	2108      	movs	r1, #8
 8006746:	430a      	orrs	r2, r1
 8006748:	701a      	strb	r2, [r3, #0]
 800674a:	e001      	b.n	8006750 <configLoraModem+0xd4>
        default:
            ASSERT(0);
 800674c:	f7fb fd7e 	bl	800224c <hal_failed>
        }

        if (getIh(LMIC.rps)) {
 8006750:	4b2d      	ldr	r3, [pc, #180]	; (8006808 <configLoraModem+0x18c>)
 8006752:	89db      	ldrh	r3, [r3, #14]
 8006754:	0018      	movs	r0, r3
 8006756:	f7fb fdf6 	bl	8002346 <getIh>
 800675a:	1e03      	subs	r3, r0, #0
 800675c:	d010      	beq.n	8006780 <configLoraModem+0x104>
            mc1 |= SX1276_MC1_IMPLICIT_HEADER_MODE_ON;
 800675e:	1dfb      	adds	r3, r7, #7
 8006760:	1dfa      	adds	r2, r7, #7
 8006762:	7812      	ldrb	r2, [r2, #0]
 8006764:	2101      	movs	r1, #1
 8006766:	430a      	orrs	r2, r1
 8006768:	701a      	strb	r2, [r3, #0]
            writeReg(LORARegPayloadLength, getIh(LMIC.rps)); // required length
 800676a:	4b27      	ldr	r3, [pc, #156]	; (8006808 <configLoraModem+0x18c>)
 800676c:	89db      	ldrh	r3, [r3, #14]
 800676e:	0018      	movs	r0, r3
 8006770:	f7fb fde9 	bl	8002346 <getIh>
 8006774:	0003      	movs	r3, r0
 8006776:	b2db      	uxtb	r3, r3
 8006778:	0019      	movs	r1, r3
 800677a:	2022      	movs	r0, #34	; 0x22
 800677c:	f7ff fe84 	bl	8006488 <writeReg>
        }
        // set ModemConfig1
        writeReg(LORARegModemConfig1, mc1);
 8006780:	1dfb      	adds	r3, r7, #7
 8006782:	781b      	ldrb	r3, [r3, #0]
 8006784:	0019      	movs	r1, r3
 8006786:	201d      	movs	r0, #29
 8006788:	f7ff fe7e 	bl	8006488 <writeReg>

        mc2 = (SX1272_MC2_SF7 + ((sf-1)<<4));
 800678c:	1d3b      	adds	r3, r7, #4
 800678e:	781b      	ldrb	r3, [r3, #0]
 8006790:	3b01      	subs	r3, #1
 8006792:	b2db      	uxtb	r3, r3
 8006794:	011b      	lsls	r3, r3, #4
 8006796:	b2da      	uxtb	r2, r3
 8006798:	1dbb      	adds	r3, r7, #6
 800679a:	3270      	adds	r2, #112	; 0x70
 800679c:	701a      	strb	r2, [r3, #0]
        if (getNocrc(LMIC.rps) == 0) {
 800679e:	4b1a      	ldr	r3, [pc, #104]	; (8006808 <configLoraModem+0x18c>)
 80067a0:	89db      	ldrh	r3, [r3, #14]
 80067a2:	0018      	movs	r0, r3
 80067a4:	f7fb fda7 	bl	80022f6 <getNocrc>
 80067a8:	1e03      	subs	r3, r0, #0
 80067aa:	d105      	bne.n	80067b8 <configLoraModem+0x13c>
            mc2 |= SX1276_MC2_RX_PAYLOAD_CRCON;
 80067ac:	1dbb      	adds	r3, r7, #6
 80067ae:	1dba      	adds	r2, r7, #6
 80067b0:	7812      	ldrb	r2, [r2, #0]
 80067b2:	2104      	movs	r1, #4
 80067b4:	430a      	orrs	r2, r1
 80067b6:	701a      	strb	r2, [r3, #0]
        }
        writeReg(LORARegModemConfig2, mc2);
 80067b8:	1dbb      	adds	r3, r7, #6
 80067ba:	781b      	ldrb	r3, [r3, #0]
 80067bc:	0019      	movs	r1, r3
 80067be:	201e      	movs	r0, #30
 80067c0:	f7ff fe62 	bl	8006488 <writeReg>
        
        mc3 = SX1276_MC3_AGCAUTO;
 80067c4:	1d7b      	adds	r3, r7, #5
 80067c6:	2204      	movs	r2, #4
 80067c8:	701a      	strb	r2, [r3, #0]
        if ((sf == SF11 || sf == SF12) && getBw(LMIC.rps) == BW125) {
 80067ca:	1d3b      	adds	r3, r7, #4
 80067cc:	781b      	ldrb	r3, [r3, #0]
 80067ce:	2b05      	cmp	r3, #5
 80067d0:	d003      	beq.n	80067da <configLoraModem+0x15e>
 80067d2:	1d3b      	adds	r3, r7, #4
 80067d4:	781b      	ldrb	r3, [r3, #0]
 80067d6:	2b06      	cmp	r3, #6
 80067d8:	d10c      	bne.n	80067f4 <configLoraModem+0x178>
 80067da:	4b0b      	ldr	r3, [pc, #44]	; (8006808 <configLoraModem+0x18c>)
 80067dc:	89db      	ldrh	r3, [r3, #14]
 80067de:	0018      	movs	r0, r3
 80067e0:	f7fb fd4b 	bl	800227a <getBw>
 80067e4:	1e03      	subs	r3, r0, #0
 80067e6:	d105      	bne.n	80067f4 <configLoraModem+0x178>
            mc3 |= SX1276_MC3_LOW_DATA_RATE_OPTIMIZE;
 80067e8:	1d7b      	adds	r3, r7, #5
 80067ea:	1d7a      	adds	r2, r7, #5
 80067ec:	7812      	ldrb	r2, [r2, #0]
 80067ee:	2108      	movs	r1, #8
 80067f0:	430a      	orrs	r2, r1
 80067f2:	701a      	strb	r2, [r3, #0]
        }
        writeReg(LORARegModemConfig3, mc3);
 80067f4:	1d7b      	adds	r3, r7, #5
 80067f6:	781b      	ldrb	r3, [r3, #0]
 80067f8:	0019      	movs	r1, r3
 80067fa:	2026      	movs	r0, #38	; 0x26
 80067fc:	f7ff fe44 	bl	8006488 <writeReg>
#endif

#else
#error Missing CFG_sx1272_radio/CFG_sx1276_radio
#endif /* CFG_sx1272_radio */
}
 8006800:	46c0      	nop			; (mov r8, r8)
 8006802:	46bd      	mov	sp, r7
 8006804:	b003      	add	sp, #12
 8006806:	bd90      	pop	{r4, r7, pc}
 8006808:	20000324 	.word	0x20000324

0800680c <configChannel>:

static void configChannel () {
 800680c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800680e:	b085      	sub	sp, #20
 8006810:	af00      	add	r7, sp, #0
    // set frequency: FQ = (FRF * 32 Mhz) / (2 ^ 19)
    u8_t frf = ((u8_t)LMIC.freq << 19) / 32000000;
 8006812:	4e1b      	ldr	r6, [pc, #108]	; (8006880 <configChannel+0x74>)
 8006814:	68b6      	ldr	r6, [r6, #8]
 8006816:	0032      	movs	r2, r6
 8006818:	2600      	movs	r6, #0
 800681a:	0033      	movs	r3, r6
 800681c:	0b51      	lsrs	r1, r2, #13
 800681e:	04d0      	lsls	r0, r2, #19
 8006820:	4a18      	ldr	r2, [pc, #96]	; (8006884 <configChannel+0x78>)
 8006822:	2300      	movs	r3, #0
 8006824:	f7f9 fe0a 	bl	800043c <__aeabi_uldivmod>
 8006828:	0002      	movs	r2, r0
 800682a:	000b      	movs	r3, r1
 800682c:	60ba      	str	r2, [r7, #8]
 800682e:	60fb      	str	r3, [r7, #12]
    writeReg(RegFrfMsb, (u1_t)(frf>>16));
 8006830:	68fb      	ldr	r3, [r7, #12]
 8006832:	041b      	lsls	r3, r3, #16
 8006834:	68ba      	ldr	r2, [r7, #8]
 8006836:	0c12      	lsrs	r2, r2, #16
 8006838:	603a      	str	r2, [r7, #0]
 800683a:	683a      	ldr	r2, [r7, #0]
 800683c:	431a      	orrs	r2, r3
 800683e:	603a      	str	r2, [r7, #0]
 8006840:	68fb      	ldr	r3, [r7, #12]
 8006842:	0c1b      	lsrs	r3, r3, #16
 8006844:	607b      	str	r3, [r7, #4]
 8006846:	783b      	ldrb	r3, [r7, #0]
 8006848:	0019      	movs	r1, r3
 800684a:	2006      	movs	r0, #6
 800684c:	f7ff fe1c 	bl	8006488 <writeReg>
    writeReg(RegFrfMid, (u1_t)(frf>> 8));
 8006850:	68fb      	ldr	r3, [r7, #12]
 8006852:	061b      	lsls	r3, r3, #24
 8006854:	68ba      	ldr	r2, [r7, #8]
 8006856:	0a14      	lsrs	r4, r2, #8
 8006858:	431c      	orrs	r4, r3
 800685a:	68fb      	ldr	r3, [r7, #12]
 800685c:	0a1d      	lsrs	r5, r3, #8
 800685e:	b2e3      	uxtb	r3, r4
 8006860:	0019      	movs	r1, r3
 8006862:	2007      	movs	r0, #7
 8006864:	f7ff fe10 	bl	8006488 <writeReg>
    writeReg(RegFrfLsb, (u1_t)(frf>> 0));
 8006868:	68ba      	ldr	r2, [r7, #8]
 800686a:	68fb      	ldr	r3, [r7, #12]
 800686c:	1c13      	adds	r3, r2, #0
 800686e:	b2db      	uxtb	r3, r3
 8006870:	0019      	movs	r1, r3
 8006872:	2008      	movs	r0, #8
 8006874:	f7ff fe08 	bl	8006488 <writeReg>
}
 8006878:	46c0      	nop			; (mov r8, r8)
 800687a:	46bd      	mov	sp, r7
 800687c:	b005      	add	sp, #20
 800687e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006880:	20000324 	.word	0x20000324
 8006884:	01e84800 	.word	0x01e84800

08006888 <configPower>:



static void configPower () {
 8006888:	b580      	push	{r7, lr}
 800688a:	b082      	sub	sp, #8
 800688c:	af00      	add	r7, sp, #0
#ifdef CFG_sx1276_radio
    // no boost used for now
    s1_t pw = (s1_t)LMIC.txpow;
 800688e:	1dfb      	adds	r3, r7, #7
 8006890:	4a18      	ldr	r2, [pc, #96]	; (80068f4 <configPower+0x6c>)
 8006892:	7c92      	ldrb	r2, [r2, #18]
 8006894:	701a      	strb	r2, [r3, #0]
    if(pw >= 17) {
 8006896:	1dfb      	adds	r3, r7, #7
 8006898:	781b      	ldrb	r3, [r3, #0]
 800689a:	b25b      	sxtb	r3, r3
 800689c:	2b10      	cmp	r3, #16
 800689e:	dd03      	ble.n	80068a8 <configPower+0x20>
        pw = 15;
 80068a0:	1dfb      	adds	r3, r7, #7
 80068a2:	220f      	movs	r2, #15
 80068a4:	701a      	strb	r2, [r3, #0]
 80068a6:	e007      	b.n	80068b8 <configPower+0x30>
    } else if(pw < 2) {
 80068a8:	1dfb      	adds	r3, r7, #7
 80068aa:	781b      	ldrb	r3, [r3, #0]
 80068ac:	b25b      	sxtb	r3, r3
 80068ae:	2b01      	cmp	r3, #1
 80068b0:	dc02      	bgt.n	80068b8 <configPower+0x30>
        pw = 2;
 80068b2:	1dfb      	adds	r3, r7, #7
 80068b4:	2202      	movs	r2, #2
 80068b6:	701a      	strb	r2, [r3, #0]
    }
    // check board type for BOOST pin
    writeReg(RegPaConfig, (u1_t)(0x80|(pw&0xf)));
 80068b8:	1dfb      	adds	r3, r7, #7
 80068ba:	781b      	ldrb	r3, [r3, #0]
 80068bc:	220f      	movs	r2, #15
 80068be:	4013      	ands	r3, r2
 80068c0:	b25b      	sxtb	r3, r3
 80068c2:	2280      	movs	r2, #128	; 0x80
 80068c4:	4252      	negs	r2, r2
 80068c6:	4313      	orrs	r3, r2
 80068c8:	b25b      	sxtb	r3, r3
 80068ca:	b2db      	uxtb	r3, r3
 80068cc:	0019      	movs	r1, r3
 80068ce:	2009      	movs	r0, #9
 80068d0:	f7ff fdda 	bl	8006488 <writeReg>
    writeReg(RegPaDac, readReg(RegPaDac)|0x4);
 80068d4:	205a      	movs	r0, #90	; 0x5a
 80068d6:	f7ff fdf8 	bl	80064ca <readReg>
 80068da:	0003      	movs	r3, r0
 80068dc:	001a      	movs	r2, r3
 80068de:	2304      	movs	r3, #4
 80068e0:	4313      	orrs	r3, r2
 80068e2:	b2db      	uxtb	r3, r3
 80068e4:	0019      	movs	r1, r3
 80068e6:	205a      	movs	r0, #90	; 0x5a
 80068e8:	f7ff fdce 	bl	8006488 <writeReg>
    }
    writeReg(RegPaConfig, (u1_t)(0x80|(pw-2)));
#else
#error Missing CFG_sx1272_radio/CFG_sx1276_radio
#endif /* CFG_sx1272_radio */
}
 80068ec:	46c0      	nop			; (mov r8, r8)
 80068ee:	46bd      	mov	sp, r7
 80068f0:	b002      	add	sp, #8
 80068f2:	bd80      	pop	{r7, pc}
 80068f4:	20000324 	.word	0x20000324

080068f8 <txfsk>:

static void txfsk () {
 80068f8:	b580      	push	{r7, lr}
 80068fa:	af00      	add	r7, sp, #0
    // select FSK modem (from sleep mode)
    writeReg(RegOpMode, 0x10); // FSK, BT=0.5
 80068fc:	2110      	movs	r1, #16
 80068fe:	2001      	movs	r0, #1
 8006900:	f7ff fdc2 	bl	8006488 <writeReg>
    ASSERT(readReg(RegOpMode) == 0x10);
 8006904:	2001      	movs	r0, #1
 8006906:	f7ff fde0 	bl	80064ca <readReg>
 800690a:	0003      	movs	r3, r0
 800690c:	2b10      	cmp	r3, #16
 800690e:	d001      	beq.n	8006914 <txfsk+0x1c>
 8006910:	f7fb fc9c 	bl	800224c <hal_failed>
    // enter standby mode (required for FIFO loading))
    opmode(OPMODE_STANDBY);
 8006914:	2001      	movs	r0, #1
 8006916:	f7ff fe69 	bl	80065ec <opmode>
    // set bitrate
    writeReg(FSKRegBitrateMsb, 0x02); // 50kbps
 800691a:	2102      	movs	r1, #2
 800691c:	2002      	movs	r0, #2
 800691e:	f7ff fdb3 	bl	8006488 <writeReg>
    writeReg(FSKRegBitrateLsb, 0x80);
 8006922:	2180      	movs	r1, #128	; 0x80
 8006924:	2003      	movs	r0, #3
 8006926:	f7ff fdaf 	bl	8006488 <writeReg>
    // set frequency deviation
    writeReg(FSKRegFdevMsb, 0x01); // +/- 25kHz
 800692a:	2101      	movs	r1, #1
 800692c:	2004      	movs	r0, #4
 800692e:	f7ff fdab 	bl	8006488 <writeReg>
    writeReg(FSKRegFdevLsb, 0x99);
 8006932:	2199      	movs	r1, #153	; 0x99
 8006934:	2005      	movs	r0, #5
 8006936:	f7ff fda7 	bl	8006488 <writeReg>
    // frame and packet handler settings
    writeReg(FSKRegPreambleMsb, 0x00);
 800693a:	2100      	movs	r1, #0
 800693c:	2025      	movs	r0, #37	; 0x25
 800693e:	f7ff fda3 	bl	8006488 <writeReg>
    writeReg(FSKRegPreambleLsb, 0x05);
 8006942:	2105      	movs	r1, #5
 8006944:	2026      	movs	r0, #38	; 0x26
 8006946:	f7ff fd9f 	bl	8006488 <writeReg>
    writeReg(FSKRegSyncConfig, 0x12);
 800694a:	2112      	movs	r1, #18
 800694c:	2027      	movs	r0, #39	; 0x27
 800694e:	f7ff fd9b 	bl	8006488 <writeReg>
    writeReg(FSKRegPacketConfig1, 0xD0);
 8006952:	21d0      	movs	r1, #208	; 0xd0
 8006954:	2030      	movs	r0, #48	; 0x30
 8006956:	f7ff fd97 	bl	8006488 <writeReg>
    writeReg(FSKRegPacketConfig2, 0x40);
 800695a:	2140      	movs	r1, #64	; 0x40
 800695c:	2031      	movs	r0, #49	; 0x31
 800695e:	f7ff fd93 	bl	8006488 <writeReg>
    writeReg(FSKRegSyncValue1, 0xC1);
 8006962:	21c1      	movs	r1, #193	; 0xc1
 8006964:	2028      	movs	r0, #40	; 0x28
 8006966:	f7ff fd8f 	bl	8006488 <writeReg>
    writeReg(FSKRegSyncValue2, 0x94);
 800696a:	2194      	movs	r1, #148	; 0x94
 800696c:	2029      	movs	r0, #41	; 0x29
 800696e:	f7ff fd8b 	bl	8006488 <writeReg>
    writeReg(FSKRegSyncValue3, 0xC1);
 8006972:	21c1      	movs	r1, #193	; 0xc1
 8006974:	202a      	movs	r0, #42	; 0x2a
 8006976:	f7ff fd87 	bl	8006488 <writeReg>
    // configure frequency
    configChannel();
 800697a:	f7ff ff47 	bl	800680c <configChannel>
    // configure output power
    configPower();
 800697e:	f7ff ff83 	bl	8006888 <configPower>

    // set the IRQ mapping DIO0=PacketSent DIO1=NOP DIO2=NOP
    writeReg(RegDioMapping1, MAP_DIO0_FSK_READY|MAP_DIO1_FSK_NOP|MAP_DIO2_FSK_TXNOP);
 8006982:	2134      	movs	r1, #52	; 0x34
 8006984:	2040      	movs	r0, #64	; 0x40
 8006986:	f7ff fd7f 	bl	8006488 <writeReg>

    // initialize the payload size and address pointers    
    writeReg(FSKRegPayloadLength, LMIC.dataLen+1); // (insert length byte into payload))
 800698a:	4a12      	ldr	r2, [pc, #72]	; (80069d4 <txfsk+0xdc>)
 800698c:	2348      	movs	r3, #72	; 0x48
 800698e:	33ff      	adds	r3, #255	; 0xff
 8006990:	5cd3      	ldrb	r3, [r2, r3]
 8006992:	3301      	adds	r3, #1
 8006994:	b2db      	uxtb	r3, r3
 8006996:	0019      	movs	r1, r3
 8006998:	2032      	movs	r0, #50	; 0x32
 800699a:	f7ff fd75 	bl	8006488 <writeReg>

    // download length byte and buffer to the radio FIFO
    writeReg(RegFifo, LMIC.dataLen);
 800699e:	4a0d      	ldr	r2, [pc, #52]	; (80069d4 <txfsk+0xdc>)
 80069a0:	2348      	movs	r3, #72	; 0x48
 80069a2:	33ff      	adds	r3, #255	; 0xff
 80069a4:	5cd3      	ldrb	r3, [r2, r3]
 80069a6:	0019      	movs	r1, r3
 80069a8:	2000      	movs	r0, #0
 80069aa:	f7ff fd6d 	bl	8006488 <writeReg>
    writeBuf(RegFifo, LMIC.frame, LMIC.dataLen);
 80069ae:	4a09      	ldr	r2, [pc, #36]	; (80069d4 <txfsk+0xdc>)
 80069b0:	2348      	movs	r3, #72	; 0x48
 80069b2:	33ff      	adds	r3, #255	; 0xff
 80069b4:	5cd2      	ldrb	r2, [r2, r3]
 80069b6:	4b08      	ldr	r3, [pc, #32]	; (80069d8 <txfsk+0xe0>)
 80069b8:	0019      	movs	r1, r3
 80069ba:	2000      	movs	r0, #0
 80069bc:	f7ff fda6 	bl	800650c <writeBuf>

    // enable antenna switch for TX
    hal_pin_rxtx(1);
 80069c0:	2001      	movs	r0, #1
 80069c2:	f7fb fa9c 	bl	8001efe <hal_pin_rxtx>
    
    // now we actually start the transmission
    opmode(OPMODE_TX);
 80069c6:	2003      	movs	r0, #3
 80069c8:	f7ff fe10 	bl	80065ec <opmode>
}
 80069cc:	46c0      	nop			; (mov r8, r8)
 80069ce:	46bd      	mov	sp, r7
 80069d0:	bd80      	pop	{r7, pc}
 80069d2:	46c0      	nop			; (mov r8, r8)
 80069d4:	20000324 	.word	0x20000324
 80069d8:	2000046c 	.word	0x2000046c

080069dc <txlora>:

static void txlora () {
 80069dc:	b580      	push	{r7, lr}
 80069de:	af00      	add	r7, sp, #0
    // select LoRa modem (from sleep mode)
    //writeReg(RegOpMode, OPMODE_LORA);
    opmodeLora();
 80069e0:	f7ff fe20 	bl	8006624 <opmodeLora>
    ASSERT((readReg(RegOpMode) & OPMODE_LORA) != 0);
 80069e4:	2001      	movs	r0, #1
 80069e6:	f7ff fd70 	bl	80064ca <readReg>
 80069ea:	0003      	movs	r3, r0
 80069ec:	b25b      	sxtb	r3, r3
 80069ee:	2b00      	cmp	r3, #0
 80069f0:	db01      	blt.n	80069f6 <txlora+0x1a>
 80069f2:	f7fb fc2b 	bl	800224c <hal_failed>

    // enter standby mode (required for FIFO loading))
    opmode(OPMODE_STANDBY);
 80069f6:	2001      	movs	r0, #1
 80069f8:	f7ff fdf8 	bl	80065ec <opmode>
    // configure LoRa modem (cfg1, cfg2)
    configLoraModem();
 80069fc:	f7ff fe3e 	bl	800667c <configLoraModem>
    // configure frequency
    configChannel();
 8006a00:	f7ff ff04 	bl	800680c <configChannel>
    // configure output power
    writeReg(RegPaRamp, (readReg(RegPaRamp) & 0xF0) | 0x08); // set PA ramp-up time 50 uSec
 8006a04:	200a      	movs	r0, #10
 8006a06:	f7ff fd60 	bl	80064ca <readReg>
 8006a0a:	0003      	movs	r3, r0
 8006a0c:	b25b      	sxtb	r3, r3
 8006a0e:	220f      	movs	r2, #15
 8006a10:	4393      	bics	r3, r2
 8006a12:	b25b      	sxtb	r3, r3
 8006a14:	2208      	movs	r2, #8
 8006a16:	4313      	orrs	r3, r2
 8006a18:	b25b      	sxtb	r3, r3
 8006a1a:	b2db      	uxtb	r3, r3
 8006a1c:	0019      	movs	r1, r3
 8006a1e:	200a      	movs	r0, #10
 8006a20:	f7ff fd32 	bl	8006488 <writeReg>
    configPower();
 8006a24:	f7ff ff30 	bl	8006888 <configPower>
    // set sync word
    writeReg(LORARegSyncWord, LORA_MAC_PREAMBLE);
 8006a28:	2134      	movs	r1, #52	; 0x34
 8006a2a:	2039      	movs	r0, #57	; 0x39
 8006a2c:	f7ff fd2c 	bl	8006488 <writeReg>
    
    // set the IRQ mapping DIO0=TxDone DIO1=NOP DIO2=NOP
    writeReg(RegDioMapping1, MAP_DIO0_LORA_TXDONE|MAP_DIO1_LORA_NOP|MAP_DIO2_LORA_NOP);
 8006a30:	21f0      	movs	r1, #240	; 0xf0
 8006a32:	2040      	movs	r0, #64	; 0x40
 8006a34:	f7ff fd28 	bl	8006488 <writeReg>
    // clear all radio IRQ flags
    writeReg(LORARegIrqFlags, 0xFF);
 8006a38:	21ff      	movs	r1, #255	; 0xff
 8006a3a:	2012      	movs	r0, #18
 8006a3c:	f7ff fd24 	bl	8006488 <writeReg>
    // mask all IRQs but TxDone
    writeReg(LORARegIrqFlagsMask, ~IRQ_LORA_TXDONE_MASK);
 8006a40:	21f7      	movs	r1, #247	; 0xf7
 8006a42:	2011      	movs	r0, #17
 8006a44:	f7ff fd20 	bl	8006488 <writeReg>

    // initialize the payload size and address pointers    
    writeReg(LORARegFifoTxBaseAddr, 0x00);
 8006a48:	2100      	movs	r1, #0
 8006a4a:	200e      	movs	r0, #14
 8006a4c:	f7ff fd1c 	bl	8006488 <writeReg>
    writeReg(LORARegFifoAddrPtr, 0x00);
 8006a50:	2100      	movs	r1, #0
 8006a52:	200d      	movs	r0, #13
 8006a54:	f7ff fd18 	bl	8006488 <writeReg>
    writeReg(LORARegPayloadLength, LMIC.dataLen);
 8006a58:	4a0c      	ldr	r2, [pc, #48]	; (8006a8c <txlora+0xb0>)
 8006a5a:	2348      	movs	r3, #72	; 0x48
 8006a5c:	33ff      	adds	r3, #255	; 0xff
 8006a5e:	5cd3      	ldrb	r3, [r2, r3]
 8006a60:	0019      	movs	r1, r3
 8006a62:	2022      	movs	r0, #34	; 0x22
 8006a64:	f7ff fd10 	bl	8006488 <writeReg>
       
    // download buffer to the radio FIFO
    writeBuf(RegFifo, LMIC.frame, LMIC.dataLen);
 8006a68:	4a08      	ldr	r2, [pc, #32]	; (8006a8c <txlora+0xb0>)
 8006a6a:	2348      	movs	r3, #72	; 0x48
 8006a6c:	33ff      	adds	r3, #255	; 0xff
 8006a6e:	5cd2      	ldrb	r2, [r2, r3]
 8006a70:	4b07      	ldr	r3, [pc, #28]	; (8006a90 <txlora+0xb4>)
 8006a72:	0019      	movs	r1, r3
 8006a74:	2000      	movs	r0, #0
 8006a76:	f7ff fd49 	bl	800650c <writeBuf>

    // enable antenna switch for TX
    hal_pin_rxtx(1);
 8006a7a:	2001      	movs	r0, #1
 8006a7c:	f7fb fa3f 	bl	8001efe <hal_pin_rxtx>
    
    // now we actually start the transmission
    opmode(OPMODE_TX);
 8006a80:	2003      	movs	r0, #3
 8006a82:	f7ff fdb3 	bl	80065ec <opmode>
}
 8006a86:	46c0      	nop			; (mov r8, r8)
 8006a88:	46bd      	mov	sp, r7
 8006a8a:	bd80      	pop	{r7, pc}
 8006a8c:	20000324 	.word	0x20000324
 8006a90:	2000046c 	.word	0x2000046c

08006a94 <starttx>:

// start transmitter (buf=LMIC.frame, len=LMIC.dataLen)
static void starttx () {
 8006a94:	b580      	push	{r7, lr}
 8006a96:	af00      	add	r7, sp, #0
    ASSERT( (readReg(RegOpMode) & OPMODE_MASK) == OPMODE_SLEEP );
 8006a98:	2001      	movs	r0, #1
 8006a9a:	f7ff fd16 	bl	80064ca <readReg>
 8006a9e:	0003      	movs	r3, r0
 8006aa0:	001a      	movs	r2, r3
 8006aa2:	2307      	movs	r3, #7
 8006aa4:	4013      	ands	r3, r2
 8006aa6:	d001      	beq.n	8006aac <starttx+0x18>
 8006aa8:	f7fb fbd0 	bl	800224c <hal_failed>
    if(getSf(LMIC.rps) == FSK) { // FSK modem
 8006aac:	4b07      	ldr	r3, [pc, #28]	; (8006acc <starttx+0x38>)
 8006aae:	89db      	ldrh	r3, [r3, #14]
 8006ab0:	0018      	movs	r0, r3
 8006ab2:	f7fb fbd2 	bl	800225a <getSf>
 8006ab6:	1e03      	subs	r3, r0, #0
 8006ab8:	d102      	bne.n	8006ac0 <starttx+0x2c>
        txfsk();
 8006aba:	f7ff ff1d 	bl	80068f8 <txfsk>
    } else { // LoRa modem
        txlora();
    }
    // the radio will go back to STANDBY mode as soon as the TX is finished
    // the corresponding IRQ will inform us about completion.
}
 8006abe:	e001      	b.n	8006ac4 <starttx+0x30>
        txlora();
 8006ac0:	f7ff ff8c 	bl	80069dc <txlora>
}
 8006ac4:	46c0      	nop			; (mov r8, r8)
 8006ac6:	46bd      	mov	sp, r7
 8006ac8:	bd80      	pop	{r7, pc}
 8006aca:	46c0      	nop			; (mov r8, r8)
 8006acc:	20000324 	.word	0x20000324

08006ad0 <rxlora>:
    [RXMODE_SCAN]   = IRQ_LORA_RXDONE_MASK,
    [RXMODE_RSSI]   = 0x00,
};

// start LoRa receiver (time=LMIC.rxtime, timeout=LMIC.rxsyms, result=LMIC.frame[LMIC.dataLen])
static void rxlora (u1_t rxmode) {
 8006ad0:	b580      	push	{r7, lr}
 8006ad2:	b082      	sub	sp, #8
 8006ad4:	af00      	add	r7, sp, #0
 8006ad6:	0002      	movs	r2, r0
 8006ad8:	1dfb      	adds	r3, r7, #7
 8006ada:	701a      	strb	r2, [r3, #0]
    // select LoRa modem (from sleep mode)
    opmodeLora();
 8006adc:	f7ff fda2 	bl	8006624 <opmodeLora>
    ASSERT((readReg(RegOpMode) & OPMODE_LORA) != 0);
 8006ae0:	2001      	movs	r0, #1
 8006ae2:	f7ff fcf2 	bl	80064ca <readReg>
 8006ae6:	0003      	movs	r3, r0
 8006ae8:	b25b      	sxtb	r3, r3
 8006aea:	2b00      	cmp	r3, #0
 8006aec:	db01      	blt.n	8006af2 <rxlora+0x22>
 8006aee:	f7fb fbad 	bl	800224c <hal_failed>
    // enter standby mode (warm up))
    opmode(OPMODE_STANDBY);
 8006af2:	2001      	movs	r0, #1
 8006af4:	f7ff fd7a 	bl	80065ec <opmode>
    // don't use MAC settings at startup
    if(rxmode == RXMODE_RSSI) { // use fixed settings for rssi scan
 8006af8:	1dfb      	adds	r3, r7, #7
 8006afa:	781b      	ldrb	r3, [r3, #0]
 8006afc:	2b02      	cmp	r3, #2
 8006afe:	d108      	bne.n	8006b12 <rxlora+0x42>
        writeReg(LORARegModemConfig1, RXLORA_RXMODE_RSSI_REG_MODEM_CONFIG1);
 8006b00:	210a      	movs	r1, #10
 8006b02:	201d      	movs	r0, #29
 8006b04:	f7ff fcc0 	bl	8006488 <writeReg>
        writeReg(LORARegModemConfig2, RXLORA_RXMODE_RSSI_REG_MODEM_CONFIG2);
 8006b08:	2170      	movs	r1, #112	; 0x70
 8006b0a:	201e      	movs	r0, #30
 8006b0c:	f7ff fcbc 	bl	8006488 <writeReg>
 8006b10:	e003      	b.n	8006b1a <rxlora+0x4a>
    } else { // single or continuous rx mode
        // configure LoRa modem (cfg1, cfg2)
        configLoraModem();
 8006b12:	f7ff fdb3 	bl	800667c <configLoraModem>
        // configure frequency
        configChannel();
 8006b16:	f7ff fe79 	bl	800680c <configChannel>
    }
    // set LNA gain
    writeReg(RegLna, LNA_RX_GAIN); 
 8006b1a:	2121      	movs	r1, #33	; 0x21
 8006b1c:	200c      	movs	r0, #12
 8006b1e:	f7ff fcb3 	bl	8006488 <writeReg>
    // set max payload size
    writeReg(LORARegPayloadMaxLength, 64);
 8006b22:	2140      	movs	r1, #64	; 0x40
 8006b24:	2023      	movs	r0, #35	; 0x23
 8006b26:	f7ff fcaf 	bl	8006488 <writeReg>
    // use inverted I/Q signal (prevent mote-to-mote communication)

    // XXX: use flag to switch on/off inversion
    if (LMIC.noRXIQinversion) {
 8006b2a:	4a29      	ldr	r2, [pc, #164]	; (8006bd0 <rxlora+0x100>)
 8006b2c:	23d4      	movs	r3, #212	; 0xd4
 8006b2e:	005b      	lsls	r3, r3, #1
 8006b30:	5cd3      	ldrb	r3, [r2, r3]
 8006b32:	2b00      	cmp	r3, #0
 8006b34:	d00d      	beq.n	8006b52 <rxlora+0x82>
        writeReg(LORARegInvertIQ, readReg(LORARegInvertIQ) & ~(1<<6));
 8006b36:	2033      	movs	r0, #51	; 0x33
 8006b38:	f7ff fcc7 	bl	80064ca <readReg>
 8006b3c:	0003      	movs	r3, r0
 8006b3e:	001a      	movs	r2, r3
 8006b40:	2340      	movs	r3, #64	; 0x40
 8006b42:	439a      	bics	r2, r3
 8006b44:	0013      	movs	r3, r2
 8006b46:	b2db      	uxtb	r3, r3
 8006b48:	0019      	movs	r1, r3
 8006b4a:	2033      	movs	r0, #51	; 0x33
 8006b4c:	f7ff fc9c 	bl	8006488 <writeReg>
 8006b50:	e00b      	b.n	8006b6a <rxlora+0x9a>
    } else {
        writeReg(LORARegInvertIQ, readReg(LORARegInvertIQ)|(1<<6));
 8006b52:	2033      	movs	r0, #51	; 0x33
 8006b54:	f7ff fcb9 	bl	80064ca <readReg>
 8006b58:	0003      	movs	r3, r0
 8006b5a:	001a      	movs	r2, r3
 8006b5c:	2340      	movs	r3, #64	; 0x40
 8006b5e:	4313      	orrs	r3, r2
 8006b60:	b2db      	uxtb	r3, r3
 8006b62:	0019      	movs	r1, r3
 8006b64:	2033      	movs	r0, #51	; 0x33
 8006b66:	f7ff fc8f 	bl	8006488 <writeReg>
    }

    // set symbol timeout (for single rx)
    writeReg(LORARegSymbTimeoutLsb, LMIC.rxsyms);
 8006b6a:	4b19      	ldr	r3, [pc, #100]	; (8006bd0 <rxlora+0x100>)
 8006b6c:	7c1b      	ldrb	r3, [r3, #16]
 8006b6e:	0019      	movs	r1, r3
 8006b70:	201f      	movs	r0, #31
 8006b72:	f7ff fc89 	bl	8006488 <writeReg>
    // set sync word
    writeReg(LORARegSyncWord, LORA_MAC_PREAMBLE);
 8006b76:	2134      	movs	r1, #52	; 0x34
 8006b78:	2039      	movs	r0, #57	; 0x39
 8006b7a:	f7ff fc85 	bl	8006488 <writeReg>
    
    // configure DIO mapping DIO0=RxDone DIO1=RxTout DIO2=NOP
    writeReg(RegDioMapping1, MAP_DIO0_LORA_RXDONE|MAP_DIO1_LORA_RXTOUT|MAP_DIO2_LORA_NOP);
 8006b7e:	21c0      	movs	r1, #192	; 0xc0
 8006b80:	2040      	movs	r0, #64	; 0x40
 8006b82:	f7ff fc81 	bl	8006488 <writeReg>
    // clear all radio IRQ flags
    writeReg(LORARegIrqFlags, 0xFF);
 8006b86:	21ff      	movs	r1, #255	; 0xff
 8006b88:	2012      	movs	r0, #18
 8006b8a:	f7ff fc7d 	bl	8006488 <writeReg>
    // enable required radio IRQs
    writeReg(LORARegIrqFlagsMask, ~rxlorairqmask[rxmode]);
 8006b8e:	1dfb      	adds	r3, r7, #7
 8006b90:	781b      	ldrb	r3, [r3, #0]
 8006b92:	4a10      	ldr	r2, [pc, #64]	; (8006bd4 <rxlora+0x104>)
 8006b94:	5cd3      	ldrb	r3, [r2, r3]
 8006b96:	43db      	mvns	r3, r3
 8006b98:	b2db      	uxtb	r3, r3
 8006b9a:	0019      	movs	r1, r3
 8006b9c:	2011      	movs	r0, #17
 8006b9e:	f7ff fc73 	bl	8006488 <writeReg>

    // enable antenna switch for RX
    hal_pin_rxtx(0);
 8006ba2:	2000      	movs	r0, #0
 8006ba4:	f7fb f9ab 	bl	8001efe <hal_pin_rxtx>

    // now instruct the radio to receive
    if (rxmode == RXMODE_SINGLE) { // single rx
 8006ba8:	1dfb      	adds	r3, r7, #7
 8006baa:	781b      	ldrb	r3, [r3, #0]
 8006bac:	2b00      	cmp	r3, #0
 8006bae:	d108      	bne.n	8006bc2 <rxlora+0xf2>
        hal_waitUntil(LMIC.rxtime); // busy wait until exact rx time
 8006bb0:	4b07      	ldr	r3, [pc, #28]	; (8006bd0 <rxlora+0x100>)
 8006bb2:	685b      	ldr	r3, [r3, #4]
 8006bb4:	0018      	movs	r0, r3
 8006bb6:	f7fb fa9f 	bl	80020f8 <hal_waitUntil>
        opmode(OPMODE_RX_SINGLE);
 8006bba:	2006      	movs	r0, #6
 8006bbc:	f7ff fd16 	bl	80065ec <opmode>
    } else { // continous rx (scan or rssi)
        opmode(OPMODE_RX); 
    }
}
 8006bc0:	e002      	b.n	8006bc8 <rxlora+0xf8>
        opmode(OPMODE_RX); 
 8006bc2:	2005      	movs	r0, #5
 8006bc4:	f7ff fd12 	bl	80065ec <opmode>
}
 8006bc8:	46c0      	nop			; (mov r8, r8)
 8006bca:	46bd      	mov	sp, r7
 8006bcc:	b002      	add	sp, #8
 8006bce:	bd80      	pop	{r7, pc}
 8006bd0:	20000324 	.word	0x20000324
 8006bd4:	0800f220 	.word	0x0800f220

08006bd8 <rxfsk>:

static void rxfsk (u1_t rxmode) {
 8006bd8:	b580      	push	{r7, lr}
 8006bda:	b082      	sub	sp, #8
 8006bdc:	af00      	add	r7, sp, #0
 8006bde:	0002      	movs	r2, r0
 8006be0:	1dfb      	adds	r3, r7, #7
 8006be2:	701a      	strb	r2, [r3, #0]
    // only single rx (no continuous scanning, no noise sampling)
    ASSERT( rxmode == RXMODE_SINGLE );
 8006be4:	1dfb      	adds	r3, r7, #7
 8006be6:	781b      	ldrb	r3, [r3, #0]
 8006be8:	2b00      	cmp	r3, #0
 8006bea:	d001      	beq.n	8006bf0 <rxfsk+0x18>
 8006bec:	f7fb fb2e 	bl	800224c <hal_failed>
    // select FSK modem (from sleep mode)
    //writeReg(RegOpMode, 0x00); // (not LoRa)
    opmodeFSK();
 8006bf0:	f7ff fd2e 	bl	8006650 <opmodeFSK>
    ASSERT((readReg(RegOpMode) & OPMODE_LORA) == 0);
 8006bf4:	2001      	movs	r0, #1
 8006bf6:	f7ff fc68 	bl	80064ca <readReg>
 8006bfa:	0003      	movs	r3, r0
 8006bfc:	b25b      	sxtb	r3, r3
 8006bfe:	2b00      	cmp	r3, #0
 8006c00:	da01      	bge.n	8006c06 <rxfsk+0x2e>
 8006c02:	f7fb fb23 	bl	800224c <hal_failed>
    // enter standby mode (warm up))
    opmode(OPMODE_STANDBY);
 8006c06:	2001      	movs	r0, #1
 8006c08:	f7ff fcf0 	bl	80065ec <opmode>
    // configure frequency
    configChannel();
 8006c0c:	f7ff fdfe 	bl	800680c <configChannel>
    // set LNA gain
    //writeReg(RegLna, 0x20|0x03); // max gain, boost enable
    writeReg(RegLna, LNA_RX_GAIN);
 8006c10:	2121      	movs	r1, #33	; 0x21
 8006c12:	200c      	movs	r0, #12
 8006c14:	f7ff fc38 	bl	8006488 <writeReg>
    // configure receiver
    writeReg(FSKRegRxConfig, 0x1E); // AFC auto, AGC, trigger on preamble?!?
 8006c18:	211e      	movs	r1, #30
 8006c1a:	200d      	movs	r0, #13
 8006c1c:	f7ff fc34 	bl	8006488 <writeReg>
    // set receiver bandwidth
    writeReg(FSKRegRxBw, 0x0B); // 50kHz SSb
 8006c20:	210b      	movs	r1, #11
 8006c22:	2012      	movs	r0, #18
 8006c24:	f7ff fc30 	bl	8006488 <writeReg>
    // set AFC bandwidth
    writeReg(FSKRegAfcBw, 0x12); // 83.3kHz SSB
 8006c28:	2112      	movs	r1, #18
 8006c2a:	2013      	movs	r0, #19
 8006c2c:	f7ff fc2c 	bl	8006488 <writeReg>
    // set preamble detection
    writeReg(FSKRegPreambleDetect, 0xAA); // enable, 2 bytes, 10 chip errors
 8006c30:	21aa      	movs	r1, #170	; 0xaa
 8006c32:	201f      	movs	r0, #31
 8006c34:	f7ff fc28 	bl	8006488 <writeReg>
    // set sync config
    writeReg(FSKRegSyncConfig, 0x12); // no auto restart, preamble 0xAA, enable, fill FIFO, 3 bytes sync
 8006c38:	2112      	movs	r1, #18
 8006c3a:	2027      	movs	r0, #39	; 0x27
 8006c3c:	f7ff fc24 	bl	8006488 <writeReg>
    // set packet config
    writeReg(FSKRegPacketConfig1, 0xD8); // var-length, whitening, crc, no auto-clear, no adr filter
 8006c40:	21d8      	movs	r1, #216	; 0xd8
 8006c42:	2030      	movs	r0, #48	; 0x30
 8006c44:	f7ff fc20 	bl	8006488 <writeReg>
    writeReg(FSKRegPacketConfig2, 0x40); // packet mode
 8006c48:	2140      	movs	r1, #64	; 0x40
 8006c4a:	2031      	movs	r0, #49	; 0x31
 8006c4c:	f7ff fc1c 	bl	8006488 <writeReg>
    // set sync value
    writeReg(FSKRegSyncValue1, 0xC1);
 8006c50:	21c1      	movs	r1, #193	; 0xc1
 8006c52:	2028      	movs	r0, #40	; 0x28
 8006c54:	f7ff fc18 	bl	8006488 <writeReg>
    writeReg(FSKRegSyncValue2, 0x94);
 8006c58:	2194      	movs	r1, #148	; 0x94
 8006c5a:	2029      	movs	r0, #41	; 0x29
 8006c5c:	f7ff fc14 	bl	8006488 <writeReg>
    writeReg(FSKRegSyncValue3, 0xC1);
 8006c60:	21c1      	movs	r1, #193	; 0xc1
 8006c62:	202a      	movs	r0, #42	; 0x2a
 8006c64:	f7ff fc10 	bl	8006488 <writeReg>
    // set preamble timeout
    writeReg(FSKRegRxTimeout2, 0xFF);//(LMIC.rxsyms+1)/2);
 8006c68:	21ff      	movs	r1, #255	; 0xff
 8006c6a:	2021      	movs	r0, #33	; 0x21
 8006c6c:	f7ff fc0c 	bl	8006488 <writeReg>
    // set bitrate
    writeReg(FSKRegBitrateMsb, 0x02); // 50kbps
 8006c70:	2102      	movs	r1, #2
 8006c72:	2002      	movs	r0, #2
 8006c74:	f7ff fc08 	bl	8006488 <writeReg>
    writeReg(FSKRegBitrateLsb, 0x80);
 8006c78:	2180      	movs	r1, #128	; 0x80
 8006c7a:	2003      	movs	r0, #3
 8006c7c:	f7ff fc04 	bl	8006488 <writeReg>
    // set frequency deviation
    writeReg(FSKRegFdevMsb, 0x01); // +/- 25kHz
 8006c80:	2101      	movs	r1, #1
 8006c82:	2004      	movs	r0, #4
 8006c84:	f7ff fc00 	bl	8006488 <writeReg>
    writeReg(FSKRegFdevLsb, 0x99);
 8006c88:	2199      	movs	r1, #153	; 0x99
 8006c8a:	2005      	movs	r0, #5
 8006c8c:	f7ff fbfc 	bl	8006488 <writeReg>
    
    // configure DIO mapping DIO0=PayloadReady DIO1=NOP DIO2=TimeOut
    writeReg(RegDioMapping1, MAP_DIO0_FSK_READY|MAP_DIO1_FSK_NOP|MAP_DIO2_FSK_TIMEOUT);
 8006c90:	2138      	movs	r1, #56	; 0x38
 8006c92:	2040      	movs	r0, #64	; 0x40
 8006c94:	f7ff fbf8 	bl	8006488 <writeReg>

    // enable antenna switch for RX
    hal_pin_rxtx(0);
 8006c98:	2000      	movs	r0, #0
 8006c9a:	f7fb f930 	bl	8001efe <hal_pin_rxtx>
    
    // now instruct the radio to receive
    hal_waitUntil(LMIC.rxtime); // busy wait until exact rx time
 8006c9e:	4b06      	ldr	r3, [pc, #24]	; (8006cb8 <rxfsk+0xe0>)
 8006ca0:	685b      	ldr	r3, [r3, #4]
 8006ca2:	0018      	movs	r0, r3
 8006ca4:	f7fb fa28 	bl	80020f8 <hal_waitUntil>
    opmode(OPMODE_RX); // no single rx mode available in FSK
 8006ca8:	2005      	movs	r0, #5
 8006caa:	f7ff fc9f 	bl	80065ec <opmode>
}
 8006cae:	46c0      	nop			; (mov r8, r8)
 8006cb0:	46bd      	mov	sp, r7
 8006cb2:	b002      	add	sp, #8
 8006cb4:	bd80      	pop	{r7, pc}
 8006cb6:	46c0      	nop			; (mov r8, r8)
 8006cb8:	20000324 	.word	0x20000324

08006cbc <startrx>:

static void startrx (u1_t rxmode) {
 8006cbc:	b580      	push	{r7, lr}
 8006cbe:	b082      	sub	sp, #8
 8006cc0:	af00      	add	r7, sp, #0
 8006cc2:	0002      	movs	r2, r0
 8006cc4:	1dfb      	adds	r3, r7, #7
 8006cc6:	701a      	strb	r2, [r3, #0]
    ASSERT( (readReg(RegOpMode) & OPMODE_MASK) == OPMODE_SLEEP );
 8006cc8:	2001      	movs	r0, #1
 8006cca:	f7ff fbfe 	bl	80064ca <readReg>
 8006cce:	0003      	movs	r3, r0
 8006cd0:	001a      	movs	r2, r3
 8006cd2:	2307      	movs	r3, #7
 8006cd4:	4013      	ands	r3, r2
 8006cd6:	d001      	beq.n	8006cdc <startrx+0x20>
 8006cd8:	f7fb fab8 	bl	800224c <hal_failed>
    if(getSf(LMIC.rps) == FSK) { // FSK modem
 8006cdc:	4b0a      	ldr	r3, [pc, #40]	; (8006d08 <startrx+0x4c>)
 8006cde:	89db      	ldrh	r3, [r3, #14]
 8006ce0:	0018      	movs	r0, r3
 8006ce2:	f7fb faba 	bl	800225a <getSf>
 8006ce6:	1e03      	subs	r3, r0, #0
 8006ce8:	d105      	bne.n	8006cf6 <startrx+0x3a>
        rxfsk(rxmode);
 8006cea:	1dfb      	adds	r3, r7, #7
 8006cec:	781b      	ldrb	r3, [r3, #0]
 8006cee:	0018      	movs	r0, r3
 8006cf0:	f7ff ff72 	bl	8006bd8 <rxfsk>
    } else { // LoRa modem
        rxlora(rxmode);
    }
    // the radio will go back to STANDBY mode as soon as the RX is finished
    // or timed out, and the corresponding IRQ will inform us about completion.
}
 8006cf4:	e004      	b.n	8006d00 <startrx+0x44>
        rxlora(rxmode);
 8006cf6:	1dfb      	adds	r3, r7, #7
 8006cf8:	781b      	ldrb	r3, [r3, #0]
 8006cfa:	0018      	movs	r0, r3
 8006cfc:	f7ff fee8 	bl	8006ad0 <rxlora>
}
 8006d00:	46c0      	nop			; (mov r8, r8)
 8006d02:	46bd      	mov	sp, r7
 8006d04:	b002      	add	sp, #8
 8006d06:	bd80      	pop	{r7, pc}
 8006d08:	20000324 	.word	0x20000324

08006d0c <radio_init>:

// get random seed from wideband noise rssi
void radio_init () {
 8006d0c:	b590      	push	{r4, r7, lr}
 8006d0e:	b085      	sub	sp, #20
 8006d10:	af00      	add	r7, sp, #0
    hal_disableIRQs();
 8006d12:	f7fb fa5d 	bl	80021d0 <hal_disableIRQs>

    // manually reset radio
#ifdef CFG_sx1276_radio
    hal_pin_rst(0); // drive RST pin low
 8006d16:	2000      	movs	r0, #0
 8006d18:	f7fb f90e 	bl	8001f38 <hal_pin_rst>
#else
    hal_pin_rst(1); // drive RST pin high
#endif
    hal_waitUntil(os_getTime()+ms2osticks(1)); // wait >100us
 8006d1c:	f7ff fad8 	bl	80062d0 <os_getTime>
 8006d20:	0003      	movs	r3, r0
 8006d22:	3320      	adds	r3, #32
 8006d24:	0018      	movs	r0, r3
 8006d26:	f7fb f9e7 	bl	80020f8 <hal_waitUntil>
    hal_pin_rst(2); // configure RST pin floating!
 8006d2a:	2002      	movs	r0, #2
 8006d2c:	f7fb f904 	bl	8001f38 <hal_pin_rst>
    hal_waitUntil(os_getTime()+ms2osticks(5)); // wait 5ms
 8006d30:	f7ff face 	bl	80062d0 <os_getTime>
 8006d34:	0003      	movs	r3, r0
 8006d36:	33a0      	adds	r3, #160	; 0xa0
 8006d38:	0018      	movs	r0, r3
 8006d3a:	f7fb f9dd 	bl	80020f8 <hal_waitUntil>

    opmode(OPMODE_SLEEP);
 8006d3e:	2000      	movs	r0, #0
 8006d40:	f7ff fc54 	bl	80065ec <opmode>

    // some sanity checks, e.g., read version number
    u1_t v = readReg(RegVersion);
 8006d44:	1dfc      	adds	r4, r7, #7
 8006d46:	2042      	movs	r0, #66	; 0x42
 8006d48:	f7ff fbbf 	bl	80064ca <readReg>
 8006d4c:	0003      	movs	r3, r0
 8006d4e:	7023      	strb	r3, [r4, #0]
#ifdef CFG_sx1276_radio
    ASSERT(v == 0x12 ); 
 8006d50:	1dfb      	adds	r3, r7, #7
 8006d52:	781b      	ldrb	r3, [r3, #0]
 8006d54:	2b12      	cmp	r3, #18
 8006d56:	d001      	beq.n	8006d5c <radio_init+0x50>
 8006d58:	f7fb fa78 	bl	800224c <hal_failed>
    ASSERT(v == 0x22);
#else
#error Missing CFG_sx1272_radio/CFG_sx1276_radio
#endif
    // seed 15-byte randomness via noise rssi
    rxlora(RXMODE_RSSI);
 8006d5c:	2002      	movs	r0, #2
 8006d5e:	f7ff feb7 	bl	8006ad0 <rxlora>
    while( (readReg(RegOpMode) & OPMODE_MASK) != OPMODE_RX ); // continuous rx
 8006d62:	46c0      	nop			; (mov r8, r8)
 8006d64:	2001      	movs	r0, #1
 8006d66:	f7ff fbb0 	bl	80064ca <readReg>
 8006d6a:	0003      	movs	r3, r0
 8006d6c:	001a      	movs	r2, r3
 8006d6e:	2307      	movs	r3, #7
 8006d70:	4013      	ands	r3, r2
 8006d72:	2b05      	cmp	r3, #5
 8006d74:	d1f6      	bne.n	8006d64 <radio_init+0x58>
    for(int i=1; i<16; i++) {
 8006d76:	2301      	movs	r3, #1
 8006d78:	60fb      	str	r3, [r7, #12]
 8006d7a:	e031      	b.n	8006de0 <radio_init+0xd4>
        for(int j=0; j<8; j++) {
 8006d7c:	2300      	movs	r3, #0
 8006d7e:	60bb      	str	r3, [r7, #8]
 8006d80:	e028      	b.n	8006dd4 <radio_init+0xc8>
            u1_t b; // wait for two non-identical subsequent least-significant bits
            while( (b = readReg(LORARegRssiWideband) & 0x01) == (readReg(LORARegRssiWideband) & 0x01) );
 8006d82:	46c0      	nop			; (mov r8, r8)
 8006d84:	202c      	movs	r0, #44	; 0x2c
 8006d86:	f7ff fba0 	bl	80064ca <readReg>
 8006d8a:	0003      	movs	r3, r0
 8006d8c:	0019      	movs	r1, r3
 8006d8e:	1dbb      	adds	r3, r7, #6
 8006d90:	2201      	movs	r2, #1
 8006d92:	400a      	ands	r2, r1
 8006d94:	701a      	strb	r2, [r3, #0]
 8006d96:	1dbb      	adds	r3, r7, #6
 8006d98:	781c      	ldrb	r4, [r3, #0]
 8006d9a:	202c      	movs	r0, #44	; 0x2c
 8006d9c:	f7ff fb95 	bl	80064ca <readReg>
 8006da0:	0003      	movs	r3, r0
 8006da2:	001a      	movs	r2, r3
 8006da4:	2301      	movs	r3, #1
 8006da6:	4013      	ands	r3, r2
 8006da8:	429c      	cmp	r4, r3
 8006daa:	d0eb      	beq.n	8006d84 <radio_init+0x78>
            randbuf[i] = (randbuf[i] << 1) | b;
 8006dac:	4a14      	ldr	r2, [pc, #80]	; (8006e00 <radio_init+0xf4>)
 8006dae:	68fb      	ldr	r3, [r7, #12]
 8006db0:	18d3      	adds	r3, r2, r3
 8006db2:	781b      	ldrb	r3, [r3, #0]
 8006db4:	005b      	lsls	r3, r3, #1
 8006db6:	b25a      	sxtb	r2, r3
 8006db8:	1dbb      	adds	r3, r7, #6
 8006dba:	781b      	ldrb	r3, [r3, #0]
 8006dbc:	b25b      	sxtb	r3, r3
 8006dbe:	4313      	orrs	r3, r2
 8006dc0:	b25b      	sxtb	r3, r3
 8006dc2:	b2d9      	uxtb	r1, r3
 8006dc4:	4a0e      	ldr	r2, [pc, #56]	; (8006e00 <radio_init+0xf4>)
 8006dc6:	68fb      	ldr	r3, [r7, #12]
 8006dc8:	18d3      	adds	r3, r2, r3
 8006dca:	1c0a      	adds	r2, r1, #0
 8006dcc:	701a      	strb	r2, [r3, #0]
        for(int j=0; j<8; j++) {
 8006dce:	68bb      	ldr	r3, [r7, #8]
 8006dd0:	3301      	adds	r3, #1
 8006dd2:	60bb      	str	r3, [r7, #8]
 8006dd4:	68bb      	ldr	r3, [r7, #8]
 8006dd6:	2b07      	cmp	r3, #7
 8006dd8:	ddd3      	ble.n	8006d82 <radio_init+0x76>
    for(int i=1; i<16; i++) {
 8006dda:	68fb      	ldr	r3, [r7, #12]
 8006ddc:	3301      	adds	r3, #1
 8006dde:	60fb      	str	r3, [r7, #12]
 8006de0:	68fb      	ldr	r3, [r7, #12]
 8006de2:	2b0f      	cmp	r3, #15
 8006de4:	ddca      	ble.n	8006d7c <radio_init+0x70>
        }
    }
    randbuf[0] = 16; // set initial index
 8006de6:	4b06      	ldr	r3, [pc, #24]	; (8006e00 <radio_init+0xf4>)
 8006de8:	2210      	movs	r2, #16
 8006dea:	701a      	strb	r2, [r3, #0]
    // Launch Rx chain calibration for HF band 
    writeReg(FSKRegImageCal, (readReg(FSKRegImageCal) & RF_IMAGECAL_IMAGECAL_MASK)|RF_IMAGECAL_IMAGECAL_START);
    while((readReg(FSKRegImageCal) & RF_IMAGECAL_IMAGECAL_RUNNING) == RF_IMAGECAL_IMAGECAL_RUNNING) { ; }
#endif /* CFG_sx1276mb1_board */

    opmode(OPMODE_SLEEP);
 8006dec:	2000      	movs	r0, #0
 8006dee:	f7ff fbfd 	bl	80065ec <opmode>

    hal_enableIRQs();
 8006df2:	f7fb f9fb 	bl	80021ec <hal_enableIRQs>
}
 8006df6:	46c0      	nop			; (mov r8, r8)
 8006df8:	46bd      	mov	sp, r7
 8006dfa:	b005      	add	sp, #20
 8006dfc:	bd90      	pop	{r4, r7, pc}
 8006dfe:	46c0      	nop			; (mov r8, r8)
 8006e00:	20000090 	.word	0x20000090

08006e04 <radio_rand1>:

// return next random byte derived from seed buffer
// (buf[0] holds index of next byte to be returned)
u1_t radio_rand1 () {
 8006e04:	b580      	push	{r7, lr}
 8006e06:	b082      	sub	sp, #8
 8006e08:	af00      	add	r7, sp, #0
    u1_t i = randbuf[0];
 8006e0a:	1dfb      	adds	r3, r7, #7
 8006e0c:	4a14      	ldr	r2, [pc, #80]	; (8006e60 <radio_rand1+0x5c>)
 8006e0e:	7812      	ldrb	r2, [r2, #0]
 8006e10:	701a      	strb	r2, [r3, #0]
    ASSERT( i != 0 );
 8006e12:	1dfb      	adds	r3, r7, #7
 8006e14:	781b      	ldrb	r3, [r3, #0]
 8006e16:	2b00      	cmp	r3, #0
 8006e18:	d101      	bne.n	8006e1e <radio_rand1+0x1a>
 8006e1a:	f7fb fa17 	bl	800224c <hal_failed>
    if( i==16 ) {
 8006e1e:	1dfb      	adds	r3, r7, #7
 8006e20:	781b      	ldrb	r3, [r3, #0]
 8006e22:	2b10      	cmp	r3, #16
 8006e24:	d108      	bne.n	8006e38 <radio_rand1+0x34>
        os_aes(AES_ENC, randbuf, 16); // encrypt seed with any key
 8006e26:	4b0e      	ldr	r3, [pc, #56]	; (8006e60 <radio_rand1+0x5c>)
 8006e28:	2210      	movs	r2, #16
 8006e2a:	0019      	movs	r1, r3
 8006e2c:	2000      	movs	r0, #0
 8006e2e:	f7fa faaf 	bl	8001390 <os_aes>
        i = 0;
 8006e32:	1dfb      	adds	r3, r7, #7
 8006e34:	2200      	movs	r2, #0
 8006e36:	701a      	strb	r2, [r3, #0]
    }
    u1_t v = randbuf[i++];
 8006e38:	1dfb      	adds	r3, r7, #7
 8006e3a:	781b      	ldrb	r3, [r3, #0]
 8006e3c:	1dfa      	adds	r2, r7, #7
 8006e3e:	1c59      	adds	r1, r3, #1
 8006e40:	7011      	strb	r1, [r2, #0]
 8006e42:	0019      	movs	r1, r3
 8006e44:	1dbb      	adds	r3, r7, #6
 8006e46:	4a06      	ldr	r2, [pc, #24]	; (8006e60 <radio_rand1+0x5c>)
 8006e48:	5c52      	ldrb	r2, [r2, r1]
 8006e4a:	701a      	strb	r2, [r3, #0]
    randbuf[0] = i;
 8006e4c:	4b04      	ldr	r3, [pc, #16]	; (8006e60 <radio_rand1+0x5c>)
 8006e4e:	1dfa      	adds	r2, r7, #7
 8006e50:	7812      	ldrb	r2, [r2, #0]
 8006e52:	701a      	strb	r2, [r3, #0]
    return v;
 8006e54:	1dbb      	adds	r3, r7, #6
 8006e56:	781b      	ldrb	r3, [r3, #0]
}
 8006e58:	0018      	movs	r0, r3
 8006e5a:	46bd      	mov	sp, r7
 8006e5c:	b002      	add	sp, #8
 8006e5e:	bd80      	pop	{r7, pc}
 8006e60:	20000090 	.word	0x20000090

08006e64 <radio_irq_handler>:
    [SF12] = us2osticks(31189), // (1022 ticks)
};

// called by hal ext IRQ handler
// (radio goes to stanby mode after tx/rx operations)
void radio_irq_handler (u1_t dio) {
 8006e64:	b5b0      	push	{r4, r5, r7, lr}
 8006e66:	b084      	sub	sp, #16
 8006e68:	af00      	add	r7, sp, #0
 8006e6a:	0002      	movs	r2, r0
 8006e6c:	1dfb      	adds	r3, r7, #7
 8006e6e:	701a      	strb	r2, [r3, #0]
    u1_t s = readReg(RegOpMode);
    u1_t c = readReg(LORARegModemConfig2);
    opmode(OPMODE_TX);
    return;
#else /* ! CFG_TxContinuousMode */
    ostime_t now = os_getTime();
 8006e70:	f7ff fa2e 	bl	80062d0 <os_getTime>
 8006e74:	0003      	movs	r3, r0
 8006e76:	60fb      	str	r3, [r7, #12]
    if( (readReg(RegOpMode) & OPMODE_LORA) != 0) { // LORA modem
 8006e78:	2001      	movs	r0, #1
 8006e7a:	f7ff fb26 	bl	80064ca <readReg>
 8006e7e:	0003      	movs	r3, r0
 8006e80:	b25b      	sxtb	r3, r3
 8006e82:	2b00      	cmp	r3, #0
 8006e84:	db00      	blt.n	8006e88 <radio_irq_handler+0x24>
 8006e86:	e07b      	b.n	8006f80 <radio_irq_handler+0x11c>
        u1_t flags = readReg(LORARegIrqFlags);
 8006e88:	2509      	movs	r5, #9
 8006e8a:	197c      	adds	r4, r7, r5
 8006e8c:	2012      	movs	r0, #18
 8006e8e:	f7ff fb1c 	bl	80064ca <readReg>
 8006e92:	0003      	movs	r3, r0
 8006e94:	7023      	strb	r3, [r4, #0]
        if( flags & IRQ_LORA_TXDONE_MASK ) {
 8006e96:	197b      	adds	r3, r7, r5
 8006e98:	781b      	ldrb	r3, [r3, #0]
 8006e9a:	2208      	movs	r2, #8
 8006e9c:	4013      	ands	r3, r2
 8006e9e:	d004      	beq.n	8006eaa <radio_irq_handler+0x46>
            // save exact tx time
            LMIC.txend = now - us2osticks(43); // TXDONE FIXUP
 8006ea0:	68fb      	ldr	r3, [r7, #12]
 8006ea2:	1e5a      	subs	r2, r3, #1
 8006ea4:	4b60      	ldr	r3, [pc, #384]	; (8007028 <radio_irq_handler+0x1c4>)
 8006ea6:	601a      	str	r2, [r3, #0]
 8006ea8:	e061      	b.n	8006f6e <radio_irq_handler+0x10a>
        } else if( flags & IRQ_LORA_RXDONE_MASK ) {
 8006eaa:	2309      	movs	r3, #9
 8006eac:	18fb      	adds	r3, r7, r3
 8006eae:	781b      	ldrb	r3, [r3, #0]
 8006eb0:	2240      	movs	r2, #64	; 0x40
 8006eb2:	4013      	ands	r3, r2
 8006eb4:	d050      	beq.n	8006f58 <radio_irq_handler+0xf4>
            // save exact rx time
            if(getBw(LMIC.rps) == BW125) {
 8006eb6:	4b5c      	ldr	r3, [pc, #368]	; (8007028 <radio_irq_handler+0x1c4>)
 8006eb8:	89db      	ldrh	r3, [r3, #14]
 8006eba:	0018      	movs	r0, r3
 8006ebc:	f7fb f9dd 	bl	800227a <getBw>
 8006ec0:	1e03      	subs	r3, r0, #0
 8006ec2:	d10d      	bne.n	8006ee0 <radio_irq_handler+0x7c>
                now -= LORA_RXDONE_FIXUP[getSf(LMIC.rps)];
 8006ec4:	4b58      	ldr	r3, [pc, #352]	; (8007028 <radio_irq_handler+0x1c4>)
 8006ec6:	89db      	ldrh	r3, [r3, #14]
 8006ec8:	0018      	movs	r0, r3
 8006eca:	f7fb f9c6 	bl	800225a <getSf>
 8006ece:	0003      	movs	r3, r0
 8006ed0:	001a      	movs	r2, r3
 8006ed2:	4b56      	ldr	r3, [pc, #344]	; (800702c <radio_irq_handler+0x1c8>)
 8006ed4:	0052      	lsls	r2, r2, #1
 8006ed6:	5ad3      	ldrh	r3, [r2, r3]
 8006ed8:	001a      	movs	r2, r3
 8006eda:	68fb      	ldr	r3, [r7, #12]
 8006edc:	1a9b      	subs	r3, r3, r2
 8006ede:	60fb      	str	r3, [r7, #12]
            }
            LMIC.rxtime = now;
 8006ee0:	4b51      	ldr	r3, [pc, #324]	; (8007028 <radio_irq_handler+0x1c4>)
 8006ee2:	68fa      	ldr	r2, [r7, #12]
 8006ee4:	605a      	str	r2, [r3, #4]
            // read the PDU and inform the MAC that we received something
            LMIC.dataLen = (readReg(LORARegModemConfig1) & SX1272_MC1_IMPLICIT_HEADER_MODE_ON) ?
 8006ee6:	201d      	movs	r0, #29
 8006ee8:	f7ff faef 	bl	80064ca <readReg>
 8006eec:	0003      	movs	r3, r0
 8006eee:	001a      	movs	r2, r3
 8006ef0:	2304      	movs	r3, #4
 8006ef2:	4013      	ands	r3, r2
 8006ef4:	d005      	beq.n	8006f02 <radio_irq_handler+0x9e>
                readReg(LORARegPayloadLength) : readReg(LORARegRxNbBytes);
 8006ef6:	2022      	movs	r0, #34	; 0x22
 8006ef8:	f7ff fae7 	bl	80064ca <readReg>
 8006efc:	0003      	movs	r3, r0
 8006efe:	0019      	movs	r1, r3
 8006f00:	e004      	b.n	8006f0c <radio_irq_handler+0xa8>
 8006f02:	2013      	movs	r0, #19
 8006f04:	f7ff fae1 	bl	80064ca <readReg>
 8006f08:	0003      	movs	r3, r0
 8006f0a:	0019      	movs	r1, r3
            LMIC.dataLen = (readReg(LORARegModemConfig1) & SX1272_MC1_IMPLICIT_HEADER_MODE_ON) ?
 8006f0c:	4a46      	ldr	r2, [pc, #280]	; (8007028 <radio_irq_handler+0x1c4>)
 8006f0e:	2348      	movs	r3, #72	; 0x48
 8006f10:	33ff      	adds	r3, #255	; 0xff
 8006f12:	54d1      	strb	r1, [r2, r3]
            // set FIFO read address pointer
            writeReg(LORARegFifoAddrPtr, readReg(LORARegFifoRxCurrentAddr)); 
 8006f14:	2010      	movs	r0, #16
 8006f16:	f7ff fad8 	bl	80064ca <readReg>
 8006f1a:	0003      	movs	r3, r0
 8006f1c:	0019      	movs	r1, r3
 8006f1e:	200d      	movs	r0, #13
 8006f20:	f7ff fab2 	bl	8006488 <writeReg>
            // now read the FIFO
            readBuf(RegFifo, LMIC.frame, LMIC.dataLen);
 8006f24:	4a40      	ldr	r2, [pc, #256]	; (8007028 <radio_irq_handler+0x1c4>)
 8006f26:	2348      	movs	r3, #72	; 0x48
 8006f28:	33ff      	adds	r3, #255	; 0xff
 8006f2a:	5cd2      	ldrb	r2, [r2, r3]
 8006f2c:	4b40      	ldr	r3, [pc, #256]	; (8007030 <radio_irq_handler+0x1cc>)
 8006f2e:	0019      	movs	r1, r3
 8006f30:	2000      	movs	r0, #0
 8006f32:	f7ff fb23 	bl	800657c <readBuf>
            // read rx quality parameters
            LMIC.snr  = readReg(LORARegPktSnrValue); // SNR [dB] * 4
 8006f36:	2019      	movs	r0, #25
 8006f38:	f7ff fac7 	bl	80064ca <readReg>
 8006f3c:	0003      	movs	r3, r0
 8006f3e:	b25a      	sxtb	r2, r3
 8006f40:	4b39      	ldr	r3, [pc, #228]	; (8007028 <radio_irq_handler+0x1c4>)
 8006f42:	735a      	strb	r2, [r3, #13]
            LMIC.rssi = readReg(LORARegPktRssiValue) - 125 + 64; // RSSI [dBm] (-196...+63)
 8006f44:	201a      	movs	r0, #26
 8006f46:	f7ff fac0 	bl	80064ca <readReg>
 8006f4a:	0003      	movs	r3, r0
 8006f4c:	3b3d      	subs	r3, #61	; 0x3d
 8006f4e:	b2db      	uxtb	r3, r3
 8006f50:	b25a      	sxtb	r2, r3
 8006f52:	4b35      	ldr	r3, [pc, #212]	; (8007028 <radio_irq_handler+0x1c4>)
 8006f54:	731a      	strb	r2, [r3, #12]
 8006f56:	e00a      	b.n	8006f6e <radio_irq_handler+0x10a>
        } else if( flags & IRQ_LORA_RXTOUT_MASK ) {
 8006f58:	2309      	movs	r3, #9
 8006f5a:	18fb      	adds	r3, r7, r3
 8006f5c:	781b      	ldrb	r3, [r3, #0]
 8006f5e:	b25b      	sxtb	r3, r3
 8006f60:	2b00      	cmp	r3, #0
 8006f62:	da04      	bge.n	8006f6e <radio_irq_handler+0x10a>
            // indicate timeout
            LMIC.dataLen = 0;
 8006f64:	4a30      	ldr	r2, [pc, #192]	; (8007028 <radio_irq_handler+0x1c4>)
 8006f66:	2348      	movs	r3, #72	; 0x48
 8006f68:	33ff      	adds	r3, #255	; 0xff
 8006f6a:	2100      	movs	r1, #0
 8006f6c:	54d1      	strb	r1, [r2, r3]
        }
        // mask all radio IRQs
        writeReg(LORARegIrqFlagsMask, 0xFF);
 8006f6e:	21ff      	movs	r1, #255	; 0xff
 8006f70:	2011      	movs	r0, #17
 8006f72:	f7ff fa89 	bl	8006488 <writeReg>
        // clear radio IRQ flags
        writeReg(LORARegIrqFlags, 0xFF);
 8006f76:	21ff      	movs	r1, #255	; 0xff
 8006f78:	2012      	movs	r0, #18
 8006f7a:	f7ff fa85 	bl	8006488 <writeReg>
 8006f7e:	e045      	b.n	800700c <radio_irq_handler+0x1a8>
    } else { // FSK modem
        u1_t flags1 = readReg(FSKRegIrqFlags1);
 8006f80:	230b      	movs	r3, #11
 8006f82:	18fc      	adds	r4, r7, r3
 8006f84:	203e      	movs	r0, #62	; 0x3e
 8006f86:	f7ff faa0 	bl	80064ca <readReg>
 8006f8a:	0003      	movs	r3, r0
 8006f8c:	7023      	strb	r3, [r4, #0]
        u1_t flags2 = readReg(FSKRegIrqFlags2);
 8006f8e:	250a      	movs	r5, #10
 8006f90:	197c      	adds	r4, r7, r5
 8006f92:	203f      	movs	r0, #63	; 0x3f
 8006f94:	f7ff fa99 	bl	80064ca <readReg>
 8006f98:	0003      	movs	r3, r0
 8006f9a:	7023      	strb	r3, [r4, #0]
        if( flags2 & IRQ_FSK2_PACKETSENT_MASK ) {
 8006f9c:	197b      	adds	r3, r7, r5
 8006f9e:	781b      	ldrb	r3, [r3, #0]
 8006fa0:	2208      	movs	r2, #8
 8006fa2:	4013      	ands	r3, r2
 8006fa4:	d003      	beq.n	8006fae <radio_irq_handler+0x14a>
            // save exact tx time
            LMIC.txend = now;
 8006fa6:	4b20      	ldr	r3, [pc, #128]	; (8007028 <radio_irq_handler+0x1c4>)
 8006fa8:	68fa      	ldr	r2, [r7, #12]
 8006faa:	601a      	str	r2, [r3, #0]
 8006fac:	e02e      	b.n	800700c <radio_irq_handler+0x1a8>
        } else if( flags2 & IRQ_FSK2_PAYLOADREADY_MASK ) {
 8006fae:	230a      	movs	r3, #10
 8006fb0:	18fb      	adds	r3, r7, r3
 8006fb2:	781b      	ldrb	r3, [r3, #0]
 8006fb4:	2204      	movs	r2, #4
 8006fb6:	4013      	ands	r3, r2
 8006fb8:	d01b      	beq.n	8006ff2 <radio_irq_handler+0x18e>
            // save exact rx time
            LMIC.rxtime = now;
 8006fba:	4b1b      	ldr	r3, [pc, #108]	; (8007028 <radio_irq_handler+0x1c4>)
 8006fbc:	68fa      	ldr	r2, [r7, #12]
 8006fbe:	605a      	str	r2, [r3, #4]
            // read the PDU and inform the MAC that we received something
            LMIC.dataLen = readReg(FSKRegPayloadLength);
 8006fc0:	2032      	movs	r0, #50	; 0x32
 8006fc2:	f7ff fa82 	bl	80064ca <readReg>
 8006fc6:	0003      	movs	r3, r0
 8006fc8:	0019      	movs	r1, r3
 8006fca:	4a17      	ldr	r2, [pc, #92]	; (8007028 <radio_irq_handler+0x1c4>)
 8006fcc:	2348      	movs	r3, #72	; 0x48
 8006fce:	33ff      	adds	r3, #255	; 0xff
 8006fd0:	54d1      	strb	r1, [r2, r3]
            // now read the FIFO
            readBuf(RegFifo, LMIC.frame, LMIC.dataLen);
 8006fd2:	4a15      	ldr	r2, [pc, #84]	; (8007028 <radio_irq_handler+0x1c4>)
 8006fd4:	2348      	movs	r3, #72	; 0x48
 8006fd6:	33ff      	adds	r3, #255	; 0xff
 8006fd8:	5cd2      	ldrb	r2, [r2, r3]
 8006fda:	4b15      	ldr	r3, [pc, #84]	; (8007030 <radio_irq_handler+0x1cc>)
 8006fdc:	0019      	movs	r1, r3
 8006fde:	2000      	movs	r0, #0
 8006fe0:	f7ff facc 	bl	800657c <readBuf>
            // read rx quality parameters
            LMIC.snr  = 0; // determine snr
 8006fe4:	4b10      	ldr	r3, [pc, #64]	; (8007028 <radio_irq_handler+0x1c4>)
 8006fe6:	2200      	movs	r2, #0
 8006fe8:	735a      	strb	r2, [r3, #13]
            LMIC.rssi = 0; // determine rssi
 8006fea:	4b0f      	ldr	r3, [pc, #60]	; (8007028 <radio_irq_handler+0x1c4>)
 8006fec:	2200      	movs	r2, #0
 8006fee:	731a      	strb	r2, [r3, #12]
 8006ff0:	e00c      	b.n	800700c <radio_irq_handler+0x1a8>
        } else if( flags1 & IRQ_FSK1_TIMEOUT_MASK ) {
 8006ff2:	230b      	movs	r3, #11
 8006ff4:	18fb      	adds	r3, r7, r3
 8006ff6:	781b      	ldrb	r3, [r3, #0]
 8006ff8:	2204      	movs	r2, #4
 8006ffa:	4013      	ands	r3, r2
 8006ffc:	d005      	beq.n	800700a <radio_irq_handler+0x1a6>
            // indicate timeout
            LMIC.dataLen = 0;
 8006ffe:	4a0a      	ldr	r2, [pc, #40]	; (8007028 <radio_irq_handler+0x1c4>)
 8007000:	2348      	movs	r3, #72	; 0x48
 8007002:	33ff      	adds	r3, #255	; 0xff
 8007004:	2100      	movs	r1, #0
 8007006:	54d1      	strb	r1, [r2, r3]
 8007008:	e000      	b.n	800700c <radio_irq_handler+0x1a8>
        } else {
            while(1);
 800700a:	e7fe      	b.n	800700a <radio_irq_handler+0x1a6>
        }
    }
    // go from stanby to sleep
    opmode(OPMODE_SLEEP);
 800700c:	2000      	movs	r0, #0
 800700e:	f7ff faed 	bl	80065ec <opmode>
    // run os job (use preset func ptr)
    os_setCallback(&LMIC.osjob, LMIC.osjob.func);
 8007012:	4b05      	ldr	r3, [pc, #20]	; (8007028 <radio_irq_handler+0x1c4>)
 8007014:	69da      	ldr	r2, [r3, #28]
 8007016:	4b07      	ldr	r3, [pc, #28]	; (8007034 <radio_irq_handler+0x1d0>)
 8007018:	0011      	movs	r1, r2
 800701a:	0018      	movs	r0, r3
 800701c:	f7ff f99e 	bl	800635c <os_setCallback>
#endif /* ! CFG_TxContinuousMode */
}
 8007020:	46c0      	nop			; (mov r8, r8)
 8007022:	46bd      	mov	sp, r7
 8007024:	b004      	add	sp, #16
 8007026:	bdb0      	pop	{r4, r5, r7, pc}
 8007028:	20000324 	.word	0x20000324
 800702c:	0800f224 	.word	0x0800f224
 8007030:	2000046c 	.word	0x2000046c
 8007034:	20000338 	.word	0x20000338

08007038 <os_radio>:

void os_radio (u1_t mode) {
 8007038:	b580      	push	{r7, lr}
 800703a:	b082      	sub	sp, #8
 800703c:	af00      	add	r7, sp, #0
 800703e:	0002      	movs	r2, r0
 8007040:	1dfb      	adds	r3, r7, #7
 8007042:	701a      	strb	r2, [r3, #0]
    hal_disableIRQs();
 8007044:	f7fb f8c4 	bl	80021d0 <hal_disableIRQs>
    switch (mode) {
 8007048:	1dfb      	adds	r3, r7, #7
 800704a:	781b      	ldrb	r3, [r3, #0]
 800704c:	2b03      	cmp	r3, #3
 800704e:	d013      	beq.n	8007078 <os_radio+0x40>
 8007050:	dc16      	bgt.n	8007080 <os_radio+0x48>
 8007052:	2b02      	cmp	r3, #2
 8007054:	d00c      	beq.n	8007070 <os_radio+0x38>
 8007056:	dc13      	bgt.n	8007080 <os_radio+0x48>
 8007058:	2b00      	cmp	r3, #0
 800705a:	d002      	beq.n	8007062 <os_radio+0x2a>
 800705c:	2b01      	cmp	r3, #1
 800705e:	d004      	beq.n	800706a <os_radio+0x32>
 8007060:	e00e      	b.n	8007080 <os_radio+0x48>
      case RADIO_RST:
        // put radio to sleep
        opmode(OPMODE_SLEEP);
 8007062:	2000      	movs	r0, #0
 8007064:	f7ff fac2 	bl	80065ec <opmode>
        break;
 8007068:	e00a      	b.n	8007080 <os_radio+0x48>

      case RADIO_TX:
        // transmit frame now
        starttx(); // buf=LMIC.frame, len=LMIC.dataLen
 800706a:	f7ff fd13 	bl	8006a94 <starttx>
        break;
 800706e:	e007      	b.n	8007080 <os_radio+0x48>
      
      case RADIO_RX:
        // receive frame now (exactly at rxtime)
        startrx(RXMODE_SINGLE); // buf=LMIC.frame, time=LMIC.rxtime, timeout=LMIC.rxsyms
 8007070:	2000      	movs	r0, #0
 8007072:	f7ff fe23 	bl	8006cbc <startrx>
        break;
 8007076:	e003      	b.n	8007080 <os_radio+0x48>

      case RADIO_RXON:
        // start scanning for beacon now
        startrx(RXMODE_SCAN); // buf=LMIC.frame
 8007078:	2001      	movs	r0, #1
 800707a:	f7ff fe1f 	bl	8006cbc <startrx>
        break;
 800707e:	46c0      	nop			; (mov r8, r8)
    }
    hal_enableIRQs();
 8007080:	f7fb f8b4 	bl	80021ec <hal_enableIRQs>
}
 8007084:	46c0      	nop			; (mov r8, r8)
 8007086:	46bd      	mov	sp, r7
 8007088:	b002      	add	sp, #8
 800708a:	bd80      	pop	{r7, pc}

0800708c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800708c:	b580      	push	{r7, lr}
 800708e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007090:	4b07      	ldr	r3, [pc, #28]	; (80070b0 <HAL_MspInit+0x24>)
 8007092:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8007094:	4b06      	ldr	r3, [pc, #24]	; (80070b0 <HAL_MspInit+0x24>)
 8007096:	2101      	movs	r1, #1
 8007098:	430a      	orrs	r2, r1
 800709a:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();
 800709c:	4b04      	ldr	r3, [pc, #16]	; (80070b0 <HAL_MspInit+0x24>)
 800709e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80070a0:	4b03      	ldr	r3, [pc, #12]	; (80070b0 <HAL_MspInit+0x24>)
 80070a2:	2180      	movs	r1, #128	; 0x80
 80070a4:	0549      	lsls	r1, r1, #21
 80070a6:	430a      	orrs	r2, r1
 80070a8:	639a      	str	r2, [r3, #56]	; 0x38
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80070aa:	46c0      	nop			; (mov r8, r8)
 80070ac:	46bd      	mov	sp, r7
 80070ae:	bd80      	pop	{r7, pc}
 80070b0:	40021000 	.word	0x40021000

080070b4 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 80070b4:	b590      	push	{r4, r7, lr}
 80070b6:	b089      	sub	sp, #36	; 0x24
 80070b8:	af00      	add	r7, sp, #0
 80070ba:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80070bc:	240c      	movs	r4, #12
 80070be:	193b      	adds	r3, r7, r4
 80070c0:	0018      	movs	r0, r3
 80070c2:	2314      	movs	r3, #20
 80070c4:	001a      	movs	r2, r3
 80070c6:	2100      	movs	r1, #0
 80070c8:	f006 fcb5 	bl	800da36 <memset>
  if(hadc->Instance==ADC1)
 80070cc:	687b      	ldr	r3, [r7, #4]
 80070ce:	681b      	ldr	r3, [r3, #0]
 80070d0:	4a14      	ldr	r2, [pc, #80]	; (8007124 <HAL_ADC_MspInit+0x70>)
 80070d2:	4293      	cmp	r3, r2
 80070d4:	d122      	bne.n	800711c <HAL_ADC_MspInit+0x68>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
 80070d6:	4b14      	ldr	r3, [pc, #80]	; (8007128 <HAL_ADC_MspInit+0x74>)
 80070d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80070da:	4b13      	ldr	r3, [pc, #76]	; (8007128 <HAL_ADC_MspInit+0x74>)
 80070dc:	2180      	movs	r1, #128	; 0x80
 80070de:	0089      	lsls	r1, r1, #2
 80070e0:	430a      	orrs	r2, r1
 80070e2:	635a      	str	r2, [r3, #52]	; 0x34

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80070e4:	4b10      	ldr	r3, [pc, #64]	; (8007128 <HAL_ADC_MspInit+0x74>)
 80070e6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80070e8:	4b0f      	ldr	r3, [pc, #60]	; (8007128 <HAL_ADC_MspInit+0x74>)
 80070ea:	2101      	movs	r1, #1
 80070ec:	430a      	orrs	r2, r1
 80070ee:	62da      	str	r2, [r3, #44]	; 0x2c
 80070f0:	4b0d      	ldr	r3, [pc, #52]	; (8007128 <HAL_ADC_MspInit+0x74>)
 80070f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80070f4:	2201      	movs	r2, #1
 80070f6:	4013      	ands	r3, r2
 80070f8:	60bb      	str	r3, [r7, #8]
 80070fa:	68bb      	ldr	r3, [r7, #8]
    /**ADC GPIO Configuration
    PA0     ------> ADC_IN0
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 80070fc:	193b      	adds	r3, r7, r4
 80070fe:	2201      	movs	r2, #1
 8007100:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8007102:	193b      	adds	r3, r7, r4
 8007104:	2203      	movs	r2, #3
 8007106:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007108:	193b      	adds	r3, r7, r4
 800710a:	2200      	movs	r2, #0
 800710c:	609a      	str	r2, [r3, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800710e:	193a      	adds	r2, r7, r4
 8007110:	23a0      	movs	r3, #160	; 0xa0
 8007112:	05db      	lsls	r3, r3, #23
 8007114:	0011      	movs	r1, r2
 8007116:	0018      	movs	r0, r3
 8007118:	f001 f9a0 	bl	800845c <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 800711c:	46c0      	nop			; (mov r8, r8)
 800711e:	46bd      	mov	sp, r7
 8007120:	b009      	add	sp, #36	; 0x24
 8007122:	bd90      	pop	{r4, r7, pc}
 8007124:	40012400 	.word	0x40012400
 8007128:	40021000 	.word	0x40021000

0800712c <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 800712c:	b590      	push	{r4, r7, lr}
 800712e:	b089      	sub	sp, #36	; 0x24
 8007130:	af00      	add	r7, sp, #0
 8007132:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007134:	240c      	movs	r4, #12
 8007136:	193b      	adds	r3, r7, r4
 8007138:	0018      	movs	r0, r3
 800713a:	2314      	movs	r3, #20
 800713c:	001a      	movs	r2, r3
 800713e:	2100      	movs	r1, #0
 8007140:	f006 fc79 	bl	800da36 <memset>
  if(hi2c->Instance==I2C1)
 8007144:	687b      	ldr	r3, [r7, #4]
 8007146:	681b      	ldr	r3, [r3, #0]
 8007148:	4a18      	ldr	r2, [pc, #96]	; (80071ac <HAL_I2C_MspInit+0x80>)
 800714a:	4293      	cmp	r3, r2
 800714c:	d129      	bne.n	80071a2 <HAL_I2C_MspInit+0x76>
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800714e:	4b18      	ldr	r3, [pc, #96]	; (80071b0 <HAL_I2C_MspInit+0x84>)
 8007150:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007152:	4b17      	ldr	r3, [pc, #92]	; (80071b0 <HAL_I2C_MspInit+0x84>)
 8007154:	2102      	movs	r1, #2
 8007156:	430a      	orrs	r2, r1
 8007158:	62da      	str	r2, [r3, #44]	; 0x2c
 800715a:	4b15      	ldr	r3, [pc, #84]	; (80071b0 <HAL_I2C_MspInit+0x84>)
 800715c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800715e:	2202      	movs	r2, #2
 8007160:	4013      	ands	r3, r2
 8007162:	60bb      	str	r3, [r7, #8]
 8007164:	68bb      	ldr	r3, [r7, #8]
    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 8007166:	193b      	adds	r3, r7, r4
 8007168:	22c0      	movs	r2, #192	; 0xc0
 800716a:	0092      	lsls	r2, r2, #2
 800716c:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800716e:	0021      	movs	r1, r4
 8007170:	187b      	adds	r3, r7, r1
 8007172:	2212      	movs	r2, #18
 8007174:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8007176:	187b      	adds	r3, r7, r1
 8007178:	2201      	movs	r2, #1
 800717a:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800717c:	187b      	adds	r3, r7, r1
 800717e:	2203      	movs	r2, #3
 8007180:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8007182:	187b      	adds	r3, r7, r1
 8007184:	2204      	movs	r2, #4
 8007186:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007188:	187b      	adds	r3, r7, r1
 800718a:	4a0a      	ldr	r2, [pc, #40]	; (80071b4 <HAL_I2C_MspInit+0x88>)
 800718c:	0019      	movs	r1, r3
 800718e:	0010      	movs	r0, r2
 8007190:	f001 f964 	bl	800845c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8007194:	4b06      	ldr	r3, [pc, #24]	; (80071b0 <HAL_I2C_MspInit+0x84>)
 8007196:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8007198:	4b05      	ldr	r3, [pc, #20]	; (80071b0 <HAL_I2C_MspInit+0x84>)
 800719a:	2180      	movs	r1, #128	; 0x80
 800719c:	0389      	lsls	r1, r1, #14
 800719e:	430a      	orrs	r2, r1
 80071a0:	639a      	str	r2, [r3, #56]	; 0x38
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }

}
 80071a2:	46c0      	nop			; (mov r8, r8)
 80071a4:	46bd      	mov	sp, r7
 80071a6:	b009      	add	sp, #36	; 0x24
 80071a8:	bd90      	pop	{r4, r7, pc}
 80071aa:	46c0      	nop			; (mov r8, r8)
 80071ac:	40005400 	.word	0x40005400
 80071b0:	40021000 	.word	0x40021000
 80071b4:	50000400 	.word	0x50000400

080071b8 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 80071b8:	b590      	push	{r4, r7, lr}
 80071ba:	b08b      	sub	sp, #44	; 0x2c
 80071bc:	af00      	add	r7, sp, #0
 80071be:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80071c0:	2414      	movs	r4, #20
 80071c2:	193b      	adds	r3, r7, r4
 80071c4:	0018      	movs	r0, r3
 80071c6:	2314      	movs	r3, #20
 80071c8:	001a      	movs	r2, r3
 80071ca:	2100      	movs	r1, #0
 80071cc:	f006 fc33 	bl	800da36 <memset>
  if(hspi->Instance==SPI1)
 80071d0:	687b      	ldr	r3, [r7, #4]
 80071d2:	681b      	ldr	r3, [r3, #0]
 80071d4:	4a28      	ldr	r2, [pc, #160]	; (8007278 <HAL_SPI_MspInit+0xc0>)
 80071d6:	4293      	cmp	r3, r2
 80071d8:	d14a      	bne.n	8007270 <HAL_SPI_MspInit+0xb8>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 80071da:	4b28      	ldr	r3, [pc, #160]	; (800727c <HAL_SPI_MspInit+0xc4>)
 80071dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80071de:	4b27      	ldr	r3, [pc, #156]	; (800727c <HAL_SPI_MspInit+0xc4>)
 80071e0:	2180      	movs	r1, #128	; 0x80
 80071e2:	0149      	lsls	r1, r1, #5
 80071e4:	430a      	orrs	r2, r1
 80071e6:	635a      	str	r2, [r3, #52]	; 0x34

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80071e8:	4b24      	ldr	r3, [pc, #144]	; (800727c <HAL_SPI_MspInit+0xc4>)
 80071ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80071ec:	4b23      	ldr	r3, [pc, #140]	; (800727c <HAL_SPI_MspInit+0xc4>)
 80071ee:	2101      	movs	r1, #1
 80071f0:	430a      	orrs	r2, r1
 80071f2:	62da      	str	r2, [r3, #44]	; 0x2c
 80071f4:	4b21      	ldr	r3, [pc, #132]	; (800727c <HAL_SPI_MspInit+0xc4>)
 80071f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80071f8:	2201      	movs	r2, #1
 80071fa:	4013      	ands	r3, r2
 80071fc:	613b      	str	r3, [r7, #16]
 80071fe:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007200:	4b1e      	ldr	r3, [pc, #120]	; (800727c <HAL_SPI_MspInit+0xc4>)
 8007202:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007204:	4b1d      	ldr	r3, [pc, #116]	; (800727c <HAL_SPI_MspInit+0xc4>)
 8007206:	2102      	movs	r1, #2
 8007208:	430a      	orrs	r2, r1
 800720a:	62da      	str	r2, [r3, #44]	; 0x2c
 800720c:	4b1b      	ldr	r3, [pc, #108]	; (800727c <HAL_SPI_MspInit+0xc4>)
 800720e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007210:	2202      	movs	r2, #2
 8007212:	4013      	ands	r3, r2
 8007214:	60fb      	str	r3, [r7, #12]
 8007216:	68fb      	ldr	r3, [r7, #12]
    /**SPI1 GPIO Configuration
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    PB3     ------> SPI1_SCK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8007218:	193b      	adds	r3, r7, r4
 800721a:	22c0      	movs	r2, #192	; 0xc0
 800721c:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800721e:	193b      	adds	r3, r7, r4
 8007220:	2202      	movs	r2, #2
 8007222:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007224:	193b      	adds	r3, r7, r4
 8007226:	2200      	movs	r2, #0
 8007228:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800722a:	193b      	adds	r3, r7, r4
 800722c:	2203      	movs	r2, #3
 800722e:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;
 8007230:	193b      	adds	r3, r7, r4
 8007232:	2200      	movs	r2, #0
 8007234:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007236:	193a      	adds	r2, r7, r4
 8007238:	23a0      	movs	r3, #160	; 0xa0
 800723a:	05db      	lsls	r3, r3, #23
 800723c:	0011      	movs	r1, r2
 800723e:	0018      	movs	r0, r3
 8007240:	f001 f90c 	bl	800845c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8007244:	0021      	movs	r1, r4
 8007246:	187b      	adds	r3, r7, r1
 8007248:	2208      	movs	r2, #8
 800724a:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800724c:	187b      	adds	r3, r7, r1
 800724e:	2202      	movs	r2, #2
 8007250:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007252:	187b      	adds	r3, r7, r1
 8007254:	2200      	movs	r2, #0
 8007256:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8007258:	187b      	adds	r3, r7, r1
 800725a:	2203      	movs	r2, #3
 800725c:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;
 800725e:	187b      	adds	r3, r7, r1
 8007260:	2200      	movs	r2, #0
 8007262:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007264:	187b      	adds	r3, r7, r1
 8007266:	4a06      	ldr	r2, [pc, #24]	; (8007280 <HAL_SPI_MspInit+0xc8>)
 8007268:	0019      	movs	r1, r3
 800726a:	0010      	movs	r0, r2
 800726c:	f001 f8f6 	bl	800845c <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 8007270:	46c0      	nop			; (mov r8, r8)
 8007272:	46bd      	mov	sp, r7
 8007274:	b00b      	add	sp, #44	; 0x2c
 8007276:	bd90      	pop	{r4, r7, pc}
 8007278:	40013000 	.word	0x40013000
 800727c:	40021000 	.word	0x40021000
 8007280:	50000400 	.word	0x50000400

08007284 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 8007284:	b580      	push	{r7, lr}
 8007286:	b082      	sub	sp, #8
 8007288:	af00      	add	r7, sp, #0
 800728a:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM21)
 800728c:	687b      	ldr	r3, [r7, #4]
 800728e:	681b      	ldr	r3, [r3, #0]
 8007290:	4a0a      	ldr	r2, [pc, #40]	; (80072bc <HAL_TIM_Base_MspInit+0x38>)
 8007292:	4293      	cmp	r3, r2
 8007294:	d10d      	bne.n	80072b2 <HAL_TIM_Base_MspInit+0x2e>
  {
  /* USER CODE BEGIN TIM21_MspInit 0 */

  /* USER CODE END TIM21_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM21_CLK_ENABLE();
 8007296:	4b0a      	ldr	r3, [pc, #40]	; (80072c0 <HAL_TIM_Base_MspInit+0x3c>)
 8007298:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800729a:	4b09      	ldr	r3, [pc, #36]	; (80072c0 <HAL_TIM_Base_MspInit+0x3c>)
 800729c:	2104      	movs	r1, #4
 800729e:	430a      	orrs	r2, r1
 80072a0:	635a      	str	r2, [r3, #52]	; 0x34
    /* TIM21 interrupt Init */
    HAL_NVIC_SetPriority(TIM21_IRQn, 0, 0);
 80072a2:	2200      	movs	r2, #0
 80072a4:	2100      	movs	r1, #0
 80072a6:	2014      	movs	r0, #20
 80072a8:	f001 f88e 	bl	80083c8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM21_IRQn);
 80072ac:	2014      	movs	r0, #20
 80072ae:	f001 f8ab 	bl	8008408 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM21_MspInit 1 */

  /* USER CODE END TIM21_MspInit 1 */
  }

}
 80072b2:	46c0      	nop			; (mov r8, r8)
 80072b4:	46bd      	mov	sp, r7
 80072b6:	b002      	add	sp, #8
 80072b8:	bd80      	pop	{r7, pc}
 80072ba:	46c0      	nop			; (mov r8, r8)
 80072bc:	40010800 	.word	0x40010800
 80072c0:	40021000 	.word	0x40021000

080072c4 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80072c4:	b590      	push	{r4, r7, lr}
 80072c6:	b089      	sub	sp, #36	; 0x24
 80072c8:	af00      	add	r7, sp, #0
 80072ca:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80072cc:	240c      	movs	r4, #12
 80072ce:	193b      	adds	r3, r7, r4
 80072d0:	0018      	movs	r0, r3
 80072d2:	2314      	movs	r3, #20
 80072d4:	001a      	movs	r2, r3
 80072d6:	2100      	movs	r1, #0
 80072d8:	f006 fbad 	bl	800da36 <memset>
  if(huart->Instance==USART2)
 80072dc:	687b      	ldr	r3, [r7, #4]
 80072de:	681b      	ldr	r3, [r3, #0]
 80072e0:	4a18      	ldr	r2, [pc, #96]	; (8007344 <HAL_UART_MspInit+0x80>)
 80072e2:	4293      	cmp	r3, r2
 80072e4:	d129      	bne.n	800733a <HAL_UART_MspInit+0x76>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 80072e6:	4b18      	ldr	r3, [pc, #96]	; (8007348 <HAL_UART_MspInit+0x84>)
 80072e8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80072ea:	4b17      	ldr	r3, [pc, #92]	; (8007348 <HAL_UART_MspInit+0x84>)
 80072ec:	2180      	movs	r1, #128	; 0x80
 80072ee:	0289      	lsls	r1, r1, #10
 80072f0:	430a      	orrs	r2, r1
 80072f2:	639a      	str	r2, [r3, #56]	; 0x38

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80072f4:	4b14      	ldr	r3, [pc, #80]	; (8007348 <HAL_UART_MspInit+0x84>)
 80072f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80072f8:	4b13      	ldr	r3, [pc, #76]	; (8007348 <HAL_UART_MspInit+0x84>)
 80072fa:	2101      	movs	r1, #1
 80072fc:	430a      	orrs	r2, r1
 80072fe:	62da      	str	r2, [r3, #44]	; 0x2c
 8007300:	4b11      	ldr	r3, [pc, #68]	; (8007348 <HAL_UART_MspInit+0x84>)
 8007302:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007304:	2201      	movs	r2, #1
 8007306:	4013      	ands	r3, r2
 8007308:	60bb      	str	r3, [r7, #8]
 800730a:	68bb      	ldr	r3, [r7, #8]
    /**USART2 GPIO Configuration
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX
    */
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 800730c:	0021      	movs	r1, r4
 800730e:	187b      	adds	r3, r7, r1
 8007310:	220c      	movs	r2, #12
 8007312:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007314:	187b      	adds	r3, r7, r1
 8007316:	2202      	movs	r2, #2
 8007318:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800731a:	187b      	adds	r3, r7, r1
 800731c:	2200      	movs	r2, #0
 800731e:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8007320:	187b      	adds	r3, r7, r1
 8007322:	2203      	movs	r2, #3
 8007324:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_USART2;
 8007326:	187b      	adds	r3, r7, r1
 8007328:	2204      	movs	r2, #4
 800732a:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800732c:	187a      	adds	r2, r7, r1
 800732e:	23a0      	movs	r3, #160	; 0xa0
 8007330:	05db      	lsls	r3, r3, #23
 8007332:	0011      	movs	r1, r2
 8007334:	0018      	movs	r0, r3
 8007336:	f001 f891 	bl	800845c <HAL_GPIO_Init>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 800733a:	46c0      	nop			; (mov r8, r8)
 800733c:	46bd      	mov	sp, r7
 800733e:	b009      	add	sp, #36	; 0x24
 8007340:	bd90      	pop	{r4, r7, pc}
 8007342:	46c0      	nop			; (mov r8, r8)
 8007344:	40004400 	.word	0x40004400
 8007348:	40021000 	.word	0x40021000

0800734c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 800734c:	b580      	push	{r7, lr}
 800734e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8007350:	e7fe      	b.n	8007350 <NMI_Handler+0x4>

08007352 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8007352:	b580      	push	{r7, lr}
 8007354:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8007356:	e7fe      	b.n	8007356 <HardFault_Handler+0x4>

08007358 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8007358:	b580      	push	{r7, lr}
 800735a:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 800735c:	46c0      	nop			; (mov r8, r8)
 800735e:	46bd      	mov	sp, r7
 8007360:	bd80      	pop	{r7, pc}

08007362 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8007362:	b580      	push	{r7, lr}
 8007364:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8007366:	46c0      	nop			; (mov r8, r8)
 8007368:	46bd      	mov	sp, r7
 800736a:	bd80      	pop	{r7, pc}

0800736c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800736c:	b580      	push	{r7, lr}
 800736e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8007370:	f000 f8a6 	bl	80074c0 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8007374:	46c0      	nop			; (mov r8, r8)
 8007376:	46bd      	mov	sp, r7
 8007378:	bd80      	pop	{r7, pc}

0800737a <EXTI0_1_IRQHandler>:

/**
  * @brief This function handles EXTI line 0 and line 1 interrupts.
  */
void EXTI0_1_IRQHandler(void)
{
 800737a:	b580      	push	{r7, lr}
 800737c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI0_1_IRQn 0 */

  /* USER CODE END EXTI0_1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 800737e:	2001      	movs	r0, #1
 8007380:	f001 fb78 	bl	8008a74 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
 8007384:	2002      	movs	r0, #2
 8007386:	f001 fb75 	bl	8008a74 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI0_1_IRQn 1 */

  /* USER CODE END EXTI0_1_IRQn 1 */
}
 800738a:	46c0      	nop			; (mov r8, r8)
 800738c:	46bd      	mov	sp, r7
 800738e:	bd80      	pop	{r7, pc}

08007390 <EXTI4_15_IRQHandler>:

/**
  * @brief This function handles EXTI line 4 to 15 interrupts.
  */
void EXTI4_15_IRQHandler(void)
{
 8007390:	b580      	push	{r7, lr}
 8007392:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI4_15_IRQn 0 */

  /* USER CODE END EXTI4_15_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);
 8007394:	2010      	movs	r0, #16
 8007396:	f001 fb6d 	bl	8008a74 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI4_15_IRQn 1 */

  /* USER CODE END EXTI4_15_IRQn 1 */
}
 800739a:	46c0      	nop			; (mov r8, r8)
 800739c:	46bd      	mov	sp, r7
 800739e:	bd80      	pop	{r7, pc}

080073a0 <TIM21_IRQHandler>:

/**
  * @brief This function handles TIM21 global interrupt.
  */
void TIM21_IRQHandler(void)
{
 80073a0:	b580      	push	{r7, lr}
 80073a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM21_IRQn 0 */

  /* USER CODE END TIM21_IRQn 0 */
  HAL_TIM_IRQHandler(&htim21);
 80073a4:	4b03      	ldr	r3, [pc, #12]	; (80073b4 <TIM21_IRQHandler+0x14>)
 80073a6:	0018      	movs	r0, r3
 80073a8:	f004 fc48 	bl	800bc3c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM21_IRQn 1 */

  /* USER CODE END TIM21_IRQn 1 */
}
 80073ac:	46c0      	nop			; (mov r8, r8)
 80073ae:	46bd      	mov	sp, r7
 80073b0:	bd80      	pop	{r7, pc}
 80073b2:	46c0      	nop			; (mov r8, r8)
 80073b4:	200002e4 	.word	0x200002e4

080073b8 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 80073b8:	b580      	push	{r7, lr}
 80073ba:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location add offset address ------------------*/
#if defined (USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 80073bc:	46c0      	nop			; (mov r8, r8)
 80073be:	46bd      	mov	sp, r7
 80073c0:	bd80      	pop	{r7, pc}
	...

080073c4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 80073c4:	480d      	ldr	r0, [pc, #52]	; (80073fc <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 80073c6:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80073c8:	480d      	ldr	r0, [pc, #52]	; (8007400 <LoopForever+0x6>)
  ldr r1, =_edata
 80073ca:	490e      	ldr	r1, [pc, #56]	; (8007404 <LoopForever+0xa>)
  ldr r2, =_sidata
 80073cc:	4a0e      	ldr	r2, [pc, #56]	; (8007408 <LoopForever+0xe>)
  movs r3, #0
 80073ce:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80073d0:	e002      	b.n	80073d8 <LoopCopyDataInit>

080073d2 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80073d2:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80073d4:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80073d6:	3304      	adds	r3, #4

080073d8 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80073d8:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80073da:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80073dc:	d3f9      	bcc.n	80073d2 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80073de:	4a0b      	ldr	r2, [pc, #44]	; (800740c <LoopForever+0x12>)
  ldr r4, =_ebss
 80073e0:	4c0b      	ldr	r4, [pc, #44]	; (8007410 <LoopForever+0x16>)
  movs r3, #0
 80073e2:	2300      	movs	r3, #0
  b LoopFillZerobss
 80073e4:	e001      	b.n	80073ea <LoopFillZerobss>

080073e6 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80073e6:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80073e8:	3204      	adds	r2, #4

080073ea <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80073ea:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80073ec:	d3fb      	bcc.n	80073e6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 80073ee:	f7ff ffe3 	bl	80073b8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80073f2:	f006 faf3 	bl	800d9dc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80073f6:	f7fe fc85 	bl	8005d04 <main>

080073fa <LoopForever>:

LoopForever:
    b LoopForever
 80073fa:	e7fe      	b.n	80073fa <LoopForever>
   ldr   r0, =_estack
 80073fc:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 8007400:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8007404:	20000058 	.word	0x20000058
  ldr r2, =_sidata
 8007408:	0800f2b0 	.word	0x0800f2b0
  ldr r2, =_sbss
 800740c:	20000058 	.word	0x20000058
  ldr r4, =_ebss
 8007410:	20000518 	.word	0x20000518

08007414 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8007414:	e7fe      	b.n	8007414 <ADC1_COMP_IRQHandler>
	...

08007418 <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8007418:	b580      	push	{r7, lr}
 800741a:	b082      	sub	sp, #8
 800741c:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 800741e:	1dfb      	adds	r3, r7, #7
 8007420:	2200      	movs	r2, #0
 8007422:	701a      	strb	r2, [r3, #0]
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 8007424:	4b0b      	ldr	r3, [pc, #44]	; (8007454 <HAL_Init+0x3c>)
 8007426:	681a      	ldr	r2, [r3, #0]
 8007428:	4b0a      	ldr	r3, [pc, #40]	; (8007454 <HAL_Init+0x3c>)
 800742a:	2140      	movs	r1, #64	; 0x40
 800742c:	430a      	orrs	r2, r1
 800742e:	601a      	str	r2, [r3, #0]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8007430:	2000      	movs	r0, #0
 8007432:	f000 f811 	bl	8007458 <HAL_InitTick>
 8007436:	1e03      	subs	r3, r0, #0
 8007438:	d003      	beq.n	8007442 <HAL_Init+0x2a>
  {
    status = HAL_ERROR;
 800743a:	1dfb      	adds	r3, r7, #7
 800743c:	2201      	movs	r2, #1
 800743e:	701a      	strb	r2, [r3, #0]
 8007440:	e001      	b.n	8007446 <HAL_Init+0x2e>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8007442:	f7ff fe23 	bl	800708c <HAL_MspInit>
  }

  /* Return function status */
  return status;
 8007446:	1dfb      	adds	r3, r7, #7
 8007448:	781b      	ldrb	r3, [r3, #0]
}
 800744a:	0018      	movs	r0, r3
 800744c:	46bd      	mov	sp, r7
 800744e:	b002      	add	sp, #8
 8007450:	bd80      	pop	{r7, pc}
 8007452:	46c0      	nop			; (mov r8, r8)
 8007454:	40022000 	.word	0x40022000

08007458 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8007458:	b590      	push	{r4, r7, lr}
 800745a:	b083      	sub	sp, #12
 800745c:	af00      	add	r7, sp, #0
 800745e:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8007460:	4b14      	ldr	r3, [pc, #80]	; (80074b4 <HAL_InitTick+0x5c>)
 8007462:	681c      	ldr	r4, [r3, #0]
 8007464:	4b14      	ldr	r3, [pc, #80]	; (80074b8 <HAL_InitTick+0x60>)
 8007466:	781b      	ldrb	r3, [r3, #0]
 8007468:	0019      	movs	r1, r3
 800746a:	23fa      	movs	r3, #250	; 0xfa
 800746c:	0098      	lsls	r0, r3, #2
 800746e:	f7f8 fe4b 	bl	8000108 <__udivsi3>
 8007472:	0003      	movs	r3, r0
 8007474:	0019      	movs	r1, r3
 8007476:	0020      	movs	r0, r4
 8007478:	f7f8 fe46 	bl	8000108 <__udivsi3>
 800747c:	0003      	movs	r3, r0
 800747e:	0018      	movs	r0, r3
 8007480:	f000 ffde 	bl	8008440 <HAL_SYSTICK_Config>
 8007484:	1e03      	subs	r3, r0, #0
 8007486:	d001      	beq.n	800748c <HAL_InitTick+0x34>
  {
    return HAL_ERROR;
 8007488:	2301      	movs	r3, #1
 800748a:	e00f      	b.n	80074ac <HAL_InitTick+0x54>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800748c:	687b      	ldr	r3, [r7, #4]
 800748e:	2b03      	cmp	r3, #3
 8007490:	d80b      	bhi.n	80074aa <HAL_InitTick+0x52>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8007492:	6879      	ldr	r1, [r7, #4]
 8007494:	2301      	movs	r3, #1
 8007496:	425b      	negs	r3, r3
 8007498:	2200      	movs	r2, #0
 800749a:	0018      	movs	r0, r3
 800749c:	f000 ff94 	bl	80083c8 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80074a0:	4b06      	ldr	r3, [pc, #24]	; (80074bc <HAL_InitTick+0x64>)
 80074a2:	687a      	ldr	r2, [r7, #4]
 80074a4:	601a      	str	r2, [r3, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 80074a6:	2300      	movs	r3, #0
 80074a8:	e000      	b.n	80074ac <HAL_InitTick+0x54>
    return HAL_ERROR;
 80074aa:	2301      	movs	r3, #1
}
 80074ac:	0018      	movs	r0, r3
 80074ae:	46bd      	mov	sp, r7
 80074b0:	b003      	add	sp, #12
 80074b2:	bd90      	pop	{r4, r7, pc}
 80074b4:	2000004c 	.word	0x2000004c
 80074b8:	20000054 	.word	0x20000054
 80074bc:	20000050 	.word	0x20000050

080074c0 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80074c0:	b580      	push	{r7, lr}
 80074c2:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 80074c4:	4b05      	ldr	r3, [pc, #20]	; (80074dc <HAL_IncTick+0x1c>)
 80074c6:	781b      	ldrb	r3, [r3, #0]
 80074c8:	001a      	movs	r2, r3
 80074ca:	4b05      	ldr	r3, [pc, #20]	; (80074e0 <HAL_IncTick+0x20>)
 80074cc:	681b      	ldr	r3, [r3, #0]
 80074ce:	18d2      	adds	r2, r2, r3
 80074d0:	4b03      	ldr	r3, [pc, #12]	; (80074e0 <HAL_IncTick+0x20>)
 80074d2:	601a      	str	r2, [r3, #0]
}
 80074d4:	46c0      	nop			; (mov r8, r8)
 80074d6:	46bd      	mov	sp, r7
 80074d8:	bd80      	pop	{r7, pc}
 80074da:	46c0      	nop			; (mov r8, r8)
 80074dc:	20000054 	.word	0x20000054
 80074e0:	20000514 	.word	0x20000514

080074e4 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80074e4:	b580      	push	{r7, lr}
 80074e6:	af00      	add	r7, sp, #0
  return uwTick;
 80074e8:	4b02      	ldr	r3, [pc, #8]	; (80074f4 <HAL_GetTick+0x10>)
 80074ea:	681b      	ldr	r3, [r3, #0]
}
 80074ec:	0018      	movs	r0, r3
 80074ee:	46bd      	mov	sp, r7
 80074f0:	bd80      	pop	{r7, pc}
 80074f2:	46c0      	nop			; (mov r8, r8)
 80074f4:	20000514 	.word	0x20000514

080074f8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80074f8:	b580      	push	{r7, lr}
 80074fa:	b084      	sub	sp, #16
 80074fc:	af00      	add	r7, sp, #0
 80074fe:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8007500:	f7ff fff0 	bl	80074e4 <HAL_GetTick>
 8007504:	0003      	movs	r3, r0
 8007506:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
 8007508:	687b      	ldr	r3, [r7, #4]
 800750a:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800750c:	68fb      	ldr	r3, [r7, #12]
 800750e:	3301      	adds	r3, #1
 8007510:	d005      	beq.n	800751e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8007512:	4b0a      	ldr	r3, [pc, #40]	; (800753c <HAL_Delay+0x44>)
 8007514:	781b      	ldrb	r3, [r3, #0]
 8007516:	001a      	movs	r2, r3
 8007518:	68fb      	ldr	r3, [r7, #12]
 800751a:	189b      	adds	r3, r3, r2
 800751c:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 800751e:	46c0      	nop			; (mov r8, r8)
 8007520:	f7ff ffe0 	bl	80074e4 <HAL_GetTick>
 8007524:	0002      	movs	r2, r0
 8007526:	68bb      	ldr	r3, [r7, #8]
 8007528:	1ad3      	subs	r3, r2, r3
 800752a:	68fa      	ldr	r2, [r7, #12]
 800752c:	429a      	cmp	r2, r3
 800752e:	d8f7      	bhi.n	8007520 <HAL_Delay+0x28>
  {
  }
}
 8007530:	46c0      	nop			; (mov r8, r8)
 8007532:	46c0      	nop			; (mov r8, r8)
 8007534:	46bd      	mov	sp, r7
 8007536:	b004      	add	sp, #16
 8007538:	bd80      	pop	{r7, pc}
 800753a:	46c0      	nop			; (mov r8, r8)
 800753c:	20000054 	.word	0x20000054

08007540 <HAL_ADC_Init>:
  *         function "HAL_ADCEx_EnableVREFINTTempSensor()" must be called similarilly.  
  * @param  hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8007540:	b580      	push	{r7, lr}
 8007542:	b082      	sub	sp, #8
 8007544:	af00      	add	r7, sp, #0
 8007546:	6078      	str	r0, [r7, #4]
 
  /* Check ADC handle */
  if(hadc == NULL)
 8007548:	687b      	ldr	r3, [r7, #4]
 800754a:	2b00      	cmp	r3, #0
 800754c:	d102      	bne.n	8007554 <HAL_ADC_Init+0x14>
  {
    return HAL_ERROR;
 800754e:	2301      	movs	r3, #1
 8007550:	f000 fb90 	bl	8007c74 <HAL_ADC_Init+0x734>
  }
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8007554:	687b      	ldr	r3, [r7, #4]
 8007556:	681b      	ldr	r3, [r3, #0]
 8007558:	4ac0      	ldr	r2, [pc, #768]	; (800785c <HAL_ADC_Init+0x31c>)
 800755a:	4293      	cmp	r3, r2
 800755c:	d006      	beq.n	800756c <HAL_ADC_Init+0x2c>
 800755e:	23ce      	movs	r3, #206	; 0xce
 8007560:	005a      	lsls	r2, r3, #1
 8007562:	4bbf      	ldr	r3, [pc, #764]	; (8007860 <HAL_ADC_Init+0x320>)
 8007564:	0011      	movs	r1, r2
 8007566:	0018      	movs	r0, r3
 8007568:	f7fe fe95 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
 800756c:	687b      	ldr	r3, [r7, #4]
 800756e:	685b      	ldr	r3, [r3, #4]
 8007570:	2b00      	cmp	r3, #0
 8007572:	d05f      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 8007574:	687b      	ldr	r3, [r7, #4]
 8007576:	685a      	ldr	r2, [r3, #4]
 8007578:	23c0      	movs	r3, #192	; 0xc0
 800757a:	061b      	lsls	r3, r3, #24
 800757c:	429a      	cmp	r2, r3
 800757e:	d059      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 8007580:	687b      	ldr	r3, [r7, #4]
 8007582:	685a      	ldr	r2, [r3, #4]
 8007584:	2380      	movs	r3, #128	; 0x80
 8007586:	05db      	lsls	r3, r3, #23
 8007588:	429a      	cmp	r2, r3
 800758a:	d053      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 800758c:	687b      	ldr	r3, [r7, #4]
 800758e:	685a      	ldr	r2, [r3, #4]
 8007590:	2380      	movs	r3, #128	; 0x80
 8007592:	061b      	lsls	r3, r3, #24
 8007594:	429a      	cmp	r2, r3
 8007596:	d04d      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 8007598:	687b      	ldr	r3, [r7, #4]
 800759a:	685b      	ldr	r3, [r3, #4]
 800759c:	2b00      	cmp	r3, #0
 800759e:	d049      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 80075a0:	687b      	ldr	r3, [r7, #4]
 80075a2:	685a      	ldr	r2, [r3, #4]
 80075a4:	2380      	movs	r3, #128	; 0x80
 80075a6:	02db      	lsls	r3, r3, #11
 80075a8:	429a      	cmp	r2, r3
 80075aa:	d043      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 80075ac:	687b      	ldr	r3, [r7, #4]
 80075ae:	685a      	ldr	r2, [r3, #4]
 80075b0:	2380      	movs	r3, #128	; 0x80
 80075b2:	031b      	lsls	r3, r3, #12
 80075b4:	429a      	cmp	r2, r3
 80075b6:	d03d      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 80075b8:	687b      	ldr	r3, [r7, #4]
 80075ba:	685a      	ldr	r2, [r3, #4]
 80075bc:	23c0      	movs	r3, #192	; 0xc0
 80075be:	031b      	lsls	r3, r3, #12
 80075c0:	429a      	cmp	r2, r3
 80075c2:	d037      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 80075c4:	687b      	ldr	r3, [r7, #4]
 80075c6:	685a      	ldr	r2, [r3, #4]
 80075c8:	2380      	movs	r3, #128	; 0x80
 80075ca:	035b      	lsls	r3, r3, #13
 80075cc:	429a      	cmp	r2, r3
 80075ce:	d031      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 80075d0:	687b      	ldr	r3, [r7, #4]
 80075d2:	685a      	ldr	r2, [r3, #4]
 80075d4:	23a0      	movs	r3, #160	; 0xa0
 80075d6:	035b      	lsls	r3, r3, #13
 80075d8:	429a      	cmp	r2, r3
 80075da:	d02b      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 80075dc:	687b      	ldr	r3, [r7, #4]
 80075de:	685a      	ldr	r2, [r3, #4]
 80075e0:	23c0      	movs	r3, #192	; 0xc0
 80075e2:	035b      	lsls	r3, r3, #13
 80075e4:	429a      	cmp	r2, r3
 80075e6:	d025      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 80075e8:	687b      	ldr	r3, [r7, #4]
 80075ea:	685a      	ldr	r2, [r3, #4]
 80075ec:	23e0      	movs	r3, #224	; 0xe0
 80075ee:	035b      	lsls	r3, r3, #13
 80075f0:	429a      	cmp	r2, r3
 80075f2:	d01f      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 80075f4:	687b      	ldr	r3, [r7, #4]
 80075f6:	685a      	ldr	r2, [r3, #4]
 80075f8:	2380      	movs	r3, #128	; 0x80
 80075fa:	039b      	lsls	r3, r3, #14
 80075fc:	429a      	cmp	r2, r3
 80075fe:	d019      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 8007600:	687b      	ldr	r3, [r7, #4]
 8007602:	685a      	ldr	r2, [r3, #4]
 8007604:	2390      	movs	r3, #144	; 0x90
 8007606:	039b      	lsls	r3, r3, #14
 8007608:	429a      	cmp	r2, r3
 800760a:	d013      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 800760c:	687b      	ldr	r3, [r7, #4]
 800760e:	685a      	ldr	r2, [r3, #4]
 8007610:	23a0      	movs	r3, #160	; 0xa0
 8007612:	039b      	lsls	r3, r3, #14
 8007614:	429a      	cmp	r2, r3
 8007616:	d00d      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 8007618:	687b      	ldr	r3, [r7, #4]
 800761a:	685a      	ldr	r2, [r3, #4]
 800761c:	23b0      	movs	r3, #176	; 0xb0
 800761e:	039b      	lsls	r3, r3, #14
 8007620:	429a      	cmp	r2, r3
 8007622:	d007      	beq.n	8007634 <HAL_ADC_Init+0xf4>
 8007624:	239e      	movs	r3, #158	; 0x9e
 8007626:	33ff      	adds	r3, #255	; 0xff
 8007628:	001a      	movs	r2, r3
 800762a:	4b8d      	ldr	r3, [pc, #564]	; (8007860 <HAL_ADC_Init+0x320>)
 800762c:	0011      	movs	r1, r2
 800762e:	0018      	movs	r0, r3
 8007630:	f7fe fe31 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
 8007634:	687b      	ldr	r3, [r7, #4]
 8007636:	689b      	ldr	r3, [r3, #8]
 8007638:	2b00      	cmp	r3, #0
 800763a:	d012      	beq.n	8007662 <HAL_ADC_Init+0x122>
 800763c:	687b      	ldr	r3, [r7, #4]
 800763e:	689b      	ldr	r3, [r3, #8]
 8007640:	2b08      	cmp	r3, #8
 8007642:	d00e      	beq.n	8007662 <HAL_ADC_Init+0x122>
 8007644:	687b      	ldr	r3, [r7, #4]
 8007646:	689b      	ldr	r3, [r3, #8]
 8007648:	2b10      	cmp	r3, #16
 800764a:	d00a      	beq.n	8007662 <HAL_ADC_Init+0x122>
 800764c:	687b      	ldr	r3, [r7, #4]
 800764e:	689b      	ldr	r3, [r3, #8]
 8007650:	2b18      	cmp	r3, #24
 8007652:	d006      	beq.n	8007662 <HAL_ADC_Init+0x122>
 8007654:	23cf      	movs	r3, #207	; 0xcf
 8007656:	005a      	lsls	r2, r3, #1
 8007658:	4b81      	ldr	r3, [pc, #516]	; (8007860 <HAL_ADC_Init+0x320>)
 800765a:	0011      	movs	r1, r2
 800765c:	0018      	movs	r0, r3
 800765e:	f7fe fe1a 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
 8007662:	687b      	ldr	r3, [r7, #4]
 8007664:	68db      	ldr	r3, [r3, #12]
 8007666:	2b00      	cmp	r3, #0
 8007668:	d00b      	beq.n	8007682 <HAL_ADC_Init+0x142>
 800766a:	687b      	ldr	r3, [r7, #4]
 800766c:	68db      	ldr	r3, [r3, #12]
 800766e:	2b20      	cmp	r3, #32
 8007670:	d007      	beq.n	8007682 <HAL_ADC_Init+0x142>
 8007672:	23a0      	movs	r3, #160	; 0xa0
 8007674:	33ff      	adds	r3, #255	; 0xff
 8007676:	001a      	movs	r2, r3
 8007678:	4b79      	ldr	r3, [pc, #484]	; (8007860 <HAL_ADC_Init+0x320>)
 800767a:	0011      	movs	r1, r2
 800767c:	0018      	movs	r0, r3
 800767e:	f7fe fe0a 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
 8007682:	687b      	ldr	r3, [r7, #4]
 8007684:	691b      	ldr	r3, [r3, #16]
 8007686:	2b01      	cmp	r3, #1
 8007688:	d00a      	beq.n	80076a0 <HAL_ADC_Init+0x160>
 800768a:	687b      	ldr	r3, [r7, #4]
 800768c:	691b      	ldr	r3, [r3, #16]
 800768e:	2b02      	cmp	r3, #2
 8007690:	d006      	beq.n	80076a0 <HAL_ADC_Init+0x160>
 8007692:	23d0      	movs	r3, #208	; 0xd0
 8007694:	005a      	lsls	r2, r3, #1
 8007696:	4b72      	ldr	r3, [pc, #456]	; (8007860 <HAL_ADC_Init+0x320>)
 8007698:	0011      	movs	r1, r2
 800769a:	0018      	movs	r0, r3
 800769c:	f7fe fdfb 	bl	8006296 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 80076a0:	687b      	ldr	r3, [r7, #4]
 80076a2:	2220      	movs	r2, #32
 80076a4:	5c9b      	ldrb	r3, [r3, r2]
 80076a6:	2b00      	cmp	r3, #0
 80076a8:	d00c      	beq.n	80076c4 <HAL_ADC_Init+0x184>
 80076aa:	687b      	ldr	r3, [r7, #4]
 80076ac:	2220      	movs	r2, #32
 80076ae:	5c9b      	ldrb	r3, [r3, r2]
 80076b0:	2b01      	cmp	r3, #1
 80076b2:	d007      	beq.n	80076c4 <HAL_ADC_Init+0x184>
 80076b4:	23a2      	movs	r3, #162	; 0xa2
 80076b6:	33ff      	adds	r3, #255	; 0xff
 80076b8:	001a      	movs	r2, r3
 80076ba:	4b69      	ldr	r3, [pc, #420]	; (8007860 <HAL_ADC_Init+0x320>)
 80076bc:	0011      	movs	r1, r2
 80076be:	0018      	movs	r0, r3
 80076c0:	f7fe fde9 	bl	8006296 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
 80076c4:	687b      	ldr	r3, [r7, #4]
 80076c6:	2221      	movs	r2, #33	; 0x21
 80076c8:	5c9b      	ldrb	r3, [r3, r2]
 80076ca:	2b00      	cmp	r3, #0
 80076cc:	d00b      	beq.n	80076e6 <HAL_ADC_Init+0x1a6>
 80076ce:	687b      	ldr	r3, [r7, #4]
 80076d0:	2221      	movs	r2, #33	; 0x21
 80076d2:	5c9b      	ldrb	r3, [r3, r2]
 80076d4:	2b01      	cmp	r3, #1
 80076d6:	d006      	beq.n	80076e6 <HAL_ADC_Init+0x1a6>
 80076d8:	23d1      	movs	r3, #209	; 0xd1
 80076da:	005a      	lsls	r2, r3, #1
 80076dc:	4b60      	ldr	r3, [pc, #384]	; (8007860 <HAL_ADC_Init+0x320>)
 80076de:	0011      	movs	r1, r2
 80076e0:	0018      	movs	r0, r3
 80076e2:	f7fe fdd8 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
 80076e6:	687b      	ldr	r3, [r7, #4]
 80076e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80076ea:	2b00      	cmp	r3, #0
 80076ec:	d019      	beq.n	8007722 <HAL_ADC_Init+0x1e2>
 80076ee:	687b      	ldr	r3, [r7, #4]
 80076f0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80076f2:	2380      	movs	r3, #128	; 0x80
 80076f4:	00db      	lsls	r3, r3, #3
 80076f6:	429a      	cmp	r2, r3
 80076f8:	d013      	beq.n	8007722 <HAL_ADC_Init+0x1e2>
 80076fa:	687b      	ldr	r3, [r7, #4]
 80076fc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80076fe:	2380      	movs	r3, #128	; 0x80
 8007700:	011b      	lsls	r3, r3, #4
 8007702:	429a      	cmp	r2, r3
 8007704:	d00d      	beq.n	8007722 <HAL_ADC_Init+0x1e2>
 8007706:	687b      	ldr	r3, [r7, #4]
 8007708:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800770a:	23c0      	movs	r3, #192	; 0xc0
 800770c:	011b      	lsls	r3, r3, #4
 800770e:	429a      	cmp	r2, r3
 8007710:	d007      	beq.n	8007722 <HAL_ADC_Init+0x1e2>
 8007712:	23a4      	movs	r3, #164	; 0xa4
 8007714:	33ff      	adds	r3, #255	; 0xff
 8007716:	001a      	movs	r2, r3
 8007718:	4b51      	ldr	r3, [pc, #324]	; (8007860 <HAL_ADC_Init+0x320>)
 800771a:	0011      	movs	r1, r2
 800771c:	0018      	movs	r0, r3
 800771e:	f7fe fdba 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
 8007722:	687b      	ldr	r3, [r7, #4]
 8007724:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007726:	2b00      	cmp	r3, #0
 8007728:	d036      	beq.n	8007798 <HAL_ADC_Init+0x258>
 800772a:	687b      	ldr	r3, [r7, #4]
 800772c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800772e:	2b40      	cmp	r3, #64	; 0x40
 8007730:	d032      	beq.n	8007798 <HAL_ADC_Init+0x258>
 8007732:	687b      	ldr	r3, [r7, #4]
 8007734:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007736:	2b80      	cmp	r3, #128	; 0x80
 8007738:	d02e      	beq.n	8007798 <HAL_ADC_Init+0x258>
 800773a:	687b      	ldr	r3, [r7, #4]
 800773c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800773e:	2bc0      	cmp	r3, #192	; 0xc0
 8007740:	d02a      	beq.n	8007798 <HAL_ADC_Init+0x258>
 8007742:	687b      	ldr	r3, [r7, #4]
 8007744:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007746:	2380      	movs	r3, #128	; 0x80
 8007748:	005b      	lsls	r3, r3, #1
 800774a:	429a      	cmp	r2, r3
 800774c:	d024      	beq.n	8007798 <HAL_ADC_Init+0x258>
 800774e:	687b      	ldr	r3, [r7, #4]
 8007750:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007752:	2380      	movs	r3, #128	; 0x80
 8007754:	005b      	lsls	r3, r3, #1
 8007756:	429a      	cmp	r2, r3
 8007758:	d01e      	beq.n	8007798 <HAL_ADC_Init+0x258>
 800775a:	687b      	ldr	r3, [r7, #4]
 800775c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800775e:	23a0      	movs	r3, #160	; 0xa0
 8007760:	005b      	lsls	r3, r3, #1
 8007762:	429a      	cmp	r2, r3
 8007764:	d018      	beq.n	8007798 <HAL_ADC_Init+0x258>
 8007766:	687b      	ldr	r3, [r7, #4]
 8007768:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800776a:	23c0      	movs	r3, #192	; 0xc0
 800776c:	005b      	lsls	r3, r3, #1
 800776e:	429a      	cmp	r2, r3
 8007770:	d012      	beq.n	8007798 <HAL_ADC_Init+0x258>
 8007772:	687b      	ldr	r3, [r7, #4]
 8007774:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007776:	23e0      	movs	r3, #224	; 0xe0
 8007778:	005b      	lsls	r3, r3, #1
 800777a:	429a      	cmp	r2, r3
 800777c:	d00c      	beq.n	8007798 <HAL_ADC_Init+0x258>
 800777e:	687b      	ldr	r3, [r7, #4]
 8007780:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007782:	23c2      	movs	r3, #194	; 0xc2
 8007784:	33ff      	adds	r3, #255	; 0xff
 8007786:	429a      	cmp	r2, r3
 8007788:	d006      	beq.n	8007798 <HAL_ADC_Init+0x258>
 800778a:	23d2      	movs	r3, #210	; 0xd2
 800778c:	005a      	lsls	r2, r3, #1
 800778e:	4b34      	ldr	r3, [pc, #208]	; (8007860 <HAL_ADC_Init+0x320>)
 8007790:	0011      	movs	r1, r2
 8007792:	0018      	movs	r0, r3
 8007794:	f7fe fd7f 	bl	8006296 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
 8007798:	687b      	ldr	r3, [r7, #4]
 800779a:	222c      	movs	r2, #44	; 0x2c
 800779c:	5c9b      	ldrb	r3, [r3, r2]
 800779e:	2b00      	cmp	r3, #0
 80077a0:	d00c      	beq.n	80077bc <HAL_ADC_Init+0x27c>
 80077a2:	687b      	ldr	r3, [r7, #4]
 80077a4:	222c      	movs	r2, #44	; 0x2c
 80077a6:	5c9b      	ldrb	r3, [r3, r2]
 80077a8:	2b01      	cmp	r3, #1
 80077aa:	d007      	beq.n	80077bc <HAL_ADC_Init+0x27c>
 80077ac:	23a6      	movs	r3, #166	; 0xa6
 80077ae:	33ff      	adds	r3, #255	; 0xff
 80077b0:	001a      	movs	r2, r3
 80077b2:	4b2b      	ldr	r3, [pc, #172]	; (8007860 <HAL_ADC_Init+0x320>)
 80077b4:	0011      	movs	r1, r2
 80077b6:	0018      	movs	r0, r3
 80077b8:	f7fe fd6d 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 80077bc:	687b      	ldr	r3, [r7, #4]
 80077be:	695b      	ldr	r3, [r3, #20]
 80077c0:	2b04      	cmp	r3, #4
 80077c2:	d00a      	beq.n	80077da <HAL_ADC_Init+0x29a>
 80077c4:	687b      	ldr	r3, [r7, #4]
 80077c6:	695b      	ldr	r3, [r3, #20]
 80077c8:	2b08      	cmp	r3, #8
 80077ca:	d006      	beq.n	80077da <HAL_ADC_Init+0x29a>
 80077cc:	23d3      	movs	r3, #211	; 0xd3
 80077ce:	005a      	lsls	r2, r3, #1
 80077d0:	4b23      	ldr	r3, [pc, #140]	; (8007860 <HAL_ADC_Init+0x320>)
 80077d2:	0011      	movs	r1, r2
 80077d4:	0018      	movs	r0, r3
 80077d6:	f7fe fd5e 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
 80077da:	687b      	ldr	r3, [r7, #4]
 80077dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80077de:	2b00      	cmp	r3, #0
 80077e0:	d00d      	beq.n	80077fe <HAL_ADC_Init+0x2be>
 80077e2:	687b      	ldr	r3, [r7, #4]
 80077e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80077e6:	2380      	movs	r3, #128	; 0x80
 80077e8:	015b      	lsls	r3, r3, #5
 80077ea:	429a      	cmp	r2, r3
 80077ec:	d007      	beq.n	80077fe <HAL_ADC_Init+0x2be>
 80077ee:	23a8      	movs	r3, #168	; 0xa8
 80077f0:	33ff      	adds	r3, #255	; 0xff
 80077f2:	001a      	movs	r2, r3
 80077f4:	4b1a      	ldr	r3, [pc, #104]	; (8007860 <HAL_ADC_Init+0x320>)
 80077f6:	0011      	movs	r1, r2
 80077f8:	0018      	movs	r0, r3
 80077fa:	f7fe fd4c 	bl	8006296 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
 80077fe:	687b      	ldr	r3, [r7, #4]
 8007800:	699b      	ldr	r3, [r3, #24]
 8007802:	2b00      	cmp	r3, #0
 8007804:	d00a      	beq.n	800781c <HAL_ADC_Init+0x2dc>
 8007806:	687b      	ldr	r3, [r7, #4]
 8007808:	699b      	ldr	r3, [r3, #24]
 800780a:	2b01      	cmp	r3, #1
 800780c:	d006      	beq.n	800781c <HAL_ADC_Init+0x2dc>
 800780e:	23d4      	movs	r3, #212	; 0xd4
 8007810:	005a      	lsls	r2, r3, #1
 8007812:	4b13      	ldr	r3, [pc, #76]	; (8007860 <HAL_ADC_Init+0x320>)
 8007814:	0011      	movs	r1, r2
 8007816:	0018      	movs	r0, r3
 8007818:	f7fe fd3d 	bl	8006296 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerFrequencyMode));
 800781c:	687b      	ldr	r3, [r7, #4]
 800781e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007820:	2b00      	cmp	r3, #0
 8007822:	d00b      	beq.n	800783c <HAL_ADC_Init+0x2fc>
 8007824:	687b      	ldr	r3, [r7, #4]
 8007826:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007828:	2b01      	cmp	r3, #1
 800782a:	d007      	beq.n	800783c <HAL_ADC_Init+0x2fc>
 800782c:	23aa      	movs	r3, #170	; 0xaa
 800782e:	33ff      	adds	r3, #255	; 0xff
 8007830:	001a      	movs	r2, r3
 8007832:	4b0b      	ldr	r3, [pc, #44]	; (8007860 <HAL_ADC_Init+0x320>)
 8007834:	0011      	movs	r1, r2
 8007836:	0018      	movs	r0, r3
 8007838:	f7fe fd2d 	bl	8006296 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoPowerOff));
 800783c:	687b      	ldr	r3, [r7, #4]
 800783e:	69db      	ldr	r3, [r3, #28]
 8007840:	2b00      	cmp	r3, #0
 8007842:	d00f      	beq.n	8007864 <HAL_ADC_Init+0x324>
 8007844:	687b      	ldr	r3, [r7, #4]
 8007846:	69db      	ldr	r3, [r3, #28]
 8007848:	2b01      	cmp	r3, #1
 800784a:	d00b      	beq.n	8007864 <HAL_ADC_Init+0x324>
 800784c:	23d5      	movs	r3, #213	; 0xd5
 800784e:	005a      	lsls	r2, r3, #1
 8007850:	4b03      	ldr	r3, [pc, #12]	; (8007860 <HAL_ADC_Init+0x320>)
 8007852:	0011      	movs	r1, r2
 8007854:	0018      	movs	r0, r3
 8007856:	f7fe fd1e 	bl	8006296 <assert_failed>
 800785a:	e003      	b.n	8007864 <HAL_ADC_Init+0x324>
 800785c:	40012400 	.word	0x40012400
 8007860:	0800dd3c 	.word	0x0800dd3c
  assert_param(IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTime));
 8007864:	687b      	ldr	r3, [r7, #4]
 8007866:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007868:	2b00      	cmp	r3, #0
 800786a:	d023      	beq.n	80078b4 <HAL_ADC_Init+0x374>
 800786c:	687b      	ldr	r3, [r7, #4]
 800786e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007870:	2b01      	cmp	r3, #1
 8007872:	d01f      	beq.n	80078b4 <HAL_ADC_Init+0x374>
 8007874:	687b      	ldr	r3, [r7, #4]
 8007876:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007878:	2b02      	cmp	r3, #2
 800787a:	d01b      	beq.n	80078b4 <HAL_ADC_Init+0x374>
 800787c:	687b      	ldr	r3, [r7, #4]
 800787e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007880:	2b03      	cmp	r3, #3
 8007882:	d017      	beq.n	80078b4 <HAL_ADC_Init+0x374>
 8007884:	687b      	ldr	r3, [r7, #4]
 8007886:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007888:	2b04      	cmp	r3, #4
 800788a:	d013      	beq.n	80078b4 <HAL_ADC_Init+0x374>
 800788c:	687b      	ldr	r3, [r7, #4]
 800788e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007890:	2b05      	cmp	r3, #5
 8007892:	d00f      	beq.n	80078b4 <HAL_ADC_Init+0x374>
 8007894:	687b      	ldr	r3, [r7, #4]
 8007896:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007898:	2b06      	cmp	r3, #6
 800789a:	d00b      	beq.n	80078b4 <HAL_ADC_Init+0x374>
 800789c:	687b      	ldr	r3, [r7, #4]
 800789e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80078a0:	2b07      	cmp	r3, #7
 80078a2:	d007      	beq.n	80078b4 <HAL_ADC_Init+0x374>
 80078a4:	23ac      	movs	r3, #172	; 0xac
 80078a6:	33ff      	adds	r3, #255	; 0xff
 80078a8:	001a      	movs	r2, r3
 80078aa:	4bd3      	ldr	r3, [pc, #844]	; (8007bf8 <HAL_ADC_Init+0x6b8>)
 80078ac:	0011      	movs	r1, r2
 80078ae:	0018      	movs	r0, r3
 80078b0:	f7fe fcf1 	bl	8006296 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
 80078b4:	687b      	ldr	r3, [r7, #4]
 80078b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80078b8:	2b00      	cmp	r3, #0
 80078ba:	d00a      	beq.n	80078d2 <HAL_ADC_Init+0x392>
 80078bc:	687b      	ldr	r3, [r7, #4]
 80078be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80078c0:	2b01      	cmp	r3, #1
 80078c2:	d006      	beq.n	80078d2 <HAL_ADC_Init+0x392>
 80078c4:	23d6      	movs	r3, #214	; 0xd6
 80078c6:	005a      	lsls	r2, r3, #1
 80078c8:	4bcb      	ldr	r3, [pc, #812]	; (8007bf8 <HAL_ADC_Init+0x6b8>)
 80078ca:	0011      	movs	r1, r2
 80078cc:	0018      	movs	r0, r3
 80078ce:	f7fe fce2 	bl	8006296 <assert_failed>
  /* Refer to header of this file for more details on clock enabling procedure*/
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  /* - ADC voltage regulator enable                                           */
  if(hadc->State == HAL_ADC_STATE_RESET)
 80078d2:	687b      	ldr	r3, [r7, #4]
 80078d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80078d6:	2b00      	cmp	r3, #0
 80078d8:	d10a      	bne.n	80078f0 <HAL_ADC_Init+0x3b0>
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
 80078da:	687b      	ldr	r3, [r7, #4]
 80078dc:	2200      	movs	r2, #0
 80078de:	659a      	str	r2, [r3, #88]	; 0x58
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 80078e0:	687b      	ldr	r3, [r7, #4]
 80078e2:	2250      	movs	r2, #80	; 0x50
 80078e4:	2100      	movs	r1, #0
 80078e6:	5499      	strb	r1, [r3, r2]
    
    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 80078e8:	687b      	ldr	r3, [r7, #4]
 80078ea:	0018      	movs	r0, r3
 80078ec:	f7ff fbe2 	bl	80070b4 <HAL_ADC_MspInit>
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  /* and if there is no conversion on going on regular group (ADC can be      */
  /* enabled anyway, in case of call of this function to update a parameter   */
  /* on the fly).                                                             */
  if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) ||
 80078f0:	687b      	ldr	r3, [r7, #4]
 80078f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80078f4:	2210      	movs	r2, #16
 80078f6:	4013      	ands	r3, r2
 80078f8:	2b10      	cmp	r3, #16
 80078fa:	d005      	beq.n	8007908 <HAL_ADC_Init+0x3c8>
     (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) != RESET)  )
 80078fc:	687b      	ldr	r3, [r7, #4]
 80078fe:	681b      	ldr	r3, [r3, #0]
 8007900:	689b      	ldr	r3, [r3, #8]
 8007902:	2204      	movs	r2, #4
 8007904:	4013      	ands	r3, r2
  if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) ||
 8007906:	d00b      	beq.n	8007920 <HAL_ADC_Init+0x3e0>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007908:	687b      	ldr	r3, [r7, #4]
 800790a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800790c:	2210      	movs	r2, #16
 800790e:	431a      	orrs	r2, r3
 8007910:	687b      	ldr	r3, [r7, #4]
 8007912:	655a      	str	r2, [r3, #84]	; 0x54
        
    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8007914:	687b      	ldr	r3, [r7, #4]
 8007916:	2250      	movs	r2, #80	; 0x50
 8007918:	2100      	movs	r1, #0
 800791a:	5499      	strb	r1, [r3, r2]
    return HAL_ERROR;
 800791c:	2301      	movs	r3, #1
 800791e:	e1a9      	b.n	8007c74 <HAL_ADC_Init+0x734>
  }

  /* Set ADC state */
  ADC_STATE_CLR_SET(hadc->State,
 8007920:	687b      	ldr	r3, [r7, #4]
 8007922:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007924:	4ab5      	ldr	r2, [pc, #724]	; (8007bfc <HAL_ADC_Init+0x6bc>)
 8007926:	4013      	ands	r3, r2
 8007928:	2202      	movs	r2, #2
 800792a:	431a      	orrs	r2, r3
 800792c:	687b      	ldr	r3, [r7, #4]
 800792e:	655a      	str	r2, [r3, #84]	; 0x54
  /* Parameters update conditioned to ADC state:                            */
  /* Parameters that can be updated only when ADC is disabled:              */
  /*  - ADC clock mode                                                      */
  /*  - ADC clock prescaler                                                 */
  /*  - ADC Resolution                                                      */
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007930:	687b      	ldr	r3, [r7, #4]
 8007932:	681b      	ldr	r3, [r3, #0]
 8007934:	689b      	ldr	r3, [r3, #8]
 8007936:	2203      	movs	r2, #3
 8007938:	4013      	ands	r3, r2
 800793a:	2b01      	cmp	r3, #1
 800793c:	d108      	bne.n	8007950 <HAL_ADC_Init+0x410>
 800793e:	687b      	ldr	r3, [r7, #4]
 8007940:	681b      	ldr	r3, [r3, #0]
 8007942:	681b      	ldr	r3, [r3, #0]
 8007944:	2201      	movs	r2, #1
 8007946:	4013      	ands	r3, r2
 8007948:	2b01      	cmp	r3, #1
 800794a:	d101      	bne.n	8007950 <HAL_ADC_Init+0x410>
 800794c:	2301      	movs	r3, #1
 800794e:	e000      	b.n	8007952 <HAL_ADC_Init+0x412>
 8007950:	2300      	movs	r3, #0
 8007952:	2b00      	cmp	r3, #0
 8007954:	d149      	bne.n	80079ea <HAL_ADC_Init+0x4aa>
    /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
    /*     (set into HAL_ADC_ConfigChannel() )                              */
   
    /* Configuration of ADC clock: clock source PCLK or asynchronous with 
    selectable prescaler */
    __HAL_ADC_CLOCK_PRESCALER(hadc);
 8007956:	687b      	ldr	r3, [r7, #4]
 8007958:	685a      	ldr	r2, [r3, #4]
 800795a:	23c0      	movs	r3, #192	; 0xc0
 800795c:	061b      	lsls	r3, r3, #24
 800795e:	429a      	cmp	r2, r3
 8007960:	d00b      	beq.n	800797a <HAL_ADC_Init+0x43a>
 8007962:	687b      	ldr	r3, [r7, #4]
 8007964:	685a      	ldr	r2, [r3, #4]
 8007966:	2380      	movs	r3, #128	; 0x80
 8007968:	05db      	lsls	r3, r3, #23
 800796a:	429a      	cmp	r2, r3
 800796c:	d005      	beq.n	800797a <HAL_ADC_Init+0x43a>
 800796e:	687b      	ldr	r3, [r7, #4]
 8007970:	685a      	ldr	r2, [r3, #4]
 8007972:	2380      	movs	r3, #128	; 0x80
 8007974:	061b      	lsls	r3, r3, #24
 8007976:	429a      	cmp	r2, r3
 8007978:	d111      	bne.n	800799e <HAL_ADC_Init+0x45e>
 800797a:	687b      	ldr	r3, [r7, #4]
 800797c:	681b      	ldr	r3, [r3, #0]
 800797e:	691a      	ldr	r2, [r3, #16]
 8007980:	687b      	ldr	r3, [r7, #4]
 8007982:	681b      	ldr	r3, [r3, #0]
 8007984:	0092      	lsls	r2, r2, #2
 8007986:	0892      	lsrs	r2, r2, #2
 8007988:	611a      	str	r2, [r3, #16]
 800798a:	687b      	ldr	r3, [r7, #4]
 800798c:	681b      	ldr	r3, [r3, #0]
 800798e:	6919      	ldr	r1, [r3, #16]
 8007990:	687b      	ldr	r3, [r7, #4]
 8007992:	685a      	ldr	r2, [r3, #4]
 8007994:	687b      	ldr	r3, [r7, #4]
 8007996:	681b      	ldr	r3, [r3, #0]
 8007998:	430a      	orrs	r2, r1
 800799a:	611a      	str	r2, [r3, #16]
 800799c:	e014      	b.n	80079c8 <HAL_ADC_Init+0x488>
 800799e:	687b      	ldr	r3, [r7, #4]
 80079a0:	681b      	ldr	r3, [r3, #0]
 80079a2:	691a      	ldr	r2, [r3, #16]
 80079a4:	687b      	ldr	r3, [r7, #4]
 80079a6:	681b      	ldr	r3, [r3, #0]
 80079a8:	0092      	lsls	r2, r2, #2
 80079aa:	0892      	lsrs	r2, r2, #2
 80079ac:	611a      	str	r2, [r3, #16]
 80079ae:	4b94      	ldr	r3, [pc, #592]	; (8007c00 <HAL_ADC_Init+0x6c0>)
 80079b0:	681a      	ldr	r2, [r3, #0]
 80079b2:	4b93      	ldr	r3, [pc, #588]	; (8007c00 <HAL_ADC_Init+0x6c0>)
 80079b4:	4993      	ldr	r1, [pc, #588]	; (8007c04 <HAL_ADC_Init+0x6c4>)
 80079b6:	400a      	ands	r2, r1
 80079b8:	601a      	str	r2, [r3, #0]
 80079ba:	4b91      	ldr	r3, [pc, #580]	; (8007c00 <HAL_ADC_Init+0x6c0>)
 80079bc:	6819      	ldr	r1, [r3, #0]
 80079be:	687b      	ldr	r3, [r7, #4]
 80079c0:	685a      	ldr	r2, [r3, #4]
 80079c2:	4b8f      	ldr	r3, [pc, #572]	; (8007c00 <HAL_ADC_Init+0x6c0>)
 80079c4:	430a      	orrs	r2, r1
 80079c6:	601a      	str	r2, [r3, #0]
    
    /* Configuration of ADC:                                                */
    /*  - Resolution                                                        */
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_RES);
 80079c8:	687b      	ldr	r3, [r7, #4]
 80079ca:	681b      	ldr	r3, [r3, #0]
 80079cc:	68da      	ldr	r2, [r3, #12]
 80079ce:	687b      	ldr	r3, [r7, #4]
 80079d0:	681b      	ldr	r3, [r3, #0]
 80079d2:	2118      	movs	r1, #24
 80079d4:	438a      	bics	r2, r1
 80079d6:	60da      	str	r2, [r3, #12]
    hadc->Instance->CFGR1 |= hadc->Init.Resolution;    
 80079d8:	687b      	ldr	r3, [r7, #4]
 80079da:	681b      	ldr	r3, [r3, #0]
 80079dc:	68d9      	ldr	r1, [r3, #12]
 80079de:	687b      	ldr	r3, [r7, #4]
 80079e0:	689a      	ldr	r2, [r3, #8]
 80079e2:	687b      	ldr	r3, [r7, #4]
 80079e4:	681b      	ldr	r3, [r3, #0]
 80079e6:	430a      	orrs	r2, r1
 80079e8:	60da      	str	r2, [r3, #12]
  }
  
  /* Set the Low Frequency mode */
  ADC->CCR &= (uint32_t)~ADC_CCR_LFMEN;
 80079ea:	4b85      	ldr	r3, [pc, #532]	; (8007c00 <HAL_ADC_Init+0x6c0>)
 80079ec:	681a      	ldr	r2, [r3, #0]
 80079ee:	4b84      	ldr	r3, [pc, #528]	; (8007c00 <HAL_ADC_Init+0x6c0>)
 80079f0:	4985      	ldr	r1, [pc, #532]	; (8007c08 <HAL_ADC_Init+0x6c8>)
 80079f2:	400a      	ands	r2, r1
 80079f4:	601a      	str	r2, [r3, #0]
  ADC->CCR |=__HAL_ADC_CCR_LOWFREQUENCY(hadc->Init.LowPowerFrequencyMode);  
 80079f6:	4b82      	ldr	r3, [pc, #520]	; (8007c00 <HAL_ADC_Init+0x6c0>)
 80079f8:	6819      	ldr	r1, [r3, #0]
 80079fa:	687b      	ldr	r3, [r7, #4]
 80079fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80079fe:	065a      	lsls	r2, r3, #25
 8007a00:	4b7f      	ldr	r3, [pc, #508]	; (8007c00 <HAL_ADC_Init+0x6c0>)
 8007a02:	430a      	orrs	r2, r1
 8007a04:	601a      	str	r2, [r3, #0]
   
  /* Enable voltage regulator (if disabled at this step) */
  if (HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADVREGEN))
 8007a06:	687b      	ldr	r3, [r7, #4]
 8007a08:	681b      	ldr	r3, [r3, #0]
 8007a0a:	689a      	ldr	r2, [r3, #8]
 8007a0c:	2380      	movs	r3, #128	; 0x80
 8007a0e:	055b      	lsls	r3, r3, #21
 8007a10:	4013      	ands	r3, r2
 8007a12:	d108      	bne.n	8007a26 <HAL_ADC_Init+0x4e6>
  {
    /* Set ADVREGEN bit */
    hadc->Instance->CR |= ADC_CR_ADVREGEN;
 8007a14:	687b      	ldr	r3, [r7, #4]
 8007a16:	681b      	ldr	r3, [r3, #0]
 8007a18:	689a      	ldr	r2, [r3, #8]
 8007a1a:	687b      	ldr	r3, [r7, #4]
 8007a1c:	681b      	ldr	r3, [r3, #0]
 8007a1e:	2180      	movs	r1, #128	; 0x80
 8007a20:	0549      	lsls	r1, r1, #21
 8007a22:	430a      	orrs	r2, r1
 8007a24:	609a      	str	r2, [r3, #8]
  /*  - Continuous conversion mode                                            */
  /*  - DMA continuous request                                                */
  /*  - Overrun                                                               */
  /*  - AutoDelay feature                                                     */
  /*  - Discontinuous mode                                                    */
  hadc->Instance->CFGR1 &= ~(ADC_CFGR1_ALIGN   |
 8007a26:	687b      	ldr	r3, [r7, #4]
 8007a28:	681b      	ldr	r3, [r3, #0]
 8007a2a:	68da      	ldr	r2, [r3, #12]
 8007a2c:	687b      	ldr	r3, [r7, #4]
 8007a2e:	681b      	ldr	r3, [r3, #0]
 8007a30:	4976      	ldr	r1, [pc, #472]	; (8007c0c <HAL_ADC_Init+0x6cc>)
 8007a32:	400a      	ands	r2, r1
 8007a34:	60da      	str	r2, [r3, #12]
                             ADC_CFGR1_OVRMOD  |
                             ADC_CFGR1_AUTDLY  |
                             ADC_CFGR1_AUTOFF  |
                             ADC_CFGR1_DISCEN   );
  
  hadc->Instance->CFGR1 |= (hadc->Init.DataAlign                             |
 8007a36:	687b      	ldr	r3, [r7, #4]
 8007a38:	681b      	ldr	r3, [r3, #0]
 8007a3a:	68d9      	ldr	r1, [r3, #12]
 8007a3c:	687b      	ldr	r3, [r7, #4]
 8007a3e:	68da      	ldr	r2, [r3, #12]
                            ADC_SCANDIR(hadc->Init.ScanConvMode)             |
 8007a40:	687b      	ldr	r3, [r7, #4]
 8007a42:	691b      	ldr	r3, [r3, #16]
 8007a44:	2b02      	cmp	r3, #2
 8007a46:	d101      	bne.n	8007a4c <HAL_ADC_Init+0x50c>
 8007a48:	2304      	movs	r3, #4
 8007a4a:	e000      	b.n	8007a4e <HAL_ADC_Init+0x50e>
 8007a4c:	2300      	movs	r3, #0
  hadc->Instance->CFGR1 |= (hadc->Init.DataAlign                             |
 8007a4e:	431a      	orrs	r2, r3
                            ADC_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 8007a50:	687b      	ldr	r3, [r7, #4]
 8007a52:	2020      	movs	r0, #32
 8007a54:	5c1b      	ldrb	r3, [r3, r0]
 8007a56:	035b      	lsls	r3, r3, #13
                            ADC_SCANDIR(hadc->Init.ScanConvMode)             |
 8007a58:	431a      	orrs	r2, r3
                            ADC_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests) |
 8007a5a:	687b      	ldr	r3, [r7, #4]
 8007a5c:	202c      	movs	r0, #44	; 0x2c
 8007a5e:	5c1b      	ldrb	r3, [r3, r0]
 8007a60:	005b      	lsls	r3, r3, #1
                            ADC_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 8007a62:	431a      	orrs	r2, r3
                            hadc->Init.Overrun                               |
 8007a64:	687b      	ldr	r3, [r7, #4]
 8007a66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                            ADC_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests) |
 8007a68:	431a      	orrs	r2, r3
                            __HAL_ADC_CFGR1_AutoDelay(hadc->Init.LowPowerAutoWait) |
 8007a6a:	687b      	ldr	r3, [r7, #4]
 8007a6c:	699b      	ldr	r3, [r3, #24]
 8007a6e:	039b      	lsls	r3, r3, #14
                            hadc->Init.Overrun                               |
 8007a70:	431a      	orrs	r2, r3
                            __HAL_ADC_CFGR1_AUTOFF(hadc->Init.LowPowerAutoPowerOff));
 8007a72:	687b      	ldr	r3, [r7, #4]
 8007a74:	69db      	ldr	r3, [r3, #28]
 8007a76:	03db      	lsls	r3, r3, #15
                            __HAL_ADC_CFGR1_AutoDelay(hadc->Init.LowPowerAutoWait) |
 8007a78:	431a      	orrs	r2, r3
  hadc->Instance->CFGR1 |= (hadc->Init.DataAlign                             |
 8007a7a:	687b      	ldr	r3, [r7, #4]
 8007a7c:	681b      	ldr	r3, [r3, #0]
 8007a7e:	430a      	orrs	r2, r1
 8007a80:	60da      	str	r2, [r3, #12]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8007a82:	687b      	ldr	r3, [r7, #4]
 8007a84:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007a86:	23c2      	movs	r3, #194	; 0xc2
 8007a88:	33ff      	adds	r3, #255	; 0xff
 8007a8a:	429a      	cmp	r2, r3
 8007a8c:	d00b      	beq.n	8007aa6 <HAL_ADC_Init+0x566>
  {
    hadc->Instance->CFGR1 |= hadc->Init.ExternalTrigConv |
 8007a8e:	687b      	ldr	r3, [r7, #4]
 8007a90:	681b      	ldr	r3, [r3, #0]
 8007a92:	68d9      	ldr	r1, [r3, #12]
 8007a94:	687b      	ldr	r3, [r7, #4]
 8007a96:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                             hadc->Init.ExternalTrigConvEdge;
 8007a98:	687b      	ldr	r3, [r7, #4]
 8007a9a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    hadc->Instance->CFGR1 |= hadc->Init.ExternalTrigConv |
 8007a9c:	431a      	orrs	r2, r3
 8007a9e:	687b      	ldr	r3, [r7, #4]
 8007aa0:	681b      	ldr	r3, [r3, #0]
 8007aa2:	430a      	orrs	r2, r1
 8007aa4:	60da      	str	r2, [r3, #12]
  }
  
  /* Enable discontinuous mode only if continuous mode is disabled */
  if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8007aa6:	687b      	ldr	r3, [r7, #4]
 8007aa8:	2221      	movs	r2, #33	; 0x21
 8007aaa:	5c9b      	ldrb	r3, [r3, r2]
 8007aac:	2b01      	cmp	r3, #1
 8007aae:	d11a      	bne.n	8007ae6 <HAL_ADC_Init+0x5a6>
  {
    if (hadc->Init.ContinuousConvMode == DISABLE)
 8007ab0:	687b      	ldr	r3, [r7, #4]
 8007ab2:	2220      	movs	r2, #32
 8007ab4:	5c9b      	ldrb	r3, [r3, r2]
 8007ab6:	2b00      	cmp	r3, #0
 8007ab8:	d109      	bne.n	8007ace <HAL_ADC_Init+0x58e>
    {
      /* Enable the selected ADC group regular discontinuous mode */
      hadc->Instance->CFGR1 |= (ADC_CFGR1_DISCEN);
 8007aba:	687b      	ldr	r3, [r7, #4]
 8007abc:	681b      	ldr	r3, [r3, #0]
 8007abe:	68da      	ldr	r2, [r3, #12]
 8007ac0:	687b      	ldr	r3, [r7, #4]
 8007ac2:	681b      	ldr	r3, [r3, #0]
 8007ac4:	2180      	movs	r1, #128	; 0x80
 8007ac6:	0249      	lsls	r1, r1, #9
 8007ac8:	430a      	orrs	r2, r1
 8007aca:	60da      	str	r2, [r3, #12]
 8007acc:	e00b      	b.n	8007ae6 <HAL_ADC_Init+0x5a6>
      /* ADC regular group discontinuous was intended to be enabled,        */
      /* but ADC regular group modes continuous and sequencer discontinuous */
      /* cannot be enabled simultaneously.                                  */
      
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007ace:	687b      	ldr	r3, [r7, #4]
 8007ad0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007ad2:	2220      	movs	r2, #32
 8007ad4:	431a      	orrs	r2, r3
 8007ad6:	687b      	ldr	r3, [r7, #4]
 8007ad8:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007ada:	687b      	ldr	r3, [r7, #4]
 8007adc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007ade:	2201      	movs	r2, #1
 8007ae0:	431a      	orrs	r2, r3
 8007ae2:	687b      	ldr	r3, [r7, #4]
 8007ae4:	659a      	str	r2, [r3, #88]	; 0x58
    }
  }
  
  if (hadc->Init.OversamplingMode == ENABLE)
 8007ae6:	687b      	ldr	r3, [r7, #4]
 8007ae8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007aea:	2b01      	cmp	r3, #1
 8007aec:	d000      	beq.n	8007af0 <HAL_ADC_Init+0x5b0>
 8007aee:	e095      	b.n	8007c1c <HAL_ADC_Init+0x6dc>
  {
    assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversample.Ratio));
 8007af0:	687b      	ldr	r3, [r7, #4]
 8007af2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007af4:	2b00      	cmp	r3, #0
 8007af6:	d022      	beq.n	8007b3e <HAL_ADC_Init+0x5fe>
 8007af8:	687b      	ldr	r3, [r7, #4]
 8007afa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007afc:	2b04      	cmp	r3, #4
 8007afe:	d01e      	beq.n	8007b3e <HAL_ADC_Init+0x5fe>
 8007b00:	687b      	ldr	r3, [r7, #4]
 8007b02:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007b04:	2b08      	cmp	r3, #8
 8007b06:	d01a      	beq.n	8007b3e <HAL_ADC_Init+0x5fe>
 8007b08:	687b      	ldr	r3, [r7, #4]
 8007b0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007b0c:	2b0c      	cmp	r3, #12
 8007b0e:	d016      	beq.n	8007b3e <HAL_ADC_Init+0x5fe>
 8007b10:	687b      	ldr	r3, [r7, #4]
 8007b12:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007b14:	2b10      	cmp	r3, #16
 8007b16:	d012      	beq.n	8007b3e <HAL_ADC_Init+0x5fe>
 8007b18:	687b      	ldr	r3, [r7, #4]
 8007b1a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007b1c:	2b14      	cmp	r3, #20
 8007b1e:	d00e      	beq.n	8007b3e <HAL_ADC_Init+0x5fe>
 8007b20:	687b      	ldr	r3, [r7, #4]
 8007b22:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007b24:	2b18      	cmp	r3, #24
 8007b26:	d00a      	beq.n	8007b3e <HAL_ADC_Init+0x5fe>
 8007b28:	687b      	ldr	r3, [r7, #4]
 8007b2a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007b2c:	2b1c      	cmp	r3, #28
 8007b2e:	d006      	beq.n	8007b3e <HAL_ADC_Init+0x5fe>
 8007b30:	2393      	movs	r3, #147	; 0x93
 8007b32:	009a      	lsls	r2, r3, #2
 8007b34:	4b30      	ldr	r3, [pc, #192]	; (8007bf8 <HAL_ADC_Init+0x6b8>)
 8007b36:	0011      	movs	r1, r2
 8007b38:	0018      	movs	r0, r3
 8007b3a:	f7fe fbac 	bl	8006296 <assert_failed>
    assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversample.RightBitShift));
 8007b3e:	687b      	ldr	r3, [r7, #4]
 8007b40:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b42:	2b00      	cmp	r3, #0
 8007b44:	d027      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b46:	687b      	ldr	r3, [r7, #4]
 8007b48:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b4a:	2b20      	cmp	r3, #32
 8007b4c:	d023      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b4e:	687b      	ldr	r3, [r7, #4]
 8007b50:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b52:	2b40      	cmp	r3, #64	; 0x40
 8007b54:	d01f      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b56:	687b      	ldr	r3, [r7, #4]
 8007b58:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b5a:	2b60      	cmp	r3, #96	; 0x60
 8007b5c:	d01b      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b5e:	687b      	ldr	r3, [r7, #4]
 8007b60:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b62:	2b80      	cmp	r3, #128	; 0x80
 8007b64:	d017      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b66:	687b      	ldr	r3, [r7, #4]
 8007b68:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b6a:	2ba0      	cmp	r3, #160	; 0xa0
 8007b6c:	d013      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b6e:	687b      	ldr	r3, [r7, #4]
 8007b70:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b72:	2bc0      	cmp	r3, #192	; 0xc0
 8007b74:	d00f      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b76:	687b      	ldr	r3, [r7, #4]
 8007b78:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007b7a:	2be0      	cmp	r3, #224	; 0xe0
 8007b7c:	d00b      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b7e:	687b      	ldr	r3, [r7, #4]
 8007b80:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8007b82:	2380      	movs	r3, #128	; 0x80
 8007b84:	005b      	lsls	r3, r3, #1
 8007b86:	429a      	cmp	r2, r3
 8007b88:	d005      	beq.n	8007b96 <HAL_ADC_Init+0x656>
 8007b8a:	4a21      	ldr	r2, [pc, #132]	; (8007c10 <HAL_ADC_Init+0x6d0>)
 8007b8c:	4b1a      	ldr	r3, [pc, #104]	; (8007bf8 <HAL_ADC_Init+0x6b8>)
 8007b8e:	0011      	movs	r1, r2
 8007b90:	0018      	movs	r0, r3
 8007b92:	f7fe fb80 	bl	8006296 <assert_failed>
    assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversample.TriggeredMode));
 8007b96:	687b      	ldr	r3, [r7, #4]
 8007b98:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8007b9a:	2b00      	cmp	r3, #0
 8007b9c:	d00b      	beq.n	8007bb6 <HAL_ADC_Init+0x676>
 8007b9e:	687b      	ldr	r3, [r7, #4]
 8007ba0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8007ba2:	2380      	movs	r3, #128	; 0x80
 8007ba4:	009b      	lsls	r3, r3, #2
 8007ba6:	429a      	cmp	r2, r3
 8007ba8:	d005      	beq.n	8007bb6 <HAL_ADC_Init+0x676>
 8007baa:	4a1a      	ldr	r2, [pc, #104]	; (8007c14 <HAL_ADC_Init+0x6d4>)
 8007bac:	4b12      	ldr	r3, [pc, #72]	; (8007bf8 <HAL_ADC_Init+0x6b8>)
 8007bae:	0011      	movs	r1, r2
 8007bb0:	0018      	movs	r0, r3
 8007bb2:	f7fe fb70 	bl	8006296 <assert_failed>
    /* Configuration of Oversampler:                                          */
    /*  - Oversampling Ratio                                                  */
    /*  - Right bit shift                                                     */
    /*  - Triggered mode                                                      */
    
    hadc->Instance->CFGR2 &= ~( ADC_CFGR2_OVSR |
 8007bb6:	687b      	ldr	r3, [r7, #4]
 8007bb8:	681b      	ldr	r3, [r3, #0]
 8007bba:	691a      	ldr	r2, [r3, #16]
 8007bbc:	687b      	ldr	r3, [r7, #4]
 8007bbe:	681b      	ldr	r3, [r3, #0]
 8007bc0:	4915      	ldr	r1, [pc, #84]	; (8007c18 <HAL_ADC_Init+0x6d8>)
 8007bc2:	400a      	ands	r2, r1
 8007bc4:	611a      	str	r2, [r3, #16]
                                ADC_CFGR2_OVSS |
                                ADC_CFGR2_TOVS );
    
    hadc->Instance->CFGR2 |= ( hadc->Init.Oversample.Ratio         |
 8007bc6:	687b      	ldr	r3, [r7, #4]
 8007bc8:	681b      	ldr	r3, [r3, #0]
 8007bca:	6919      	ldr	r1, [r3, #16]
 8007bcc:	687b      	ldr	r3, [r7, #4]
 8007bce:	6c1a      	ldr	r2, [r3, #64]	; 0x40
                               hadc->Init.Oversample.RightBitShift             |
 8007bd0:	687b      	ldr	r3, [r7, #4]
 8007bd2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    hadc->Instance->CFGR2 |= ( hadc->Init.Oversample.Ratio         |
 8007bd4:	431a      	orrs	r2, r3
                               hadc->Init.Oversample.TriggeredMode );
 8007bd6:	687b      	ldr	r3, [r7, #4]
 8007bd8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
                               hadc->Init.Oversample.RightBitShift             |
 8007bda:	431a      	orrs	r2, r3
    hadc->Instance->CFGR2 |= ( hadc->Init.Oversample.Ratio         |
 8007bdc:	687b      	ldr	r3, [r7, #4]
 8007bde:	681b      	ldr	r3, [r3, #0]
 8007be0:	430a      	orrs	r2, r1
 8007be2:	611a      	str	r2, [r3, #16]
    
    /* Enable OverSampling mode */
     hadc->Instance->CFGR2 |= ADC_CFGR2_OVSE;
 8007be4:	687b      	ldr	r3, [r7, #4]
 8007be6:	681b      	ldr	r3, [r3, #0]
 8007be8:	691a      	ldr	r2, [r3, #16]
 8007bea:	687b      	ldr	r3, [r7, #4]
 8007bec:	681b      	ldr	r3, [r3, #0]
 8007bee:	2101      	movs	r1, #1
 8007bf0:	430a      	orrs	r2, r1
 8007bf2:	611a      	str	r2, [r3, #16]
 8007bf4:	e021      	b.n	8007c3a <HAL_ADC_Init+0x6fa>
 8007bf6:	46c0      	nop			; (mov r8, r8)
 8007bf8:	0800dd3c 	.word	0x0800dd3c
 8007bfc:	fffffefd 	.word	0xfffffefd
 8007c00:	40012708 	.word	0x40012708
 8007c04:	ffc3ffff 	.word	0xffc3ffff
 8007c08:	fdffffff 	.word	0xfdffffff
 8007c0c:	fffe0219 	.word	0xfffe0219
 8007c10:	0000024d 	.word	0x0000024d
 8007c14:	0000024e 	.word	0x0000024e
 8007c18:	fffffc03 	.word	0xfffffc03
  }
  else
  {
    if(HAL_IS_BIT_SET(hadc->Instance->CFGR2, ADC_CFGR2_OVSE))
 8007c1c:	687b      	ldr	r3, [r7, #4]
 8007c1e:	681b      	ldr	r3, [r3, #0]
 8007c20:	691b      	ldr	r3, [r3, #16]
 8007c22:	2201      	movs	r2, #1
 8007c24:	4013      	ands	r3, r2
 8007c26:	2b01      	cmp	r3, #1
 8007c28:	d107      	bne.n	8007c3a <HAL_ADC_Init+0x6fa>
    {
      /* Disable OverSampling mode if needed */
      hadc->Instance->CFGR2 &= ~ADC_CFGR2_OVSE;
 8007c2a:	687b      	ldr	r3, [r7, #4]
 8007c2c:	681b      	ldr	r3, [r3, #0]
 8007c2e:	691a      	ldr	r2, [r3, #16]
 8007c30:	687b      	ldr	r3, [r7, #4]
 8007c32:	681b      	ldr	r3, [r3, #0]
 8007c34:	2101      	movs	r1, #1
 8007c36:	438a      	bics	r2, r1
 8007c38:	611a      	str	r2, [r3, #16]
    }
  }    
  
  /* Clear the old sampling time */
  hadc->Instance->SMPR &= (uint32_t)(~ADC_SMPR_SMPR);
 8007c3a:	687b      	ldr	r3, [r7, #4]
 8007c3c:	681b      	ldr	r3, [r3, #0]
 8007c3e:	695a      	ldr	r2, [r3, #20]
 8007c40:	687b      	ldr	r3, [r7, #4]
 8007c42:	681b      	ldr	r3, [r3, #0]
 8007c44:	2107      	movs	r1, #7
 8007c46:	438a      	bics	r2, r1
 8007c48:	615a      	str	r2, [r3, #20]
  
  /* Set the new sample time */
  hadc->Instance->SMPR |= hadc->Init.SamplingTime;
 8007c4a:	687b      	ldr	r3, [r7, #4]
 8007c4c:	681b      	ldr	r3, [r3, #0]
 8007c4e:	6959      	ldr	r1, [r3, #20]
 8007c50:	687b      	ldr	r3, [r7, #4]
 8007c52:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8007c54:	687b      	ldr	r3, [r7, #4]
 8007c56:	681b      	ldr	r3, [r3, #0]
 8007c58:	430a      	orrs	r2, r1
 8007c5a:	615a      	str	r2, [r3, #20]
  
  /* Clear ADC error code */
  ADC_CLEAR_ERRORCODE(hadc);
 8007c5c:	687b      	ldr	r3, [r7, #4]
 8007c5e:	2200      	movs	r2, #0
 8007c60:	659a      	str	r2, [r3, #88]	; 0x58

  /* Set the ADC state */
  ADC_STATE_CLR_SET(hadc->State,
 8007c62:	687b      	ldr	r3, [r7, #4]
 8007c64:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007c66:	2203      	movs	r2, #3
 8007c68:	4393      	bics	r3, r2
 8007c6a:	2201      	movs	r2, #1
 8007c6c:	431a      	orrs	r2, r3
 8007c6e:	687b      	ldr	r3, [r7, #4]
 8007c70:	655a      	str	r2, [r3, #84]	; 0x54
                    HAL_ADC_STATE_BUSY_INTERNAL,
                    HAL_ADC_STATE_READY);


  /* Return function status */
  return HAL_OK;
 8007c72:	2300      	movs	r3, #0
}
 8007c74:	0018      	movs	r0, r3
 8007c76:	46bd      	mov	sp, r7
 8007c78:	b002      	add	sp, #8
 8007c7a:	bd80      	pop	{r7, pc}

08007c7c <HAL_ADC_Start>:
  * @note   Interruptions enabled in this function: None.
  * @param  hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
{
 8007c7c:	b590      	push	{r4, r7, lr}
 8007c7e:	b085      	sub	sp, #20
 8007c80:	af00      	add	r7, sp, #0
 8007c82:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007c84:	230f      	movs	r3, #15
 8007c86:	18fb      	adds	r3, r7, r3
 8007c88:	2200      	movs	r2, #0
 8007c8a:	701a      	strb	r2, [r3, #0]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8007c8c:	687b      	ldr	r3, [r7, #4]
 8007c8e:	681b      	ldr	r3, [r3, #0]
 8007c90:	4a29      	ldr	r2, [pc, #164]	; (8007d38 <HAL_ADC_Start+0xbc>)
 8007c92:	4293      	cmp	r3, r2
 8007c94:	d005      	beq.n	8007ca2 <HAL_ADC_Start+0x26>
 8007c96:	4a29      	ldr	r2, [pc, #164]	; (8007d3c <HAL_ADC_Start+0xc0>)
 8007c98:	4b29      	ldr	r3, [pc, #164]	; (8007d40 <HAL_ADC_Start+0xc4>)
 8007c9a:	0011      	movs	r1, r2
 8007c9c:	0018      	movs	r0, r3
 8007c9e:	f7fe fafa 	bl	8006296 <assert_failed>
  
  /* Perform ADC enable and conversion start if no conversion is on going */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007ca2:	687b      	ldr	r3, [r7, #4]
 8007ca4:	681b      	ldr	r3, [r3, #0]
 8007ca6:	689b      	ldr	r3, [r3, #8]
 8007ca8:	2204      	movs	r2, #4
 8007caa:	4013      	ands	r3, r2
 8007cac:	d138      	bne.n	8007d20 <HAL_ADC_Start+0xa4>
  {
    /* Process locked */
    __HAL_LOCK(hadc);
 8007cae:	687b      	ldr	r3, [r7, #4]
 8007cb0:	2250      	movs	r2, #80	; 0x50
 8007cb2:	5c9b      	ldrb	r3, [r3, r2]
 8007cb4:	2b01      	cmp	r3, #1
 8007cb6:	d101      	bne.n	8007cbc <HAL_ADC_Start+0x40>
 8007cb8:	2302      	movs	r3, #2
 8007cba:	e038      	b.n	8007d2e <HAL_ADC_Start+0xb2>
 8007cbc:	687b      	ldr	r3, [r7, #4]
 8007cbe:	2250      	movs	r2, #80	; 0x50
 8007cc0:	2101      	movs	r1, #1
 8007cc2:	5499      	strb	r1, [r3, r2]
    
    /* Enable the ADC peripheral */
    /* If low power mode AutoPowerOff is enabled, power-on/off phases are     */
    /* performed automatically by hardware.                                   */
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 8007cc4:	687b      	ldr	r3, [r7, #4]
 8007cc6:	69db      	ldr	r3, [r3, #28]
 8007cc8:	2b01      	cmp	r3, #1
 8007cca:	d007      	beq.n	8007cdc <HAL_ADC_Start+0x60>
    {
      tmp_hal_status = ADC_Enable(hadc);
 8007ccc:	230f      	movs	r3, #15
 8007cce:	18fc      	adds	r4, r7, r3
 8007cd0:	687b      	ldr	r3, [r7, #4]
 8007cd2:	0018      	movs	r0, r3
 8007cd4:	f000 fa4c 	bl	8008170 <ADC_Enable>
 8007cd8:	0003      	movs	r3, r0
 8007cda:	7023      	strb	r3, [r4, #0]
    }
    
    /* Start conversion if ADC is effectively enabled */
    if (tmp_hal_status == HAL_OK)
 8007cdc:	230f      	movs	r3, #15
 8007cde:	18fb      	adds	r3, r7, r3
 8007ce0:	781b      	ldrb	r3, [r3, #0]
 8007ce2:	2b00      	cmp	r3, #0
 8007ce4:	d120      	bne.n	8007d28 <HAL_ADC_Start+0xac>
    {
      /* Set ADC state                                                        */
      /* - Clear state bitfield related to regular group conversion results   */
      /* - Set state bitfield related to regular operation                    */
      ADC_STATE_CLR_SET(hadc->State,
 8007ce6:	687b      	ldr	r3, [r7, #4]
 8007ce8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007cea:	4a16      	ldr	r2, [pc, #88]	; (8007d44 <HAL_ADC_Start+0xc8>)
 8007cec:	4013      	ands	r3, r2
 8007cee:	2280      	movs	r2, #128	; 0x80
 8007cf0:	0052      	lsls	r2, r2, #1
 8007cf2:	431a      	orrs	r2, r3
 8007cf4:	687b      	ldr	r3, [r7, #4]
 8007cf6:	655a      	str	r2, [r3, #84]	; 0x54
                        HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
                        HAL_ADC_STATE_REG_BUSY);
      
      /* Reset ADC all error code fields */
      ADC_CLEAR_ERRORCODE(hadc);
 8007cf8:	687b      	ldr	r3, [r7, #4]
 8007cfa:	2200      	movs	r2, #0
 8007cfc:	659a      	str	r2, [r3, #88]	; 0x58
      
      /* Process unlocked */
      /* Unlock before starting ADC conversions: in case of potential         */
      /* interruption, to let the process to ADC IRQ Handler.                 */
      __HAL_UNLOCK(hadc);
 8007cfe:	687b      	ldr	r3, [r7, #4]
 8007d00:	2250      	movs	r2, #80	; 0x50
 8007d02:	2100      	movs	r1, #0
 8007d04:	5499      	strb	r1, [r3, r2]
      
      /* Clear regular group conversion flag and overrun flag */
      /* (To ensure of no unknown state from potential previous ADC           */
      /* operations)                                                          */
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8007d06:	687b      	ldr	r3, [r7, #4]
 8007d08:	681b      	ldr	r3, [r3, #0]
 8007d0a:	221c      	movs	r2, #28
 8007d0c:	601a      	str	r2, [r3, #0]
      
      /* Enable conversion of regular group.                                  */
      /* If software start has been selected, conversion starts immediately.  */
      /* If external trigger has been selected, conversion will start at next */
      /* trigger event.                                                       */
      hadc->Instance->CR |= ADC_CR_ADSTART;
 8007d0e:	687b      	ldr	r3, [r7, #4]
 8007d10:	681b      	ldr	r3, [r3, #0]
 8007d12:	689a      	ldr	r2, [r3, #8]
 8007d14:	687b      	ldr	r3, [r7, #4]
 8007d16:	681b      	ldr	r3, [r3, #0]
 8007d18:	2104      	movs	r1, #4
 8007d1a:	430a      	orrs	r2, r1
 8007d1c:	609a      	str	r2, [r3, #8]
 8007d1e:	e003      	b.n	8007d28 <HAL_ADC_Start+0xac>
    }
  }
  else
  {
    tmp_hal_status = HAL_BUSY;
 8007d20:	230f      	movs	r3, #15
 8007d22:	18fb      	adds	r3, r7, r3
 8007d24:	2202      	movs	r2, #2
 8007d26:	701a      	strb	r2, [r3, #0]
  }
  
  /* Return function status */
  return tmp_hal_status;
 8007d28:	230f      	movs	r3, #15
 8007d2a:	18fb      	adds	r3, r7, r3
 8007d2c:	781b      	ldrb	r3, [r3, #0]
}
 8007d2e:	0018      	movs	r0, r3
 8007d30:	46bd      	mov	sp, r7
 8007d32:	b005      	add	sp, #20
 8007d34:	bd90      	pop	{r4, r7, pc}
 8007d36:	46c0      	nop			; (mov r8, r8)
 8007d38:	40012400 	.word	0x40012400
 8007d3c:	0000040d 	.word	0x0000040d
 8007d40:	0800dd3c 	.word	0x0800dd3c
 8007d44:	fffff0fe 	.word	0xfffff0fe

08007d48 <HAL_ADC_PollForConversion>:
  * @param  hadc ADC handle
  * @param  Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 8007d48:	b580      	push	{r7, lr}
 8007d4a:	b084      	sub	sp, #16
 8007d4c:	af00      	add	r7, sp, #0
 8007d4e:	6078      	str	r0, [r7, #4]
 8007d50:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 8007d52:	2300      	movs	r3, #0
 8007d54:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_Flag_EOC   = 0x00;
 8007d56:	2300      	movs	r3, #0
 8007d58:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8007d5a:	687b      	ldr	r3, [r7, #4]
 8007d5c:	681b      	ldr	r3, [r3, #0]
 8007d5e:	4a4a      	ldr	r2, [pc, #296]	; (8007e88 <HAL_ADC_PollForConversion+0x140>)
 8007d60:	4293      	cmp	r3, r2
 8007d62:	d005      	beq.n	8007d70 <HAL_ADC_PollForConversion+0x28>
 8007d64:	4a49      	ldr	r2, [pc, #292]	; (8007e8c <HAL_ADC_PollForConversion+0x144>)
 8007d66:	4b4a      	ldr	r3, [pc, #296]	; (8007e90 <HAL_ADC_PollForConversion+0x148>)
 8007d68:	0011      	movs	r1, r2
 8007d6a:	0018      	movs	r0, r3
 8007d6c:	f7fe fa93 	bl	8006296 <assert_failed>
  
  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8007d70:	687b      	ldr	r3, [r7, #4]
 8007d72:	695b      	ldr	r3, [r3, #20]
 8007d74:	2b08      	cmp	r3, #8
 8007d76:	d102      	bne.n	8007d7e <HAL_ADC_PollForConversion+0x36>
  {
    tmp_Flag_EOC = ADC_FLAG_EOS;
 8007d78:	2308      	movs	r3, #8
 8007d7a:	60fb      	str	r3, [r7, #12]
 8007d7c:	e014      	b.n	8007da8 <HAL_ADC_PollForConversion+0x60>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if (HAL_IS_BIT_SET(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN))
 8007d7e:	687b      	ldr	r3, [r7, #4]
 8007d80:	681b      	ldr	r3, [r3, #0]
 8007d82:	68db      	ldr	r3, [r3, #12]
 8007d84:	2201      	movs	r2, #1
 8007d86:	4013      	ands	r3, r2
 8007d88:	2b01      	cmp	r3, #1
 8007d8a:	d10b      	bne.n	8007da4 <HAL_ADC_PollForConversion+0x5c>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007d8c:	687b      	ldr	r3, [r7, #4]
 8007d8e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007d90:	2220      	movs	r2, #32
 8007d92:	431a      	orrs	r2, r3
 8007d94:	687b      	ldr	r3, [r7, #4]
 8007d96:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Process unlocked */
      __HAL_UNLOCK(hadc);
 8007d98:	687b      	ldr	r3, [r7, #4]
 8007d9a:	2250      	movs	r2, #80	; 0x50
 8007d9c:	2100      	movs	r1, #0
 8007d9e:	5499      	strb	r1, [r3, r2]
      
      return HAL_ERROR;
 8007da0:	2301      	movs	r3, #1
 8007da2:	e06c      	b.n	8007e7e <HAL_ADC_PollForConversion+0x136>
    }
    else
    {
      tmp_Flag_EOC = (ADC_FLAG_EOC | ADC_FLAG_EOS);
 8007da4:	230c      	movs	r3, #12
 8007da6:	60fb      	str	r3, [r7, #12]
    }
  }
  
  /* Get tick count */
  tickstart = HAL_GetTick();
 8007da8:	f7ff fb9c 	bl	80074e4 <HAL_GetTick>
 8007dac:	0003      	movs	r3, r0
 8007dae:	60bb      	str	r3, [r7, #8]
  
  /* Wait until End of unitary conversion or sequence conversions flag is raised */
  while(HAL_IS_BIT_CLR(hadc->Instance->ISR, tmp_Flag_EOC))
 8007db0:	e019      	b.n	8007de6 <HAL_ADC_PollForConversion+0x9e>
  {
    /* Check if timeout is disabled (set to infinite wait) */
    if(Timeout != HAL_MAX_DELAY)
 8007db2:	683b      	ldr	r3, [r7, #0]
 8007db4:	3301      	adds	r3, #1
 8007db6:	d016      	beq.n	8007de6 <HAL_ADC_PollForConversion+0x9e>
    {
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8007db8:	683b      	ldr	r3, [r7, #0]
 8007dba:	2b00      	cmp	r3, #0
 8007dbc:	d007      	beq.n	8007dce <HAL_ADC_PollForConversion+0x86>
 8007dbe:	f7ff fb91 	bl	80074e4 <HAL_GetTick>
 8007dc2:	0002      	movs	r2, r0
 8007dc4:	68bb      	ldr	r3, [r7, #8]
 8007dc6:	1ad3      	subs	r3, r2, r3
 8007dc8:	683a      	ldr	r2, [r7, #0]
 8007dca:	429a      	cmp	r2, r3
 8007dcc:	d20b      	bcs.n	8007de6 <HAL_ADC_PollForConversion+0x9e>
      {
        /* Update ADC state machine to timeout */
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8007dce:	687b      	ldr	r3, [r7, #4]
 8007dd0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007dd2:	2204      	movs	r2, #4
 8007dd4:	431a      	orrs	r2, r3
 8007dd6:	687b      	ldr	r3, [r7, #4]
 8007dd8:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8007dda:	687b      	ldr	r3, [r7, #4]
 8007ddc:	2250      	movs	r2, #80	; 0x50
 8007dde:	2100      	movs	r1, #0
 8007de0:	5499      	strb	r1, [r3, r2]
        
        return HAL_TIMEOUT;
 8007de2:	2303      	movs	r3, #3
 8007de4:	e04b      	b.n	8007e7e <HAL_ADC_PollForConversion+0x136>
  while(HAL_IS_BIT_CLR(hadc->Instance->ISR, tmp_Flag_EOC))
 8007de6:	687b      	ldr	r3, [r7, #4]
 8007de8:	681b      	ldr	r3, [r3, #0]
 8007dea:	681b      	ldr	r3, [r3, #0]
 8007dec:	68fa      	ldr	r2, [r7, #12]
 8007dee:	4013      	ands	r3, r2
 8007df0:	d0df      	beq.n	8007db2 <HAL_ADC_PollForConversion+0x6a>
      }
    }
  }
  
  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8007df2:	687b      	ldr	r3, [r7, #4]
 8007df4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007df6:	2280      	movs	r2, #128	; 0x80
 8007df8:	0092      	lsls	r2, r2, #2
 8007dfa:	431a      	orrs	r2, r3
 8007dfc:	687b      	ldr	r3, [r7, #4]
 8007dfe:	655a      	str	r2, [r3, #84]	; 0x54
  
  /* Determine whether any further conversion upcoming on group regular       */
  /* by external trigger, continuous mode or scan sequence on going.          */
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8007e00:	687b      	ldr	r3, [r7, #4]
 8007e02:	681b      	ldr	r3, [r3, #0]
 8007e04:	68da      	ldr	r2, [r3, #12]
 8007e06:	23c0      	movs	r3, #192	; 0xc0
 8007e08:	011b      	lsls	r3, r3, #4
 8007e0a:	4013      	ands	r3, r2
 8007e0c:	d12e      	bne.n	8007e6c <HAL_ADC_PollForConversion+0x124>
     (hadc->Init.ContinuousConvMode == DISABLE)   )
 8007e0e:	687b      	ldr	r3, [r7, #4]
 8007e10:	2220      	movs	r2, #32
 8007e12:	5c9b      	ldrb	r3, [r3, r2]
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8007e14:	2b00      	cmp	r3, #0
 8007e16:	d129      	bne.n	8007e6c <HAL_ADC_PollForConversion+0x124>
  {
    /* If End of Sequence is reached, disable interrupts */
    if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 8007e18:	687b      	ldr	r3, [r7, #4]
 8007e1a:	681b      	ldr	r3, [r3, #0]
 8007e1c:	681b      	ldr	r3, [r3, #0]
 8007e1e:	2208      	movs	r2, #8
 8007e20:	4013      	ands	r3, r2
 8007e22:	2b08      	cmp	r3, #8
 8007e24:	d122      	bne.n	8007e6c <HAL_ADC_PollForConversion+0x124>
    {
      /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit             */
      /* ADSTART==0 (no conversion on going)                                  */
      if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007e26:	687b      	ldr	r3, [r7, #4]
 8007e28:	681b      	ldr	r3, [r3, #0]
 8007e2a:	689b      	ldr	r3, [r3, #8]
 8007e2c:	2204      	movs	r2, #4
 8007e2e:	4013      	ands	r3, r2
 8007e30:	d110      	bne.n	8007e54 <HAL_ADC_PollForConversion+0x10c>
      {
        /* Disable ADC end of single conversion interrupt on group regular */
        /* Note: Overrun interrupt was enabled with EOC interrupt in          */
        /* HAL_Start_IT(), but is not disabled here because can be used       */
        /* by overrun IRQ process below.                                      */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8007e32:	687b      	ldr	r3, [r7, #4]
 8007e34:	681b      	ldr	r3, [r3, #0]
 8007e36:	685a      	ldr	r2, [r3, #4]
 8007e38:	687b      	ldr	r3, [r7, #4]
 8007e3a:	681b      	ldr	r3, [r3, #0]
 8007e3c:	210c      	movs	r1, #12
 8007e3e:	438a      	bics	r2, r1
 8007e40:	605a      	str	r2, [r3, #4]
        
        /* Set ADC state */
        ADC_STATE_CLR_SET(hadc->State,
 8007e42:	687b      	ldr	r3, [r7, #4]
 8007e44:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007e46:	4a13      	ldr	r2, [pc, #76]	; (8007e94 <HAL_ADC_PollForConversion+0x14c>)
 8007e48:	4013      	ands	r3, r2
 8007e4a:	2201      	movs	r2, #1
 8007e4c:	431a      	orrs	r2, r3
 8007e4e:	687b      	ldr	r3, [r7, #4]
 8007e50:	655a      	str	r2, [r3, #84]	; 0x54
 8007e52:	e00b      	b.n	8007e6c <HAL_ADC_PollForConversion+0x124>
                          HAL_ADC_STATE_READY);
      }
      else
      {
        /* Change ADC state to error state */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007e54:	687b      	ldr	r3, [r7, #4]
 8007e56:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007e58:	2220      	movs	r2, #32
 8007e5a:	431a      	orrs	r2, r3
 8007e5c:	687b      	ldr	r3, [r7, #4]
 8007e5e:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Set ADC error code to ADC peripheral internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007e60:	687b      	ldr	r3, [r7, #4]
 8007e62:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007e64:	2201      	movs	r2, #1
 8007e66:	431a      	orrs	r2, r3
 8007e68:	687b      	ldr	r3, [r7, #4]
 8007e6a:	659a      	str	r2, [r3, #88]	; 0x58
  }
  
  /* Clear end of conversion flag of regular group if low power feature       */
  /* "LowPowerAutoWait " is disabled, to not interfere with this feature      */
  /* until data register is read using function HAL_ADC_GetValue().           */
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 8007e6c:	687b      	ldr	r3, [r7, #4]
 8007e6e:	699b      	ldr	r3, [r3, #24]
 8007e70:	2b00      	cmp	r3, #0
 8007e72:	d103      	bne.n	8007e7c <HAL_ADC_PollForConversion+0x134>
  {
    /* Clear regular group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8007e74:	687b      	ldr	r3, [r7, #4]
 8007e76:	681b      	ldr	r3, [r3, #0]
 8007e78:	220c      	movs	r2, #12
 8007e7a:	601a      	str	r2, [r3, #0]
  }
  
  /* Return function status */
  return HAL_OK;
 8007e7c:	2300      	movs	r3, #0
}
 8007e7e:	0018      	movs	r0, r3
 8007e80:	46bd      	mov	sp, r7
 8007e82:	b004      	add	sp, #16
 8007e84:	bd80      	pop	{r7, pc}
 8007e86:	46c0      	nop			; (mov r8, r8)
 8007e88:	40012400 	.word	0x40012400
 8007e8c:	00000486 	.word	0x00000486
 8007e90:	0800dd3c 	.word	0x0800dd3c
 8007e94:	fffffefe 	.word	0xfffffefe

08007e98 <HAL_ADC_GetValue>:
  *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_EOS).
  * @param  hadc ADC handle
  * @retval ADC group regular conversion data
  */
uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
{
 8007e98:	b580      	push	{r7, lr}
 8007e9a:	b082      	sub	sp, #8
 8007e9c:	af00      	add	r7, sp, #0
 8007e9e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8007ea0:	687b      	ldr	r3, [r7, #4]
 8007ea2:	681b      	ldr	r3, [r3, #0]
 8007ea4:	4a07      	ldr	r2, [pc, #28]	; (8007ec4 <HAL_ADC_GetValue+0x2c>)
 8007ea6:	4293      	cmp	r3, r2
 8007ea8:	d005      	beq.n	8007eb6 <HAL_ADC_GetValue+0x1e>
 8007eaa:	4a07      	ldr	r2, [pc, #28]	; (8007ec8 <HAL_ADC_GetValue+0x30>)
 8007eac:	4b07      	ldr	r3, [pc, #28]	; (8007ecc <HAL_ADC_GetValue+0x34>)
 8007eae:	0011      	movs	r1, r2
 8007eb0:	0018      	movs	r0, r3
 8007eb2:	f7fe f9f0 	bl	8006296 <assert_failed>

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */
  
  /* Return ADC converted value */ 
  return hadc->Instance->DR;
 8007eb6:	687b      	ldr	r3, [r7, #4]
 8007eb8:	681b      	ldr	r3, [r3, #0]
 8007eba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 8007ebc:	0018      	movs	r0, r3
 8007ebe:	46bd      	mov	sp, r7
 8007ec0:	b002      	add	sp, #8
 8007ec2:	bd80      	pop	{r7, pc}
 8007ec4:	40012400 	.word	0x40012400
 8007ec8:	00000686 	.word	0x00000686
 8007ecc:	0800dd3c 	.word	0x0800dd3c

08007ed0 <HAL_ADC_ConfigChannel>:
  * @param  hadc ADC handle
  * @param  sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 8007ed0:	b580      	push	{r7, lr}
 8007ed2:	b082      	sub	sp, #8
 8007ed4:	af00      	add	r7, sp, #0
 8007ed6:	6078      	str	r0, [r7, #4]
 8007ed8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8007eda:	687b      	ldr	r3, [r7, #4]
 8007edc:	681b      	ldr	r3, [r3, #0]
 8007ede:	4a88      	ldr	r2, [pc, #544]	; (8008100 <HAL_ADC_ConfigChannel+0x230>)
 8007ee0:	4293      	cmp	r3, r2
 8007ee2:	d005      	beq.n	8007ef0 <HAL_ADC_ConfigChannel+0x20>
 8007ee4:	4a87      	ldr	r2, [pc, #540]	; (8008104 <HAL_ADC_ConfigChannel+0x234>)
 8007ee6:	4b88      	ldr	r3, [pc, #544]	; (8008108 <HAL_ADC_ConfigChannel+0x238>)
 8007ee8:	0011      	movs	r1, r2
 8007eea:	0018      	movs	r0, r3
 8007eec:	f7fe f9d3 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
 8007ef0:	683b      	ldr	r3, [r7, #0]
 8007ef2:	681b      	ldr	r3, [r3, #0]
 8007ef4:	2b01      	cmp	r3, #1
 8007ef6:	d100      	bne.n	8007efa <HAL_ADC_ConfigChannel+0x2a>
 8007ef8:	e05f      	b.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007efa:	683b      	ldr	r3, [r7, #0]
 8007efc:	681b      	ldr	r3, [r3, #0]
 8007efe:	4a83      	ldr	r2, [pc, #524]	; (800810c <HAL_ADC_ConfigChannel+0x23c>)
 8007f00:	4293      	cmp	r3, r2
 8007f02:	d05a      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f04:	683b      	ldr	r3, [r7, #0]
 8007f06:	681b      	ldr	r3, [r3, #0]
 8007f08:	4a81      	ldr	r2, [pc, #516]	; (8008110 <HAL_ADC_ConfigChannel+0x240>)
 8007f0a:	4293      	cmp	r3, r2
 8007f0c:	d055      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f0e:	683b      	ldr	r3, [r7, #0]
 8007f10:	681b      	ldr	r3, [r3, #0]
 8007f12:	4a80      	ldr	r2, [pc, #512]	; (8008114 <HAL_ADC_ConfigChannel+0x244>)
 8007f14:	4293      	cmp	r3, r2
 8007f16:	d050      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f18:	683b      	ldr	r3, [r7, #0]
 8007f1a:	681b      	ldr	r3, [r3, #0]
 8007f1c:	4a7e      	ldr	r2, [pc, #504]	; (8008118 <HAL_ADC_ConfigChannel+0x248>)
 8007f1e:	4293      	cmp	r3, r2
 8007f20:	d04b      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f22:	683b      	ldr	r3, [r7, #0]
 8007f24:	681b      	ldr	r3, [r3, #0]
 8007f26:	4a7d      	ldr	r2, [pc, #500]	; (800811c <HAL_ADC_ConfigChannel+0x24c>)
 8007f28:	4293      	cmp	r3, r2
 8007f2a:	d046      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f2c:	683b      	ldr	r3, [r7, #0]
 8007f2e:	681b      	ldr	r3, [r3, #0]
 8007f30:	4a7b      	ldr	r2, [pc, #492]	; (8008120 <HAL_ADC_ConfigChannel+0x250>)
 8007f32:	4293      	cmp	r3, r2
 8007f34:	d041      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f36:	683b      	ldr	r3, [r7, #0]
 8007f38:	681b      	ldr	r3, [r3, #0]
 8007f3a:	4a7a      	ldr	r2, [pc, #488]	; (8008124 <HAL_ADC_ConfigChannel+0x254>)
 8007f3c:	4293      	cmp	r3, r2
 8007f3e:	d03c      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f40:	683b      	ldr	r3, [r7, #0]
 8007f42:	681b      	ldr	r3, [r3, #0]
 8007f44:	4a78      	ldr	r2, [pc, #480]	; (8008128 <HAL_ADC_ConfigChannel+0x258>)
 8007f46:	4293      	cmp	r3, r2
 8007f48:	d037      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f4a:	683b      	ldr	r3, [r7, #0]
 8007f4c:	681b      	ldr	r3, [r3, #0]
 8007f4e:	4a77      	ldr	r2, [pc, #476]	; (800812c <HAL_ADC_ConfigChannel+0x25c>)
 8007f50:	4293      	cmp	r3, r2
 8007f52:	d032      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f54:	683b      	ldr	r3, [r7, #0]
 8007f56:	681b      	ldr	r3, [r3, #0]
 8007f58:	4a75      	ldr	r2, [pc, #468]	; (8008130 <HAL_ADC_ConfigChannel+0x260>)
 8007f5a:	4293      	cmp	r3, r2
 8007f5c:	d02d      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f5e:	683b      	ldr	r3, [r7, #0]
 8007f60:	681b      	ldr	r3, [r3, #0]
 8007f62:	4a74      	ldr	r2, [pc, #464]	; (8008134 <HAL_ADC_ConfigChannel+0x264>)
 8007f64:	4293      	cmp	r3, r2
 8007f66:	d028      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f68:	683b      	ldr	r3, [r7, #0]
 8007f6a:	681b      	ldr	r3, [r3, #0]
 8007f6c:	4a72      	ldr	r2, [pc, #456]	; (8008138 <HAL_ADC_ConfigChannel+0x268>)
 8007f6e:	4293      	cmp	r3, r2
 8007f70:	d023      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f72:	683b      	ldr	r3, [r7, #0]
 8007f74:	681b      	ldr	r3, [r3, #0]
 8007f76:	4a71      	ldr	r2, [pc, #452]	; (800813c <HAL_ADC_ConfigChannel+0x26c>)
 8007f78:	4293      	cmp	r3, r2
 8007f7a:	d01e      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f7c:	683b      	ldr	r3, [r7, #0]
 8007f7e:	681b      	ldr	r3, [r3, #0]
 8007f80:	4a6f      	ldr	r2, [pc, #444]	; (8008140 <HAL_ADC_ConfigChannel+0x270>)
 8007f82:	4293      	cmp	r3, r2
 8007f84:	d019      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f86:	683b      	ldr	r3, [r7, #0]
 8007f88:	681b      	ldr	r3, [r3, #0]
 8007f8a:	4a6e      	ldr	r2, [pc, #440]	; (8008144 <HAL_ADC_ConfigChannel+0x274>)
 8007f8c:	4293      	cmp	r3, r2
 8007f8e:	d014      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f90:	683b      	ldr	r3, [r7, #0]
 8007f92:	681b      	ldr	r3, [r3, #0]
 8007f94:	4a6c      	ldr	r2, [pc, #432]	; (8008148 <HAL_ADC_ConfigChannel+0x278>)
 8007f96:	4293      	cmp	r3, r2
 8007f98:	d00f      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007f9a:	683b      	ldr	r3, [r7, #0]
 8007f9c:	681b      	ldr	r3, [r3, #0]
 8007f9e:	4a6b      	ldr	r2, [pc, #428]	; (800814c <HAL_ADC_ConfigChannel+0x27c>)
 8007fa0:	4293      	cmp	r3, r2
 8007fa2:	d00a      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007fa4:	683b      	ldr	r3, [r7, #0]
 8007fa6:	681b      	ldr	r3, [r3, #0]
 8007fa8:	4a69      	ldr	r2, [pc, #420]	; (8008150 <HAL_ADC_ConfigChannel+0x280>)
 8007faa:	4293      	cmp	r3, r2
 8007fac:	d005      	beq.n	8007fba <HAL_ADC_ConfigChannel+0xea>
 8007fae:	4a69      	ldr	r2, [pc, #420]	; (8008154 <HAL_ADC_ConfigChannel+0x284>)
 8007fb0:	4b55      	ldr	r3, [pc, #340]	; (8008108 <HAL_ADC_ConfigChannel+0x238>)
 8007fb2:	0011      	movs	r1, r2
 8007fb4:	0018      	movs	r0, r3
 8007fb6:	f7fe f96e 	bl	8006296 <assert_failed>
  assert_param(IS_ADC_RANK(sConfig->Rank));
 8007fba:	683b      	ldr	r3, [r7, #0]
 8007fbc:	685a      	ldr	r2, [r3, #4]
 8007fbe:	2380      	movs	r3, #128	; 0x80
 8007fc0:	015b      	lsls	r3, r3, #5
 8007fc2:	429a      	cmp	r2, r3
 8007fc4:	d00a      	beq.n	8007fdc <HAL_ADC_ConfigChannel+0x10c>
 8007fc6:	683b      	ldr	r3, [r7, #0]
 8007fc8:	685b      	ldr	r3, [r3, #4]
 8007fca:	4a63      	ldr	r2, [pc, #396]	; (8008158 <HAL_ADC_ConfigChannel+0x288>)
 8007fcc:	4293      	cmp	r3, r2
 8007fce:	d005      	beq.n	8007fdc <HAL_ADC_ConfigChannel+0x10c>
 8007fd0:	4a62      	ldr	r2, [pc, #392]	; (800815c <HAL_ADC_ConfigChannel+0x28c>)
 8007fd2:	4b4d      	ldr	r3, [pc, #308]	; (8008108 <HAL_ADC_ConfigChannel+0x238>)
 8007fd4:	0011      	movs	r1, r2
 8007fd6:	0018      	movs	r0, r3
 8007fd8:	f7fe f95d 	bl	8006296 <assert_failed>
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8007fdc:	687b      	ldr	r3, [r7, #4]
 8007fde:	2250      	movs	r2, #80	; 0x50
 8007fe0:	5c9b      	ldrb	r3, [r3, r2]
 8007fe2:	2b01      	cmp	r3, #1
 8007fe4:	d101      	bne.n	8007fea <HAL_ADC_ConfigChannel+0x11a>
 8007fe6:	2302      	movs	r3, #2
 8007fe8:	e085      	b.n	80080f6 <HAL_ADC_ConfigChannel+0x226>
 8007fea:	687b      	ldr	r3, [r7, #4]
 8007fec:	2250      	movs	r2, #80	; 0x50
 8007fee:	2101      	movs	r1, #1
 8007ff0:	5499      	strb	r1, [r3, r2]
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Management of internal measurement channels: Vbat/VrefInt/TempSensor  */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) != RESET)
 8007ff2:	687b      	ldr	r3, [r7, #4]
 8007ff4:	681b      	ldr	r3, [r3, #0]
 8007ff6:	689b      	ldr	r3, [r3, #8]
 8007ff8:	2204      	movs	r2, #4
 8007ffa:	4013      	ands	r3, r2
 8007ffc:	d00b      	beq.n	8008016 <HAL_ADC_ConfigChannel+0x146>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007ffe:	687b      	ldr	r3, [r7, #4]
 8008000:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008002:	2220      	movs	r2, #32
 8008004:	431a      	orrs	r2, r3
 8008006:	687b      	ldr	r3, [r7, #4]
 8008008:	655a      	str	r2, [r3, #84]	; 0x54
    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 800800a:	687b      	ldr	r3, [r7, #4]
 800800c:	2250      	movs	r2, #80	; 0x50
 800800e:	2100      	movs	r1, #0
 8008010:	5499      	strb	r1, [r3, r2]
    return HAL_ERROR;
 8008012:	2301      	movs	r3, #1
 8008014:	e06f      	b.n	80080f6 <HAL_ADC_ConfigChannel+0x226>
  }
  
  if (sConfig->Rank != ADC_RANK_NONE)
 8008016:	683b      	ldr	r3, [r7, #0]
 8008018:	685b      	ldr	r3, [r3, #4]
 800801a:	4a4f      	ldr	r2, [pc, #316]	; (8008158 <HAL_ADC_ConfigChannel+0x288>)
 800801c:	4293      	cmp	r3, r2
 800801e:	d035      	beq.n	800808c <HAL_ADC_ConfigChannel+0x1bc>
  {
    /* Enable selected channels */
    hadc->Instance->CHSELR |= (uint32_t)(sConfig->Channel & ADC_CHANNEL_MASK);
 8008020:	687b      	ldr	r3, [r7, #4]
 8008022:	681b      	ldr	r3, [r3, #0]
 8008024:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8008026:	683b      	ldr	r3, [r7, #0]
 8008028:	681b      	ldr	r3, [r3, #0]
 800802a:	035b      	lsls	r3, r3, #13
 800802c:	0b5a      	lsrs	r2, r3, #13
 800802e:	687b      	ldr	r3, [r7, #4]
 8008030:	681b      	ldr	r3, [r3, #0]
 8008032:	430a      	orrs	r2, r1
 8008034:	629a      	str	r2, [r3, #40]	; 0x28
    /* dedicated internal buffers and path.                                     */
    
    #if defined(ADC_CCR_TSEN)
    /* If Temperature sensor channel is selected, then enable the internal      */
    /* buffers and path  */
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_TEMPSENSOR ) == (ADC_CHANNEL_TEMPSENSOR & ADC_CHANNEL_MASK))
 8008036:	683b      	ldr	r3, [r7, #0]
 8008038:	681a      	ldr	r2, [r3, #0]
 800803a:	2380      	movs	r3, #128	; 0x80
 800803c:	02db      	lsls	r3, r3, #11
 800803e:	4013      	ands	r3, r2
 8008040:	d009      	beq.n	8008056 <HAL_ADC_ConfigChannel+0x186>
    {
      ADC->CCR |= ADC_CCR_TSEN;   
 8008042:	4b47      	ldr	r3, [pc, #284]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 8008044:	681a      	ldr	r2, [r3, #0]
 8008046:	4b46      	ldr	r3, [pc, #280]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 8008048:	2180      	movs	r1, #128	; 0x80
 800804a:	0409      	lsls	r1, r1, #16
 800804c:	430a      	orrs	r2, r1
 800804e:	601a      	str	r2, [r3, #0]
      
      /* Delay for temperature sensor stabilization time */
      ADC_DelayMicroSecond(ADC_TEMPSENSOR_DELAY_US);
 8008050:	200a      	movs	r0, #10
 8008052:	f000 f8ed 	bl	8008230 <ADC_DelayMicroSecond>
    }
    #endif
    
    /* If VRefInt channel is selected, then enable the internal buffers and path   */
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_VREFINT) == (ADC_CHANNEL_VREFINT & ADC_CHANNEL_MASK))
 8008056:	683b      	ldr	r3, [r7, #0]
 8008058:	681a      	ldr	r2, [r3, #0]
 800805a:	2380      	movs	r3, #128	; 0x80
 800805c:	029b      	lsls	r3, r3, #10
 800805e:	4013      	ands	r3, r2
 8008060:	d006      	beq.n	8008070 <HAL_ADC_ConfigChannel+0x1a0>
    {
      ADC->CCR |= ADC_CCR_VREFEN;   
 8008062:	4b3f      	ldr	r3, [pc, #252]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 8008064:	681a      	ldr	r2, [r3, #0]
 8008066:	4b3e      	ldr	r3, [pc, #248]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 8008068:	2180      	movs	r1, #128	; 0x80
 800806a:	03c9      	lsls	r1, r1, #15
 800806c:	430a      	orrs	r2, r1
 800806e:	601a      	str	r2, [r3, #0]
    }
    
#if defined (STM32L053xx) || defined (STM32L063xx) || defined (STM32L073xx) || defined (STM32L083xx)
    /* If Vlcd channel is selected, then enable the internal buffers and path   */
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_VLCD) == (ADC_CHANNEL_VLCD & ADC_CHANNEL_MASK))
 8008070:	683b      	ldr	r3, [r7, #0]
 8008072:	681a      	ldr	r2, [r3, #0]
 8008074:	2380      	movs	r3, #128	; 0x80
 8008076:	025b      	lsls	r3, r3, #9
 8008078:	4013      	ands	r3, r2
 800807a:	d037      	beq.n	80080ec <HAL_ADC_ConfigChannel+0x21c>
    {
      ADC->CCR |= ADC_CCR_VLCDEN;   
 800807c:	4b38      	ldr	r3, [pc, #224]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 800807e:	681a      	ldr	r2, [r3, #0]
 8008080:	4b37      	ldr	r3, [pc, #220]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 8008082:	2180      	movs	r1, #128	; 0x80
 8008084:	0449      	lsls	r1, r1, #17
 8008086:	430a      	orrs	r2, r1
 8008088:	601a      	str	r2, [r3, #0]
 800808a:	e02f      	b.n	80080ec <HAL_ADC_ConfigChannel+0x21c>
  }
  else
  {
    /* Regular sequence configuration */
    /* Reset the channel selection register from the selected channel */
    hadc->Instance->CHSELR &= ~((uint32_t)(sConfig->Channel & ADC_CHANNEL_MASK));
 800808c:	687b      	ldr	r3, [r7, #4]
 800808e:	681b      	ldr	r3, [r3, #0]
 8008090:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8008092:	683b      	ldr	r3, [r7, #0]
 8008094:	681b      	ldr	r3, [r3, #0]
 8008096:	035b      	lsls	r3, r3, #13
 8008098:	0b5b      	lsrs	r3, r3, #13
 800809a:	43d9      	mvns	r1, r3
 800809c:	687b      	ldr	r3, [r7, #4]
 800809e:	681b      	ldr	r3, [r3, #0]
 80080a0:	400a      	ands	r2, r1
 80080a2:	629a      	str	r2, [r3, #40]	; 0x28
    
    /* Management of internal measurement channels: VrefInt/TempSensor/Vbat */
    /* internal measurement paths disable: If internal channel selected,    */
    /* disable dedicated internal buffers and path.                         */
    #if defined(ADC_CCR_TSEN)
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_TEMPSENSOR ) == (ADC_CHANNEL_TEMPSENSOR & ADC_CHANNEL_MASK))
 80080a4:	683b      	ldr	r3, [r7, #0]
 80080a6:	681a      	ldr	r2, [r3, #0]
 80080a8:	2380      	movs	r3, #128	; 0x80
 80080aa:	02db      	lsls	r3, r3, #11
 80080ac:	4013      	ands	r3, r2
 80080ae:	d005      	beq.n	80080bc <HAL_ADC_ConfigChannel+0x1ec>
    {
      ADC->CCR &= ~ADC_CCR_TSEN;   
 80080b0:	4b2b      	ldr	r3, [pc, #172]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 80080b2:	681a      	ldr	r2, [r3, #0]
 80080b4:	4b2a      	ldr	r3, [pc, #168]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 80080b6:	492b      	ldr	r1, [pc, #172]	; (8008164 <HAL_ADC_ConfigChannel+0x294>)
 80080b8:	400a      	ands	r2, r1
 80080ba:	601a      	str	r2, [r3, #0]
    }
    #endif
    
    /* If VRefInt channel is selected, then enable the internal buffers and path   */
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_VREFINT) == (ADC_CHANNEL_VREFINT & ADC_CHANNEL_MASK))
 80080bc:	683b      	ldr	r3, [r7, #0]
 80080be:	681a      	ldr	r2, [r3, #0]
 80080c0:	2380      	movs	r3, #128	; 0x80
 80080c2:	029b      	lsls	r3, r3, #10
 80080c4:	4013      	ands	r3, r2
 80080c6:	d005      	beq.n	80080d4 <HAL_ADC_ConfigChannel+0x204>
    {
      ADC->CCR &= ~ADC_CCR_VREFEN;   
 80080c8:	4b25      	ldr	r3, [pc, #148]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 80080ca:	681a      	ldr	r2, [r3, #0]
 80080cc:	4b24      	ldr	r3, [pc, #144]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 80080ce:	4926      	ldr	r1, [pc, #152]	; (8008168 <HAL_ADC_ConfigChannel+0x298>)
 80080d0:	400a      	ands	r2, r1
 80080d2:	601a      	str	r2, [r3, #0]
    }
    
#if defined (STM32L053xx) || defined (STM32L063xx) || defined (STM32L073xx) || defined (STM32L083xx)
    /* If Vlcd channel is selected, then enable the internal buffers and path   */
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_VLCD) == (ADC_CHANNEL_VLCD & ADC_CHANNEL_MASK))
 80080d4:	683b      	ldr	r3, [r7, #0]
 80080d6:	681a      	ldr	r2, [r3, #0]
 80080d8:	2380      	movs	r3, #128	; 0x80
 80080da:	025b      	lsls	r3, r3, #9
 80080dc:	4013      	ands	r3, r2
 80080de:	d005      	beq.n	80080ec <HAL_ADC_ConfigChannel+0x21c>
    {
      ADC->CCR &= ~ADC_CCR_VLCDEN;   
 80080e0:	4b1f      	ldr	r3, [pc, #124]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 80080e2:	681a      	ldr	r2, [r3, #0]
 80080e4:	4b1e      	ldr	r3, [pc, #120]	; (8008160 <HAL_ADC_ConfigChannel+0x290>)
 80080e6:	4921      	ldr	r1, [pc, #132]	; (800816c <HAL_ADC_ConfigChannel+0x29c>)
 80080e8:	400a      	ands	r2, r1
 80080ea:	601a      	str	r2, [r3, #0]
    }
#endif
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80080ec:	687b      	ldr	r3, [r7, #4]
 80080ee:	2250      	movs	r2, #80	; 0x50
 80080f0:	2100      	movs	r1, #0
 80080f2:	5499      	strb	r1, [r3, r2]
  
  /* Return function status */
  return HAL_OK;
 80080f4:	2300      	movs	r3, #0
}
 80080f6:	0018      	movs	r0, r3
 80080f8:	46bd      	mov	sp, r7
 80080fa:	b002      	add	sp, #8
 80080fc:	bd80      	pop	{r7, pc}
 80080fe:	46c0      	nop			; (mov r8, r8)
 8008100:	40012400 	.word	0x40012400
 8008104:	00000781 	.word	0x00000781
 8008108:	0800dd3c 	.word	0x0800dd3c
 800810c:	04000002 	.word	0x04000002
 8008110:	08000004 	.word	0x08000004
 8008114:	0c000008 	.word	0x0c000008
 8008118:	10000010 	.word	0x10000010
 800811c:	14000020 	.word	0x14000020
 8008120:	18000040 	.word	0x18000040
 8008124:	1c000080 	.word	0x1c000080
 8008128:	20000100 	.word	0x20000100
 800812c:	24000200 	.word	0x24000200
 8008130:	28000400 	.word	0x28000400
 8008134:	2c000800 	.word	0x2c000800
 8008138:	30001000 	.word	0x30001000
 800813c:	34002000 	.word	0x34002000
 8008140:	38004000 	.word	0x38004000
 8008144:	3c008000 	.word	0x3c008000
 8008148:	48040000 	.word	0x48040000
 800814c:	44020000 	.word	0x44020000
 8008150:	40010000 	.word	0x40010000
 8008154:	00000782 	.word	0x00000782
 8008158:	00001001 	.word	0x00001001
 800815c:	00000783 	.word	0x00000783
 8008160:	40012708 	.word	0x40012708
 8008164:	ff7fffff 	.word	0xff7fffff
 8008168:	ffbfffff 	.word	0xffbfffff
 800816c:	feffffff 	.word	0xfeffffff

08008170 <ADC_Enable>:
  *         "if (hadc->Init.LowPowerAutoPowerOff != ENABLE)".
  * @param  hadc ADC handle
  * @retval HAL status.
  */
static HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
 8008170:	b580      	push	{r7, lr}
 8008172:	b084      	sub	sp, #16
 8008174:	af00      	add	r7, sp, #0
 8008176:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8008178:	2300      	movs	r3, #0
 800817a:	60fb      	str	r3, [r7, #12]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 800817c:	687b      	ldr	r3, [r7, #4]
 800817e:	681b      	ldr	r3, [r3, #0]
 8008180:	689b      	ldr	r3, [r3, #8]
 8008182:	2203      	movs	r2, #3
 8008184:	4013      	ands	r3, r2
 8008186:	2b01      	cmp	r3, #1
 8008188:	d108      	bne.n	800819c <ADC_Enable+0x2c>
 800818a:	687b      	ldr	r3, [r7, #4]
 800818c:	681b      	ldr	r3, [r3, #0]
 800818e:	681b      	ldr	r3, [r3, #0]
 8008190:	2201      	movs	r2, #1
 8008192:	4013      	ands	r3, r2
 8008194:	2b01      	cmp	r3, #1
 8008196:	d101      	bne.n	800819c <ADC_Enable+0x2c>
 8008198:	2301      	movs	r3, #1
 800819a:	e000      	b.n	800819e <ADC_Enable+0x2e>
 800819c:	2300      	movs	r3, #0
 800819e:	2b00      	cmp	r3, #0
 80081a0:	d13f      	bne.n	8008222 <ADC_Enable+0xb2>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 80081a2:	687b      	ldr	r3, [r7, #4]
 80081a4:	681b      	ldr	r3, [r3, #0]
 80081a6:	689b      	ldr	r3, [r3, #8]
 80081a8:	4a20      	ldr	r2, [pc, #128]	; (800822c <ADC_Enable+0xbc>)
 80081aa:	4013      	ands	r3, r2
 80081ac:	d00d      	beq.n	80081ca <ADC_Enable+0x5a>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80081ae:	687b      	ldr	r3, [r7, #4]
 80081b0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80081b2:	2210      	movs	r2, #16
 80081b4:	431a      	orrs	r2, r3
 80081b6:	687b      	ldr	r3, [r7, #4]
 80081b8:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80081ba:	687b      	ldr	r3, [r7, #4]
 80081bc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80081be:	2201      	movs	r2, #1
 80081c0:	431a      	orrs	r2, r3
 80081c2:	687b      	ldr	r3, [r7, #4]
 80081c4:	659a      	str	r2, [r3, #88]	; 0x58
      
      return HAL_ERROR;
 80081c6:	2301      	movs	r3, #1
 80081c8:	e02c      	b.n	8008224 <ADC_Enable+0xb4>
    }
    
    /* Enable the ADC peripheral */
    __HAL_ADC_ENABLE(hadc);
 80081ca:	687b      	ldr	r3, [r7, #4]
 80081cc:	681b      	ldr	r3, [r3, #0]
 80081ce:	689a      	ldr	r2, [r3, #8]
 80081d0:	687b      	ldr	r3, [r7, #4]
 80081d2:	681b      	ldr	r3, [r3, #0]
 80081d4:	2101      	movs	r1, #1
 80081d6:	430a      	orrs	r2, r1
 80081d8:	609a      	str	r2, [r3, #8]
    
    /* Delay for ADC stabilization time. */
    ADC_DelayMicroSecond(ADC_STAB_DELAY_US);
 80081da:	2001      	movs	r0, #1
 80081dc:	f000 f828 	bl	8008230 <ADC_DelayMicroSecond>

    /* Get tick count */
    tickstart = HAL_GetTick();
 80081e0:	f7ff f980 	bl	80074e4 <HAL_GetTick>
 80081e4:	0003      	movs	r3, r0
 80081e6:	60fb      	str	r3, [r7, #12]
    
    /* Wait for ADC effectively enabled */
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 80081e8:	e014      	b.n	8008214 <ADC_Enable+0xa4>
    {
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 80081ea:	f7ff f97b 	bl	80074e4 <HAL_GetTick>
 80081ee:	0002      	movs	r2, r0
 80081f0:	68fb      	ldr	r3, [r7, #12]
 80081f2:	1ad3      	subs	r3, r2, r3
 80081f4:	2b0a      	cmp	r3, #10
 80081f6:	d90d      	bls.n	8008214 <ADC_Enable+0xa4>
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80081f8:	687b      	ldr	r3, [r7, #4]
 80081fa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80081fc:	2210      	movs	r2, #16
 80081fe:	431a      	orrs	r2, r3
 8008200:	687b      	ldr	r3, [r7, #4]
 8008202:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Set ADC error code to ADC peripheral internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8008204:	687b      	ldr	r3, [r7, #4]
 8008206:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008208:	2201      	movs	r2, #1
 800820a:	431a      	orrs	r2, r3
 800820c:	687b      	ldr	r3, [r7, #4]
 800820e:	659a      	str	r2, [r3, #88]	; 0x58
        
        return HAL_ERROR;
 8008210:	2301      	movs	r3, #1
 8008212:	e007      	b.n	8008224 <ADC_Enable+0xb4>
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 8008214:	687b      	ldr	r3, [r7, #4]
 8008216:	681b      	ldr	r3, [r3, #0]
 8008218:	681b      	ldr	r3, [r3, #0]
 800821a:	2201      	movs	r2, #1
 800821c:	4013      	ands	r3, r2
 800821e:	2b01      	cmp	r3, #1
 8008220:	d1e3      	bne.n	80081ea <ADC_Enable+0x7a>
      }
    }
  }
   
  /* Return HAL status */
  return HAL_OK;
 8008222:	2300      	movs	r3, #0
}
 8008224:	0018      	movs	r0, r3
 8008226:	46bd      	mov	sp, r7
 8008228:	b004      	add	sp, #16
 800822a:	bd80      	pop	{r7, pc}
 800822c:	80000017 	.word	0x80000017

08008230 <ADC_DelayMicroSecond>:
  * @brief  Delay micro seconds 
  * @param  microSecond  delay
  * @retval None
  */
static void ADC_DelayMicroSecond(uint32_t microSecond)
{
 8008230:	b580      	push	{r7, lr}
 8008232:	b084      	sub	sp, #16
 8008234:	af00      	add	r7, sp, #0
 8008236:	6078      	str	r0, [r7, #4]
  /* Compute number of CPU cycles to wait for */
  __IO uint32_t waitLoopIndex = (microSecond * (SystemCoreClock / 1000000U));
 8008238:	4b0b      	ldr	r3, [pc, #44]	; (8008268 <ADC_DelayMicroSecond+0x38>)
 800823a:	681b      	ldr	r3, [r3, #0]
 800823c:	490b      	ldr	r1, [pc, #44]	; (800826c <ADC_DelayMicroSecond+0x3c>)
 800823e:	0018      	movs	r0, r3
 8008240:	f7f7 ff62 	bl	8000108 <__udivsi3>
 8008244:	0003      	movs	r3, r0
 8008246:	001a      	movs	r2, r3
 8008248:	687b      	ldr	r3, [r7, #4]
 800824a:	4353      	muls	r3, r2
 800824c:	60fb      	str	r3, [r7, #12]

  while(waitLoopIndex != 0U)
 800824e:	e002      	b.n	8008256 <ADC_DelayMicroSecond+0x26>
  {
    waitLoopIndex--;
 8008250:	68fb      	ldr	r3, [r7, #12]
 8008252:	3b01      	subs	r3, #1
 8008254:	60fb      	str	r3, [r7, #12]
  while(waitLoopIndex != 0U)
 8008256:	68fb      	ldr	r3, [r7, #12]
 8008258:	2b00      	cmp	r3, #0
 800825a:	d1f9      	bne.n	8008250 <ADC_DelayMicroSecond+0x20>
  } 
}
 800825c:	46c0      	nop			; (mov r8, r8)
 800825e:	46c0      	nop			; (mov r8, r8)
 8008260:	46bd      	mov	sp, r7
 8008262:	b004      	add	sp, #16
 8008264:	bd80      	pop	{r7, pc}
 8008266:	46c0      	nop			; (mov r8, r8)
 8008268:	2000004c 	.word	0x2000004c
 800826c:	000f4240 	.word	0x000f4240

08008270 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8008270:	b580      	push	{r7, lr}
 8008272:	b082      	sub	sp, #8
 8008274:	af00      	add	r7, sp, #0
 8008276:	0002      	movs	r2, r0
 8008278:	1dfb      	adds	r3, r7, #7
 800827a:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 800827c:	1dfb      	adds	r3, r7, #7
 800827e:	781b      	ldrb	r3, [r3, #0]
 8008280:	2b7f      	cmp	r3, #127	; 0x7f
 8008282:	d809      	bhi.n	8008298 <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8008284:	1dfb      	adds	r3, r7, #7
 8008286:	781b      	ldrb	r3, [r3, #0]
 8008288:	001a      	movs	r2, r3
 800828a:	231f      	movs	r3, #31
 800828c:	401a      	ands	r2, r3
 800828e:	4b04      	ldr	r3, [pc, #16]	; (80082a0 <__NVIC_EnableIRQ+0x30>)
 8008290:	2101      	movs	r1, #1
 8008292:	4091      	lsls	r1, r2
 8008294:	000a      	movs	r2, r1
 8008296:	601a      	str	r2, [r3, #0]
  }
}
 8008298:	46c0      	nop			; (mov r8, r8)
 800829a:	46bd      	mov	sp, r7
 800829c:	b002      	add	sp, #8
 800829e:	bd80      	pop	{r7, pc}
 80082a0:	e000e100 	.word	0xe000e100

080082a4 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80082a4:	b590      	push	{r4, r7, lr}
 80082a6:	b083      	sub	sp, #12
 80082a8:	af00      	add	r7, sp, #0
 80082aa:	0002      	movs	r2, r0
 80082ac:	6039      	str	r1, [r7, #0]
 80082ae:	1dfb      	adds	r3, r7, #7
 80082b0:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 80082b2:	1dfb      	adds	r3, r7, #7
 80082b4:	781b      	ldrb	r3, [r3, #0]
 80082b6:	2b7f      	cmp	r3, #127	; 0x7f
 80082b8:	d828      	bhi.n	800830c <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80082ba:	4a2f      	ldr	r2, [pc, #188]	; (8008378 <__NVIC_SetPriority+0xd4>)
 80082bc:	1dfb      	adds	r3, r7, #7
 80082be:	781b      	ldrb	r3, [r3, #0]
 80082c0:	b25b      	sxtb	r3, r3
 80082c2:	089b      	lsrs	r3, r3, #2
 80082c4:	33c0      	adds	r3, #192	; 0xc0
 80082c6:	009b      	lsls	r3, r3, #2
 80082c8:	589b      	ldr	r3, [r3, r2]
 80082ca:	1dfa      	adds	r2, r7, #7
 80082cc:	7812      	ldrb	r2, [r2, #0]
 80082ce:	0011      	movs	r1, r2
 80082d0:	2203      	movs	r2, #3
 80082d2:	400a      	ands	r2, r1
 80082d4:	00d2      	lsls	r2, r2, #3
 80082d6:	21ff      	movs	r1, #255	; 0xff
 80082d8:	4091      	lsls	r1, r2
 80082da:	000a      	movs	r2, r1
 80082dc:	43d2      	mvns	r2, r2
 80082de:	401a      	ands	r2, r3
 80082e0:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80082e2:	683b      	ldr	r3, [r7, #0]
 80082e4:	019b      	lsls	r3, r3, #6
 80082e6:	22ff      	movs	r2, #255	; 0xff
 80082e8:	401a      	ands	r2, r3
 80082ea:	1dfb      	adds	r3, r7, #7
 80082ec:	781b      	ldrb	r3, [r3, #0]
 80082ee:	0018      	movs	r0, r3
 80082f0:	2303      	movs	r3, #3
 80082f2:	4003      	ands	r3, r0
 80082f4:	00db      	lsls	r3, r3, #3
 80082f6:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80082f8:	481f      	ldr	r0, [pc, #124]	; (8008378 <__NVIC_SetPriority+0xd4>)
 80082fa:	1dfb      	adds	r3, r7, #7
 80082fc:	781b      	ldrb	r3, [r3, #0]
 80082fe:	b25b      	sxtb	r3, r3
 8008300:	089b      	lsrs	r3, r3, #2
 8008302:	430a      	orrs	r2, r1
 8008304:	33c0      	adds	r3, #192	; 0xc0
 8008306:	009b      	lsls	r3, r3, #2
 8008308:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 800830a:	e031      	b.n	8008370 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800830c:	4a1b      	ldr	r2, [pc, #108]	; (800837c <__NVIC_SetPriority+0xd8>)
 800830e:	1dfb      	adds	r3, r7, #7
 8008310:	781b      	ldrb	r3, [r3, #0]
 8008312:	0019      	movs	r1, r3
 8008314:	230f      	movs	r3, #15
 8008316:	400b      	ands	r3, r1
 8008318:	3b08      	subs	r3, #8
 800831a:	089b      	lsrs	r3, r3, #2
 800831c:	3306      	adds	r3, #6
 800831e:	009b      	lsls	r3, r3, #2
 8008320:	18d3      	adds	r3, r2, r3
 8008322:	3304      	adds	r3, #4
 8008324:	681b      	ldr	r3, [r3, #0]
 8008326:	1dfa      	adds	r2, r7, #7
 8008328:	7812      	ldrb	r2, [r2, #0]
 800832a:	0011      	movs	r1, r2
 800832c:	2203      	movs	r2, #3
 800832e:	400a      	ands	r2, r1
 8008330:	00d2      	lsls	r2, r2, #3
 8008332:	21ff      	movs	r1, #255	; 0xff
 8008334:	4091      	lsls	r1, r2
 8008336:	000a      	movs	r2, r1
 8008338:	43d2      	mvns	r2, r2
 800833a:	401a      	ands	r2, r3
 800833c:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800833e:	683b      	ldr	r3, [r7, #0]
 8008340:	019b      	lsls	r3, r3, #6
 8008342:	22ff      	movs	r2, #255	; 0xff
 8008344:	401a      	ands	r2, r3
 8008346:	1dfb      	adds	r3, r7, #7
 8008348:	781b      	ldrb	r3, [r3, #0]
 800834a:	0018      	movs	r0, r3
 800834c:	2303      	movs	r3, #3
 800834e:	4003      	ands	r3, r0
 8008350:	00db      	lsls	r3, r3, #3
 8008352:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8008354:	4809      	ldr	r0, [pc, #36]	; (800837c <__NVIC_SetPriority+0xd8>)
 8008356:	1dfb      	adds	r3, r7, #7
 8008358:	781b      	ldrb	r3, [r3, #0]
 800835a:	001c      	movs	r4, r3
 800835c:	230f      	movs	r3, #15
 800835e:	4023      	ands	r3, r4
 8008360:	3b08      	subs	r3, #8
 8008362:	089b      	lsrs	r3, r3, #2
 8008364:	430a      	orrs	r2, r1
 8008366:	3306      	adds	r3, #6
 8008368:	009b      	lsls	r3, r3, #2
 800836a:	18c3      	adds	r3, r0, r3
 800836c:	3304      	adds	r3, #4
 800836e:	601a      	str	r2, [r3, #0]
}
 8008370:	46c0      	nop			; (mov r8, r8)
 8008372:	46bd      	mov	sp, r7
 8008374:	b003      	add	sp, #12
 8008376:	bd90      	pop	{r4, r7, pc}
 8008378:	e000e100 	.word	0xe000e100
 800837c:	e000ed00 	.word	0xe000ed00

08008380 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8008380:	b580      	push	{r7, lr}
 8008382:	b082      	sub	sp, #8
 8008384:	af00      	add	r7, sp, #0
 8008386:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8008388:	687b      	ldr	r3, [r7, #4]
 800838a:	1e5a      	subs	r2, r3, #1
 800838c:	2380      	movs	r3, #128	; 0x80
 800838e:	045b      	lsls	r3, r3, #17
 8008390:	429a      	cmp	r2, r3
 8008392:	d301      	bcc.n	8008398 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 8008394:	2301      	movs	r3, #1
 8008396:	e010      	b.n	80083ba <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8008398:	4b0a      	ldr	r3, [pc, #40]	; (80083c4 <SysTick_Config+0x44>)
 800839a:	687a      	ldr	r2, [r7, #4]
 800839c:	3a01      	subs	r2, #1
 800839e:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80083a0:	2301      	movs	r3, #1
 80083a2:	425b      	negs	r3, r3
 80083a4:	2103      	movs	r1, #3
 80083a6:	0018      	movs	r0, r3
 80083a8:	f7ff ff7c 	bl	80082a4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80083ac:	4b05      	ldr	r3, [pc, #20]	; (80083c4 <SysTick_Config+0x44>)
 80083ae:	2200      	movs	r2, #0
 80083b0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80083b2:	4b04      	ldr	r3, [pc, #16]	; (80083c4 <SysTick_Config+0x44>)
 80083b4:	2207      	movs	r2, #7
 80083b6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80083b8:	2300      	movs	r3, #0
}
 80083ba:	0018      	movs	r0, r3
 80083bc:	46bd      	mov	sp, r7
 80083be:	b002      	add	sp, #8
 80083c0:	bd80      	pop	{r7, pc}
 80083c2:	46c0      	nop			; (mov r8, r8)
 80083c4:	e000e010 	.word	0xe000e010

080083c8 <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80083c8:	b580      	push	{r7, lr}
 80083ca:	b084      	sub	sp, #16
 80083cc:	af00      	add	r7, sp, #0
 80083ce:	60b9      	str	r1, [r7, #8]
 80083d0:	607a      	str	r2, [r7, #4]
 80083d2:	230f      	movs	r3, #15
 80083d4:	18fb      	adds	r3, r7, r3
 80083d6:	1c02      	adds	r2, r0, #0
 80083d8:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 80083da:	68bb      	ldr	r3, [r7, #8]
 80083dc:	2b0f      	cmp	r3, #15
 80083de:	d904      	bls.n	80083ea <HAL_NVIC_SetPriority+0x22>
 80083e0:	4b08      	ldr	r3, [pc, #32]	; (8008404 <HAL_NVIC_SetPriority+0x3c>)
 80083e2:	2187      	movs	r1, #135	; 0x87
 80083e4:	0018      	movs	r0, r3
 80083e6:	f7fd ff56 	bl	8006296 <assert_failed>
  NVIC_SetPriority(IRQn,PreemptPriority);
 80083ea:	68ba      	ldr	r2, [r7, #8]
 80083ec:	230f      	movs	r3, #15
 80083ee:	18fb      	adds	r3, r7, r3
 80083f0:	781b      	ldrb	r3, [r3, #0]
 80083f2:	b25b      	sxtb	r3, r3
 80083f4:	0011      	movs	r1, r2
 80083f6:	0018      	movs	r0, r3
 80083f8:	f7ff ff54 	bl	80082a4 <__NVIC_SetPriority>
}
 80083fc:	46c0      	nop			; (mov r8, r8)
 80083fe:	46bd      	mov	sp, r7
 8008400:	b004      	add	sp, #16
 8008402:	bd80      	pop	{r7, pc}
 8008404:	0800dd74 	.word	0x0800dd74

08008408 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of  IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8008408:	b580      	push	{r7, lr}
 800840a:	b082      	sub	sp, #8
 800840c:	af00      	add	r7, sp, #0
 800840e:	0002      	movs	r2, r0
 8008410:	1dfb      	adds	r3, r7, #7
 8008412:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8008414:	1dfb      	adds	r3, r7, #7
 8008416:	781b      	ldrb	r3, [r3, #0]
 8008418:	2b7f      	cmp	r3, #127	; 0x7f
 800841a:	d904      	bls.n	8008426 <HAL_NVIC_EnableIRQ+0x1e>
 800841c:	4b07      	ldr	r3, [pc, #28]	; (800843c <HAL_NVIC_EnableIRQ+0x34>)
 800841e:	2197      	movs	r1, #151	; 0x97
 8008420:	0018      	movs	r0, r3
 8008422:	f7fd ff38 	bl	8006296 <assert_failed>
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8008426:	1dfb      	adds	r3, r7, #7
 8008428:	781b      	ldrb	r3, [r3, #0]
 800842a:	b25b      	sxtb	r3, r3
 800842c:	0018      	movs	r0, r3
 800842e:	f7ff ff1f 	bl	8008270 <__NVIC_EnableIRQ>
}
 8008432:	46c0      	nop			; (mov r8, r8)
 8008434:	46bd      	mov	sp, r7
 8008436:	b002      	add	sp, #8
 8008438:	bd80      	pop	{r7, pc}
 800843a:	46c0      	nop			; (mov r8, r8)
 800843c:	0800dd74 	.word	0x0800dd74

08008440 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8008440:	b580      	push	{r7, lr}
 8008442:	b082      	sub	sp, #8
 8008444:	af00      	add	r7, sp, #0
 8008446:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8008448:	687b      	ldr	r3, [r7, #4]
 800844a:	0018      	movs	r0, r3
 800844c:	f7ff ff98 	bl	8008380 <SysTick_Config>
 8008450:	0003      	movs	r3, r0
}
 8008452:	0018      	movs	r0, r3
 8008454:	46bd      	mov	sp, r7
 8008456:	b002      	add	sp, #8
 8008458:	bd80      	pop	{r7, pc}
	...

0800845c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800845c:	b580      	push	{r7, lr}
 800845e:	b086      	sub	sp, #24
 8008460:	af00      	add	r7, sp, #0
 8008462:	6078      	str	r0, [r7, #4]
 8008464:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 8008466:	2300      	movs	r3, #0
 8008468:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800846a:	2300      	movs	r3, #0
 800846c:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
 800846e:	2300      	movs	r3, #0
 8008470:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 8008472:	683b      	ldr	r3, [r7, #0]
 8008474:	685b      	ldr	r3, [r3, #4]
 8008476:	2b00      	cmp	r3, #0
 8008478:	d036      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 800847a:	683b      	ldr	r3, [r7, #0]
 800847c:	685b      	ldr	r3, [r3, #4]
 800847e:	2b01      	cmp	r3, #1
 8008480:	d032      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 8008482:	683b      	ldr	r3, [r7, #0]
 8008484:	685b      	ldr	r3, [r3, #4]
 8008486:	2b11      	cmp	r3, #17
 8008488:	d02e      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 800848a:	683b      	ldr	r3, [r7, #0]
 800848c:	685b      	ldr	r3, [r3, #4]
 800848e:	2b02      	cmp	r3, #2
 8008490:	d02a      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 8008492:	683b      	ldr	r3, [r7, #0]
 8008494:	685b      	ldr	r3, [r3, #4]
 8008496:	2b12      	cmp	r3, #18
 8008498:	d026      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 800849a:	683b      	ldr	r3, [r7, #0]
 800849c:	685b      	ldr	r3, [r3, #4]
 800849e:	4a51      	ldr	r2, [pc, #324]	; (80085e4 <HAL_GPIO_Init+0x188>)
 80084a0:	4293      	cmp	r3, r2
 80084a2:	d021      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 80084a4:	683b      	ldr	r3, [r7, #0]
 80084a6:	685b      	ldr	r3, [r3, #4]
 80084a8:	4a4f      	ldr	r2, [pc, #316]	; (80085e8 <HAL_GPIO_Init+0x18c>)
 80084aa:	4293      	cmp	r3, r2
 80084ac:	d01c      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 80084ae:	683b      	ldr	r3, [r7, #0]
 80084b0:	685b      	ldr	r3, [r3, #4]
 80084b2:	4a4e      	ldr	r2, [pc, #312]	; (80085ec <HAL_GPIO_Init+0x190>)
 80084b4:	4293      	cmp	r3, r2
 80084b6:	d017      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 80084b8:	683b      	ldr	r3, [r7, #0]
 80084ba:	685b      	ldr	r3, [r3, #4]
 80084bc:	4a4c      	ldr	r2, [pc, #304]	; (80085f0 <HAL_GPIO_Init+0x194>)
 80084be:	4293      	cmp	r3, r2
 80084c0:	d012      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 80084c2:	683b      	ldr	r3, [r7, #0]
 80084c4:	685b      	ldr	r3, [r3, #4]
 80084c6:	4a4b      	ldr	r2, [pc, #300]	; (80085f4 <HAL_GPIO_Init+0x198>)
 80084c8:	4293      	cmp	r3, r2
 80084ca:	d00d      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 80084cc:	683b      	ldr	r3, [r7, #0]
 80084ce:	685b      	ldr	r3, [r3, #4]
 80084d0:	4a49      	ldr	r2, [pc, #292]	; (80085f8 <HAL_GPIO_Init+0x19c>)
 80084d2:	4293      	cmp	r3, r2
 80084d4:	d008      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 80084d6:	683b      	ldr	r3, [r7, #0]
 80084d8:	685b      	ldr	r3, [r3, #4]
 80084da:	2b03      	cmp	r3, #3
 80084dc:	d004      	beq.n	80084e8 <HAL_GPIO_Init+0x8c>
 80084de:	4b47      	ldr	r3, [pc, #284]	; (80085fc <HAL_GPIO_Init+0x1a0>)
 80084e0:	21ae      	movs	r1, #174	; 0xae
 80084e2:	0018      	movs	r0, r3
 80084e4:	f7fd fed7 	bl	8006296 <assert_failed>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 80084e8:	683b      	ldr	r3, [r7, #0]
 80084ea:	689b      	ldr	r3, [r3, #8]
 80084ec:	2b00      	cmp	r3, #0
 80084ee:	d00c      	beq.n	800850a <HAL_GPIO_Init+0xae>
 80084f0:	683b      	ldr	r3, [r7, #0]
 80084f2:	689b      	ldr	r3, [r3, #8]
 80084f4:	2b01      	cmp	r3, #1
 80084f6:	d008      	beq.n	800850a <HAL_GPIO_Init+0xae>
 80084f8:	683b      	ldr	r3, [r7, #0]
 80084fa:	689b      	ldr	r3, [r3, #8]
 80084fc:	2b02      	cmp	r3, #2
 80084fe:	d004      	beq.n	800850a <HAL_GPIO_Init+0xae>
 8008500:	4b3e      	ldr	r3, [pc, #248]	; (80085fc <HAL_GPIO_Init+0x1a0>)
 8008502:	21af      	movs	r1, #175	; 0xaf
 8008504:	0018      	movs	r0, r3
 8008506:	f7fd fec6 	bl	8006296 <assert_failed>
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, (GPIO_Init->Pin)));
 800850a:	687a      	ldr	r2, [r7, #4]
 800850c:	23a0      	movs	r3, #160	; 0xa0
 800850e:	05db      	lsls	r3, r3, #23
 8008510:	429a      	cmp	r2, r3
 8008512:	d10c      	bne.n	800852e <HAL_GPIO_Init+0xd2>
 8008514:	683b      	ldr	r3, [r7, #0]
 8008516:	681b      	ldr	r3, [r3, #0]
 8008518:	041b      	lsls	r3, r3, #16
 800851a:	0c1b      	lsrs	r3, r3, #16
 800851c:	d007      	beq.n	800852e <HAL_GPIO_Init+0xd2>
 800851e:	683b      	ldr	r3, [r7, #0]
 8008520:	681b      	ldr	r3, [r3, #0]
 8008522:	4a37      	ldr	r2, [pc, #220]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 8008524:	4313      	orrs	r3, r2
 8008526:	4a36      	ldr	r2, [pc, #216]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 8008528:	4293      	cmp	r3, r2
 800852a:	d100      	bne.n	800852e <HAL_GPIO_Init+0xd2>
 800852c:	e208      	b.n	8008940 <HAL_GPIO_Init+0x4e4>
 800852e:	687b      	ldr	r3, [r7, #4]
 8008530:	4a34      	ldr	r2, [pc, #208]	; (8008604 <HAL_GPIO_Init+0x1a8>)
 8008532:	4293      	cmp	r3, r2
 8008534:	d10c      	bne.n	8008550 <HAL_GPIO_Init+0xf4>
 8008536:	683b      	ldr	r3, [r7, #0]
 8008538:	681b      	ldr	r3, [r3, #0]
 800853a:	041b      	lsls	r3, r3, #16
 800853c:	0c1b      	lsrs	r3, r3, #16
 800853e:	d007      	beq.n	8008550 <HAL_GPIO_Init+0xf4>
 8008540:	683b      	ldr	r3, [r7, #0]
 8008542:	681b      	ldr	r3, [r3, #0]
 8008544:	4a2e      	ldr	r2, [pc, #184]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 8008546:	4313      	orrs	r3, r2
 8008548:	4a2d      	ldr	r2, [pc, #180]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 800854a:	4293      	cmp	r3, r2
 800854c:	d100      	bne.n	8008550 <HAL_GPIO_Init+0xf4>
 800854e:	e1f7      	b.n	8008940 <HAL_GPIO_Init+0x4e4>
 8008550:	687b      	ldr	r3, [r7, #4]
 8008552:	4a2d      	ldr	r2, [pc, #180]	; (8008608 <HAL_GPIO_Init+0x1ac>)
 8008554:	4293      	cmp	r3, r2
 8008556:	d10c      	bne.n	8008572 <HAL_GPIO_Init+0x116>
 8008558:	683b      	ldr	r3, [r7, #0]
 800855a:	681b      	ldr	r3, [r3, #0]
 800855c:	041b      	lsls	r3, r3, #16
 800855e:	0c1b      	lsrs	r3, r3, #16
 8008560:	d007      	beq.n	8008572 <HAL_GPIO_Init+0x116>
 8008562:	683b      	ldr	r3, [r7, #0]
 8008564:	681b      	ldr	r3, [r3, #0]
 8008566:	4a26      	ldr	r2, [pc, #152]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 8008568:	4313      	orrs	r3, r2
 800856a:	4a25      	ldr	r2, [pc, #148]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 800856c:	4293      	cmp	r3, r2
 800856e:	d100      	bne.n	8008572 <HAL_GPIO_Init+0x116>
 8008570:	e1e6      	b.n	8008940 <HAL_GPIO_Init+0x4e4>
 8008572:	687b      	ldr	r3, [r7, #4]
 8008574:	4a25      	ldr	r2, [pc, #148]	; (800860c <HAL_GPIO_Init+0x1b0>)
 8008576:	4293      	cmp	r3, r2
 8008578:	d10c      	bne.n	8008594 <HAL_GPIO_Init+0x138>
 800857a:	683b      	ldr	r3, [r7, #0]
 800857c:	681b      	ldr	r3, [r3, #0]
 800857e:	041b      	lsls	r3, r3, #16
 8008580:	0c1b      	lsrs	r3, r3, #16
 8008582:	d007      	beq.n	8008594 <HAL_GPIO_Init+0x138>
 8008584:	683b      	ldr	r3, [r7, #0]
 8008586:	681b      	ldr	r3, [r3, #0]
 8008588:	4a1d      	ldr	r2, [pc, #116]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 800858a:	4313      	orrs	r3, r2
 800858c:	4a1c      	ldr	r2, [pc, #112]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 800858e:	4293      	cmp	r3, r2
 8008590:	d100      	bne.n	8008594 <HAL_GPIO_Init+0x138>
 8008592:	e1d5      	b.n	8008940 <HAL_GPIO_Init+0x4e4>
 8008594:	687b      	ldr	r3, [r7, #4]
 8008596:	4a1e      	ldr	r2, [pc, #120]	; (8008610 <HAL_GPIO_Init+0x1b4>)
 8008598:	4293      	cmp	r3, r2
 800859a:	d10c      	bne.n	80085b6 <HAL_GPIO_Init+0x15a>
 800859c:	683b      	ldr	r3, [r7, #0]
 800859e:	681b      	ldr	r3, [r3, #0]
 80085a0:	041b      	lsls	r3, r3, #16
 80085a2:	0c1b      	lsrs	r3, r3, #16
 80085a4:	d007      	beq.n	80085b6 <HAL_GPIO_Init+0x15a>
 80085a6:	683b      	ldr	r3, [r7, #0]
 80085a8:	681b      	ldr	r3, [r3, #0]
 80085aa:	4a15      	ldr	r2, [pc, #84]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 80085ac:	4313      	orrs	r3, r2
 80085ae:	4a14      	ldr	r2, [pc, #80]	; (8008600 <HAL_GPIO_Init+0x1a4>)
 80085b0:	4293      	cmp	r3, r2
 80085b2:	d100      	bne.n	80085b6 <HAL_GPIO_Init+0x15a>
 80085b4:	e1c4      	b.n	8008940 <HAL_GPIO_Init+0x4e4>
 80085b6:	687b      	ldr	r3, [r7, #4]
 80085b8:	4a16      	ldr	r2, [pc, #88]	; (8008614 <HAL_GPIO_Init+0x1b8>)
 80085ba:	4293      	cmp	r3, r2
 80085bc:	d10c      	bne.n	80085d8 <HAL_GPIO_Init+0x17c>
 80085be:	683b      	ldr	r3, [r7, #0]
 80085c0:	681b      	ldr	r3, [r3, #0]
 80085c2:	4a15      	ldr	r2, [pc, #84]	; (8008618 <HAL_GPIO_Init+0x1bc>)
 80085c4:	4013      	ands	r3, r2
 80085c6:	d007      	beq.n	80085d8 <HAL_GPIO_Init+0x17c>
 80085c8:	683b      	ldr	r3, [r7, #0]
 80085ca:	681b      	ldr	r3, [r3, #0]
 80085cc:	4a12      	ldr	r2, [pc, #72]	; (8008618 <HAL_GPIO_Init+0x1bc>)
 80085ce:	4313      	orrs	r3, r2
 80085d0:	4a11      	ldr	r2, [pc, #68]	; (8008618 <HAL_GPIO_Init+0x1bc>)
 80085d2:	4293      	cmp	r3, r2
 80085d4:	d100      	bne.n	80085d8 <HAL_GPIO_Init+0x17c>
 80085d6:	e1b3      	b.n	8008940 <HAL_GPIO_Init+0x4e4>
 80085d8:	4b08      	ldr	r3, [pc, #32]	; (80085fc <HAL_GPIO_Init+0x1a0>)
 80085da:	21b0      	movs	r1, #176	; 0xb0
 80085dc:	0018      	movs	r0, r3
 80085de:	f7fd fe5a 	bl	8006296 <assert_failed>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 80085e2:	e1ad      	b.n	8008940 <HAL_GPIO_Init+0x4e4>
 80085e4:	10110000 	.word	0x10110000
 80085e8:	10210000 	.word	0x10210000
 80085ec:	10310000 	.word	0x10310000
 80085f0:	10120000 	.word	0x10120000
 80085f4:	10220000 	.word	0x10220000
 80085f8:	10320000 	.word	0x10320000
 80085fc:	0800ddb0 	.word	0x0800ddb0
 8008600:	0000ffff 	.word	0x0000ffff
 8008604:	50000400 	.word	0x50000400
 8008608:	50000800 	.word	0x50000800
 800860c:	50000c00 	.word	0x50000c00
 8008610:	50001000 	.word	0x50001000
 8008614:	50001c00 	.word	0x50001c00
 8008618:	00000603 	.word	0x00000603
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 800861c:	683b      	ldr	r3, [r7, #0]
 800861e:	681b      	ldr	r3, [r3, #0]
 8008620:	2101      	movs	r1, #1
 8008622:	697a      	ldr	r2, [r7, #20]
 8008624:	4091      	lsls	r1, r2
 8008626:	000a      	movs	r2, r1
 8008628:	4013      	ands	r3, r2
 800862a:	60fb      	str	r3, [r7, #12]

    if (iocurrent)
 800862c:	68fb      	ldr	r3, [r7, #12]
 800862e:	2b00      	cmp	r3, #0
 8008630:	d100      	bne.n	8008634 <HAL_GPIO_Init+0x1d8>
 8008632:	e182      	b.n	800893a <HAL_GPIO_Init+0x4de>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8008634:	683b      	ldr	r3, [r7, #0]
 8008636:	685b      	ldr	r3, [r3, #4]
 8008638:	2b01      	cmp	r3, #1
 800863a:	d00b      	beq.n	8008654 <HAL_GPIO_Init+0x1f8>
 800863c:	683b      	ldr	r3, [r7, #0]
 800863e:	685b      	ldr	r3, [r3, #4]
 8008640:	2b02      	cmp	r3, #2
 8008642:	d007      	beq.n	8008654 <HAL_GPIO_Init+0x1f8>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8008644:	683b      	ldr	r3, [r7, #0]
 8008646:	685b      	ldr	r3, [r3, #4]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8008648:	2b11      	cmp	r3, #17
 800864a:	d003      	beq.n	8008654 <HAL_GPIO_Init+0x1f8>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800864c:	683b      	ldr	r3, [r7, #0]
 800864e:	685b      	ldr	r3, [r3, #4]
 8008650:	2b12      	cmp	r3, #18
 8008652:	d145      	bne.n	80086e0 <HAL_GPIO_Init+0x284>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8008654:	683b      	ldr	r3, [r7, #0]
 8008656:	68db      	ldr	r3, [r3, #12]
 8008658:	2b00      	cmp	r3, #0
 800865a:	d010      	beq.n	800867e <HAL_GPIO_Init+0x222>
 800865c:	683b      	ldr	r3, [r7, #0]
 800865e:	68db      	ldr	r3, [r3, #12]
 8008660:	2b01      	cmp	r3, #1
 8008662:	d00c      	beq.n	800867e <HAL_GPIO_Init+0x222>
 8008664:	683b      	ldr	r3, [r7, #0]
 8008666:	68db      	ldr	r3, [r3, #12]
 8008668:	2b02      	cmp	r3, #2
 800866a:	d008      	beq.n	800867e <HAL_GPIO_Init+0x222>
 800866c:	683b      	ldr	r3, [r7, #0]
 800866e:	68db      	ldr	r3, [r3, #12]
 8008670:	2b03      	cmp	r3, #3
 8008672:	d004      	beq.n	800867e <HAL_GPIO_Init+0x222>
 8008674:	4bb8      	ldr	r3, [pc, #736]	; (8008958 <HAL_GPIO_Init+0x4fc>)
 8008676:	21c0      	movs	r1, #192	; 0xc0
 8008678:	0018      	movs	r0, r3
 800867a:	f7fd fe0c 	bl	8006296 <assert_failed>
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800867e:	687b      	ldr	r3, [r7, #4]
 8008680:	689b      	ldr	r3, [r3, #8]
 8008682:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 8008684:	697b      	ldr	r3, [r7, #20]
 8008686:	005b      	lsls	r3, r3, #1
 8008688:	2203      	movs	r2, #3
 800868a:	409a      	lsls	r2, r3
 800868c:	0013      	movs	r3, r2
 800868e:	43da      	mvns	r2, r3
 8008690:	693b      	ldr	r3, [r7, #16]
 8008692:	4013      	ands	r3, r2
 8008694:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8008696:	683b      	ldr	r3, [r7, #0]
 8008698:	68da      	ldr	r2, [r3, #12]
 800869a:	697b      	ldr	r3, [r7, #20]
 800869c:	005b      	lsls	r3, r3, #1
 800869e:	409a      	lsls	r2, r3
 80086a0:	0013      	movs	r3, r2
 80086a2:	693a      	ldr	r2, [r7, #16]
 80086a4:	4313      	orrs	r3, r2
 80086a6:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 80086a8:	687b      	ldr	r3, [r7, #4]
 80086aa:	693a      	ldr	r2, [r7, #16]
 80086ac:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80086ae:	687b      	ldr	r3, [r7, #4]
 80086b0:	685b      	ldr	r3, [r3, #4]
 80086b2:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80086b4:	2201      	movs	r2, #1
 80086b6:	697b      	ldr	r3, [r7, #20]
 80086b8:	409a      	lsls	r2, r3
 80086ba:	0013      	movs	r3, r2
 80086bc:	43da      	mvns	r2, r3
 80086be:	693b      	ldr	r3, [r7, #16]
 80086c0:	4013      	ands	r3, r2
 80086c2:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80086c4:	683b      	ldr	r3, [r7, #0]
 80086c6:	685b      	ldr	r3, [r3, #4]
 80086c8:	091b      	lsrs	r3, r3, #4
 80086ca:	2201      	movs	r2, #1
 80086cc:	401a      	ands	r2, r3
 80086ce:	697b      	ldr	r3, [r7, #20]
 80086d0:	409a      	lsls	r2, r3
 80086d2:	0013      	movs	r3, r2
 80086d4:	693a      	ldr	r2, [r7, #16]
 80086d6:	4313      	orrs	r3, r2
 80086d8:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 80086da:	687b      	ldr	r3, [r7, #4]
 80086dc:	693a      	ldr	r2, [r7, #16]
 80086de:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80086e0:	687b      	ldr	r3, [r7, #4]
 80086e2:	68db      	ldr	r3, [r3, #12]
 80086e4:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80086e6:	697b      	ldr	r3, [r7, #20]
 80086e8:	005b      	lsls	r3, r3, #1
 80086ea:	2203      	movs	r2, #3
 80086ec:	409a      	lsls	r2, r3
 80086ee:	0013      	movs	r3, r2
 80086f0:	43da      	mvns	r2, r3
 80086f2:	693b      	ldr	r3, [r7, #16]
 80086f4:	4013      	ands	r3, r2
 80086f6:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80086f8:	683b      	ldr	r3, [r7, #0]
 80086fa:	689a      	ldr	r2, [r3, #8]
 80086fc:	697b      	ldr	r3, [r7, #20]
 80086fe:	005b      	lsls	r3, r3, #1
 8008700:	409a      	lsls	r2, r3
 8008702:	0013      	movs	r3, r2
 8008704:	693a      	ldr	r2, [r7, #16]
 8008706:	4313      	orrs	r3, r2
 8008708:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 800870a:	687b      	ldr	r3, [r7, #4]
 800870c:	693a      	ldr	r2, [r7, #16]
 800870e:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8008710:	683b      	ldr	r3, [r7, #0]
 8008712:	685b      	ldr	r3, [r3, #4]
 8008714:	2b02      	cmp	r3, #2
 8008716:	d003      	beq.n	8008720 <HAL_GPIO_Init+0x2c4>
 8008718:	683b      	ldr	r3, [r7, #0]
 800871a:	685b      	ldr	r3, [r3, #4]
 800871c:	2b12      	cmp	r3, #18
 800871e:	d14a      	bne.n	80087b6 <HAL_GPIO_Init+0x35a>
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 8008720:	687a      	ldr	r2, [r7, #4]
 8008722:	23a0      	movs	r3, #160	; 0xa0
 8008724:	05db      	lsls	r3, r3, #23
 8008726:	429a      	cmp	r2, r3
 8008728:	d018      	beq.n	800875c <HAL_GPIO_Init+0x300>
 800872a:	687b      	ldr	r3, [r7, #4]
 800872c:	4a8b      	ldr	r2, [pc, #556]	; (800895c <HAL_GPIO_Init+0x500>)
 800872e:	4293      	cmp	r3, r2
 8008730:	d014      	beq.n	800875c <HAL_GPIO_Init+0x300>
 8008732:	687b      	ldr	r3, [r7, #4]
 8008734:	4a8a      	ldr	r2, [pc, #552]	; (8008960 <HAL_GPIO_Init+0x504>)
 8008736:	4293      	cmp	r3, r2
 8008738:	d010      	beq.n	800875c <HAL_GPIO_Init+0x300>
 800873a:	687b      	ldr	r3, [r7, #4]
 800873c:	4a89      	ldr	r2, [pc, #548]	; (8008964 <HAL_GPIO_Init+0x508>)
 800873e:	4293      	cmp	r3, r2
 8008740:	d00c      	beq.n	800875c <HAL_GPIO_Init+0x300>
 8008742:	687b      	ldr	r3, [r7, #4]
 8008744:	4a88      	ldr	r2, [pc, #544]	; (8008968 <HAL_GPIO_Init+0x50c>)
 8008746:	4293      	cmp	r3, r2
 8008748:	d008      	beq.n	800875c <HAL_GPIO_Init+0x300>
 800874a:	687b      	ldr	r3, [r7, #4]
 800874c:	4a87      	ldr	r2, [pc, #540]	; (800896c <HAL_GPIO_Init+0x510>)
 800874e:	4293      	cmp	r3, r2
 8008750:	d004      	beq.n	800875c <HAL_GPIO_Init+0x300>
 8008752:	4b81      	ldr	r3, [pc, #516]	; (8008958 <HAL_GPIO_Init+0x4fc>)
 8008754:	21d8      	movs	r1, #216	; 0xd8
 8008756:	0018      	movs	r0, r3
 8008758:	f7fd fd9d 	bl	8006296 <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 800875c:	683b      	ldr	r3, [r7, #0]
 800875e:	691b      	ldr	r3, [r3, #16]
 8008760:	2b07      	cmp	r3, #7
 8008762:	d904      	bls.n	800876e <HAL_GPIO_Init+0x312>
 8008764:	4b7c      	ldr	r3, [pc, #496]	; (8008958 <HAL_GPIO_Init+0x4fc>)
 8008766:	21d9      	movs	r1, #217	; 0xd9
 8008768:	0018      	movs	r0, r3
 800876a:	f7fd fd94 	bl	8006296 <assert_failed>

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 800876e:	697b      	ldr	r3, [r7, #20]
 8008770:	08da      	lsrs	r2, r3, #3
 8008772:	687b      	ldr	r3, [r7, #4]
 8008774:	3208      	adds	r2, #8
 8008776:	0092      	lsls	r2, r2, #2
 8008778:	58d3      	ldr	r3, [r2, r3]
 800877a:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFUL << ((uint32_t)(position & 0x07UL) * 4U));
 800877c:	697b      	ldr	r3, [r7, #20]
 800877e:	2207      	movs	r2, #7
 8008780:	4013      	ands	r3, r2
 8008782:	009b      	lsls	r3, r3, #2
 8008784:	220f      	movs	r2, #15
 8008786:	409a      	lsls	r2, r3
 8008788:	0013      	movs	r3, r2
 800878a:	43da      	mvns	r2, r3
 800878c:	693b      	ldr	r3, [r7, #16]
 800878e:	4013      	ands	r3, r2
 8008790:	613b      	str	r3, [r7, #16]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 8008792:	683b      	ldr	r3, [r7, #0]
 8008794:	691a      	ldr	r2, [r3, #16]
 8008796:	697b      	ldr	r3, [r7, #20]
 8008798:	2107      	movs	r1, #7
 800879a:	400b      	ands	r3, r1
 800879c:	009b      	lsls	r3, r3, #2
 800879e:	409a      	lsls	r2, r3
 80087a0:	0013      	movs	r3, r2
 80087a2:	693a      	ldr	r2, [r7, #16]
 80087a4:	4313      	orrs	r3, r2
 80087a6:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 80087a8:	697b      	ldr	r3, [r7, #20]
 80087aa:	08da      	lsrs	r2, r3, #3
 80087ac:	687b      	ldr	r3, [r7, #4]
 80087ae:	3208      	adds	r2, #8
 80087b0:	0092      	lsls	r2, r2, #2
 80087b2:	6939      	ldr	r1, [r7, #16]
 80087b4:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80087b6:	687b      	ldr	r3, [r7, #4]
 80087b8:	681b      	ldr	r3, [r3, #0]
 80087ba:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80087bc:	697b      	ldr	r3, [r7, #20]
 80087be:	005b      	lsls	r3, r3, #1
 80087c0:	2203      	movs	r2, #3
 80087c2:	409a      	lsls	r2, r3
 80087c4:	0013      	movs	r3, r2
 80087c6:	43da      	mvns	r2, r3
 80087c8:	693b      	ldr	r3, [r7, #16]
 80087ca:	4013      	ands	r3, r2
 80087cc:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80087ce:	683b      	ldr	r3, [r7, #0]
 80087d0:	685b      	ldr	r3, [r3, #4]
 80087d2:	2203      	movs	r2, #3
 80087d4:	401a      	ands	r2, r3
 80087d6:	697b      	ldr	r3, [r7, #20]
 80087d8:	005b      	lsls	r3, r3, #1
 80087da:	409a      	lsls	r2, r3
 80087dc:	0013      	movs	r3, r2
 80087de:	693a      	ldr	r2, [r7, #16]
 80087e0:	4313      	orrs	r3, r2
 80087e2:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 80087e4:	687b      	ldr	r3, [r7, #4]
 80087e6:	693a      	ldr	r2, [r7, #16]
 80087e8:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80087ea:	683b      	ldr	r3, [r7, #0]
 80087ec:	685a      	ldr	r2, [r3, #4]
 80087ee:	2380      	movs	r3, #128	; 0x80
 80087f0:	055b      	lsls	r3, r3, #21
 80087f2:	4013      	ands	r3, r2
 80087f4:	d100      	bne.n	80087f8 <HAL_GPIO_Init+0x39c>
 80087f6:	e0a0      	b.n	800893a <HAL_GPIO_Init+0x4de>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80087f8:	4b5d      	ldr	r3, [pc, #372]	; (8008970 <HAL_GPIO_Init+0x514>)
 80087fa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80087fc:	4b5c      	ldr	r3, [pc, #368]	; (8008970 <HAL_GPIO_Init+0x514>)
 80087fe:	2101      	movs	r1, #1
 8008800:	430a      	orrs	r2, r1
 8008802:	635a      	str	r2, [r3, #52]	; 0x34

        temp = SYSCFG->EXTICR[position >> 2U];
 8008804:	4a5b      	ldr	r2, [pc, #364]	; (8008974 <HAL_GPIO_Init+0x518>)
 8008806:	697b      	ldr	r3, [r7, #20]
 8008808:	089b      	lsrs	r3, r3, #2
 800880a:	3302      	adds	r3, #2
 800880c:	009b      	lsls	r3, r3, #2
 800880e:	589b      	ldr	r3, [r3, r2]
 8008810:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (0x0FUL) << (4U * (position & 0x03U)));
 8008812:	697b      	ldr	r3, [r7, #20]
 8008814:	2203      	movs	r2, #3
 8008816:	4013      	ands	r3, r2
 8008818:	009b      	lsls	r3, r3, #2
 800881a:	220f      	movs	r2, #15
 800881c:	409a      	lsls	r2, r3
 800881e:	0013      	movs	r3, r2
 8008820:	43da      	mvns	r2, r3
 8008822:	693b      	ldr	r3, [r7, #16]
 8008824:	4013      	ands	r3, r2
 8008826:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 8008828:	687a      	ldr	r2, [r7, #4]
 800882a:	23a0      	movs	r3, #160	; 0xa0
 800882c:	05db      	lsls	r3, r3, #23
 800882e:	429a      	cmp	r2, r3
 8008830:	d01f      	beq.n	8008872 <HAL_GPIO_Init+0x416>
 8008832:	687b      	ldr	r3, [r7, #4]
 8008834:	4a49      	ldr	r2, [pc, #292]	; (800895c <HAL_GPIO_Init+0x500>)
 8008836:	4293      	cmp	r3, r2
 8008838:	d019      	beq.n	800886e <HAL_GPIO_Init+0x412>
 800883a:	687b      	ldr	r3, [r7, #4]
 800883c:	4a48      	ldr	r2, [pc, #288]	; (8008960 <HAL_GPIO_Init+0x504>)
 800883e:	4293      	cmp	r3, r2
 8008840:	d013      	beq.n	800886a <HAL_GPIO_Init+0x40e>
 8008842:	687b      	ldr	r3, [r7, #4]
 8008844:	4a47      	ldr	r2, [pc, #284]	; (8008964 <HAL_GPIO_Init+0x508>)
 8008846:	4293      	cmp	r3, r2
 8008848:	d00d      	beq.n	8008866 <HAL_GPIO_Init+0x40a>
 800884a:	687b      	ldr	r3, [r7, #4]
 800884c:	4a46      	ldr	r2, [pc, #280]	; (8008968 <HAL_GPIO_Init+0x50c>)
 800884e:	4293      	cmp	r3, r2
 8008850:	d007      	beq.n	8008862 <HAL_GPIO_Init+0x406>
 8008852:	687b      	ldr	r3, [r7, #4]
 8008854:	4a45      	ldr	r2, [pc, #276]	; (800896c <HAL_GPIO_Init+0x510>)
 8008856:	4293      	cmp	r3, r2
 8008858:	d101      	bne.n	800885e <HAL_GPIO_Init+0x402>
 800885a:	2305      	movs	r3, #5
 800885c:	e00a      	b.n	8008874 <HAL_GPIO_Init+0x418>
 800885e:	2306      	movs	r3, #6
 8008860:	e008      	b.n	8008874 <HAL_GPIO_Init+0x418>
 8008862:	2304      	movs	r3, #4
 8008864:	e006      	b.n	8008874 <HAL_GPIO_Init+0x418>
 8008866:	2303      	movs	r3, #3
 8008868:	e004      	b.n	8008874 <HAL_GPIO_Init+0x418>
 800886a:	2302      	movs	r3, #2
 800886c:	e002      	b.n	8008874 <HAL_GPIO_Init+0x418>
 800886e:	2301      	movs	r3, #1
 8008870:	e000      	b.n	8008874 <HAL_GPIO_Init+0x418>
 8008872:	2300      	movs	r3, #0
 8008874:	697a      	ldr	r2, [r7, #20]
 8008876:	2103      	movs	r1, #3
 8008878:	400a      	ands	r2, r1
 800887a:	0092      	lsls	r2, r2, #2
 800887c:	4093      	lsls	r3, r2
 800887e:	693a      	ldr	r2, [r7, #16]
 8008880:	4313      	orrs	r3, r2
 8008882:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8008884:	493b      	ldr	r1, [pc, #236]	; (8008974 <HAL_GPIO_Init+0x518>)
 8008886:	697b      	ldr	r3, [r7, #20]
 8008888:	089b      	lsrs	r3, r3, #2
 800888a:	3302      	adds	r3, #2
 800888c:	009b      	lsls	r3, r3, #2
 800888e:	693a      	ldr	r2, [r7, #16]
 8008890:	505a      	str	r2, [r3, r1]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8008892:	4b39      	ldr	r3, [pc, #228]	; (8008978 <HAL_GPIO_Init+0x51c>)
 8008894:	681b      	ldr	r3, [r3, #0]
 8008896:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8008898:	68fb      	ldr	r3, [r7, #12]
 800889a:	43da      	mvns	r2, r3
 800889c:	693b      	ldr	r3, [r7, #16]
 800889e:	4013      	ands	r3, r2
 80088a0:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80088a2:	683b      	ldr	r3, [r7, #0]
 80088a4:	685a      	ldr	r2, [r3, #4]
 80088a6:	2380      	movs	r3, #128	; 0x80
 80088a8:	025b      	lsls	r3, r3, #9
 80088aa:	4013      	ands	r3, r2
 80088ac:	d003      	beq.n	80088b6 <HAL_GPIO_Init+0x45a>
        {
          temp |= iocurrent;
 80088ae:	693a      	ldr	r2, [r7, #16]
 80088b0:	68fb      	ldr	r3, [r7, #12]
 80088b2:	4313      	orrs	r3, r2
 80088b4:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 80088b6:	4b30      	ldr	r3, [pc, #192]	; (8008978 <HAL_GPIO_Init+0x51c>)
 80088b8:	693a      	ldr	r2, [r7, #16]
 80088ba:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 80088bc:	4b2e      	ldr	r3, [pc, #184]	; (8008978 <HAL_GPIO_Init+0x51c>)
 80088be:	685b      	ldr	r3, [r3, #4]
 80088c0:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 80088c2:	68fb      	ldr	r3, [r7, #12]
 80088c4:	43da      	mvns	r2, r3
 80088c6:	693b      	ldr	r3, [r7, #16]
 80088c8:	4013      	ands	r3, r2
 80088ca:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80088cc:	683b      	ldr	r3, [r7, #0]
 80088ce:	685a      	ldr	r2, [r3, #4]
 80088d0:	2380      	movs	r3, #128	; 0x80
 80088d2:	029b      	lsls	r3, r3, #10
 80088d4:	4013      	ands	r3, r2
 80088d6:	d003      	beq.n	80088e0 <HAL_GPIO_Init+0x484>
        {
          temp |= iocurrent;
 80088d8:	693a      	ldr	r2, [r7, #16]
 80088da:	68fb      	ldr	r3, [r7, #12]
 80088dc:	4313      	orrs	r3, r2
 80088de:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 80088e0:	4b25      	ldr	r3, [pc, #148]	; (8008978 <HAL_GPIO_Init+0x51c>)
 80088e2:	693a      	ldr	r2, [r7, #16]
 80088e4:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80088e6:	4b24      	ldr	r3, [pc, #144]	; (8008978 <HAL_GPIO_Init+0x51c>)
 80088e8:	689b      	ldr	r3, [r3, #8]
 80088ea:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 80088ec:	68fb      	ldr	r3, [r7, #12]
 80088ee:	43da      	mvns	r2, r3
 80088f0:	693b      	ldr	r3, [r7, #16]
 80088f2:	4013      	ands	r3, r2
 80088f4:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80088f6:	683b      	ldr	r3, [r7, #0]
 80088f8:	685a      	ldr	r2, [r3, #4]
 80088fa:	2380      	movs	r3, #128	; 0x80
 80088fc:	035b      	lsls	r3, r3, #13
 80088fe:	4013      	ands	r3, r2
 8008900:	d003      	beq.n	800890a <HAL_GPIO_Init+0x4ae>
        {
          temp |= iocurrent;
 8008902:	693a      	ldr	r2, [r7, #16]
 8008904:	68fb      	ldr	r3, [r7, #12]
 8008906:	4313      	orrs	r3, r2
 8008908:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 800890a:	4b1b      	ldr	r3, [pc, #108]	; (8008978 <HAL_GPIO_Init+0x51c>)
 800890c:	693a      	ldr	r2, [r7, #16]
 800890e:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 8008910:	4b19      	ldr	r3, [pc, #100]	; (8008978 <HAL_GPIO_Init+0x51c>)
 8008912:	68db      	ldr	r3, [r3, #12]
 8008914:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8008916:	68fb      	ldr	r3, [r7, #12]
 8008918:	43da      	mvns	r2, r3
 800891a:	693b      	ldr	r3, [r7, #16]
 800891c:	4013      	ands	r3, r2
 800891e:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8008920:	683b      	ldr	r3, [r7, #0]
 8008922:	685a      	ldr	r2, [r3, #4]
 8008924:	2380      	movs	r3, #128	; 0x80
 8008926:	039b      	lsls	r3, r3, #14
 8008928:	4013      	ands	r3, r2
 800892a:	d003      	beq.n	8008934 <HAL_GPIO_Init+0x4d8>
        {
          temp |= iocurrent;
 800892c:	693a      	ldr	r2, [r7, #16]
 800892e:	68fb      	ldr	r3, [r7, #12]
 8008930:	4313      	orrs	r3, r2
 8008932:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 8008934:	4b10      	ldr	r3, [pc, #64]	; (8008978 <HAL_GPIO_Init+0x51c>)
 8008936:	693a      	ldr	r2, [r7, #16]
 8008938:	60da      	str	r2, [r3, #12]
      }
    }
    position++;
 800893a:	697b      	ldr	r3, [r7, #20]
 800893c:	3301      	adds	r3, #1
 800893e:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0)
 8008940:	683b      	ldr	r3, [r7, #0]
 8008942:	681a      	ldr	r2, [r3, #0]
 8008944:	697b      	ldr	r3, [r7, #20]
 8008946:	40da      	lsrs	r2, r3
 8008948:	1e13      	subs	r3, r2, #0
 800894a:	d000      	beq.n	800894e <HAL_GPIO_Init+0x4f2>
 800894c:	e666      	b.n	800861c <HAL_GPIO_Init+0x1c0>
  }
}
 800894e:	46c0      	nop			; (mov r8, r8)
 8008950:	46c0      	nop			; (mov r8, r8)
 8008952:	46bd      	mov	sp, r7
 8008954:	b006      	add	sp, #24
 8008956:	bd80      	pop	{r7, pc}
 8008958:	0800ddb0 	.word	0x0800ddb0
 800895c:	50000400 	.word	0x50000400
 8008960:	50000800 	.word	0x50000800
 8008964:	50000c00 	.word	0x50000c00
 8008968:	50001000 	.word	0x50001000
 800896c:	50001c00 	.word	0x50001c00
 8008970:	40021000 	.word	0x40021000
 8008974:	40010000 	.word	0x40010000
 8008978:	40010400 	.word	0x40010400

0800897c <HAL_GPIO_WritePin>:
  *                        GPIO_PIN_RESET: to clear the port pin
  *                        GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800897c:	b580      	push	{r7, lr}
 800897e:	b082      	sub	sp, #8
 8008980:	af00      	add	r7, sp, #0
 8008982:	6078      	str	r0, [r7, #4]
 8008984:	0008      	movs	r0, r1
 8008986:	0011      	movs	r1, r2
 8008988:	1cbb      	adds	r3, r7, #2
 800898a:	1c02      	adds	r2, r0, #0
 800898c:	801a      	strh	r2, [r3, #0]
 800898e:	1c7b      	adds	r3, r7, #1
 8008990:	1c0a      	adds	r2, r1, #0
 8008992:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, GPIO_Pin));
 8008994:	687a      	ldr	r2, [r7, #4]
 8008996:	23a0      	movs	r3, #160	; 0xa0
 8008998:	05db      	lsls	r3, r3, #23
 800899a:	429a      	cmp	r2, r3
 800899c:	d103      	bne.n	80089a6 <HAL_GPIO_WritePin+0x2a>
 800899e:	1cbb      	adds	r3, r7, #2
 80089a0:	881b      	ldrh	r3, [r3, #0]
 80089a2:	2b00      	cmp	r3, #0
 80089a4:	d137      	bne.n	8008a16 <HAL_GPIO_WritePin+0x9a>
 80089a6:	687b      	ldr	r3, [r7, #4]
 80089a8:	4a2b      	ldr	r2, [pc, #172]	; (8008a58 <HAL_GPIO_WritePin+0xdc>)
 80089aa:	4293      	cmp	r3, r2
 80089ac:	d103      	bne.n	80089b6 <HAL_GPIO_WritePin+0x3a>
 80089ae:	1cbb      	adds	r3, r7, #2
 80089b0:	881b      	ldrh	r3, [r3, #0]
 80089b2:	2b00      	cmp	r3, #0
 80089b4:	d12f      	bne.n	8008a16 <HAL_GPIO_WritePin+0x9a>
 80089b6:	687b      	ldr	r3, [r7, #4]
 80089b8:	4a28      	ldr	r2, [pc, #160]	; (8008a5c <HAL_GPIO_WritePin+0xe0>)
 80089ba:	4293      	cmp	r3, r2
 80089bc:	d103      	bne.n	80089c6 <HAL_GPIO_WritePin+0x4a>
 80089be:	1cbb      	adds	r3, r7, #2
 80089c0:	881b      	ldrh	r3, [r3, #0]
 80089c2:	2b00      	cmp	r3, #0
 80089c4:	d127      	bne.n	8008a16 <HAL_GPIO_WritePin+0x9a>
 80089c6:	687b      	ldr	r3, [r7, #4]
 80089c8:	4a25      	ldr	r2, [pc, #148]	; (8008a60 <HAL_GPIO_WritePin+0xe4>)
 80089ca:	4293      	cmp	r3, r2
 80089cc:	d103      	bne.n	80089d6 <HAL_GPIO_WritePin+0x5a>
 80089ce:	1cbb      	adds	r3, r7, #2
 80089d0:	881b      	ldrh	r3, [r3, #0]
 80089d2:	2b00      	cmp	r3, #0
 80089d4:	d11f      	bne.n	8008a16 <HAL_GPIO_WritePin+0x9a>
 80089d6:	687b      	ldr	r3, [r7, #4]
 80089d8:	4a22      	ldr	r2, [pc, #136]	; (8008a64 <HAL_GPIO_WritePin+0xe8>)
 80089da:	4293      	cmp	r3, r2
 80089dc:	d103      	bne.n	80089e6 <HAL_GPIO_WritePin+0x6a>
 80089de:	1cbb      	adds	r3, r7, #2
 80089e0:	881b      	ldrh	r3, [r3, #0]
 80089e2:	2b00      	cmp	r3, #0
 80089e4:	d117      	bne.n	8008a16 <HAL_GPIO_WritePin+0x9a>
 80089e6:	687b      	ldr	r3, [r7, #4]
 80089e8:	4a1f      	ldr	r2, [pc, #124]	; (8008a68 <HAL_GPIO_WritePin+0xec>)
 80089ea:	4293      	cmp	r3, r2
 80089ec:	d10c      	bne.n	8008a08 <HAL_GPIO_WritePin+0x8c>
 80089ee:	1cbb      	adds	r3, r7, #2
 80089f0:	881b      	ldrh	r3, [r3, #0]
 80089f2:	4a1e      	ldr	r2, [pc, #120]	; (8008a6c <HAL_GPIO_WritePin+0xf0>)
 80089f4:	4013      	ands	r3, r2
 80089f6:	d007      	beq.n	8008a08 <HAL_GPIO_WritePin+0x8c>
 80089f8:	1cbb      	adds	r3, r7, #2
 80089fa:	881b      	ldrh	r3, [r3, #0]
 80089fc:	4a1b      	ldr	r2, [pc, #108]	; (8008a6c <HAL_GPIO_WritePin+0xf0>)
 80089fe:	4313      	orrs	r3, r2
 8008a00:	b29b      	uxth	r3, r3
 8008a02:	4a1a      	ldr	r2, [pc, #104]	; (8008a6c <HAL_GPIO_WritePin+0xf0>)
 8008a04:	4293      	cmp	r3, r2
 8008a06:	d006      	beq.n	8008a16 <HAL_GPIO_WritePin+0x9a>
 8008a08:	23ce      	movs	r3, #206	; 0xce
 8008a0a:	005a      	lsls	r2, r3, #1
 8008a0c:	4b18      	ldr	r3, [pc, #96]	; (8008a70 <HAL_GPIO_WritePin+0xf4>)
 8008a0e:	0011      	movs	r1, r2
 8008a10:	0018      	movs	r0, r3
 8008a12:	f7fd fc40 	bl	8006296 <assert_failed>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 8008a16:	1c7b      	adds	r3, r7, #1
 8008a18:	781b      	ldrb	r3, [r3, #0]
 8008a1a:	2b00      	cmp	r3, #0
 8008a1c:	d00b      	beq.n	8008a36 <HAL_GPIO_WritePin+0xba>
 8008a1e:	1c7b      	adds	r3, r7, #1
 8008a20:	781b      	ldrb	r3, [r3, #0]
 8008a22:	2b01      	cmp	r3, #1
 8008a24:	d007      	beq.n	8008a36 <HAL_GPIO_WritePin+0xba>
 8008a26:	239e      	movs	r3, #158	; 0x9e
 8008a28:	33ff      	adds	r3, #255	; 0xff
 8008a2a:	001a      	movs	r2, r3
 8008a2c:	4b10      	ldr	r3, [pc, #64]	; (8008a70 <HAL_GPIO_WritePin+0xf4>)
 8008a2e:	0011      	movs	r1, r2
 8008a30:	0018      	movs	r0, r3
 8008a32:	f7fd fc30 	bl	8006296 <assert_failed>

  if (PinState != GPIO_PIN_RESET)
 8008a36:	1c7b      	adds	r3, r7, #1
 8008a38:	781b      	ldrb	r3, [r3, #0]
 8008a3a:	2b00      	cmp	r3, #0
 8008a3c:	d004      	beq.n	8008a48 <HAL_GPIO_WritePin+0xcc>
  {
    GPIOx->BSRR = GPIO_Pin;
 8008a3e:	1cbb      	adds	r3, r7, #2
 8008a40:	881a      	ldrh	r2, [r3, #0]
 8008a42:	687b      	ldr	r3, [r7, #4]
 8008a44:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 8008a46:	e003      	b.n	8008a50 <HAL_GPIO_WritePin+0xd4>
    GPIOx->BRR = GPIO_Pin ;
 8008a48:	1cbb      	adds	r3, r7, #2
 8008a4a:	881a      	ldrh	r2, [r3, #0]
 8008a4c:	687b      	ldr	r3, [r7, #4]
 8008a4e:	629a      	str	r2, [r3, #40]	; 0x28
}
 8008a50:	46c0      	nop			; (mov r8, r8)
 8008a52:	46bd      	mov	sp, r7
 8008a54:	b002      	add	sp, #8
 8008a56:	bd80      	pop	{r7, pc}
 8008a58:	50000400 	.word	0x50000400
 8008a5c:	50000800 	.word	0x50000800
 8008a60:	50000c00 	.word	0x50000c00
 8008a64:	50001000 	.word	0x50001000
 8008a68:	50001c00 	.word	0x50001c00
 8008a6c:	00000603 	.word	0x00000603
 8008a70:	0800ddb0 	.word	0x0800ddb0

08008a74 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected to the EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8008a74:	b580      	push	{r7, lr}
 8008a76:	b082      	sub	sp, #8
 8008a78:	af00      	add	r7, sp, #0
 8008a7a:	0002      	movs	r2, r0
 8008a7c:	1dbb      	adds	r3, r7, #6
 8008a7e:	801a      	strh	r2, [r3, #0]
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 8008a80:	4b09      	ldr	r3, [pc, #36]	; (8008aa8 <HAL_GPIO_EXTI_IRQHandler+0x34>)
 8008a82:	695b      	ldr	r3, [r3, #20]
 8008a84:	1dba      	adds	r2, r7, #6
 8008a86:	8812      	ldrh	r2, [r2, #0]
 8008a88:	4013      	ands	r3, r2
 8008a8a:	d008      	beq.n	8008a9e <HAL_GPIO_EXTI_IRQHandler+0x2a>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8008a8c:	4b06      	ldr	r3, [pc, #24]	; (8008aa8 <HAL_GPIO_EXTI_IRQHandler+0x34>)
 8008a8e:	1dba      	adds	r2, r7, #6
 8008a90:	8812      	ldrh	r2, [r2, #0]
 8008a92:	615a      	str	r2, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8008a94:	1dbb      	adds	r3, r7, #6
 8008a96:	881b      	ldrh	r3, [r3, #0]
 8008a98:	0018      	movs	r0, r3
 8008a9a:	f7f9 fa8b 	bl	8001fb4 <HAL_GPIO_EXTI_Callback>
  }
}
 8008a9e:	46c0      	nop			; (mov r8, r8)
 8008aa0:	46bd      	mov	sp, r7
 8008aa2:	b002      	add	sp, #8
 8008aa4:	bd80      	pop	{r7, pc}
 8008aa6:	46c0      	nop			; (mov r8, r8)
 8008aa8:	40010400 	.word	0x40010400

08008aac <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8008aac:	b580      	push	{r7, lr}
 8008aae:	b082      	sub	sp, #8
 8008ab0:	af00      	add	r7, sp, #0
 8008ab2:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8008ab4:	687b      	ldr	r3, [r7, #4]
 8008ab6:	2b00      	cmp	r3, #0
 8008ab8:	d101      	bne.n	8008abe <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 8008aba:	2301      	movs	r3, #1
 8008abc:	e11d      	b.n	8008cfa <HAL_I2C_Init+0x24e>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008abe:	687b      	ldr	r3, [r7, #4]
 8008ac0:	681b      	ldr	r3, [r3, #0]
 8008ac2:	4a90      	ldr	r2, [pc, #576]	; (8008d04 <HAL_I2C_Init+0x258>)
 8008ac4:	4293      	cmp	r3, r2
 8008ac6:	d011      	beq.n	8008aec <HAL_I2C_Init+0x40>
 8008ac8:	687b      	ldr	r3, [r7, #4]
 8008aca:	681b      	ldr	r3, [r3, #0]
 8008acc:	4a8e      	ldr	r2, [pc, #568]	; (8008d08 <HAL_I2C_Init+0x25c>)
 8008ace:	4293      	cmp	r3, r2
 8008ad0:	d00c      	beq.n	8008aec <HAL_I2C_Init+0x40>
 8008ad2:	687b      	ldr	r3, [r7, #4]
 8008ad4:	681b      	ldr	r3, [r3, #0]
 8008ad6:	4a8d      	ldr	r2, [pc, #564]	; (8008d0c <HAL_I2C_Init+0x260>)
 8008ad8:	4293      	cmp	r3, r2
 8008ada:	d007      	beq.n	8008aec <HAL_I2C_Init+0x40>
 8008adc:	23e6      	movs	r3, #230	; 0xe6
 8008ade:	33ff      	adds	r3, #255	; 0xff
 8008ae0:	001a      	movs	r2, r3
 8008ae2:	4b8b      	ldr	r3, [pc, #556]	; (8008d10 <HAL_I2C_Init+0x264>)
 8008ae4:	0011      	movs	r1, r2
 8008ae6:	0018      	movs	r0, r3
 8008ae8:	f7fd fbd5 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 8008aec:	687b      	ldr	r3, [r7, #4]
 8008aee:	689a      	ldr	r2, [r3, #8]
 8008af0:	2380      	movs	r3, #128	; 0x80
 8008af2:	00db      	lsls	r3, r3, #3
 8008af4:	429a      	cmp	r2, r3
 8008af6:	d306      	bcc.n	8008b06 <HAL_I2C_Init+0x5a>
 8008af8:	23f3      	movs	r3, #243	; 0xf3
 8008afa:	005a      	lsls	r2, r3, #1
 8008afc:	4b84      	ldr	r3, [pc, #528]	; (8008d10 <HAL_I2C_Init+0x264>)
 8008afe:	0011      	movs	r1, r2
 8008b00:	0018      	movs	r0, r3
 8008b02:	f7fd fbc8 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 8008b06:	687b      	ldr	r3, [r7, #4]
 8008b08:	68db      	ldr	r3, [r3, #12]
 8008b0a:	2b01      	cmp	r3, #1
 8008b0c:	d00b      	beq.n	8008b26 <HAL_I2C_Init+0x7a>
 8008b0e:	687b      	ldr	r3, [r7, #4]
 8008b10:	68db      	ldr	r3, [r3, #12]
 8008b12:	2b02      	cmp	r3, #2
 8008b14:	d007      	beq.n	8008b26 <HAL_I2C_Init+0x7a>
 8008b16:	23e8      	movs	r3, #232	; 0xe8
 8008b18:	33ff      	adds	r3, #255	; 0xff
 8008b1a:	001a      	movs	r2, r3
 8008b1c:	4b7c      	ldr	r3, [pc, #496]	; (8008d10 <HAL_I2C_Init+0x264>)
 8008b1e:	0011      	movs	r1, r2
 8008b20:	0018      	movs	r0, r3
 8008b22:	f7fd fbb8 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 8008b26:	687b      	ldr	r3, [r7, #4]
 8008b28:	691b      	ldr	r3, [r3, #16]
 8008b2a:	2b00      	cmp	r3, #0
 8008b2c:	d00c      	beq.n	8008b48 <HAL_I2C_Init+0x9c>
 8008b2e:	687b      	ldr	r3, [r7, #4]
 8008b30:	691a      	ldr	r2, [r3, #16]
 8008b32:	2380      	movs	r3, #128	; 0x80
 8008b34:	021b      	lsls	r3, r3, #8
 8008b36:	429a      	cmp	r2, r3
 8008b38:	d006      	beq.n	8008b48 <HAL_I2C_Init+0x9c>
 8008b3a:	23f4      	movs	r3, #244	; 0xf4
 8008b3c:	005a      	lsls	r2, r3, #1
 8008b3e:	4b74      	ldr	r3, [pc, #464]	; (8008d10 <HAL_I2C_Init+0x264>)
 8008b40:	0011      	movs	r1, r2
 8008b42:	0018      	movs	r0, r3
 8008b44:	f7fd fba7 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 8008b48:	687b      	ldr	r3, [r7, #4]
 8008b4a:	695b      	ldr	r3, [r3, #20]
 8008b4c:	2bff      	cmp	r3, #255	; 0xff
 8008b4e:	d907      	bls.n	8008b60 <HAL_I2C_Init+0xb4>
 8008b50:	23ea      	movs	r3, #234	; 0xea
 8008b52:	33ff      	adds	r3, #255	; 0xff
 8008b54:	001a      	movs	r2, r3
 8008b56:	4b6e      	ldr	r3, [pc, #440]	; (8008d10 <HAL_I2C_Init+0x264>)
 8008b58:	0011      	movs	r1, r2
 8008b5a:	0018      	movs	r0, r3
 8008b5c:	f7fd fb9b 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 8008b60:	687b      	ldr	r3, [r7, #4]
 8008b62:	699b      	ldr	r3, [r3, #24]
 8008b64:	2b00      	cmp	r3, #0
 8008b66:	d022      	beq.n	8008bae <HAL_I2C_Init+0x102>
 8008b68:	687b      	ldr	r3, [r7, #4]
 8008b6a:	699b      	ldr	r3, [r3, #24]
 8008b6c:	2b01      	cmp	r3, #1
 8008b6e:	d01e      	beq.n	8008bae <HAL_I2C_Init+0x102>
 8008b70:	687b      	ldr	r3, [r7, #4]
 8008b72:	699b      	ldr	r3, [r3, #24]
 8008b74:	2b02      	cmp	r3, #2
 8008b76:	d01a      	beq.n	8008bae <HAL_I2C_Init+0x102>
 8008b78:	687b      	ldr	r3, [r7, #4]
 8008b7a:	699b      	ldr	r3, [r3, #24]
 8008b7c:	2b03      	cmp	r3, #3
 8008b7e:	d016      	beq.n	8008bae <HAL_I2C_Init+0x102>
 8008b80:	687b      	ldr	r3, [r7, #4]
 8008b82:	699b      	ldr	r3, [r3, #24]
 8008b84:	2b04      	cmp	r3, #4
 8008b86:	d012      	beq.n	8008bae <HAL_I2C_Init+0x102>
 8008b88:	687b      	ldr	r3, [r7, #4]
 8008b8a:	699b      	ldr	r3, [r3, #24]
 8008b8c:	2b05      	cmp	r3, #5
 8008b8e:	d00e      	beq.n	8008bae <HAL_I2C_Init+0x102>
 8008b90:	687b      	ldr	r3, [r7, #4]
 8008b92:	699b      	ldr	r3, [r3, #24]
 8008b94:	2b06      	cmp	r3, #6
 8008b96:	d00a      	beq.n	8008bae <HAL_I2C_Init+0x102>
 8008b98:	687b      	ldr	r3, [r7, #4]
 8008b9a:	699b      	ldr	r3, [r3, #24]
 8008b9c:	2b07      	cmp	r3, #7
 8008b9e:	d006      	beq.n	8008bae <HAL_I2C_Init+0x102>
 8008ba0:	23f5      	movs	r3, #245	; 0xf5
 8008ba2:	005a      	lsls	r2, r3, #1
 8008ba4:	4b5a      	ldr	r3, [pc, #360]	; (8008d10 <HAL_I2C_Init+0x264>)
 8008ba6:	0011      	movs	r1, r2
 8008ba8:	0018      	movs	r0, r3
 8008baa:	f7fd fb74 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 8008bae:	687b      	ldr	r3, [r7, #4]
 8008bb0:	69db      	ldr	r3, [r3, #28]
 8008bb2:	2b00      	cmp	r3, #0
 8008bb4:	d00d      	beq.n	8008bd2 <HAL_I2C_Init+0x126>
 8008bb6:	687b      	ldr	r3, [r7, #4]
 8008bb8:	69da      	ldr	r2, [r3, #28]
 8008bba:	2380      	movs	r3, #128	; 0x80
 8008bbc:	031b      	lsls	r3, r3, #12
 8008bbe:	429a      	cmp	r2, r3
 8008bc0:	d007      	beq.n	8008bd2 <HAL_I2C_Init+0x126>
 8008bc2:	23ec      	movs	r3, #236	; 0xec
 8008bc4:	33ff      	adds	r3, #255	; 0xff
 8008bc6:	001a      	movs	r2, r3
 8008bc8:	4b51      	ldr	r3, [pc, #324]	; (8008d10 <HAL_I2C_Init+0x264>)
 8008bca:	0011      	movs	r1, r2
 8008bcc:	0018      	movs	r0, r3
 8008bce:	f7fd fb62 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 8008bd2:	687b      	ldr	r3, [r7, #4]
 8008bd4:	6a1b      	ldr	r3, [r3, #32]
 8008bd6:	2b00      	cmp	r3, #0
 8008bd8:	d00c      	beq.n	8008bf4 <HAL_I2C_Init+0x148>
 8008bda:	687b      	ldr	r3, [r7, #4]
 8008bdc:	6a1a      	ldr	r2, [r3, #32]
 8008bde:	2380      	movs	r3, #128	; 0x80
 8008be0:	029b      	lsls	r3, r3, #10
 8008be2:	429a      	cmp	r2, r3
 8008be4:	d006      	beq.n	8008bf4 <HAL_I2C_Init+0x148>
 8008be6:	23f6      	movs	r3, #246	; 0xf6
 8008be8:	005a      	lsls	r2, r3, #1
 8008bea:	4b49      	ldr	r3, [pc, #292]	; (8008d10 <HAL_I2C_Init+0x264>)
 8008bec:	0011      	movs	r1, r2
 8008bee:	0018      	movs	r0, r3
 8008bf0:	f7fd fb51 	bl	8006296 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_RESET)
 8008bf4:	687b      	ldr	r3, [r7, #4]
 8008bf6:	2241      	movs	r2, #65	; 0x41
 8008bf8:	5c9b      	ldrb	r3, [r3, r2]
 8008bfa:	b2db      	uxtb	r3, r3
 8008bfc:	2b00      	cmp	r3, #0
 8008bfe:	d107      	bne.n	8008c10 <HAL_I2C_Init+0x164>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8008c00:	687b      	ldr	r3, [r7, #4]
 8008c02:	2240      	movs	r2, #64	; 0x40
 8008c04:	2100      	movs	r1, #0
 8008c06:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 8008c08:	687b      	ldr	r3, [r7, #4]
 8008c0a:	0018      	movs	r0, r3
 8008c0c:	f7fe fa8e 	bl	800712c <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8008c10:	687b      	ldr	r3, [r7, #4]
 8008c12:	2241      	movs	r2, #65	; 0x41
 8008c14:	2124      	movs	r1, #36	; 0x24
 8008c16:	5499      	strb	r1, [r3, r2]

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8008c18:	687b      	ldr	r3, [r7, #4]
 8008c1a:	681b      	ldr	r3, [r3, #0]
 8008c1c:	681a      	ldr	r2, [r3, #0]
 8008c1e:	687b      	ldr	r3, [r7, #4]
 8008c20:	681b      	ldr	r3, [r3, #0]
 8008c22:	2101      	movs	r1, #1
 8008c24:	438a      	bics	r2, r1
 8008c26:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8008c28:	687b      	ldr	r3, [r7, #4]
 8008c2a:	685a      	ldr	r2, [r3, #4]
 8008c2c:	687b      	ldr	r3, [r7, #4]
 8008c2e:	681b      	ldr	r3, [r3, #0]
 8008c30:	4938      	ldr	r1, [pc, #224]	; (8008d14 <HAL_I2C_Init+0x268>)
 8008c32:	400a      	ands	r2, r1
 8008c34:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8008c36:	687b      	ldr	r3, [r7, #4]
 8008c38:	681b      	ldr	r3, [r3, #0]
 8008c3a:	689a      	ldr	r2, [r3, #8]
 8008c3c:	687b      	ldr	r3, [r7, #4]
 8008c3e:	681b      	ldr	r3, [r3, #0]
 8008c40:	4935      	ldr	r1, [pc, #212]	; (8008d18 <HAL_I2C_Init+0x26c>)
 8008c42:	400a      	ands	r2, r1
 8008c44:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8008c46:	687b      	ldr	r3, [r7, #4]
 8008c48:	68db      	ldr	r3, [r3, #12]
 8008c4a:	2b01      	cmp	r3, #1
 8008c4c:	d108      	bne.n	8008c60 <HAL_I2C_Init+0x1b4>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8008c4e:	687b      	ldr	r3, [r7, #4]
 8008c50:	689a      	ldr	r2, [r3, #8]
 8008c52:	687b      	ldr	r3, [r7, #4]
 8008c54:	681b      	ldr	r3, [r3, #0]
 8008c56:	2180      	movs	r1, #128	; 0x80
 8008c58:	0209      	lsls	r1, r1, #8
 8008c5a:	430a      	orrs	r2, r1
 8008c5c:	609a      	str	r2, [r3, #8]
 8008c5e:	e007      	b.n	8008c70 <HAL_I2C_Init+0x1c4>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8008c60:	687b      	ldr	r3, [r7, #4]
 8008c62:	689a      	ldr	r2, [r3, #8]
 8008c64:	687b      	ldr	r3, [r7, #4]
 8008c66:	681b      	ldr	r3, [r3, #0]
 8008c68:	2184      	movs	r1, #132	; 0x84
 8008c6a:	0209      	lsls	r1, r1, #8
 8008c6c:	430a      	orrs	r2, r1
 8008c6e:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8008c70:	687b      	ldr	r3, [r7, #4]
 8008c72:	68db      	ldr	r3, [r3, #12]
 8008c74:	2b02      	cmp	r3, #2
 8008c76:	d104      	bne.n	8008c82 <HAL_I2C_Init+0x1d6>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8008c78:	687b      	ldr	r3, [r7, #4]
 8008c7a:	681b      	ldr	r3, [r3, #0]
 8008c7c:	2280      	movs	r2, #128	; 0x80
 8008c7e:	0112      	lsls	r2, r2, #4
 8008c80:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8008c82:	687b      	ldr	r3, [r7, #4]
 8008c84:	681b      	ldr	r3, [r3, #0]
 8008c86:	685a      	ldr	r2, [r3, #4]
 8008c88:	687b      	ldr	r3, [r7, #4]
 8008c8a:	681b      	ldr	r3, [r3, #0]
 8008c8c:	4923      	ldr	r1, [pc, #140]	; (8008d1c <HAL_I2C_Init+0x270>)
 8008c8e:	430a      	orrs	r2, r1
 8008c90:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8008c92:	687b      	ldr	r3, [r7, #4]
 8008c94:	681b      	ldr	r3, [r3, #0]
 8008c96:	68da      	ldr	r2, [r3, #12]
 8008c98:	687b      	ldr	r3, [r7, #4]
 8008c9a:	681b      	ldr	r3, [r3, #0]
 8008c9c:	491e      	ldr	r1, [pc, #120]	; (8008d18 <HAL_I2C_Init+0x26c>)
 8008c9e:	400a      	ands	r2, r1
 8008ca0:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8008ca2:	687b      	ldr	r3, [r7, #4]
 8008ca4:	691a      	ldr	r2, [r3, #16]
 8008ca6:	687b      	ldr	r3, [r7, #4]
 8008ca8:	695b      	ldr	r3, [r3, #20]
 8008caa:	431a      	orrs	r2, r3
 8008cac:	0011      	movs	r1, r2
 8008cae:	687b      	ldr	r3, [r7, #4]
 8008cb0:	699b      	ldr	r3, [r3, #24]
 8008cb2:	021a      	lsls	r2, r3, #8
 8008cb4:	687b      	ldr	r3, [r7, #4]
 8008cb6:	681b      	ldr	r3, [r3, #0]
 8008cb8:	430a      	orrs	r2, r1
 8008cba:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8008cbc:	687b      	ldr	r3, [r7, #4]
 8008cbe:	69d9      	ldr	r1, [r3, #28]
 8008cc0:	687b      	ldr	r3, [r7, #4]
 8008cc2:	6a1a      	ldr	r2, [r3, #32]
 8008cc4:	687b      	ldr	r3, [r7, #4]
 8008cc6:	681b      	ldr	r3, [r3, #0]
 8008cc8:	430a      	orrs	r2, r1
 8008cca:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8008ccc:	687b      	ldr	r3, [r7, #4]
 8008cce:	681b      	ldr	r3, [r3, #0]
 8008cd0:	681a      	ldr	r2, [r3, #0]
 8008cd2:	687b      	ldr	r3, [r7, #4]
 8008cd4:	681b      	ldr	r3, [r3, #0]
 8008cd6:	2101      	movs	r1, #1
 8008cd8:	430a      	orrs	r2, r1
 8008cda:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8008cdc:	687b      	ldr	r3, [r7, #4]
 8008cde:	2200      	movs	r2, #0
 8008ce0:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8008ce2:	687b      	ldr	r3, [r7, #4]
 8008ce4:	2241      	movs	r2, #65	; 0x41
 8008ce6:	2120      	movs	r1, #32
 8008ce8:	5499      	strb	r1, [r3, r2]
  hi2c->PreviousState = I2C_STATE_NONE;
 8008cea:	687b      	ldr	r3, [r7, #4]
 8008cec:	2200      	movs	r2, #0
 8008cee:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8008cf0:	687b      	ldr	r3, [r7, #4]
 8008cf2:	2242      	movs	r2, #66	; 0x42
 8008cf4:	2100      	movs	r1, #0
 8008cf6:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8008cf8:	2300      	movs	r3, #0
}
 8008cfa:	0018      	movs	r0, r3
 8008cfc:	46bd      	mov	sp, r7
 8008cfe:	b002      	add	sp, #8
 8008d00:	bd80      	pop	{r7, pc}
 8008d02:	46c0      	nop			; (mov r8, r8)
 8008d04:	40005400 	.word	0x40005400
 8008d08:	40005800 	.word	0x40005800
 8008d0c:	40007800 	.word	0x40007800
 8008d10:	0800ddec 	.word	0x0800ddec
 8008d14:	f0ffffff 	.word	0xf0ffffff
 8008d18:	ffff7fff 	.word	0xffff7fff
 8008d1c:	02008000 	.word	0x02008000

08008d20 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8008d20:	b590      	push	{r4, r7, lr}
 8008d22:	b089      	sub	sp, #36	; 0x24
 8008d24:	af02      	add	r7, sp, #8
 8008d26:	60f8      	str	r0, [r7, #12]
 8008d28:	000c      	movs	r4, r1
 8008d2a:	0010      	movs	r0, r2
 8008d2c:	0019      	movs	r1, r3
 8008d2e:	230a      	movs	r3, #10
 8008d30:	18fb      	adds	r3, r7, r3
 8008d32:	1c22      	adds	r2, r4, #0
 8008d34:	801a      	strh	r2, [r3, #0]
 8008d36:	2308      	movs	r3, #8
 8008d38:	18fb      	adds	r3, r7, r3
 8008d3a:	1c02      	adds	r2, r0, #0
 8008d3c:	801a      	strh	r2, [r3, #0]
 8008d3e:	1dbb      	adds	r3, r7, #6
 8008d40:	1c0a      	adds	r2, r1, #0
 8008d42:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
 8008d44:	1dbb      	adds	r3, r7, #6
 8008d46:	881b      	ldrh	r3, [r3, #0]
 8008d48:	2b01      	cmp	r3, #1
 8008d4a:	d009      	beq.n	8008d60 <HAL_I2C_Mem_Write+0x40>
 8008d4c:	1dbb      	adds	r3, r7, #6
 8008d4e:	881b      	ldrh	r3, [r3, #0]
 8008d50:	2b02      	cmp	r3, #2
 8008d52:	d005      	beq.n	8008d60 <HAL_I2C_Mem_Write+0x40>
 8008d54:	4a8f      	ldr	r2, [pc, #572]	; (8008f94 <HAL_I2C_Mem_Write+0x274>)
 8008d56:	4b90      	ldr	r3, [pc, #576]	; (8008f98 <HAL_I2C_Mem_Write+0x278>)
 8008d58:	0011      	movs	r1, r2
 8008d5a:	0018      	movs	r0, r3
 8008d5c:	f7fd fa9b 	bl	8006296 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8008d60:	68fb      	ldr	r3, [r7, #12]
 8008d62:	2241      	movs	r2, #65	; 0x41
 8008d64:	5c9b      	ldrb	r3, [r3, r2]
 8008d66:	b2db      	uxtb	r3, r3
 8008d68:	2b20      	cmp	r3, #32
 8008d6a:	d000      	beq.n	8008d6e <HAL_I2C_Mem_Write+0x4e>
 8008d6c:	e10c      	b.n	8008f88 <HAL_I2C_Mem_Write+0x268>
  {
    if ((pData == NULL) || (Size == 0U))
 8008d6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008d70:	2b00      	cmp	r3, #0
 8008d72:	d004      	beq.n	8008d7e <HAL_I2C_Mem_Write+0x5e>
 8008d74:	232c      	movs	r3, #44	; 0x2c
 8008d76:	18fb      	adds	r3, r7, r3
 8008d78:	881b      	ldrh	r3, [r3, #0]
 8008d7a:	2b00      	cmp	r3, #0
 8008d7c:	d105      	bne.n	8008d8a <HAL_I2C_Mem_Write+0x6a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8008d7e:	68fb      	ldr	r3, [r7, #12]
 8008d80:	2280      	movs	r2, #128	; 0x80
 8008d82:	0092      	lsls	r2, r2, #2
 8008d84:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
 8008d86:	2301      	movs	r3, #1
 8008d88:	e0ff      	b.n	8008f8a <HAL_I2C_Mem_Write+0x26a>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8008d8a:	68fb      	ldr	r3, [r7, #12]
 8008d8c:	2240      	movs	r2, #64	; 0x40
 8008d8e:	5c9b      	ldrb	r3, [r3, r2]
 8008d90:	2b01      	cmp	r3, #1
 8008d92:	d101      	bne.n	8008d98 <HAL_I2C_Mem_Write+0x78>
 8008d94:	2302      	movs	r3, #2
 8008d96:	e0f8      	b.n	8008f8a <HAL_I2C_Mem_Write+0x26a>
 8008d98:	68fb      	ldr	r3, [r7, #12]
 8008d9a:	2240      	movs	r2, #64	; 0x40
 8008d9c:	2101      	movs	r1, #1
 8008d9e:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 8008da0:	f7fe fba0 	bl	80074e4 <HAL_GetTick>
 8008da4:	0003      	movs	r3, r0
 8008da6:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8008da8:	2380      	movs	r3, #128	; 0x80
 8008daa:	0219      	lsls	r1, r3, #8
 8008dac:	68f8      	ldr	r0, [r7, #12]
 8008dae:	697b      	ldr	r3, [r7, #20]
 8008db0:	9300      	str	r3, [sp, #0]
 8008db2:	2319      	movs	r3, #25
 8008db4:	2201      	movs	r2, #1
 8008db6:	f000 fb21 	bl	80093fc <I2C_WaitOnFlagUntilTimeout>
 8008dba:	1e03      	subs	r3, r0, #0
 8008dbc:	d001      	beq.n	8008dc2 <HAL_I2C_Mem_Write+0xa2>
    {
      return HAL_ERROR;
 8008dbe:	2301      	movs	r3, #1
 8008dc0:	e0e3      	b.n	8008f8a <HAL_I2C_Mem_Write+0x26a>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8008dc2:	68fb      	ldr	r3, [r7, #12]
 8008dc4:	2241      	movs	r2, #65	; 0x41
 8008dc6:	2121      	movs	r1, #33	; 0x21
 8008dc8:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8008dca:	68fb      	ldr	r3, [r7, #12]
 8008dcc:	2242      	movs	r2, #66	; 0x42
 8008dce:	2140      	movs	r1, #64	; 0x40
 8008dd0:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8008dd2:	68fb      	ldr	r3, [r7, #12]
 8008dd4:	2200      	movs	r2, #0
 8008dd6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 8008dd8:	68fb      	ldr	r3, [r7, #12]
 8008dda:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008ddc:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 8008dde:	68fb      	ldr	r3, [r7, #12]
 8008de0:	222c      	movs	r2, #44	; 0x2c
 8008de2:	18ba      	adds	r2, r7, r2
 8008de4:	8812      	ldrh	r2, [r2, #0]
 8008de6:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8008de8:	68fb      	ldr	r3, [r7, #12]
 8008dea:	2200      	movs	r2, #0
 8008dec:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8008dee:	1dbb      	adds	r3, r7, #6
 8008df0:	881c      	ldrh	r4, [r3, #0]
 8008df2:	2308      	movs	r3, #8
 8008df4:	18fb      	adds	r3, r7, r3
 8008df6:	881a      	ldrh	r2, [r3, #0]
 8008df8:	230a      	movs	r3, #10
 8008dfa:	18fb      	adds	r3, r7, r3
 8008dfc:	8819      	ldrh	r1, [r3, #0]
 8008dfe:	68f8      	ldr	r0, [r7, #12]
 8008e00:	697b      	ldr	r3, [r7, #20]
 8008e02:	9301      	str	r3, [sp, #4]
 8008e04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008e06:	9300      	str	r3, [sp, #0]
 8008e08:	0023      	movs	r3, r4
 8008e0a:	f000 fa0f 	bl	800922c <I2C_RequestMemoryWrite>
 8008e0e:	1e03      	subs	r3, r0, #0
 8008e10:	d005      	beq.n	8008e1e <HAL_I2C_Mem_Write+0xfe>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8008e12:	68fb      	ldr	r3, [r7, #12]
 8008e14:	2240      	movs	r2, #64	; 0x40
 8008e16:	2100      	movs	r1, #0
 8008e18:	5499      	strb	r1, [r3, r2]
      return HAL_ERROR;
 8008e1a:	2301      	movs	r3, #1
 8008e1c:	e0b5      	b.n	8008f8a <HAL_I2C_Mem_Write+0x26a>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8008e1e:	68fb      	ldr	r3, [r7, #12]
 8008e20:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8008e22:	b29b      	uxth	r3, r3
 8008e24:	2bff      	cmp	r3, #255	; 0xff
 8008e26:	d911      	bls.n	8008e4c <HAL_I2C_Mem_Write+0x12c>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8008e28:	68fb      	ldr	r3, [r7, #12]
 8008e2a:	22ff      	movs	r2, #255	; 0xff
 8008e2c:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8008e2e:	68fb      	ldr	r3, [r7, #12]
 8008e30:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8008e32:	b2da      	uxtb	r2, r3
 8008e34:	2380      	movs	r3, #128	; 0x80
 8008e36:	045c      	lsls	r4, r3, #17
 8008e38:	230a      	movs	r3, #10
 8008e3a:	18fb      	adds	r3, r7, r3
 8008e3c:	8819      	ldrh	r1, [r3, #0]
 8008e3e:	68f8      	ldr	r0, [r7, #12]
 8008e40:	2300      	movs	r3, #0
 8008e42:	9300      	str	r3, [sp, #0]
 8008e44:	0023      	movs	r3, r4
 8008e46:	f000 fbf9 	bl	800963c <I2C_TransferConfig>
 8008e4a:	e012      	b.n	8008e72 <HAL_I2C_Mem_Write+0x152>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 8008e4c:	68fb      	ldr	r3, [r7, #12]
 8008e4e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8008e50:	b29a      	uxth	r2, r3
 8008e52:	68fb      	ldr	r3, [r7, #12]
 8008e54:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008e56:	68fb      	ldr	r3, [r7, #12]
 8008e58:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8008e5a:	b2da      	uxtb	r2, r3
 8008e5c:	2380      	movs	r3, #128	; 0x80
 8008e5e:	049c      	lsls	r4, r3, #18
 8008e60:	230a      	movs	r3, #10
 8008e62:	18fb      	adds	r3, r7, r3
 8008e64:	8819      	ldrh	r1, [r3, #0]
 8008e66:	68f8      	ldr	r0, [r7, #12]
 8008e68:	2300      	movs	r3, #0
 8008e6a:	9300      	str	r3, [sp, #0]
 8008e6c:	0023      	movs	r3, r4
 8008e6e:	f000 fbe5 	bl	800963c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8008e72:	697a      	ldr	r2, [r7, #20]
 8008e74:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8008e76:	68fb      	ldr	r3, [r7, #12]
 8008e78:	0018      	movs	r0, r3
 8008e7a:	f000 fafe 	bl	800947a <I2C_WaitOnTXISFlagUntilTimeout>
 8008e7e:	1e03      	subs	r3, r0, #0
 8008e80:	d001      	beq.n	8008e86 <HAL_I2C_Mem_Write+0x166>
      {
        return HAL_ERROR;
 8008e82:	2301      	movs	r3, #1
 8008e84:	e081      	b.n	8008f8a <HAL_I2C_Mem_Write+0x26a>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8008e86:	68fb      	ldr	r3, [r7, #12]
 8008e88:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008e8a:	781a      	ldrb	r2, [r3, #0]
 8008e8c:	68fb      	ldr	r3, [r7, #12]
 8008e8e:	681b      	ldr	r3, [r3, #0]
 8008e90:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8008e92:	68fb      	ldr	r3, [r7, #12]
 8008e94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008e96:	1c5a      	adds	r2, r3, #1
 8008e98:	68fb      	ldr	r3, [r7, #12]
 8008e9a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
 8008e9c:	68fb      	ldr	r3, [r7, #12]
 8008e9e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8008ea0:	b29b      	uxth	r3, r3
 8008ea2:	3b01      	subs	r3, #1
 8008ea4:	b29a      	uxth	r2, r3
 8008ea6:	68fb      	ldr	r3, [r7, #12]
 8008ea8:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
 8008eaa:	68fb      	ldr	r3, [r7, #12]
 8008eac:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8008eae:	3b01      	subs	r3, #1
 8008eb0:	b29a      	uxth	r2, r3
 8008eb2:	68fb      	ldr	r3, [r7, #12]
 8008eb4:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8008eb6:	68fb      	ldr	r3, [r7, #12]
 8008eb8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8008eba:	b29b      	uxth	r3, r3
 8008ebc:	2b00      	cmp	r3, #0
 8008ebe:	d03a      	beq.n	8008f36 <HAL_I2C_Mem_Write+0x216>
 8008ec0:	68fb      	ldr	r3, [r7, #12]
 8008ec2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8008ec4:	2b00      	cmp	r3, #0
 8008ec6:	d136      	bne.n	8008f36 <HAL_I2C_Mem_Write+0x216>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8008ec8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008eca:	68f8      	ldr	r0, [r7, #12]
 8008ecc:	697b      	ldr	r3, [r7, #20]
 8008ece:	9300      	str	r3, [sp, #0]
 8008ed0:	0013      	movs	r3, r2
 8008ed2:	2200      	movs	r2, #0
 8008ed4:	2180      	movs	r1, #128	; 0x80
 8008ed6:	f000 fa91 	bl	80093fc <I2C_WaitOnFlagUntilTimeout>
 8008eda:	1e03      	subs	r3, r0, #0
 8008edc:	d001      	beq.n	8008ee2 <HAL_I2C_Mem_Write+0x1c2>
        {
          return HAL_ERROR;
 8008ede:	2301      	movs	r3, #1
 8008ee0:	e053      	b.n	8008f8a <HAL_I2C_Mem_Write+0x26a>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8008ee2:	68fb      	ldr	r3, [r7, #12]
 8008ee4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8008ee6:	b29b      	uxth	r3, r3
 8008ee8:	2bff      	cmp	r3, #255	; 0xff
 8008eea:	d911      	bls.n	8008f10 <HAL_I2C_Mem_Write+0x1f0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8008eec:	68fb      	ldr	r3, [r7, #12]
 8008eee:	22ff      	movs	r2, #255	; 0xff
 8008ef0:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8008ef2:	68fb      	ldr	r3, [r7, #12]
 8008ef4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8008ef6:	b2da      	uxtb	r2, r3
 8008ef8:	2380      	movs	r3, #128	; 0x80
 8008efa:	045c      	lsls	r4, r3, #17
 8008efc:	230a      	movs	r3, #10
 8008efe:	18fb      	adds	r3, r7, r3
 8008f00:	8819      	ldrh	r1, [r3, #0]
 8008f02:	68f8      	ldr	r0, [r7, #12]
 8008f04:	2300      	movs	r3, #0
 8008f06:	9300      	str	r3, [sp, #0]
 8008f08:	0023      	movs	r3, r4
 8008f0a:	f000 fb97 	bl	800963c <I2C_TransferConfig>
 8008f0e:	e012      	b.n	8008f36 <HAL_I2C_Mem_Write+0x216>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8008f10:	68fb      	ldr	r3, [r7, #12]
 8008f12:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8008f14:	b29a      	uxth	r2, r3
 8008f16:	68fb      	ldr	r3, [r7, #12]
 8008f18:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008f1a:	68fb      	ldr	r3, [r7, #12]
 8008f1c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8008f1e:	b2da      	uxtb	r2, r3
 8008f20:	2380      	movs	r3, #128	; 0x80
 8008f22:	049c      	lsls	r4, r3, #18
 8008f24:	230a      	movs	r3, #10
 8008f26:	18fb      	adds	r3, r7, r3
 8008f28:	8819      	ldrh	r1, [r3, #0]
 8008f2a:	68f8      	ldr	r0, [r7, #12]
 8008f2c:	2300      	movs	r3, #0
 8008f2e:	9300      	str	r3, [sp, #0]
 8008f30:	0023      	movs	r3, r4
 8008f32:	f000 fb83 	bl	800963c <I2C_TransferConfig>
        }
      }

    } while (hi2c->XferCount > 0U);
 8008f36:	68fb      	ldr	r3, [r7, #12]
 8008f38:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8008f3a:	b29b      	uxth	r3, r3
 8008f3c:	2b00      	cmp	r3, #0
 8008f3e:	d198      	bne.n	8008e72 <HAL_I2C_Mem_Write+0x152>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8008f40:	697a      	ldr	r2, [r7, #20]
 8008f42:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8008f44:	68fb      	ldr	r3, [r7, #12]
 8008f46:	0018      	movs	r0, r3
 8008f48:	f000 fad6 	bl	80094f8 <I2C_WaitOnSTOPFlagUntilTimeout>
 8008f4c:	1e03      	subs	r3, r0, #0
 8008f4e:	d001      	beq.n	8008f54 <HAL_I2C_Mem_Write+0x234>
    {
      return HAL_ERROR;
 8008f50:	2301      	movs	r3, #1
 8008f52:	e01a      	b.n	8008f8a <HAL_I2C_Mem_Write+0x26a>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8008f54:	68fb      	ldr	r3, [r7, #12]
 8008f56:	681b      	ldr	r3, [r3, #0]
 8008f58:	2220      	movs	r2, #32
 8008f5a:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8008f5c:	68fb      	ldr	r3, [r7, #12]
 8008f5e:	681b      	ldr	r3, [r3, #0]
 8008f60:	685a      	ldr	r2, [r3, #4]
 8008f62:	68fb      	ldr	r3, [r7, #12]
 8008f64:	681b      	ldr	r3, [r3, #0]
 8008f66:	490d      	ldr	r1, [pc, #52]	; (8008f9c <HAL_I2C_Mem_Write+0x27c>)
 8008f68:	400a      	ands	r2, r1
 8008f6a:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8008f6c:	68fb      	ldr	r3, [r7, #12]
 8008f6e:	2241      	movs	r2, #65	; 0x41
 8008f70:	2120      	movs	r1, #32
 8008f72:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8008f74:	68fb      	ldr	r3, [r7, #12]
 8008f76:	2242      	movs	r2, #66	; 0x42
 8008f78:	2100      	movs	r1, #0
 8008f7a:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8008f7c:	68fb      	ldr	r3, [r7, #12]
 8008f7e:	2240      	movs	r2, #64	; 0x40
 8008f80:	2100      	movs	r1, #0
 8008f82:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 8008f84:	2300      	movs	r3, #0
 8008f86:	e000      	b.n	8008f8a <HAL_I2C_Mem_Write+0x26a>
  }
  else
  {
    return HAL_BUSY;
 8008f88:	2302      	movs	r3, #2
  }
}
 8008f8a:	0018      	movs	r0, r3
 8008f8c:	46bd      	mov	sp, r7
 8008f8e:	b007      	add	sp, #28
 8008f90:	bd90      	pop	{r4, r7, pc}
 8008f92:	46c0      	nop			; (mov r8, r8)
 8008f94:	000008fb 	.word	0x000008fb
 8008f98:	0800ddec 	.word	0x0800ddec
 8008f9c:	fe00e800 	.word	0xfe00e800

08008fa0 <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8008fa0:	b590      	push	{r4, r7, lr}
 8008fa2:	b089      	sub	sp, #36	; 0x24
 8008fa4:	af02      	add	r7, sp, #8
 8008fa6:	60f8      	str	r0, [r7, #12]
 8008fa8:	000c      	movs	r4, r1
 8008faa:	0010      	movs	r0, r2
 8008fac:	0019      	movs	r1, r3
 8008fae:	230a      	movs	r3, #10
 8008fb0:	18fb      	adds	r3, r7, r3
 8008fb2:	1c22      	adds	r2, r4, #0
 8008fb4:	801a      	strh	r2, [r3, #0]
 8008fb6:	2308      	movs	r3, #8
 8008fb8:	18fb      	adds	r3, r7, r3
 8008fba:	1c02      	adds	r2, r0, #0
 8008fbc:	801a      	strh	r2, [r3, #0]
 8008fbe:	1dbb      	adds	r3, r7, #6
 8008fc0:	1c0a      	adds	r2, r1, #0
 8008fc2:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
 8008fc4:	1dbb      	adds	r3, r7, #6
 8008fc6:	881b      	ldrh	r3, [r3, #0]
 8008fc8:	2b01      	cmp	r3, #1
 8008fca:	d009      	beq.n	8008fe0 <HAL_I2C_Mem_Read+0x40>
 8008fcc:	1dbb      	adds	r3, r7, #6
 8008fce:	881b      	ldrh	r3, [r3, #0]
 8008fd0:	2b02      	cmp	r3, #2
 8008fd2:	d005      	beq.n	8008fe0 <HAL_I2C_Mem_Read+0x40>
 8008fd4:	4a91      	ldr	r2, [pc, #580]	; (800921c <HAL_I2C_Mem_Read+0x27c>)
 8008fd6:	4b92      	ldr	r3, [pc, #584]	; (8009220 <HAL_I2C_Mem_Read+0x280>)
 8008fd8:	0011      	movs	r1, r2
 8008fda:	0018      	movs	r0, r3
 8008fdc:	f7fd f95b 	bl	8006296 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8008fe0:	68fb      	ldr	r3, [r7, #12]
 8008fe2:	2241      	movs	r2, #65	; 0x41
 8008fe4:	5c9b      	ldrb	r3, [r3, r2]
 8008fe6:	b2db      	uxtb	r3, r3
 8008fe8:	2b20      	cmp	r3, #32
 8008fea:	d000      	beq.n	8008fee <HAL_I2C_Mem_Read+0x4e>
 8008fec:	e110      	b.n	8009210 <HAL_I2C_Mem_Read+0x270>
  {
    if ((pData == NULL) || (Size == 0U))
 8008fee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008ff0:	2b00      	cmp	r3, #0
 8008ff2:	d004      	beq.n	8008ffe <HAL_I2C_Mem_Read+0x5e>
 8008ff4:	232c      	movs	r3, #44	; 0x2c
 8008ff6:	18fb      	adds	r3, r7, r3
 8008ff8:	881b      	ldrh	r3, [r3, #0]
 8008ffa:	2b00      	cmp	r3, #0
 8008ffc:	d105      	bne.n	800900a <HAL_I2C_Mem_Read+0x6a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8008ffe:	68fb      	ldr	r3, [r7, #12]
 8009000:	2280      	movs	r2, #128	; 0x80
 8009002:	0092      	lsls	r2, r2, #2
 8009004:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
 8009006:	2301      	movs	r3, #1
 8009008:	e103      	b.n	8009212 <HAL_I2C_Mem_Read+0x272>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800900a:	68fb      	ldr	r3, [r7, #12]
 800900c:	2240      	movs	r2, #64	; 0x40
 800900e:	5c9b      	ldrb	r3, [r3, r2]
 8009010:	2b01      	cmp	r3, #1
 8009012:	d101      	bne.n	8009018 <HAL_I2C_Mem_Read+0x78>
 8009014:	2302      	movs	r3, #2
 8009016:	e0fc      	b.n	8009212 <HAL_I2C_Mem_Read+0x272>
 8009018:	68fb      	ldr	r3, [r7, #12]
 800901a:	2240      	movs	r2, #64	; 0x40
 800901c:	2101      	movs	r1, #1
 800901e:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 8009020:	f7fe fa60 	bl	80074e4 <HAL_GetTick>
 8009024:	0003      	movs	r3, r0
 8009026:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8009028:	2380      	movs	r3, #128	; 0x80
 800902a:	0219      	lsls	r1, r3, #8
 800902c:	68f8      	ldr	r0, [r7, #12]
 800902e:	697b      	ldr	r3, [r7, #20]
 8009030:	9300      	str	r3, [sp, #0]
 8009032:	2319      	movs	r3, #25
 8009034:	2201      	movs	r2, #1
 8009036:	f000 f9e1 	bl	80093fc <I2C_WaitOnFlagUntilTimeout>
 800903a:	1e03      	subs	r3, r0, #0
 800903c:	d001      	beq.n	8009042 <HAL_I2C_Mem_Read+0xa2>
    {
      return HAL_ERROR;
 800903e:	2301      	movs	r3, #1
 8009040:	e0e7      	b.n	8009212 <HAL_I2C_Mem_Read+0x272>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8009042:	68fb      	ldr	r3, [r7, #12]
 8009044:	2241      	movs	r2, #65	; 0x41
 8009046:	2122      	movs	r1, #34	; 0x22
 8009048:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 800904a:	68fb      	ldr	r3, [r7, #12]
 800904c:	2242      	movs	r2, #66	; 0x42
 800904e:	2140      	movs	r1, #64	; 0x40
 8009050:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8009052:	68fb      	ldr	r3, [r7, #12]
 8009054:	2200      	movs	r2, #0
 8009056:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 8009058:	68fb      	ldr	r3, [r7, #12]
 800905a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800905c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800905e:	68fb      	ldr	r3, [r7, #12]
 8009060:	222c      	movs	r2, #44	; 0x2c
 8009062:	18ba      	adds	r2, r7, r2
 8009064:	8812      	ldrh	r2, [r2, #0]
 8009066:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8009068:	68fb      	ldr	r3, [r7, #12]
 800906a:	2200      	movs	r2, #0
 800906c:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 800906e:	1dbb      	adds	r3, r7, #6
 8009070:	881c      	ldrh	r4, [r3, #0]
 8009072:	2308      	movs	r3, #8
 8009074:	18fb      	adds	r3, r7, r3
 8009076:	881a      	ldrh	r2, [r3, #0]
 8009078:	230a      	movs	r3, #10
 800907a:	18fb      	adds	r3, r7, r3
 800907c:	8819      	ldrh	r1, [r3, #0]
 800907e:	68f8      	ldr	r0, [r7, #12]
 8009080:	697b      	ldr	r3, [r7, #20]
 8009082:	9301      	str	r3, [sp, #4]
 8009084:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009086:	9300      	str	r3, [sp, #0]
 8009088:	0023      	movs	r3, r4
 800908a:	f000 f933 	bl	80092f4 <I2C_RequestMemoryRead>
 800908e:	1e03      	subs	r3, r0, #0
 8009090:	d005      	beq.n	800909e <HAL_I2C_Mem_Read+0xfe>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8009092:	68fb      	ldr	r3, [r7, #12]
 8009094:	2240      	movs	r2, #64	; 0x40
 8009096:	2100      	movs	r1, #0
 8009098:	5499      	strb	r1, [r3, r2]
      return HAL_ERROR;
 800909a:	2301      	movs	r3, #1
 800909c:	e0b9      	b.n	8009212 <HAL_I2C_Mem_Read+0x272>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800909e:	68fb      	ldr	r3, [r7, #12]
 80090a0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80090a2:	b29b      	uxth	r3, r3
 80090a4:	2bff      	cmp	r3, #255	; 0xff
 80090a6:	d911      	bls.n	80090cc <HAL_I2C_Mem_Read+0x12c>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80090a8:	68fb      	ldr	r3, [r7, #12]
 80090aa:	22ff      	movs	r2, #255	; 0xff
 80090ac:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80090ae:	68fb      	ldr	r3, [r7, #12]
 80090b0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80090b2:	b2da      	uxtb	r2, r3
 80090b4:	2380      	movs	r3, #128	; 0x80
 80090b6:	045c      	lsls	r4, r3, #17
 80090b8:	230a      	movs	r3, #10
 80090ba:	18fb      	adds	r3, r7, r3
 80090bc:	8819      	ldrh	r1, [r3, #0]
 80090be:	68f8      	ldr	r0, [r7, #12]
 80090c0:	4b58      	ldr	r3, [pc, #352]	; (8009224 <HAL_I2C_Mem_Read+0x284>)
 80090c2:	9300      	str	r3, [sp, #0]
 80090c4:	0023      	movs	r3, r4
 80090c6:	f000 fab9 	bl	800963c <I2C_TransferConfig>
 80090ca:	e012      	b.n	80090f2 <HAL_I2C_Mem_Read+0x152>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 80090cc:	68fb      	ldr	r3, [r7, #12]
 80090ce:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80090d0:	b29a      	uxth	r2, r3
 80090d2:	68fb      	ldr	r3, [r7, #12]
 80090d4:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 80090d6:	68fb      	ldr	r3, [r7, #12]
 80090d8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80090da:	b2da      	uxtb	r2, r3
 80090dc:	2380      	movs	r3, #128	; 0x80
 80090de:	049c      	lsls	r4, r3, #18
 80090e0:	230a      	movs	r3, #10
 80090e2:	18fb      	adds	r3, r7, r3
 80090e4:	8819      	ldrh	r1, [r3, #0]
 80090e6:	68f8      	ldr	r0, [r7, #12]
 80090e8:	4b4e      	ldr	r3, [pc, #312]	; (8009224 <HAL_I2C_Mem_Read+0x284>)
 80090ea:	9300      	str	r3, [sp, #0]
 80090ec:	0023      	movs	r3, r4
 80090ee:	f000 faa5 	bl	800963c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 80090f2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80090f4:	68f8      	ldr	r0, [r7, #12]
 80090f6:	697b      	ldr	r3, [r7, #20]
 80090f8:	9300      	str	r3, [sp, #0]
 80090fa:	0013      	movs	r3, r2
 80090fc:	2200      	movs	r2, #0
 80090fe:	2104      	movs	r1, #4
 8009100:	f000 f97c 	bl	80093fc <I2C_WaitOnFlagUntilTimeout>
 8009104:	1e03      	subs	r3, r0, #0
 8009106:	d001      	beq.n	800910c <HAL_I2C_Mem_Read+0x16c>
      {
        return HAL_ERROR;
 8009108:	2301      	movs	r3, #1
 800910a:	e082      	b.n	8009212 <HAL_I2C_Mem_Read+0x272>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800910c:	68fb      	ldr	r3, [r7, #12]
 800910e:	681b      	ldr	r3, [r3, #0]
 8009110:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009112:	68fb      	ldr	r3, [r7, #12]
 8009114:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009116:	b2d2      	uxtb	r2, r2
 8009118:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800911a:	68fb      	ldr	r3, [r7, #12]
 800911c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800911e:	1c5a      	adds	r2, r3, #1
 8009120:	68fb      	ldr	r3, [r7, #12]
 8009122:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
 8009124:	68fb      	ldr	r3, [r7, #12]
 8009126:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8009128:	3b01      	subs	r3, #1
 800912a:	b29a      	uxth	r2, r3
 800912c:	68fb      	ldr	r3, [r7, #12]
 800912e:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 8009130:	68fb      	ldr	r3, [r7, #12]
 8009132:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8009134:	b29b      	uxth	r3, r3
 8009136:	3b01      	subs	r3, #1
 8009138:	b29a      	uxth	r2, r3
 800913a:	68fb      	ldr	r3, [r7, #12]
 800913c:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800913e:	68fb      	ldr	r3, [r7, #12]
 8009140:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8009142:	b29b      	uxth	r3, r3
 8009144:	2b00      	cmp	r3, #0
 8009146:	d03a      	beq.n	80091be <HAL_I2C_Mem_Read+0x21e>
 8009148:	68fb      	ldr	r3, [r7, #12]
 800914a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800914c:	2b00      	cmp	r3, #0
 800914e:	d136      	bne.n	80091be <HAL_I2C_Mem_Read+0x21e>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8009150:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009152:	68f8      	ldr	r0, [r7, #12]
 8009154:	697b      	ldr	r3, [r7, #20]
 8009156:	9300      	str	r3, [sp, #0]
 8009158:	0013      	movs	r3, r2
 800915a:	2200      	movs	r2, #0
 800915c:	2180      	movs	r1, #128	; 0x80
 800915e:	f000 f94d 	bl	80093fc <I2C_WaitOnFlagUntilTimeout>
 8009162:	1e03      	subs	r3, r0, #0
 8009164:	d001      	beq.n	800916a <HAL_I2C_Mem_Read+0x1ca>
        {
          return HAL_ERROR;
 8009166:	2301      	movs	r3, #1
 8009168:	e053      	b.n	8009212 <HAL_I2C_Mem_Read+0x272>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800916a:	68fb      	ldr	r3, [r7, #12]
 800916c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800916e:	b29b      	uxth	r3, r3
 8009170:	2bff      	cmp	r3, #255	; 0xff
 8009172:	d911      	bls.n	8009198 <HAL_I2C_Mem_Read+0x1f8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8009174:	68fb      	ldr	r3, [r7, #12]
 8009176:	22ff      	movs	r2, #255	; 0xff
 8009178:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800917a:	68fb      	ldr	r3, [r7, #12]
 800917c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800917e:	b2da      	uxtb	r2, r3
 8009180:	2380      	movs	r3, #128	; 0x80
 8009182:	045c      	lsls	r4, r3, #17
 8009184:	230a      	movs	r3, #10
 8009186:	18fb      	adds	r3, r7, r3
 8009188:	8819      	ldrh	r1, [r3, #0]
 800918a:	68f8      	ldr	r0, [r7, #12]
 800918c:	2300      	movs	r3, #0
 800918e:	9300      	str	r3, [sp, #0]
 8009190:	0023      	movs	r3, r4
 8009192:	f000 fa53 	bl	800963c <I2C_TransferConfig>
 8009196:	e012      	b.n	80091be <HAL_I2C_Mem_Read+0x21e>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8009198:	68fb      	ldr	r3, [r7, #12]
 800919a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800919c:	b29a      	uxth	r2, r3
 800919e:	68fb      	ldr	r3, [r7, #12]
 80091a0:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80091a2:	68fb      	ldr	r3, [r7, #12]
 80091a4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80091a6:	b2da      	uxtb	r2, r3
 80091a8:	2380      	movs	r3, #128	; 0x80
 80091aa:	049c      	lsls	r4, r3, #18
 80091ac:	230a      	movs	r3, #10
 80091ae:	18fb      	adds	r3, r7, r3
 80091b0:	8819      	ldrh	r1, [r3, #0]
 80091b2:	68f8      	ldr	r0, [r7, #12]
 80091b4:	2300      	movs	r3, #0
 80091b6:	9300      	str	r3, [sp, #0]
 80091b8:	0023      	movs	r3, r4
 80091ba:	f000 fa3f 	bl	800963c <I2C_TransferConfig>
        }
      }
    } while (hi2c->XferCount > 0U);
 80091be:	68fb      	ldr	r3, [r7, #12]
 80091c0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80091c2:	b29b      	uxth	r3, r3
 80091c4:	2b00      	cmp	r3, #0
 80091c6:	d194      	bne.n	80090f2 <HAL_I2C_Mem_Read+0x152>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80091c8:	697a      	ldr	r2, [r7, #20]
 80091ca:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80091cc:	68fb      	ldr	r3, [r7, #12]
 80091ce:	0018      	movs	r0, r3
 80091d0:	f000 f992 	bl	80094f8 <I2C_WaitOnSTOPFlagUntilTimeout>
 80091d4:	1e03      	subs	r3, r0, #0
 80091d6:	d001      	beq.n	80091dc <HAL_I2C_Mem_Read+0x23c>
    {
      return HAL_ERROR;
 80091d8:	2301      	movs	r3, #1
 80091da:	e01a      	b.n	8009212 <HAL_I2C_Mem_Read+0x272>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80091dc:	68fb      	ldr	r3, [r7, #12]
 80091de:	681b      	ldr	r3, [r3, #0]
 80091e0:	2220      	movs	r2, #32
 80091e2:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80091e4:	68fb      	ldr	r3, [r7, #12]
 80091e6:	681b      	ldr	r3, [r3, #0]
 80091e8:	685a      	ldr	r2, [r3, #4]
 80091ea:	68fb      	ldr	r3, [r7, #12]
 80091ec:	681b      	ldr	r3, [r3, #0]
 80091ee:	490e      	ldr	r1, [pc, #56]	; (8009228 <HAL_I2C_Mem_Read+0x288>)
 80091f0:	400a      	ands	r2, r1
 80091f2:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 80091f4:	68fb      	ldr	r3, [r7, #12]
 80091f6:	2241      	movs	r2, #65	; 0x41
 80091f8:	2120      	movs	r1, #32
 80091fa:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 80091fc:	68fb      	ldr	r3, [r7, #12]
 80091fe:	2242      	movs	r2, #66	; 0x42
 8009200:	2100      	movs	r1, #0
 8009202:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8009204:	68fb      	ldr	r3, [r7, #12]
 8009206:	2240      	movs	r2, #64	; 0x40
 8009208:	2100      	movs	r1, #0
 800920a:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 800920c:	2300      	movs	r3, #0
 800920e:	e000      	b.n	8009212 <HAL_I2C_Mem_Read+0x272>
  }
  else
  {
    return HAL_BUSY;
 8009210:	2302      	movs	r3, #2
  }
}
 8009212:	0018      	movs	r0, r3
 8009214:	46bd      	mov	sp, r7
 8009216:	b007      	add	sp, #28
 8009218:	bd90      	pop	{r4, r7, pc}
 800921a:	46c0      	nop			; (mov r8, r8)
 800921c:	00000982 	.word	0x00000982
 8009220:	0800ddec 	.word	0x0800ddec
 8009224:	80002400 	.word	0x80002400
 8009228:	fe00e800 	.word	0xfe00e800

0800922c <I2C_RequestMemoryWrite>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                                uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 800922c:	b5b0      	push	{r4, r5, r7, lr}
 800922e:	b086      	sub	sp, #24
 8009230:	af02      	add	r7, sp, #8
 8009232:	60f8      	str	r0, [r7, #12]
 8009234:	000c      	movs	r4, r1
 8009236:	0010      	movs	r0, r2
 8009238:	0019      	movs	r1, r3
 800923a:	250a      	movs	r5, #10
 800923c:	197b      	adds	r3, r7, r5
 800923e:	1c22      	adds	r2, r4, #0
 8009240:	801a      	strh	r2, [r3, #0]
 8009242:	2308      	movs	r3, #8
 8009244:	18fb      	adds	r3, r7, r3
 8009246:	1c02      	adds	r2, r0, #0
 8009248:	801a      	strh	r2, [r3, #0]
 800924a:	1dbb      	adds	r3, r7, #6
 800924c:	1c0a      	adds	r2, r1, #0
 800924e:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8009250:	1dbb      	adds	r3, r7, #6
 8009252:	881b      	ldrh	r3, [r3, #0]
 8009254:	b2da      	uxtb	r2, r3
 8009256:	2380      	movs	r3, #128	; 0x80
 8009258:	045c      	lsls	r4, r3, #17
 800925a:	197b      	adds	r3, r7, r5
 800925c:	8819      	ldrh	r1, [r3, #0]
 800925e:	68f8      	ldr	r0, [r7, #12]
 8009260:	4b23      	ldr	r3, [pc, #140]	; (80092f0 <I2C_RequestMemoryWrite+0xc4>)
 8009262:	9300      	str	r3, [sp, #0]
 8009264:	0023      	movs	r3, r4
 8009266:	f000 f9e9 	bl	800963c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800926a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800926c:	6a39      	ldr	r1, [r7, #32]
 800926e:	68fb      	ldr	r3, [r7, #12]
 8009270:	0018      	movs	r0, r3
 8009272:	f000 f902 	bl	800947a <I2C_WaitOnTXISFlagUntilTimeout>
 8009276:	1e03      	subs	r3, r0, #0
 8009278:	d001      	beq.n	800927e <I2C_RequestMemoryWrite+0x52>
  {
    return HAL_ERROR;
 800927a:	2301      	movs	r3, #1
 800927c:	e033      	b.n	80092e6 <I2C_RequestMemoryWrite+0xba>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800927e:	1dbb      	adds	r3, r7, #6
 8009280:	881b      	ldrh	r3, [r3, #0]
 8009282:	2b01      	cmp	r3, #1
 8009284:	d107      	bne.n	8009296 <I2C_RequestMemoryWrite+0x6a>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8009286:	2308      	movs	r3, #8
 8009288:	18fb      	adds	r3, r7, r3
 800928a:	881b      	ldrh	r3, [r3, #0]
 800928c:	b2da      	uxtb	r2, r3
 800928e:	68fb      	ldr	r3, [r7, #12]
 8009290:	681b      	ldr	r3, [r3, #0]
 8009292:	629a      	str	r2, [r3, #40]	; 0x28
 8009294:	e019      	b.n	80092ca <I2C_RequestMemoryWrite+0x9e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8009296:	2308      	movs	r3, #8
 8009298:	18fb      	adds	r3, r7, r3
 800929a:	881b      	ldrh	r3, [r3, #0]
 800929c:	0a1b      	lsrs	r3, r3, #8
 800929e:	b29b      	uxth	r3, r3
 80092a0:	b2da      	uxtb	r2, r3
 80092a2:	68fb      	ldr	r3, [r7, #12]
 80092a4:	681b      	ldr	r3, [r3, #0]
 80092a6:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80092a8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80092aa:	6a39      	ldr	r1, [r7, #32]
 80092ac:	68fb      	ldr	r3, [r7, #12]
 80092ae:	0018      	movs	r0, r3
 80092b0:	f000 f8e3 	bl	800947a <I2C_WaitOnTXISFlagUntilTimeout>
 80092b4:	1e03      	subs	r3, r0, #0
 80092b6:	d001      	beq.n	80092bc <I2C_RequestMemoryWrite+0x90>
    {
      return HAL_ERROR;
 80092b8:	2301      	movs	r3, #1
 80092ba:	e014      	b.n	80092e6 <I2C_RequestMemoryWrite+0xba>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 80092bc:	2308      	movs	r3, #8
 80092be:	18fb      	adds	r3, r7, r3
 80092c0:	881b      	ldrh	r3, [r3, #0]
 80092c2:	b2da      	uxtb	r2, r3
 80092c4:	68fb      	ldr	r3, [r7, #12]
 80092c6:	681b      	ldr	r3, [r3, #0]
 80092c8:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 80092ca:	6a3a      	ldr	r2, [r7, #32]
 80092cc:	68f8      	ldr	r0, [r7, #12]
 80092ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80092d0:	9300      	str	r3, [sp, #0]
 80092d2:	0013      	movs	r3, r2
 80092d4:	2200      	movs	r2, #0
 80092d6:	2180      	movs	r1, #128	; 0x80
 80092d8:	f000 f890 	bl	80093fc <I2C_WaitOnFlagUntilTimeout>
 80092dc:	1e03      	subs	r3, r0, #0
 80092de:	d001      	beq.n	80092e4 <I2C_RequestMemoryWrite+0xb8>
  {
    return HAL_ERROR;
 80092e0:	2301      	movs	r3, #1
 80092e2:	e000      	b.n	80092e6 <I2C_RequestMemoryWrite+0xba>
  }

  return HAL_OK;
 80092e4:	2300      	movs	r3, #0
}
 80092e6:	0018      	movs	r0, r3
 80092e8:	46bd      	mov	sp, r7
 80092ea:	b004      	add	sp, #16
 80092ec:	bdb0      	pop	{r4, r5, r7, pc}
 80092ee:	46c0      	nop			; (mov r8, r8)
 80092f0:	80002000 	.word	0x80002000

080092f4 <I2C_RequestMemoryRead>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                               uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 80092f4:	b5b0      	push	{r4, r5, r7, lr}
 80092f6:	b086      	sub	sp, #24
 80092f8:	af02      	add	r7, sp, #8
 80092fa:	60f8      	str	r0, [r7, #12]
 80092fc:	000c      	movs	r4, r1
 80092fe:	0010      	movs	r0, r2
 8009300:	0019      	movs	r1, r3
 8009302:	250a      	movs	r5, #10
 8009304:	197b      	adds	r3, r7, r5
 8009306:	1c22      	adds	r2, r4, #0
 8009308:	801a      	strh	r2, [r3, #0]
 800930a:	2308      	movs	r3, #8
 800930c:	18fb      	adds	r3, r7, r3
 800930e:	1c02      	adds	r2, r0, #0
 8009310:	801a      	strh	r2, [r3, #0]
 8009312:	1dbb      	adds	r3, r7, #6
 8009314:	1c0a      	adds	r2, r1, #0
 8009316:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8009318:	1dbb      	adds	r3, r7, #6
 800931a:	881b      	ldrh	r3, [r3, #0]
 800931c:	b2da      	uxtb	r2, r3
 800931e:	197b      	adds	r3, r7, r5
 8009320:	8819      	ldrh	r1, [r3, #0]
 8009322:	68f8      	ldr	r0, [r7, #12]
 8009324:	4b23      	ldr	r3, [pc, #140]	; (80093b4 <I2C_RequestMemoryRead+0xc0>)
 8009326:	9300      	str	r3, [sp, #0]
 8009328:	2300      	movs	r3, #0
 800932a:	f000 f987 	bl	800963c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800932e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009330:	6a39      	ldr	r1, [r7, #32]
 8009332:	68fb      	ldr	r3, [r7, #12]
 8009334:	0018      	movs	r0, r3
 8009336:	f000 f8a0 	bl	800947a <I2C_WaitOnTXISFlagUntilTimeout>
 800933a:	1e03      	subs	r3, r0, #0
 800933c:	d001      	beq.n	8009342 <I2C_RequestMemoryRead+0x4e>
  {
    return HAL_ERROR;
 800933e:	2301      	movs	r3, #1
 8009340:	e033      	b.n	80093aa <I2C_RequestMemoryRead+0xb6>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8009342:	1dbb      	adds	r3, r7, #6
 8009344:	881b      	ldrh	r3, [r3, #0]
 8009346:	2b01      	cmp	r3, #1
 8009348:	d107      	bne.n	800935a <I2C_RequestMemoryRead+0x66>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800934a:	2308      	movs	r3, #8
 800934c:	18fb      	adds	r3, r7, r3
 800934e:	881b      	ldrh	r3, [r3, #0]
 8009350:	b2da      	uxtb	r2, r3
 8009352:	68fb      	ldr	r3, [r7, #12]
 8009354:	681b      	ldr	r3, [r3, #0]
 8009356:	629a      	str	r2, [r3, #40]	; 0x28
 8009358:	e019      	b.n	800938e <I2C_RequestMemoryRead+0x9a>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 800935a:	2308      	movs	r3, #8
 800935c:	18fb      	adds	r3, r7, r3
 800935e:	881b      	ldrh	r3, [r3, #0]
 8009360:	0a1b      	lsrs	r3, r3, #8
 8009362:	b29b      	uxth	r3, r3
 8009364:	b2da      	uxtb	r2, r3
 8009366:	68fb      	ldr	r3, [r7, #12]
 8009368:	681b      	ldr	r3, [r3, #0]
 800936a:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800936c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800936e:	6a39      	ldr	r1, [r7, #32]
 8009370:	68fb      	ldr	r3, [r7, #12]
 8009372:	0018      	movs	r0, r3
 8009374:	f000 f881 	bl	800947a <I2C_WaitOnTXISFlagUntilTimeout>
 8009378:	1e03      	subs	r3, r0, #0
 800937a:	d001      	beq.n	8009380 <I2C_RequestMemoryRead+0x8c>
    {
      return HAL_ERROR;
 800937c:	2301      	movs	r3, #1
 800937e:	e014      	b.n	80093aa <I2C_RequestMemoryRead+0xb6>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8009380:	2308      	movs	r3, #8
 8009382:	18fb      	adds	r3, r7, r3
 8009384:	881b      	ldrh	r3, [r3, #0]
 8009386:	b2da      	uxtb	r2, r3
 8009388:	68fb      	ldr	r3, [r7, #12]
 800938a:	681b      	ldr	r3, [r3, #0]
 800938c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 800938e:	6a3a      	ldr	r2, [r7, #32]
 8009390:	68f8      	ldr	r0, [r7, #12]
 8009392:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009394:	9300      	str	r3, [sp, #0]
 8009396:	0013      	movs	r3, r2
 8009398:	2200      	movs	r2, #0
 800939a:	2140      	movs	r1, #64	; 0x40
 800939c:	f000 f82e 	bl	80093fc <I2C_WaitOnFlagUntilTimeout>
 80093a0:	1e03      	subs	r3, r0, #0
 80093a2:	d001      	beq.n	80093a8 <I2C_RequestMemoryRead+0xb4>
  {
    return HAL_ERROR;
 80093a4:	2301      	movs	r3, #1
 80093a6:	e000      	b.n	80093aa <I2C_RequestMemoryRead+0xb6>
  }

  return HAL_OK;
 80093a8:	2300      	movs	r3, #0
}
 80093aa:	0018      	movs	r0, r3
 80093ac:	46bd      	mov	sp, r7
 80093ae:	b004      	add	sp, #16
 80093b0:	bdb0      	pop	{r4, r5, r7, pc}
 80093b2:	46c0      	nop			; (mov r8, r8)
 80093b4:	80002000 	.word	0x80002000

080093b8 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 80093b8:	b580      	push	{r7, lr}
 80093ba:	b082      	sub	sp, #8
 80093bc:	af00      	add	r7, sp, #0
 80093be:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80093c0:	687b      	ldr	r3, [r7, #4]
 80093c2:	681b      	ldr	r3, [r3, #0]
 80093c4:	699b      	ldr	r3, [r3, #24]
 80093c6:	2202      	movs	r2, #2
 80093c8:	4013      	ands	r3, r2
 80093ca:	2b02      	cmp	r3, #2
 80093cc:	d103      	bne.n	80093d6 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 80093ce:	687b      	ldr	r3, [r7, #4]
 80093d0:	681b      	ldr	r3, [r3, #0]
 80093d2:	2200      	movs	r2, #0
 80093d4:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80093d6:	687b      	ldr	r3, [r7, #4]
 80093d8:	681b      	ldr	r3, [r3, #0]
 80093da:	699b      	ldr	r3, [r3, #24]
 80093dc:	2201      	movs	r2, #1
 80093de:	4013      	ands	r3, r2
 80093e0:	2b01      	cmp	r3, #1
 80093e2:	d007      	beq.n	80093f4 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80093e4:	687b      	ldr	r3, [r7, #4]
 80093e6:	681b      	ldr	r3, [r3, #0]
 80093e8:	699a      	ldr	r2, [r3, #24]
 80093ea:	687b      	ldr	r3, [r7, #4]
 80093ec:	681b      	ldr	r3, [r3, #0]
 80093ee:	2101      	movs	r1, #1
 80093f0:	430a      	orrs	r2, r1
 80093f2:	619a      	str	r2, [r3, #24]
  }
}
 80093f4:	46c0      	nop			; (mov r8, r8)
 80093f6:	46bd      	mov	sp, r7
 80093f8:	b002      	add	sp, #8
 80093fa:	bd80      	pop	{r7, pc}

080093fc <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 80093fc:	b580      	push	{r7, lr}
 80093fe:	b084      	sub	sp, #16
 8009400:	af00      	add	r7, sp, #0
 8009402:	60f8      	str	r0, [r7, #12]
 8009404:	60b9      	str	r1, [r7, #8]
 8009406:	603b      	str	r3, [r7, #0]
 8009408:	1dfb      	adds	r3, r7, #7
 800940a:	701a      	strb	r2, [r3, #0]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800940c:	e021      	b.n	8009452 <I2C_WaitOnFlagUntilTimeout+0x56>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800940e:	683b      	ldr	r3, [r7, #0]
 8009410:	3301      	adds	r3, #1
 8009412:	d01e      	beq.n	8009452 <I2C_WaitOnFlagUntilTimeout+0x56>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8009414:	f7fe f866 	bl	80074e4 <HAL_GetTick>
 8009418:	0002      	movs	r2, r0
 800941a:	69bb      	ldr	r3, [r7, #24]
 800941c:	1ad3      	subs	r3, r2, r3
 800941e:	683a      	ldr	r2, [r7, #0]
 8009420:	429a      	cmp	r2, r3
 8009422:	d302      	bcc.n	800942a <I2C_WaitOnFlagUntilTimeout+0x2e>
 8009424:	683b      	ldr	r3, [r7, #0]
 8009426:	2b00      	cmp	r3, #0
 8009428:	d113      	bne.n	8009452 <I2C_WaitOnFlagUntilTimeout+0x56>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800942a:	68fb      	ldr	r3, [r7, #12]
 800942c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800942e:	2220      	movs	r2, #32
 8009430:	431a      	orrs	r2, r3
 8009432:	68fb      	ldr	r3, [r7, #12]
 8009434:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8009436:	68fb      	ldr	r3, [r7, #12]
 8009438:	2241      	movs	r2, #65	; 0x41
 800943a:	2120      	movs	r1, #32
 800943c:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800943e:	68fb      	ldr	r3, [r7, #12]
 8009440:	2242      	movs	r2, #66	; 0x42
 8009442:	2100      	movs	r1, #0
 8009444:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8009446:	68fb      	ldr	r3, [r7, #12]
 8009448:	2240      	movs	r2, #64	; 0x40
 800944a:	2100      	movs	r1, #0
 800944c:	5499      	strb	r1, [r3, r2]
        return HAL_ERROR;
 800944e:	2301      	movs	r3, #1
 8009450:	e00f      	b.n	8009472 <I2C_WaitOnFlagUntilTimeout+0x76>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8009452:	68fb      	ldr	r3, [r7, #12]
 8009454:	681b      	ldr	r3, [r3, #0]
 8009456:	699b      	ldr	r3, [r3, #24]
 8009458:	68ba      	ldr	r2, [r7, #8]
 800945a:	4013      	ands	r3, r2
 800945c:	68ba      	ldr	r2, [r7, #8]
 800945e:	1ad3      	subs	r3, r2, r3
 8009460:	425a      	negs	r2, r3
 8009462:	4153      	adcs	r3, r2
 8009464:	b2db      	uxtb	r3, r3
 8009466:	001a      	movs	r2, r3
 8009468:	1dfb      	adds	r3, r7, #7
 800946a:	781b      	ldrb	r3, [r3, #0]
 800946c:	429a      	cmp	r2, r3
 800946e:	d0ce      	beq.n	800940e <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8009470:	2300      	movs	r3, #0
}
 8009472:	0018      	movs	r0, r3
 8009474:	46bd      	mov	sp, r7
 8009476:	b004      	add	sp, #16
 8009478:	bd80      	pop	{r7, pc}

0800947a <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800947a:	b580      	push	{r7, lr}
 800947c:	b084      	sub	sp, #16
 800947e:	af00      	add	r7, sp, #0
 8009480:	60f8      	str	r0, [r7, #12]
 8009482:	60b9      	str	r1, [r7, #8]
 8009484:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8009486:	e02b      	b.n	80094e0 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8009488:	687a      	ldr	r2, [r7, #4]
 800948a:	68b9      	ldr	r1, [r7, #8]
 800948c:	68fb      	ldr	r3, [r7, #12]
 800948e:	0018      	movs	r0, r3
 8009490:	f000 f86e 	bl	8009570 <I2C_IsAcknowledgeFailed>
 8009494:	1e03      	subs	r3, r0, #0
 8009496:	d001      	beq.n	800949c <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8009498:	2301      	movs	r3, #1
 800949a:	e029      	b.n	80094f0 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800949c:	68bb      	ldr	r3, [r7, #8]
 800949e:	3301      	adds	r3, #1
 80094a0:	d01e      	beq.n	80094e0 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80094a2:	f7fe f81f 	bl	80074e4 <HAL_GetTick>
 80094a6:	0002      	movs	r2, r0
 80094a8:	687b      	ldr	r3, [r7, #4]
 80094aa:	1ad3      	subs	r3, r2, r3
 80094ac:	68ba      	ldr	r2, [r7, #8]
 80094ae:	429a      	cmp	r2, r3
 80094b0:	d302      	bcc.n	80094b8 <I2C_WaitOnTXISFlagUntilTimeout+0x3e>
 80094b2:	68bb      	ldr	r3, [r7, #8]
 80094b4:	2b00      	cmp	r3, #0
 80094b6:	d113      	bne.n	80094e0 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80094b8:	68fb      	ldr	r3, [r7, #12]
 80094ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80094bc:	2220      	movs	r2, #32
 80094be:	431a      	orrs	r2, r3
 80094c0:	68fb      	ldr	r3, [r7, #12]
 80094c2:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80094c4:	68fb      	ldr	r3, [r7, #12]
 80094c6:	2241      	movs	r2, #65	; 0x41
 80094c8:	2120      	movs	r1, #32
 80094ca:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80094cc:	68fb      	ldr	r3, [r7, #12]
 80094ce:	2242      	movs	r2, #66	; 0x42
 80094d0:	2100      	movs	r1, #0
 80094d2:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80094d4:	68fb      	ldr	r3, [r7, #12]
 80094d6:	2240      	movs	r2, #64	; 0x40
 80094d8:	2100      	movs	r1, #0
 80094da:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
 80094dc:	2301      	movs	r3, #1
 80094de:	e007      	b.n	80094f0 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 80094e0:	68fb      	ldr	r3, [r7, #12]
 80094e2:	681b      	ldr	r3, [r3, #0]
 80094e4:	699b      	ldr	r3, [r3, #24]
 80094e6:	2202      	movs	r2, #2
 80094e8:	4013      	ands	r3, r2
 80094ea:	2b02      	cmp	r3, #2
 80094ec:	d1cc      	bne.n	8009488 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 80094ee:	2300      	movs	r3, #0
}
 80094f0:	0018      	movs	r0, r3
 80094f2:	46bd      	mov	sp, r7
 80094f4:	b004      	add	sp, #16
 80094f6:	bd80      	pop	{r7, pc}

080094f8 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 80094f8:	b580      	push	{r7, lr}
 80094fa:	b084      	sub	sp, #16
 80094fc:	af00      	add	r7, sp, #0
 80094fe:	60f8      	str	r0, [r7, #12]
 8009500:	60b9      	str	r1, [r7, #8]
 8009502:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8009504:	e028      	b.n	8009558 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8009506:	687a      	ldr	r2, [r7, #4]
 8009508:	68b9      	ldr	r1, [r7, #8]
 800950a:	68fb      	ldr	r3, [r7, #12]
 800950c:	0018      	movs	r0, r3
 800950e:	f000 f82f 	bl	8009570 <I2C_IsAcknowledgeFailed>
 8009512:	1e03      	subs	r3, r0, #0
 8009514:	d001      	beq.n	800951a <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8009516:	2301      	movs	r3, #1
 8009518:	e026      	b.n	8009568 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800951a:	f7fd ffe3 	bl	80074e4 <HAL_GetTick>
 800951e:	0002      	movs	r2, r0
 8009520:	687b      	ldr	r3, [r7, #4]
 8009522:	1ad3      	subs	r3, r2, r3
 8009524:	68ba      	ldr	r2, [r7, #8]
 8009526:	429a      	cmp	r2, r3
 8009528:	d302      	bcc.n	8009530 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 800952a:	68bb      	ldr	r3, [r7, #8]
 800952c:	2b00      	cmp	r3, #0
 800952e:	d113      	bne.n	8009558 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8009530:	68fb      	ldr	r3, [r7, #12]
 8009532:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009534:	2220      	movs	r2, #32
 8009536:	431a      	orrs	r2, r3
 8009538:	68fb      	ldr	r3, [r7, #12]
 800953a:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800953c:	68fb      	ldr	r3, [r7, #12]
 800953e:	2241      	movs	r2, #65	; 0x41
 8009540:	2120      	movs	r1, #32
 8009542:	5499      	strb	r1, [r3, r2]
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8009544:	68fb      	ldr	r3, [r7, #12]
 8009546:	2242      	movs	r2, #66	; 0x42
 8009548:	2100      	movs	r1, #0
 800954a:	5499      	strb	r1, [r3, r2]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800954c:	68fb      	ldr	r3, [r7, #12]
 800954e:	2240      	movs	r2, #64	; 0x40
 8009550:	2100      	movs	r1, #0
 8009552:	5499      	strb	r1, [r3, r2]

      return HAL_ERROR;
 8009554:	2301      	movs	r3, #1
 8009556:	e007      	b.n	8009568 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8009558:	68fb      	ldr	r3, [r7, #12]
 800955a:	681b      	ldr	r3, [r3, #0]
 800955c:	699b      	ldr	r3, [r3, #24]
 800955e:	2220      	movs	r2, #32
 8009560:	4013      	ands	r3, r2
 8009562:	2b20      	cmp	r3, #32
 8009564:	d1cf      	bne.n	8009506 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 8009566:	2300      	movs	r3, #0
}
 8009568:	0018      	movs	r0, r3
 800956a:	46bd      	mov	sp, r7
 800956c:	b004      	add	sp, #16
 800956e:	bd80      	pop	{r7, pc}

08009570 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8009570:	b580      	push	{r7, lr}
 8009572:	b084      	sub	sp, #16
 8009574:	af00      	add	r7, sp, #0
 8009576:	60f8      	str	r0, [r7, #12]
 8009578:	60b9      	str	r1, [r7, #8]
 800957a:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800957c:	68fb      	ldr	r3, [r7, #12]
 800957e:	681b      	ldr	r3, [r3, #0]
 8009580:	699b      	ldr	r3, [r3, #24]
 8009582:	2210      	movs	r2, #16
 8009584:	4013      	ands	r3, r2
 8009586:	2b10      	cmp	r3, #16
 8009588:	d151      	bne.n	800962e <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800958a:	e021      	b.n	80095d0 <I2C_IsAcknowledgeFailed+0x60>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 800958c:	68bb      	ldr	r3, [r7, #8]
 800958e:	3301      	adds	r3, #1
 8009590:	d01e      	beq.n	80095d0 <I2C_IsAcknowledgeFailed+0x60>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8009592:	f7fd ffa7 	bl	80074e4 <HAL_GetTick>
 8009596:	0002      	movs	r2, r0
 8009598:	687b      	ldr	r3, [r7, #4]
 800959a:	1ad3      	subs	r3, r2, r3
 800959c:	68ba      	ldr	r2, [r7, #8]
 800959e:	429a      	cmp	r2, r3
 80095a0:	d302      	bcc.n	80095a8 <I2C_IsAcknowledgeFailed+0x38>
 80095a2:	68bb      	ldr	r3, [r7, #8]
 80095a4:	2b00      	cmp	r3, #0
 80095a6:	d113      	bne.n	80095d0 <I2C_IsAcknowledgeFailed+0x60>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80095a8:	68fb      	ldr	r3, [r7, #12]
 80095aa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80095ac:	2220      	movs	r2, #32
 80095ae:	431a      	orrs	r2, r3
 80095b0:	68fb      	ldr	r3, [r7, #12]
 80095b2:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 80095b4:	68fb      	ldr	r3, [r7, #12]
 80095b6:	2241      	movs	r2, #65	; 0x41
 80095b8:	2120      	movs	r1, #32
 80095ba:	5499      	strb	r1, [r3, r2]
          hi2c->Mode = HAL_I2C_MODE_NONE;
 80095bc:	68fb      	ldr	r3, [r7, #12]
 80095be:	2242      	movs	r2, #66	; 0x42
 80095c0:	2100      	movs	r1, #0
 80095c2:	5499      	strb	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 80095c4:	68fb      	ldr	r3, [r7, #12]
 80095c6:	2240      	movs	r2, #64	; 0x40
 80095c8:	2100      	movs	r1, #0
 80095ca:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
 80095cc:	2301      	movs	r3, #1
 80095ce:	e02f      	b.n	8009630 <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80095d0:	68fb      	ldr	r3, [r7, #12]
 80095d2:	681b      	ldr	r3, [r3, #0]
 80095d4:	699b      	ldr	r3, [r3, #24]
 80095d6:	2220      	movs	r2, #32
 80095d8:	4013      	ands	r3, r2
 80095da:	2b20      	cmp	r3, #32
 80095dc:	d1d6      	bne.n	800958c <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80095de:	68fb      	ldr	r3, [r7, #12]
 80095e0:	681b      	ldr	r3, [r3, #0]
 80095e2:	2210      	movs	r2, #16
 80095e4:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80095e6:	68fb      	ldr	r3, [r7, #12]
 80095e8:	681b      	ldr	r3, [r3, #0]
 80095ea:	2220      	movs	r2, #32
 80095ec:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 80095ee:	68fb      	ldr	r3, [r7, #12]
 80095f0:	0018      	movs	r0, r3
 80095f2:	f7ff fee1 	bl	80093b8 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80095f6:	68fb      	ldr	r3, [r7, #12]
 80095f8:	681b      	ldr	r3, [r3, #0]
 80095fa:	685a      	ldr	r2, [r3, #4]
 80095fc:	68fb      	ldr	r3, [r7, #12]
 80095fe:	681b      	ldr	r3, [r3, #0]
 8009600:	490d      	ldr	r1, [pc, #52]	; (8009638 <I2C_IsAcknowledgeFailed+0xc8>)
 8009602:	400a      	ands	r2, r1
 8009604:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8009606:	68fb      	ldr	r3, [r7, #12]
 8009608:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800960a:	2204      	movs	r2, #4
 800960c:	431a      	orrs	r2, r3
 800960e:	68fb      	ldr	r3, [r7, #12]
 8009610:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8009612:	68fb      	ldr	r3, [r7, #12]
 8009614:	2241      	movs	r2, #65	; 0x41
 8009616:	2120      	movs	r1, #32
 8009618:	5499      	strb	r1, [r3, r2]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800961a:	68fb      	ldr	r3, [r7, #12]
 800961c:	2242      	movs	r2, #66	; 0x42
 800961e:	2100      	movs	r1, #0
 8009620:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8009622:	68fb      	ldr	r3, [r7, #12]
 8009624:	2240      	movs	r2, #64	; 0x40
 8009626:	2100      	movs	r1, #0
 8009628:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 800962a:	2301      	movs	r3, #1
 800962c:	e000      	b.n	8009630 <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
 800962e:	2300      	movs	r3, #0
}
 8009630:	0018      	movs	r0, r3
 8009632:	46bd      	mov	sp, r7
 8009634:	b004      	add	sp, #16
 8009636:	bd80      	pop	{r7, pc}
 8009638:	fe00e800 	.word	0xfe00e800

0800963c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 800963c:	b580      	push	{r7, lr}
 800963e:	b084      	sub	sp, #16
 8009640:	af00      	add	r7, sp, #0
 8009642:	60f8      	str	r0, [r7, #12]
 8009644:	0008      	movs	r0, r1
 8009646:	0011      	movs	r1, r2
 8009648:	607b      	str	r3, [r7, #4]
 800964a:	230a      	movs	r3, #10
 800964c:	18fb      	adds	r3, r7, r3
 800964e:	1c02      	adds	r2, r0, #0
 8009650:	801a      	strh	r2, [r3, #0]
 8009652:	2309      	movs	r3, #9
 8009654:	18fb      	adds	r3, r7, r3
 8009656:	1c0a      	adds	r2, r1, #0
 8009658:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800965a:	68fb      	ldr	r3, [r7, #12]
 800965c:	681b      	ldr	r3, [r3, #0]
 800965e:	4a30      	ldr	r2, [pc, #192]	; (8009720 <I2C_TransferConfig+0xe4>)
 8009660:	4293      	cmp	r3, r2
 8009662:	d00f      	beq.n	8009684 <I2C_TransferConfig+0x48>
 8009664:	68fb      	ldr	r3, [r7, #12]
 8009666:	681b      	ldr	r3, [r3, #0]
 8009668:	4a2e      	ldr	r2, [pc, #184]	; (8009724 <I2C_TransferConfig+0xe8>)
 800966a:	4293      	cmp	r3, r2
 800966c:	d00a      	beq.n	8009684 <I2C_TransferConfig+0x48>
 800966e:	68fb      	ldr	r3, [r7, #12]
 8009670:	681b      	ldr	r3, [r3, #0]
 8009672:	4a2d      	ldr	r2, [pc, #180]	; (8009728 <I2C_TransferConfig+0xec>)
 8009674:	4293      	cmp	r3, r2
 8009676:	d005      	beq.n	8009684 <I2C_TransferConfig+0x48>
 8009678:	4a2c      	ldr	r2, [pc, #176]	; (800972c <I2C_TransferConfig+0xf0>)
 800967a:	4b2d      	ldr	r3, [pc, #180]	; (8009730 <I2C_TransferConfig+0xf4>)
 800967c:	0011      	movs	r1, r2
 800967e:	0018      	movs	r0, r3
 8009680:	f7fc fe09 	bl	8006296 <assert_failed>
  assert_param(IS_TRANSFER_MODE(Mode));
 8009684:	687a      	ldr	r2, [r7, #4]
 8009686:	2380      	movs	r3, #128	; 0x80
 8009688:	045b      	lsls	r3, r3, #17
 800968a:	429a      	cmp	r2, r3
 800968c:	d00d      	beq.n	80096aa <I2C_TransferConfig+0x6e>
 800968e:	687a      	ldr	r2, [r7, #4]
 8009690:	2380      	movs	r3, #128	; 0x80
 8009692:	049b      	lsls	r3, r3, #18
 8009694:	429a      	cmp	r2, r3
 8009696:	d008      	beq.n	80096aa <I2C_TransferConfig+0x6e>
 8009698:	687b      	ldr	r3, [r7, #4]
 800969a:	2b00      	cmp	r3, #0
 800969c:	d005      	beq.n	80096aa <I2C_TransferConfig+0x6e>
 800969e:	4a25      	ldr	r2, [pc, #148]	; (8009734 <I2C_TransferConfig+0xf8>)
 80096a0:	4b23      	ldr	r3, [pc, #140]	; (8009730 <I2C_TransferConfig+0xf4>)
 80096a2:	0011      	movs	r1, r2
 80096a4:	0018      	movs	r0, r3
 80096a6:	f7fc fdf6 	bl	8006296 <assert_failed>
  assert_param(IS_TRANSFER_REQUEST(Request));
 80096aa:	69bb      	ldr	r3, [r7, #24]
 80096ac:	4a22      	ldr	r2, [pc, #136]	; (8009738 <I2C_TransferConfig+0xfc>)
 80096ae:	4293      	cmp	r3, r2
 80096b0:	d010      	beq.n	80096d4 <I2C_TransferConfig+0x98>
 80096b2:	69bb      	ldr	r3, [r7, #24]
 80096b4:	4a21      	ldr	r2, [pc, #132]	; (800973c <I2C_TransferConfig+0x100>)
 80096b6:	4293      	cmp	r3, r2
 80096b8:	d00c      	beq.n	80096d4 <I2C_TransferConfig+0x98>
 80096ba:	69bb      	ldr	r3, [r7, #24]
 80096bc:	4a20      	ldr	r2, [pc, #128]	; (8009740 <I2C_TransferConfig+0x104>)
 80096be:	4293      	cmp	r3, r2
 80096c0:	d008      	beq.n	80096d4 <I2C_TransferConfig+0x98>
 80096c2:	69bb      	ldr	r3, [r7, #24]
 80096c4:	2b00      	cmp	r3, #0
 80096c6:	d005      	beq.n	80096d4 <I2C_TransferConfig+0x98>
 80096c8:	4a1e      	ldr	r2, [pc, #120]	; (8009744 <I2C_TransferConfig+0x108>)
 80096ca:	4b19      	ldr	r3, [pc, #100]	; (8009730 <I2C_TransferConfig+0xf4>)
 80096cc:	0011      	movs	r1, r2
 80096ce:	0018      	movs	r0, r3
 80096d0:	f7fc fde1 	bl	8006296 <assert_failed>

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
 80096d4:	68fb      	ldr	r3, [r7, #12]
 80096d6:	681b      	ldr	r3, [r3, #0]
 80096d8:	685b      	ldr	r3, [r3, #4]
 80096da:	69ba      	ldr	r2, [r7, #24]
 80096dc:	0d51      	lsrs	r1, r2, #21
 80096de:	2280      	movs	r2, #128	; 0x80
 80096e0:	00d2      	lsls	r2, r2, #3
 80096e2:	400a      	ands	r2, r1
 80096e4:	4918      	ldr	r1, [pc, #96]	; (8009748 <I2C_TransferConfig+0x10c>)
 80096e6:	430a      	orrs	r2, r1
 80096e8:	43d2      	mvns	r2, r2
 80096ea:	401a      	ands	r2, r3
 80096ec:	0011      	movs	r1, r2
 80096ee:	230a      	movs	r3, #10
 80096f0:	18fb      	adds	r3, r7, r3
 80096f2:	881b      	ldrh	r3, [r3, #0]
 80096f4:	059b      	lsls	r3, r3, #22
 80096f6:	0d9a      	lsrs	r2, r3, #22
 80096f8:	2309      	movs	r3, #9
 80096fa:	18fb      	adds	r3, r7, r3
 80096fc:	781b      	ldrb	r3, [r3, #0]
 80096fe:	0418      	lsls	r0, r3, #16
 8009700:	23ff      	movs	r3, #255	; 0xff
 8009702:	041b      	lsls	r3, r3, #16
 8009704:	4003      	ands	r3, r0
 8009706:	431a      	orrs	r2, r3
 8009708:	687b      	ldr	r3, [r7, #4]
 800970a:	431a      	orrs	r2, r3
 800970c:	69bb      	ldr	r3, [r7, #24]
 800970e:	431a      	orrs	r2, r3
 8009710:	68fb      	ldr	r3, [r7, #12]
 8009712:	681b      	ldr	r3, [r3, #0]
 8009714:	430a      	orrs	r2, r1
 8009716:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) |
                        (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 8009718:	46c0      	nop			; (mov r8, r8)
 800971a:	46bd      	mov	sp, r7
 800971c:	b004      	add	sp, #16
 800971e:	bd80      	pop	{r7, pc}
 8009720:	40005400 	.word	0x40005400
 8009724:	40005800 	.word	0x40005800
 8009728:	40007800 	.word	0x40007800
 800972c:	00001939 	.word	0x00001939
 8009730:	0800ddec 	.word	0x0800ddec
 8009734:	0000193a 	.word	0x0000193a
 8009738:	80004000 	.word	0x80004000
 800973c:	80002400 	.word	0x80002400
 8009740:	80002000 	.word	0x80002000
 8009744:	0000193b 	.word	0x0000193b
 8009748:	03ff63ff 	.word	0x03ff63ff

0800974c <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 800974c:	b580      	push	{r7, lr}
 800974e:	b082      	sub	sp, #8
 8009750:	af00      	add	r7, sp, #0
 8009752:	6078      	str	r0, [r7, #4]
 8009754:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8009756:	687b      	ldr	r3, [r7, #4]
 8009758:	681b      	ldr	r3, [r3, #0]
 800975a:	4a31      	ldr	r2, [pc, #196]	; (8009820 <HAL_I2CEx_ConfigAnalogFilter+0xd4>)
 800975c:	4293      	cmp	r3, r2
 800975e:	d00e      	beq.n	800977e <HAL_I2CEx_ConfigAnalogFilter+0x32>
 8009760:	687b      	ldr	r3, [r7, #4]
 8009762:	681b      	ldr	r3, [r3, #0]
 8009764:	4a2f      	ldr	r2, [pc, #188]	; (8009824 <HAL_I2CEx_ConfigAnalogFilter+0xd8>)
 8009766:	4293      	cmp	r3, r2
 8009768:	d009      	beq.n	800977e <HAL_I2CEx_ConfigAnalogFilter+0x32>
 800976a:	687b      	ldr	r3, [r7, #4]
 800976c:	681b      	ldr	r3, [r3, #0]
 800976e:	4a2e      	ldr	r2, [pc, #184]	; (8009828 <HAL_I2CEx_ConfigAnalogFilter+0xdc>)
 8009770:	4293      	cmp	r3, r2
 8009772:	d004      	beq.n	800977e <HAL_I2CEx_ConfigAnalogFilter+0x32>
 8009774:	4b2d      	ldr	r3, [pc, #180]	; (800982c <HAL_I2CEx_ConfigAnalogFilter+0xe0>)
 8009776:	2164      	movs	r1, #100	; 0x64
 8009778:	0018      	movs	r0, r3
 800977a:	f7fc fd8c 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
 800977e:	683b      	ldr	r3, [r7, #0]
 8009780:	2b00      	cmp	r3, #0
 8009782:	d009      	beq.n	8009798 <HAL_I2CEx_ConfigAnalogFilter+0x4c>
 8009784:	683a      	ldr	r2, [r7, #0]
 8009786:	2380      	movs	r3, #128	; 0x80
 8009788:	015b      	lsls	r3, r3, #5
 800978a:	429a      	cmp	r2, r3
 800978c:	d004      	beq.n	8009798 <HAL_I2CEx_ConfigAnalogFilter+0x4c>
 800978e:	4b27      	ldr	r3, [pc, #156]	; (800982c <HAL_I2CEx_ConfigAnalogFilter+0xe0>)
 8009790:	2165      	movs	r1, #101	; 0x65
 8009792:	0018      	movs	r0, r3
 8009794:	f7fc fd7f 	bl	8006296 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8009798:	687b      	ldr	r3, [r7, #4]
 800979a:	2241      	movs	r2, #65	; 0x41
 800979c:	5c9b      	ldrb	r3, [r3, r2]
 800979e:	b2db      	uxtb	r3, r3
 80097a0:	2b20      	cmp	r3, #32
 80097a2:	d138      	bne.n	8009816 <HAL_I2CEx_ConfigAnalogFilter+0xca>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80097a4:	687b      	ldr	r3, [r7, #4]
 80097a6:	2240      	movs	r2, #64	; 0x40
 80097a8:	5c9b      	ldrb	r3, [r3, r2]
 80097aa:	2b01      	cmp	r3, #1
 80097ac:	d101      	bne.n	80097b2 <HAL_I2CEx_ConfigAnalogFilter+0x66>
 80097ae:	2302      	movs	r3, #2
 80097b0:	e032      	b.n	8009818 <HAL_I2CEx_ConfigAnalogFilter+0xcc>
 80097b2:	687b      	ldr	r3, [r7, #4]
 80097b4:	2240      	movs	r2, #64	; 0x40
 80097b6:	2101      	movs	r1, #1
 80097b8:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
 80097ba:	687b      	ldr	r3, [r7, #4]
 80097bc:	2241      	movs	r2, #65	; 0x41
 80097be:	2124      	movs	r1, #36	; 0x24
 80097c0:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80097c2:	687b      	ldr	r3, [r7, #4]
 80097c4:	681b      	ldr	r3, [r3, #0]
 80097c6:	681a      	ldr	r2, [r3, #0]
 80097c8:	687b      	ldr	r3, [r7, #4]
 80097ca:	681b      	ldr	r3, [r3, #0]
 80097cc:	2101      	movs	r1, #1
 80097ce:	438a      	bics	r2, r1
 80097d0:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 80097d2:	687b      	ldr	r3, [r7, #4]
 80097d4:	681b      	ldr	r3, [r3, #0]
 80097d6:	681a      	ldr	r2, [r3, #0]
 80097d8:	687b      	ldr	r3, [r7, #4]
 80097da:	681b      	ldr	r3, [r3, #0]
 80097dc:	4914      	ldr	r1, [pc, #80]	; (8009830 <HAL_I2CEx_ConfigAnalogFilter+0xe4>)
 80097de:	400a      	ands	r2, r1
 80097e0:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 80097e2:	687b      	ldr	r3, [r7, #4]
 80097e4:	681b      	ldr	r3, [r3, #0]
 80097e6:	6819      	ldr	r1, [r3, #0]
 80097e8:	687b      	ldr	r3, [r7, #4]
 80097ea:	681b      	ldr	r3, [r3, #0]
 80097ec:	683a      	ldr	r2, [r7, #0]
 80097ee:	430a      	orrs	r2, r1
 80097f0:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 80097f2:	687b      	ldr	r3, [r7, #4]
 80097f4:	681b      	ldr	r3, [r3, #0]
 80097f6:	681a      	ldr	r2, [r3, #0]
 80097f8:	687b      	ldr	r3, [r7, #4]
 80097fa:	681b      	ldr	r3, [r3, #0]
 80097fc:	2101      	movs	r1, #1
 80097fe:	430a      	orrs	r2, r1
 8009800:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8009802:	687b      	ldr	r3, [r7, #4]
 8009804:	2241      	movs	r2, #65	; 0x41
 8009806:	2120      	movs	r1, #32
 8009808:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800980a:	687b      	ldr	r3, [r7, #4]
 800980c:	2240      	movs	r2, #64	; 0x40
 800980e:	2100      	movs	r1, #0
 8009810:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 8009812:	2300      	movs	r3, #0
 8009814:	e000      	b.n	8009818 <HAL_I2CEx_ConfigAnalogFilter+0xcc>
  }
  else
  {
    return HAL_BUSY;
 8009816:	2302      	movs	r3, #2
  }
}
 8009818:	0018      	movs	r0, r3
 800981a:	46bd      	mov	sp, r7
 800981c:	b002      	add	sp, #8
 800981e:	bd80      	pop	{r7, pc}
 8009820:	40005400 	.word	0x40005400
 8009824:	40005800 	.word	0x40005800
 8009828:	40007800 	.word	0x40007800
 800982c:	0800de24 	.word	0x0800de24
 8009830:	ffffefff 	.word	0xffffefff

08009834 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8009834:	b580      	push	{r7, lr}
 8009836:	b084      	sub	sp, #16
 8009838:	af00      	add	r7, sp, #0
 800983a:	6078      	str	r0, [r7, #4]
 800983c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800983e:	687b      	ldr	r3, [r7, #4]
 8009840:	681b      	ldr	r3, [r3, #0]
 8009842:	4a2f      	ldr	r2, [pc, #188]	; (8009900 <HAL_I2CEx_ConfigDigitalFilter+0xcc>)
 8009844:	4293      	cmp	r3, r2
 8009846:	d00e      	beq.n	8009866 <HAL_I2CEx_ConfigDigitalFilter+0x32>
 8009848:	687b      	ldr	r3, [r7, #4]
 800984a:	681b      	ldr	r3, [r3, #0]
 800984c:	4a2d      	ldr	r2, [pc, #180]	; (8009904 <HAL_I2CEx_ConfigDigitalFilter+0xd0>)
 800984e:	4293      	cmp	r3, r2
 8009850:	d009      	beq.n	8009866 <HAL_I2CEx_ConfigDigitalFilter+0x32>
 8009852:	687b      	ldr	r3, [r7, #4]
 8009854:	681b      	ldr	r3, [r3, #0]
 8009856:	4a2c      	ldr	r2, [pc, #176]	; (8009908 <HAL_I2CEx_ConfigDigitalFilter+0xd4>)
 8009858:	4293      	cmp	r3, r2
 800985a:	d004      	beq.n	8009866 <HAL_I2CEx_ConfigDigitalFilter+0x32>
 800985c:	4b2b      	ldr	r3, [pc, #172]	; (800990c <HAL_I2CEx_ConfigDigitalFilter+0xd8>)
 800985e:	2192      	movs	r1, #146	; 0x92
 8009860:	0018      	movs	r0, r3
 8009862:	f7fc fd18 	bl	8006296 <assert_failed>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
 8009866:	683b      	ldr	r3, [r7, #0]
 8009868:	2b0f      	cmp	r3, #15
 800986a:	d904      	bls.n	8009876 <HAL_I2CEx_ConfigDigitalFilter+0x42>
 800986c:	4b27      	ldr	r3, [pc, #156]	; (800990c <HAL_I2CEx_ConfigDigitalFilter+0xd8>)
 800986e:	2193      	movs	r1, #147	; 0x93
 8009870:	0018      	movs	r0, r3
 8009872:	f7fc fd10 	bl	8006296 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8009876:	687b      	ldr	r3, [r7, #4]
 8009878:	2241      	movs	r2, #65	; 0x41
 800987a:	5c9b      	ldrb	r3, [r3, r2]
 800987c:	b2db      	uxtb	r3, r3
 800987e:	2b20      	cmp	r3, #32
 8009880:	d139      	bne.n	80098f6 <HAL_I2CEx_ConfigDigitalFilter+0xc2>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8009882:	687b      	ldr	r3, [r7, #4]
 8009884:	2240      	movs	r2, #64	; 0x40
 8009886:	5c9b      	ldrb	r3, [r3, r2]
 8009888:	2b01      	cmp	r3, #1
 800988a:	d101      	bne.n	8009890 <HAL_I2CEx_ConfigDigitalFilter+0x5c>
 800988c:	2302      	movs	r3, #2
 800988e:	e033      	b.n	80098f8 <HAL_I2CEx_ConfigDigitalFilter+0xc4>
 8009890:	687b      	ldr	r3, [r7, #4]
 8009892:	2240      	movs	r2, #64	; 0x40
 8009894:	2101      	movs	r1, #1
 8009896:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
 8009898:	687b      	ldr	r3, [r7, #4]
 800989a:	2241      	movs	r2, #65	; 0x41
 800989c:	2124      	movs	r1, #36	; 0x24
 800989e:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80098a0:	687b      	ldr	r3, [r7, #4]
 80098a2:	681b      	ldr	r3, [r3, #0]
 80098a4:	681a      	ldr	r2, [r3, #0]
 80098a6:	687b      	ldr	r3, [r7, #4]
 80098a8:	681b      	ldr	r3, [r3, #0]
 80098aa:	2101      	movs	r1, #1
 80098ac:	438a      	bics	r2, r1
 80098ae:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 80098b0:	687b      	ldr	r3, [r7, #4]
 80098b2:	681b      	ldr	r3, [r3, #0]
 80098b4:	681b      	ldr	r3, [r3, #0]
 80098b6:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 80098b8:	68fb      	ldr	r3, [r7, #12]
 80098ba:	4a15      	ldr	r2, [pc, #84]	; (8009910 <HAL_I2CEx_ConfigDigitalFilter+0xdc>)
 80098bc:	4013      	ands	r3, r2
 80098be:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 80098c0:	683b      	ldr	r3, [r7, #0]
 80098c2:	021b      	lsls	r3, r3, #8
 80098c4:	68fa      	ldr	r2, [r7, #12]
 80098c6:	4313      	orrs	r3, r2
 80098c8:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 80098ca:	687b      	ldr	r3, [r7, #4]
 80098cc:	681b      	ldr	r3, [r3, #0]
 80098ce:	68fa      	ldr	r2, [r7, #12]
 80098d0:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 80098d2:	687b      	ldr	r3, [r7, #4]
 80098d4:	681b      	ldr	r3, [r3, #0]
 80098d6:	681a      	ldr	r2, [r3, #0]
 80098d8:	687b      	ldr	r3, [r7, #4]
 80098da:	681b      	ldr	r3, [r3, #0]
 80098dc:	2101      	movs	r1, #1
 80098de:	430a      	orrs	r2, r1
 80098e0:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 80098e2:	687b      	ldr	r3, [r7, #4]
 80098e4:	2241      	movs	r2, #65	; 0x41
 80098e6:	2120      	movs	r1, #32
 80098e8:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80098ea:	687b      	ldr	r3, [r7, #4]
 80098ec:	2240      	movs	r2, #64	; 0x40
 80098ee:	2100      	movs	r1, #0
 80098f0:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 80098f2:	2300      	movs	r3, #0
 80098f4:	e000      	b.n	80098f8 <HAL_I2CEx_ConfigDigitalFilter+0xc4>
  }
  else
  {
    return HAL_BUSY;
 80098f6:	2302      	movs	r3, #2
  }
}
 80098f8:	0018      	movs	r0, r3
 80098fa:	46bd      	mov	sp, r7
 80098fc:	b004      	add	sp, #16
 80098fe:	bd80      	pop	{r7, pc}
 8009900:	40005400 	.word	0x40005400
 8009904:	40005800 	.word	0x40005800
 8009908:	40007800 	.word	0x40007800
 800990c:	0800de24 	.word	0x0800de24
 8009910:	fffff0ff 	.word	0xfffff0ff

08009914 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8009914:	b5b0      	push	{r4, r5, r7, lr}
 8009916:	b08a      	sub	sp, #40	; 0x28
 8009918:	af00      	add	r7, sp, #0
 800991a:	6078      	str	r0, [r7, #4]
  uint32_t hsi_state;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800991c:	687b      	ldr	r3, [r7, #4]
 800991e:	2b00      	cmp	r3, #0
 8009920:	d102      	bne.n	8009928 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 8009922:	2301      	movs	r3, #1
 8009924:	f000 fd81 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8009928:	687b      	ldr	r3, [r7, #4]
 800992a:	681b      	ldr	r3, [r3, #0]
 800992c:	2b00      	cmp	r3, #0
 800992e:	d024      	beq.n	800997a <HAL_RCC_OscConfig+0x66>
 8009930:	687b      	ldr	r3, [r7, #4]
 8009932:	681b      	ldr	r3, [r3, #0]
 8009934:	2201      	movs	r2, #1
 8009936:	4013      	ands	r3, r2
 8009938:	d11f      	bne.n	800997a <HAL_RCC_OscConfig+0x66>
 800993a:	687b      	ldr	r3, [r7, #4]
 800993c:	681b      	ldr	r3, [r3, #0]
 800993e:	2202      	movs	r2, #2
 8009940:	4013      	ands	r3, r2
 8009942:	d11a      	bne.n	800997a <HAL_RCC_OscConfig+0x66>
 8009944:	687b      	ldr	r3, [r7, #4]
 8009946:	681b      	ldr	r3, [r3, #0]
 8009948:	2220      	movs	r2, #32
 800994a:	4013      	ands	r3, r2
 800994c:	d115      	bne.n	800997a <HAL_RCC_OscConfig+0x66>
 800994e:	687b      	ldr	r3, [r7, #4]
 8009950:	681b      	ldr	r3, [r3, #0]
 8009952:	2208      	movs	r2, #8
 8009954:	4013      	ands	r3, r2
 8009956:	d110      	bne.n	800997a <HAL_RCC_OscConfig+0x66>
 8009958:	687b      	ldr	r3, [r7, #4]
 800995a:	681b      	ldr	r3, [r3, #0]
 800995c:	2204      	movs	r2, #4
 800995e:	4013      	ands	r3, r2
 8009960:	d10b      	bne.n	800997a <HAL_RCC_OscConfig+0x66>
 8009962:	687b      	ldr	r3, [r7, #4]
 8009964:	681b      	ldr	r3, [r3, #0]
 8009966:	2210      	movs	r2, #16
 8009968:	4013      	ands	r3, r2
 800996a:	d106      	bne.n	800997a <HAL_RCC_OscConfig+0x66>
 800996c:	23b0      	movs	r3, #176	; 0xb0
 800996e:	005a      	lsls	r2, r3, #1
 8009970:	4bc9      	ldr	r3, [pc, #804]	; (8009c98 <HAL_RCC_OscConfig+0x384>)
 8009972:	0011      	movs	r1, r2
 8009974:	0018      	movs	r0, r3
 8009976:	f7fc fc8e 	bl	8006296 <assert_failed>

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800997a:	4bc8      	ldr	r3, [pc, #800]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 800997c:	68db      	ldr	r3, [r3, #12]
 800997e:	220c      	movs	r2, #12
 8009980:	4013      	ands	r3, r2
 8009982:	61fb      	str	r3, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8009984:	4bc5      	ldr	r3, [pc, #788]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009986:	68da      	ldr	r2, [r3, #12]
 8009988:	2380      	movs	r3, #128	; 0x80
 800998a:	025b      	lsls	r3, r3, #9
 800998c:	4013      	ands	r3, r2
 800998e:	61bb      	str	r3, [r7, #24]

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8009990:	687b      	ldr	r3, [r7, #4]
 8009992:	681b      	ldr	r3, [r3, #0]
 8009994:	2201      	movs	r2, #1
 8009996:	4013      	ands	r3, r2
 8009998:	d100      	bne.n	800999c <HAL_RCC_OscConfig+0x88>
 800999a:	e097      	b.n	8009acc <HAL_RCC_OscConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 800999c:	687b      	ldr	r3, [r7, #4]
 800999e:	685b      	ldr	r3, [r3, #4]
 80099a0:	2b00      	cmp	r3, #0
 80099a2:	d013      	beq.n	80099cc <HAL_RCC_OscConfig+0xb8>
 80099a4:	687b      	ldr	r3, [r7, #4]
 80099a6:	685a      	ldr	r2, [r3, #4]
 80099a8:	2380      	movs	r3, #128	; 0x80
 80099aa:	025b      	lsls	r3, r3, #9
 80099ac:	429a      	cmp	r2, r3
 80099ae:	d00d      	beq.n	80099cc <HAL_RCC_OscConfig+0xb8>
 80099b0:	687b      	ldr	r3, [r7, #4]
 80099b2:	685a      	ldr	r2, [r3, #4]
 80099b4:	23a0      	movs	r3, #160	; 0xa0
 80099b6:	02db      	lsls	r3, r3, #11
 80099b8:	429a      	cmp	r2, r3
 80099ba:	d007      	beq.n	80099cc <HAL_RCC_OscConfig+0xb8>
 80099bc:	236a      	movs	r3, #106	; 0x6a
 80099be:	33ff      	adds	r3, #255	; 0xff
 80099c0:	001a      	movs	r2, r3
 80099c2:	4bb5      	ldr	r3, [pc, #724]	; (8009c98 <HAL_RCC_OscConfig+0x384>)
 80099c4:	0011      	movs	r1, r2
 80099c6:	0018      	movs	r0, r3
 80099c8:	f7fc fc65 	bl	8006296 <assert_failed>

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 80099cc:	69fb      	ldr	r3, [r7, #28]
 80099ce:	2b08      	cmp	r3, #8
 80099d0:	d007      	beq.n	80099e2 <HAL_RCC_OscConfig+0xce>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 80099d2:	69fb      	ldr	r3, [r7, #28]
 80099d4:	2b0c      	cmp	r3, #12
 80099d6:	d112      	bne.n	80099fe <HAL_RCC_OscConfig+0xea>
 80099d8:	69ba      	ldr	r2, [r7, #24]
 80099da:	2380      	movs	r3, #128	; 0x80
 80099dc:	025b      	lsls	r3, r3, #9
 80099de:	429a      	cmp	r2, r3
 80099e0:	d10d      	bne.n	80099fe <HAL_RCC_OscConfig+0xea>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80099e2:	4bae      	ldr	r3, [pc, #696]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 80099e4:	681a      	ldr	r2, [r3, #0]
 80099e6:	2380      	movs	r3, #128	; 0x80
 80099e8:	029b      	lsls	r3, r3, #10
 80099ea:	4013      	ands	r3, r2
 80099ec:	d100      	bne.n	80099f0 <HAL_RCC_OscConfig+0xdc>
 80099ee:	e06c      	b.n	8009aca <HAL_RCC_OscConfig+0x1b6>
 80099f0:	687b      	ldr	r3, [r7, #4]
 80099f2:	685b      	ldr	r3, [r3, #4]
 80099f4:	2b00      	cmp	r3, #0
 80099f6:	d168      	bne.n	8009aca <HAL_RCC_OscConfig+0x1b6>
      {
        return HAL_ERROR;
 80099f8:	2301      	movs	r3, #1
 80099fa:	f000 fd16 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80099fe:	687b      	ldr	r3, [r7, #4]
 8009a00:	685a      	ldr	r2, [r3, #4]
 8009a02:	2380      	movs	r3, #128	; 0x80
 8009a04:	025b      	lsls	r3, r3, #9
 8009a06:	429a      	cmp	r2, r3
 8009a08:	d107      	bne.n	8009a1a <HAL_RCC_OscConfig+0x106>
 8009a0a:	4ba4      	ldr	r3, [pc, #656]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a0c:	681a      	ldr	r2, [r3, #0]
 8009a0e:	4ba3      	ldr	r3, [pc, #652]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a10:	2180      	movs	r1, #128	; 0x80
 8009a12:	0249      	lsls	r1, r1, #9
 8009a14:	430a      	orrs	r2, r1
 8009a16:	601a      	str	r2, [r3, #0]
 8009a18:	e027      	b.n	8009a6a <HAL_RCC_OscConfig+0x156>
 8009a1a:	687b      	ldr	r3, [r7, #4]
 8009a1c:	685a      	ldr	r2, [r3, #4]
 8009a1e:	23a0      	movs	r3, #160	; 0xa0
 8009a20:	02db      	lsls	r3, r3, #11
 8009a22:	429a      	cmp	r2, r3
 8009a24:	d10e      	bne.n	8009a44 <HAL_RCC_OscConfig+0x130>
 8009a26:	4b9d      	ldr	r3, [pc, #628]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a28:	681a      	ldr	r2, [r3, #0]
 8009a2a:	4b9c      	ldr	r3, [pc, #624]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a2c:	2180      	movs	r1, #128	; 0x80
 8009a2e:	02c9      	lsls	r1, r1, #11
 8009a30:	430a      	orrs	r2, r1
 8009a32:	601a      	str	r2, [r3, #0]
 8009a34:	4b99      	ldr	r3, [pc, #612]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a36:	681a      	ldr	r2, [r3, #0]
 8009a38:	4b98      	ldr	r3, [pc, #608]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a3a:	2180      	movs	r1, #128	; 0x80
 8009a3c:	0249      	lsls	r1, r1, #9
 8009a3e:	430a      	orrs	r2, r1
 8009a40:	601a      	str	r2, [r3, #0]
 8009a42:	e012      	b.n	8009a6a <HAL_RCC_OscConfig+0x156>
 8009a44:	4b95      	ldr	r3, [pc, #596]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a46:	681a      	ldr	r2, [r3, #0]
 8009a48:	4b94      	ldr	r3, [pc, #592]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a4a:	4995      	ldr	r1, [pc, #596]	; (8009ca0 <HAL_RCC_OscConfig+0x38c>)
 8009a4c:	400a      	ands	r2, r1
 8009a4e:	601a      	str	r2, [r3, #0]
 8009a50:	4b92      	ldr	r3, [pc, #584]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a52:	681a      	ldr	r2, [r3, #0]
 8009a54:	2380      	movs	r3, #128	; 0x80
 8009a56:	025b      	lsls	r3, r3, #9
 8009a58:	4013      	ands	r3, r2
 8009a5a:	60fb      	str	r3, [r7, #12]
 8009a5c:	68fb      	ldr	r3, [r7, #12]
 8009a5e:	4b8f      	ldr	r3, [pc, #572]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a60:	681a      	ldr	r2, [r3, #0]
 8009a62:	4b8e      	ldr	r3, [pc, #568]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a64:	498f      	ldr	r1, [pc, #572]	; (8009ca4 <HAL_RCC_OscConfig+0x390>)
 8009a66:	400a      	ands	r2, r1
 8009a68:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8009a6a:	687b      	ldr	r3, [r7, #4]
 8009a6c:	685b      	ldr	r3, [r3, #4]
 8009a6e:	2b00      	cmp	r3, #0
 8009a70:	d015      	beq.n	8009a9e <HAL_RCC_OscConfig+0x18a>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8009a72:	f7fd fd37 	bl	80074e4 <HAL_GetTick>
 8009a76:	0003      	movs	r3, r0
 8009a78:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8009a7a:	e009      	b.n	8009a90 <HAL_RCC_OscConfig+0x17c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8009a7c:	f7fd fd32 	bl	80074e4 <HAL_GetTick>
 8009a80:	0002      	movs	r2, r0
 8009a82:	697b      	ldr	r3, [r7, #20]
 8009a84:	1ad3      	subs	r3, r2, r3
 8009a86:	2b64      	cmp	r3, #100	; 0x64
 8009a88:	d902      	bls.n	8009a90 <HAL_RCC_OscConfig+0x17c>
          {
            return HAL_TIMEOUT;
 8009a8a:	2303      	movs	r3, #3
 8009a8c:	f000 fccd 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8009a90:	4b82      	ldr	r3, [pc, #520]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009a92:	681a      	ldr	r2, [r3, #0]
 8009a94:	2380      	movs	r3, #128	; 0x80
 8009a96:	029b      	lsls	r3, r3, #10
 8009a98:	4013      	ands	r3, r2
 8009a9a:	d0ef      	beq.n	8009a7c <HAL_RCC_OscConfig+0x168>
 8009a9c:	e016      	b.n	8009acc <HAL_RCC_OscConfig+0x1b8>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8009a9e:	f7fd fd21 	bl	80074e4 <HAL_GetTick>
 8009aa2:	0003      	movs	r3, r0
 8009aa4:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8009aa6:	e009      	b.n	8009abc <HAL_RCC_OscConfig+0x1a8>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8009aa8:	f7fd fd1c 	bl	80074e4 <HAL_GetTick>
 8009aac:	0002      	movs	r2, r0
 8009aae:	697b      	ldr	r3, [r7, #20]
 8009ab0:	1ad3      	subs	r3, r2, r3
 8009ab2:	2b64      	cmp	r3, #100	; 0x64
 8009ab4:	d902      	bls.n	8009abc <HAL_RCC_OscConfig+0x1a8>
          {
            return HAL_TIMEOUT;
 8009ab6:	2303      	movs	r3, #3
 8009ab8:	f000 fcb7 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8009abc:	4b77      	ldr	r3, [pc, #476]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009abe:	681a      	ldr	r2, [r3, #0]
 8009ac0:	2380      	movs	r3, #128	; 0x80
 8009ac2:	029b      	lsls	r3, r3, #10
 8009ac4:	4013      	ands	r3, r2
 8009ac6:	d1ef      	bne.n	8009aa8 <HAL_RCC_OscConfig+0x194>
 8009ac8:	e000      	b.n	8009acc <HAL_RCC_OscConfig+0x1b8>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8009aca:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8009acc:	687b      	ldr	r3, [r7, #4]
 8009ace:	681b      	ldr	r3, [r3, #0]
 8009ad0:	2202      	movs	r2, #2
 8009ad2:	4013      	ands	r3, r2
 8009ad4:	d100      	bne.n	8009ad8 <HAL_RCC_OscConfig+0x1c4>
 8009ad6:	e0c8      	b.n	8009c6a <HAL_RCC_OscConfig+0x356>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 8009ad8:	687b      	ldr	r3, [r7, #4]
 8009ada:	68db      	ldr	r3, [r3, #12]
 8009adc:	2b00      	cmp	r3, #0
 8009ade:	d01a      	beq.n	8009b16 <HAL_RCC_OscConfig+0x202>
 8009ae0:	687b      	ldr	r3, [r7, #4]
 8009ae2:	68db      	ldr	r3, [r3, #12]
 8009ae4:	2b01      	cmp	r3, #1
 8009ae6:	d016      	beq.n	8009b16 <HAL_RCC_OscConfig+0x202>
 8009ae8:	687b      	ldr	r3, [r7, #4]
 8009aea:	68db      	ldr	r3, [r3, #12]
 8009aec:	2b09      	cmp	r3, #9
 8009aee:	d012      	beq.n	8009b16 <HAL_RCC_OscConfig+0x202>
 8009af0:	687b      	ldr	r3, [r7, #4]
 8009af2:	68db      	ldr	r3, [r3, #12]
 8009af4:	2b20      	cmp	r3, #32
 8009af6:	d00e      	beq.n	8009b16 <HAL_RCC_OscConfig+0x202>
 8009af8:	687b      	ldr	r3, [r7, #4]
 8009afa:	68db      	ldr	r3, [r3, #12]
 8009afc:	2b21      	cmp	r3, #33	; 0x21
 8009afe:	d00a      	beq.n	8009b16 <HAL_RCC_OscConfig+0x202>
 8009b00:	687b      	ldr	r3, [r7, #4]
 8009b02:	68db      	ldr	r3, [r3, #12]
 8009b04:	2b29      	cmp	r3, #41	; 0x29
 8009b06:	d006      	beq.n	8009b16 <HAL_RCC_OscConfig+0x202>
 8009b08:	23ce      	movs	r3, #206	; 0xce
 8009b0a:	005a      	lsls	r2, r3, #1
 8009b0c:	4b62      	ldr	r3, [pc, #392]	; (8009c98 <HAL_RCC_OscConfig+0x384>)
 8009b0e:	0011      	movs	r1, r2
 8009b10:	0018      	movs	r0, r3
 8009b12:	f7fc fbc0 	bl	8006296 <assert_failed>
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 8009b16:	687b      	ldr	r3, [r7, #4]
 8009b18:	691b      	ldr	r3, [r3, #16]
 8009b1a:	2b1f      	cmp	r3, #31
 8009b1c:	d907      	bls.n	8009b2e <HAL_RCC_OscConfig+0x21a>
 8009b1e:	239e      	movs	r3, #158	; 0x9e
 8009b20:	33ff      	adds	r3, #255	; 0xff
 8009b22:	001a      	movs	r2, r3
 8009b24:	4b5c      	ldr	r3, [pc, #368]	; (8009c98 <HAL_RCC_OscConfig+0x384>)
 8009b26:	0011      	movs	r1, r2
 8009b28:	0018      	movs	r0, r3
 8009b2a:	f7fc fbb4 	bl	8006296 <assert_failed>

    hsi_state = RCC_OscInitStruct->HSIState;
 8009b2e:	687b      	ldr	r3, [r7, #4]
 8009b30:	68db      	ldr	r3, [r3, #12]
 8009b32:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(RCC_CR_HSIOUTEN)
    if((hsi_state & RCC_HSI_OUTEN) != 0U)
 8009b34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009b36:	2220      	movs	r2, #32
 8009b38:	4013      	ands	r3, r2
 8009b3a:	d009      	beq.n	8009b50 <HAL_RCC_OscConfig+0x23c>
    {
      /* HSI Output enable for timer requested */
      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
 8009b3c:	4b57      	ldr	r3, [pc, #348]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009b3e:	681a      	ldr	r2, [r3, #0]
 8009b40:	4b56      	ldr	r3, [pc, #344]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009b42:	2120      	movs	r1, #32
 8009b44:	430a      	orrs	r2, r1
 8009b46:	601a      	str	r2, [r3, #0]

      hsi_state &= ~RCC_CR_HSIOUTEN;
 8009b48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009b4a:	2220      	movs	r2, #32
 8009b4c:	4393      	bics	r3, r2
 8009b4e:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8009b50:	69fb      	ldr	r3, [r7, #28]
 8009b52:	2b04      	cmp	r3, #4
 8009b54:	d005      	beq.n	8009b62 <HAL_RCC_OscConfig+0x24e>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8009b56:	69fb      	ldr	r3, [r7, #28]
 8009b58:	2b0c      	cmp	r3, #12
 8009b5a:	d140      	bne.n	8009bde <HAL_RCC_OscConfig+0x2ca>
 8009b5c:	69bb      	ldr	r3, [r7, #24]
 8009b5e:	2b00      	cmp	r3, #0
 8009b60:	d13d      	bne.n	8009bde <HAL_RCC_OscConfig+0x2ca>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
 8009b62:	4b4e      	ldr	r3, [pc, #312]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009b64:	681b      	ldr	r3, [r3, #0]
 8009b66:	2204      	movs	r2, #4
 8009b68:	4013      	ands	r3, r2
 8009b6a:	d005      	beq.n	8009b78 <HAL_RCC_OscConfig+0x264>
 8009b6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009b6e:	2b00      	cmp	r3, #0
 8009b70:	d102      	bne.n	8009b78 <HAL_RCC_OscConfig+0x264>
      {
        return HAL_ERROR;
 8009b72:	2301      	movs	r3, #1
 8009b74:	f000 fc59 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
      }
      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8009b78:	4b48      	ldr	r3, [pc, #288]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009b7a:	685b      	ldr	r3, [r3, #4]
 8009b7c:	4a4a      	ldr	r2, [pc, #296]	; (8009ca8 <HAL_RCC_OscConfig+0x394>)
 8009b7e:	4013      	ands	r3, r2
 8009b80:	0019      	movs	r1, r3
 8009b82:	687b      	ldr	r3, [r7, #4]
 8009b84:	691b      	ldr	r3, [r3, #16]
 8009b86:	021a      	lsls	r2, r3, #8
 8009b88:	4b44      	ldr	r3, [pc, #272]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009b8a:	430a      	orrs	r2, r1
 8009b8c:	605a      	str	r2, [r3, #4]

        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8009b8e:	4b43      	ldr	r3, [pc, #268]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009b90:	681b      	ldr	r3, [r3, #0]
 8009b92:	2209      	movs	r2, #9
 8009b94:	4393      	bics	r3, r2
 8009b96:	0019      	movs	r1, r3
 8009b98:	4b40      	ldr	r3, [pc, #256]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009b9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009b9c:	430a      	orrs	r2, r1
 8009b9e:	601a      	str	r2, [r3, #0]
      }

      /* Update the SystemCoreClock global variable */
      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8009ba0:	f000 fe4e 	bl	800a840 <HAL_RCC_GetSysClockFreq>
 8009ba4:	0001      	movs	r1, r0
 8009ba6:	4b3d      	ldr	r3, [pc, #244]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009ba8:	68db      	ldr	r3, [r3, #12]
 8009baa:	091b      	lsrs	r3, r3, #4
 8009bac:	220f      	movs	r2, #15
 8009bae:	4013      	ands	r3, r2
 8009bb0:	4a3e      	ldr	r2, [pc, #248]	; (8009cac <HAL_RCC_OscConfig+0x398>)
 8009bb2:	5cd3      	ldrb	r3, [r2, r3]
 8009bb4:	000a      	movs	r2, r1
 8009bb6:	40da      	lsrs	r2, r3
 8009bb8:	4b3d      	ldr	r3, [pc, #244]	; (8009cb0 <HAL_RCC_OscConfig+0x39c>)
 8009bba:	601a      	str	r2, [r3, #0]

      /* Configure the source of time base considering new system clocks settings*/
      status = HAL_InitTick (uwTickPrio);
 8009bbc:	4b3d      	ldr	r3, [pc, #244]	; (8009cb4 <HAL_RCC_OscConfig+0x3a0>)
 8009bbe:	681b      	ldr	r3, [r3, #0]
 8009bc0:	2513      	movs	r5, #19
 8009bc2:	197c      	adds	r4, r7, r5
 8009bc4:	0018      	movs	r0, r3
 8009bc6:	f7fd fc47 	bl	8007458 <HAL_InitTick>
 8009bca:	0003      	movs	r3, r0
 8009bcc:	7023      	strb	r3, [r4, #0]
      if(status != HAL_OK)
 8009bce:	197b      	adds	r3, r7, r5
 8009bd0:	781b      	ldrb	r3, [r3, #0]
 8009bd2:	2b00      	cmp	r3, #0
 8009bd4:	d049      	beq.n	8009c6a <HAL_RCC_OscConfig+0x356>
      {
        return status;
 8009bd6:	197b      	adds	r3, r7, r5
 8009bd8:	781b      	ldrb	r3, [r3, #0]
 8009bda:	f000 fc26 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
      }
    }
    else
    {
      /* Check the HSI State */
      if(hsi_state != RCC_HSI_OFF)
 8009bde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009be0:	2b00      	cmp	r3, #0
 8009be2:	d028      	beq.n	8009c36 <HAL_RCC_OscConfig+0x322>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8009be4:	4b2d      	ldr	r3, [pc, #180]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009be6:	681b      	ldr	r3, [r3, #0]
 8009be8:	2209      	movs	r2, #9
 8009bea:	4393      	bics	r3, r2
 8009bec:	0019      	movs	r1, r3
 8009bee:	4b2b      	ldr	r3, [pc, #172]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009bf0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009bf2:	430a      	orrs	r2, r1
 8009bf4:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8009bf6:	f7fd fc75 	bl	80074e4 <HAL_GetTick>
 8009bfa:	0003      	movs	r3, r0
 8009bfc:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009bfe:	e009      	b.n	8009c14 <HAL_RCC_OscConfig+0x300>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8009c00:	f7fd fc70 	bl	80074e4 <HAL_GetTick>
 8009c04:	0002      	movs	r2, r0
 8009c06:	697b      	ldr	r3, [r7, #20]
 8009c08:	1ad3      	subs	r3, r2, r3
 8009c0a:	2b02      	cmp	r3, #2
 8009c0c:	d902      	bls.n	8009c14 <HAL_RCC_OscConfig+0x300>
          {
            return HAL_TIMEOUT;
 8009c0e:	2303      	movs	r3, #3
 8009c10:	f000 fc0b 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009c14:	4b21      	ldr	r3, [pc, #132]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009c16:	681b      	ldr	r3, [r3, #0]
 8009c18:	2204      	movs	r2, #4
 8009c1a:	4013      	ands	r3, r2
 8009c1c:	d0f0      	beq.n	8009c00 <HAL_RCC_OscConfig+0x2ec>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8009c1e:	4b1f      	ldr	r3, [pc, #124]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009c20:	685b      	ldr	r3, [r3, #4]
 8009c22:	4a21      	ldr	r2, [pc, #132]	; (8009ca8 <HAL_RCC_OscConfig+0x394>)
 8009c24:	4013      	ands	r3, r2
 8009c26:	0019      	movs	r1, r3
 8009c28:	687b      	ldr	r3, [r7, #4]
 8009c2a:	691b      	ldr	r3, [r3, #16]
 8009c2c:	021a      	lsls	r2, r3, #8
 8009c2e:	4b1b      	ldr	r3, [pc, #108]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009c30:	430a      	orrs	r2, r1
 8009c32:	605a      	str	r2, [r3, #4]
 8009c34:	e019      	b.n	8009c6a <HAL_RCC_OscConfig+0x356>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8009c36:	4b19      	ldr	r3, [pc, #100]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009c38:	681a      	ldr	r2, [r3, #0]
 8009c3a:	4b18      	ldr	r3, [pc, #96]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009c3c:	2101      	movs	r1, #1
 8009c3e:	438a      	bics	r2, r1
 8009c40:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8009c42:	f7fd fc4f 	bl	80074e4 <HAL_GetTick>
 8009c46:	0003      	movs	r3, r0
 8009c48:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8009c4a:	e009      	b.n	8009c60 <HAL_RCC_OscConfig+0x34c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8009c4c:	f7fd fc4a 	bl	80074e4 <HAL_GetTick>
 8009c50:	0002      	movs	r2, r0
 8009c52:	697b      	ldr	r3, [r7, #20]
 8009c54:	1ad3      	subs	r3, r2, r3
 8009c56:	2b02      	cmp	r3, #2
 8009c58:	d902      	bls.n	8009c60 <HAL_RCC_OscConfig+0x34c>
          {
            return HAL_TIMEOUT;
 8009c5a:	2303      	movs	r3, #3
 8009c5c:	f000 fbe5 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8009c60:	4b0e      	ldr	r3, [pc, #56]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009c62:	681b      	ldr	r3, [r3, #0]
 8009c64:	2204      	movs	r2, #4
 8009c66:	4013      	ands	r3, r2
 8009c68:	d1f0      	bne.n	8009c4c <HAL_RCC_OscConfig+0x338>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8009c6a:	687b      	ldr	r3, [r7, #4]
 8009c6c:	681b      	ldr	r3, [r3, #0]
 8009c6e:	2210      	movs	r2, #16
 8009c70:	4013      	ands	r3, r2
 8009c72:	d100      	bne.n	8009c76 <HAL_RCC_OscConfig+0x362>
 8009c74:	e127      	b.n	8009ec6 <HAL_RCC_OscConfig+0x5b2>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8009c76:	69fb      	ldr	r3, [r7, #28]
 8009c78:	2b00      	cmp	r3, #0
 8009c7a:	d000      	beq.n	8009c7e <HAL_RCC_OscConfig+0x36a>
 8009c7c:	e08c      	b.n	8009d98 <HAL_RCC_OscConfig+0x484>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8009c7e:	4b07      	ldr	r3, [pc, #28]	; (8009c9c <HAL_RCC_OscConfig+0x388>)
 8009c80:	681a      	ldr	r2, [r3, #0]
 8009c82:	2380      	movs	r3, #128	; 0x80
 8009c84:	009b      	lsls	r3, r3, #2
 8009c86:	4013      	ands	r3, r2
 8009c88:	d016      	beq.n	8009cb8 <HAL_RCC_OscConfig+0x3a4>
 8009c8a:	687b      	ldr	r3, [r7, #4]
 8009c8c:	69db      	ldr	r3, [r3, #28]
 8009c8e:	2b00      	cmp	r3, #0
 8009c90:	d112      	bne.n	8009cb8 <HAL_RCC_OscConfig+0x3a4>
      {
        return HAL_ERROR;
 8009c92:	2301      	movs	r3, #1
 8009c94:	f000 fbc9 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
 8009c98:	0800de60 	.word	0x0800de60
 8009c9c:	40021000 	.word	0x40021000
 8009ca0:	fffeffff 	.word	0xfffeffff
 8009ca4:	fffbffff 	.word	0xfffbffff
 8009ca8:	ffffe0ff 	.word	0xffffe0ff
 8009cac:	0800f234 	.word	0x0800f234
 8009cb0:	2000004c 	.word	0x2000004c
 8009cb4:	20000050 	.word	0x20000050
      }
      /* Otherwise, just the calibration and MSI range change are allowed */
      else
      {
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
 8009cb8:	687b      	ldr	r3, [r7, #4]
 8009cba:	6a1b      	ldr	r3, [r3, #32]
 8009cbc:	2bff      	cmp	r3, #255	; 0xff
 8009cbe:	d906      	bls.n	8009cce <HAL_RCC_OscConfig+0x3ba>
 8009cc0:	2380      	movs	r3, #128	; 0x80
 8009cc2:	009a      	lsls	r2, r3, #2
 8009cc4:	4bcb      	ldr	r3, [pc, #812]	; (8009ff4 <HAL_RCC_OscConfig+0x6e0>)
 8009cc6:	0011      	movs	r1, r2
 8009cc8:	0018      	movs	r0, r3
 8009cca:	f7fc fae4 	bl	8006296 <assert_failed>
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
 8009cce:	687b      	ldr	r3, [r7, #4]
 8009cd0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009cd2:	2b00      	cmp	r3, #0
 8009cd4:	d029      	beq.n	8009d2a <HAL_RCC_OscConfig+0x416>
 8009cd6:	687b      	ldr	r3, [r7, #4]
 8009cd8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009cda:	2380      	movs	r3, #128	; 0x80
 8009cdc:	019b      	lsls	r3, r3, #6
 8009cde:	429a      	cmp	r2, r3
 8009ce0:	d023      	beq.n	8009d2a <HAL_RCC_OscConfig+0x416>
 8009ce2:	687b      	ldr	r3, [r7, #4]
 8009ce4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009ce6:	2380      	movs	r3, #128	; 0x80
 8009ce8:	01db      	lsls	r3, r3, #7
 8009cea:	429a      	cmp	r2, r3
 8009cec:	d01d      	beq.n	8009d2a <HAL_RCC_OscConfig+0x416>
 8009cee:	687b      	ldr	r3, [r7, #4]
 8009cf0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009cf2:	23c0      	movs	r3, #192	; 0xc0
 8009cf4:	01db      	lsls	r3, r3, #7
 8009cf6:	429a      	cmp	r2, r3
 8009cf8:	d017      	beq.n	8009d2a <HAL_RCC_OscConfig+0x416>
 8009cfa:	687b      	ldr	r3, [r7, #4]
 8009cfc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009cfe:	2380      	movs	r3, #128	; 0x80
 8009d00:	021b      	lsls	r3, r3, #8
 8009d02:	429a      	cmp	r2, r3
 8009d04:	d011      	beq.n	8009d2a <HAL_RCC_OscConfig+0x416>
 8009d06:	687b      	ldr	r3, [r7, #4]
 8009d08:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009d0a:	23a0      	movs	r3, #160	; 0xa0
 8009d0c:	021b      	lsls	r3, r3, #8
 8009d0e:	429a      	cmp	r2, r3
 8009d10:	d00b      	beq.n	8009d2a <HAL_RCC_OscConfig+0x416>
 8009d12:	687b      	ldr	r3, [r7, #4]
 8009d14:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009d16:	23c0      	movs	r3, #192	; 0xc0
 8009d18:	021b      	lsls	r3, r3, #8
 8009d1a:	429a      	cmp	r2, r3
 8009d1c:	d005      	beq.n	8009d2a <HAL_RCC_OscConfig+0x416>
 8009d1e:	4ab6      	ldr	r2, [pc, #728]	; (8009ff8 <HAL_RCC_OscConfig+0x6e4>)
 8009d20:	4bb4      	ldr	r3, [pc, #720]	; (8009ff4 <HAL_RCC_OscConfig+0x6e0>)
 8009d22:	0011      	movs	r1, r2
 8009d24:	0018      	movs	r0, r3
 8009d26:	f7fc fab6 	bl	8006296 <assert_failed>

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8009d2a:	4bb4      	ldr	r3, [pc, #720]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009d2c:	685b      	ldr	r3, [r3, #4]
 8009d2e:	4ab4      	ldr	r2, [pc, #720]	; (800a000 <HAL_RCC_OscConfig+0x6ec>)
 8009d30:	4013      	ands	r3, r2
 8009d32:	0019      	movs	r1, r3
 8009d34:	687b      	ldr	r3, [r7, #4]
 8009d36:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009d38:	4bb0      	ldr	r3, [pc, #704]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009d3a:	430a      	orrs	r2, r1
 8009d3c:	605a      	str	r2, [r3, #4]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8009d3e:	4baf      	ldr	r3, [pc, #700]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009d40:	685b      	ldr	r3, [r3, #4]
 8009d42:	021b      	lsls	r3, r3, #8
 8009d44:	0a19      	lsrs	r1, r3, #8
 8009d46:	687b      	ldr	r3, [r7, #4]
 8009d48:	6a1b      	ldr	r3, [r3, #32]
 8009d4a:	061a      	lsls	r2, r3, #24
 8009d4c:	4bab      	ldr	r3, [pc, #684]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009d4e:	430a      	orrs	r2, r1
 8009d50:	605a      	str	r2, [r3, #4]


        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 8009d52:	687b      	ldr	r3, [r7, #4]
 8009d54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009d56:	0b5b      	lsrs	r3, r3, #13
 8009d58:	3301      	adds	r3, #1
 8009d5a:	2280      	movs	r2, #128	; 0x80
 8009d5c:	0212      	lsls	r2, r2, #8
 8009d5e:	409a      	lsls	r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 8009d60:	4ba6      	ldr	r3, [pc, #664]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009d62:	68db      	ldr	r3, [r3, #12]
 8009d64:	091b      	lsrs	r3, r3, #4
 8009d66:	210f      	movs	r1, #15
 8009d68:	400b      	ands	r3, r1
 8009d6a:	49a6      	ldr	r1, [pc, #664]	; (800a004 <HAL_RCC_OscConfig+0x6f0>)
 8009d6c:	5ccb      	ldrb	r3, [r1, r3]
 8009d6e:	40da      	lsrs	r2, r3
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 8009d70:	4ba5      	ldr	r3, [pc, #660]	; (800a008 <HAL_RCC_OscConfig+0x6f4>)
 8009d72:	601a      	str	r2, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick (uwTickPrio);
 8009d74:	4ba5      	ldr	r3, [pc, #660]	; (800a00c <HAL_RCC_OscConfig+0x6f8>)
 8009d76:	681b      	ldr	r3, [r3, #0]
 8009d78:	2513      	movs	r5, #19
 8009d7a:	197c      	adds	r4, r7, r5
 8009d7c:	0018      	movs	r0, r3
 8009d7e:	f7fd fb6b 	bl	8007458 <HAL_InitTick>
 8009d82:	0003      	movs	r3, r0
 8009d84:	7023      	strb	r3, [r4, #0]
        if(status != HAL_OK)
 8009d86:	197b      	adds	r3, r7, r5
 8009d88:	781b      	ldrb	r3, [r3, #0]
 8009d8a:	2b00      	cmp	r3, #0
 8009d8c:	d100      	bne.n	8009d90 <HAL_RCC_OscConfig+0x47c>
 8009d8e:	e09a      	b.n	8009ec6 <HAL_RCC_OscConfig+0x5b2>
        {
          return status;
 8009d90:	197b      	adds	r3, r7, r5
 8009d92:	781b      	ldrb	r3, [r3, #0]
 8009d94:	f000 fb49 	bl	800a42a <HAL_RCC_OscConfig+0xb16>
      }
    }
    else
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
 8009d98:	687b      	ldr	r3, [r7, #4]
 8009d9a:	69db      	ldr	r3, [r3, #28]
 8009d9c:	2b00      	cmp	r3, #0
 8009d9e:	d00a      	beq.n	8009db6 <HAL_RCC_OscConfig+0x4a2>
 8009da0:	687b      	ldr	r3, [r7, #4]
 8009da2:	69db      	ldr	r3, [r3, #28]
 8009da4:	2b01      	cmp	r3, #1
 8009da6:	d006      	beq.n	8009db6 <HAL_RCC_OscConfig+0x4a2>
 8009da8:	2386      	movs	r3, #134	; 0x86
 8009daa:	009a      	lsls	r2, r3, #2
 8009dac:	4b91      	ldr	r3, [pc, #580]	; (8009ff4 <HAL_RCC_OscConfig+0x6e0>)
 8009dae:	0011      	movs	r1, r2
 8009db0:	0018      	movs	r0, r3
 8009db2:	f7fc fa70 	bl	8006296 <assert_failed>

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8009db6:	687b      	ldr	r3, [r7, #4]
 8009db8:	69db      	ldr	r3, [r3, #28]
 8009dba:	2b00      	cmp	r3, #0
 8009dbc:	d100      	bne.n	8009dc0 <HAL_RCC_OscConfig+0x4ac>
 8009dbe:	e068      	b.n	8009e92 <HAL_RCC_OscConfig+0x57e>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8009dc0:	4b8e      	ldr	r3, [pc, #568]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009dc2:	681a      	ldr	r2, [r3, #0]
 8009dc4:	4b8d      	ldr	r3, [pc, #564]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009dc6:	2180      	movs	r1, #128	; 0x80
 8009dc8:	0049      	lsls	r1, r1, #1
 8009dca:	430a      	orrs	r2, r1
 8009dcc:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8009dce:	f7fd fb89 	bl	80074e4 <HAL_GetTick>
 8009dd2:	0003      	movs	r3, r0
 8009dd4:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8009dd6:	e008      	b.n	8009dea <HAL_RCC_OscConfig+0x4d6>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8009dd8:	f7fd fb84 	bl	80074e4 <HAL_GetTick>
 8009ddc:	0002      	movs	r2, r0
 8009dde:	697b      	ldr	r3, [r7, #20]
 8009de0:	1ad3      	subs	r3, r2, r3
 8009de2:	2b02      	cmp	r3, #2
 8009de4:	d901      	bls.n	8009dea <HAL_RCC_OscConfig+0x4d6>
          {
            return HAL_TIMEOUT;
 8009de6:	2303      	movs	r3, #3
 8009de8:	e31f      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8009dea:	4b84      	ldr	r3, [pc, #528]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009dec:	681a      	ldr	r2, [r3, #0]
 8009dee:	2380      	movs	r3, #128	; 0x80
 8009df0:	009b      	lsls	r3, r3, #2
 8009df2:	4013      	ands	r3, r2
 8009df4:	d0f0      	beq.n	8009dd8 <HAL_RCC_OscConfig+0x4c4>
          }
        }
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
 8009df6:	687b      	ldr	r3, [r7, #4]
 8009df8:	6a1b      	ldr	r3, [r3, #32]
 8009dfa:	2bff      	cmp	r3, #255	; 0xff
 8009dfc:	d906      	bls.n	8009e0c <HAL_RCC_OscConfig+0x4f8>
 8009dfe:	238b      	movs	r3, #139	; 0x8b
 8009e00:	009a      	lsls	r2, r3, #2
 8009e02:	4b7c      	ldr	r3, [pc, #496]	; (8009ff4 <HAL_RCC_OscConfig+0x6e0>)
 8009e04:	0011      	movs	r1, r2
 8009e06:	0018      	movs	r0, r3
 8009e08:	f7fc fa45 	bl	8006296 <assert_failed>
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
 8009e0c:	687b      	ldr	r3, [r7, #4]
 8009e0e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009e10:	2b00      	cmp	r3, #0
 8009e12:	d029      	beq.n	8009e68 <HAL_RCC_OscConfig+0x554>
 8009e14:	687b      	ldr	r3, [r7, #4]
 8009e16:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009e18:	2380      	movs	r3, #128	; 0x80
 8009e1a:	019b      	lsls	r3, r3, #6
 8009e1c:	429a      	cmp	r2, r3
 8009e1e:	d023      	beq.n	8009e68 <HAL_RCC_OscConfig+0x554>
 8009e20:	687b      	ldr	r3, [r7, #4]
 8009e22:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009e24:	2380      	movs	r3, #128	; 0x80
 8009e26:	01db      	lsls	r3, r3, #7
 8009e28:	429a      	cmp	r2, r3
 8009e2a:	d01d      	beq.n	8009e68 <HAL_RCC_OscConfig+0x554>
 8009e2c:	687b      	ldr	r3, [r7, #4]
 8009e2e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009e30:	23c0      	movs	r3, #192	; 0xc0
 8009e32:	01db      	lsls	r3, r3, #7
 8009e34:	429a      	cmp	r2, r3
 8009e36:	d017      	beq.n	8009e68 <HAL_RCC_OscConfig+0x554>
 8009e38:	687b      	ldr	r3, [r7, #4]
 8009e3a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009e3c:	2380      	movs	r3, #128	; 0x80
 8009e3e:	021b      	lsls	r3, r3, #8
 8009e40:	429a      	cmp	r2, r3
 8009e42:	d011      	beq.n	8009e68 <HAL_RCC_OscConfig+0x554>
 8009e44:	687b      	ldr	r3, [r7, #4]
 8009e46:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009e48:	23a0      	movs	r3, #160	; 0xa0
 8009e4a:	021b      	lsls	r3, r3, #8
 8009e4c:	429a      	cmp	r2, r3
 8009e4e:	d00b      	beq.n	8009e68 <HAL_RCC_OscConfig+0x554>
 8009e50:	687b      	ldr	r3, [r7, #4]
 8009e52:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009e54:	23c0      	movs	r3, #192	; 0xc0
 8009e56:	021b      	lsls	r3, r3, #8
 8009e58:	429a      	cmp	r2, r3
 8009e5a:	d005      	beq.n	8009e68 <HAL_RCC_OscConfig+0x554>
 8009e5c:	4a6c      	ldr	r2, [pc, #432]	; (800a010 <HAL_RCC_OscConfig+0x6fc>)
 8009e5e:	4b65      	ldr	r3, [pc, #404]	; (8009ff4 <HAL_RCC_OscConfig+0x6e0>)
 8009e60:	0011      	movs	r1, r2
 8009e62:	0018      	movs	r0, r3
 8009e64:	f7fc fa17 	bl	8006296 <assert_failed>

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8009e68:	4b64      	ldr	r3, [pc, #400]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009e6a:	685b      	ldr	r3, [r3, #4]
 8009e6c:	4a64      	ldr	r2, [pc, #400]	; (800a000 <HAL_RCC_OscConfig+0x6ec>)
 8009e6e:	4013      	ands	r3, r2
 8009e70:	0019      	movs	r1, r3
 8009e72:	687b      	ldr	r3, [r7, #4]
 8009e74:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009e76:	4b61      	ldr	r3, [pc, #388]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009e78:	430a      	orrs	r2, r1
 8009e7a:	605a      	str	r2, [r3, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8009e7c:	4b5f      	ldr	r3, [pc, #380]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009e7e:	685b      	ldr	r3, [r3, #4]
 8009e80:	021b      	lsls	r3, r3, #8
 8009e82:	0a19      	lsrs	r1, r3, #8
 8009e84:	687b      	ldr	r3, [r7, #4]
 8009e86:	6a1b      	ldr	r3, [r3, #32]
 8009e88:	061a      	lsls	r2, r3, #24
 8009e8a:	4b5c      	ldr	r3, [pc, #368]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009e8c:	430a      	orrs	r2, r1
 8009e8e:	605a      	str	r2, [r3, #4]
 8009e90:	e019      	b.n	8009ec6 <HAL_RCC_OscConfig+0x5b2>
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8009e92:	4b5a      	ldr	r3, [pc, #360]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009e94:	681a      	ldr	r2, [r3, #0]
 8009e96:	4b59      	ldr	r3, [pc, #356]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009e98:	495e      	ldr	r1, [pc, #376]	; (800a014 <HAL_RCC_OscConfig+0x700>)
 8009e9a:	400a      	ands	r2, r1
 8009e9c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8009e9e:	f7fd fb21 	bl	80074e4 <HAL_GetTick>
 8009ea2:	0003      	movs	r3, r0
 8009ea4:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 8009ea6:	e008      	b.n	8009eba <HAL_RCC_OscConfig+0x5a6>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8009ea8:	f7fd fb1c 	bl	80074e4 <HAL_GetTick>
 8009eac:	0002      	movs	r2, r0
 8009eae:	697b      	ldr	r3, [r7, #20]
 8009eb0:	1ad3      	subs	r3, r2, r3
 8009eb2:	2b02      	cmp	r3, #2
 8009eb4:	d901      	bls.n	8009eba <HAL_RCC_OscConfig+0x5a6>
          {
            return HAL_TIMEOUT;
 8009eb6:	2303      	movs	r3, #3
 8009eb8:	e2b7      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 8009eba:	4b50      	ldr	r3, [pc, #320]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009ebc:	681a      	ldr	r2, [r3, #0]
 8009ebe:	2380      	movs	r3, #128	; 0x80
 8009ec0:	009b      	lsls	r3, r3, #2
 8009ec2:	4013      	ands	r3, r2
 8009ec4:	d1f0      	bne.n	8009ea8 <HAL_RCC_OscConfig+0x594>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8009ec6:	687b      	ldr	r3, [r7, #4]
 8009ec8:	681b      	ldr	r3, [r3, #0]
 8009eca:	2208      	movs	r2, #8
 8009ecc:	4013      	ands	r3, r2
 8009ece:	d044      	beq.n	8009f5a <HAL_RCC_OscConfig+0x646>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 8009ed0:	687b      	ldr	r3, [r7, #4]
 8009ed2:	695b      	ldr	r3, [r3, #20]
 8009ed4:	2b00      	cmp	r3, #0
 8009ed6:	d009      	beq.n	8009eec <HAL_RCC_OscConfig+0x5d8>
 8009ed8:	687b      	ldr	r3, [r7, #4]
 8009eda:	695b      	ldr	r3, [r3, #20]
 8009edc:	2b01      	cmp	r3, #1
 8009ede:	d005      	beq.n	8009eec <HAL_RCC_OscConfig+0x5d8>
 8009ee0:	4a4d      	ldr	r2, [pc, #308]	; (800a018 <HAL_RCC_OscConfig+0x704>)
 8009ee2:	4b44      	ldr	r3, [pc, #272]	; (8009ff4 <HAL_RCC_OscConfig+0x6e0>)
 8009ee4:	0011      	movs	r1, r2
 8009ee6:	0018      	movs	r0, r3
 8009ee8:	f7fc f9d5 	bl	8006296 <assert_failed>

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8009eec:	687b      	ldr	r3, [r7, #4]
 8009eee:	695b      	ldr	r3, [r3, #20]
 8009ef0:	2b00      	cmp	r3, #0
 8009ef2:	d019      	beq.n	8009f28 <HAL_RCC_OscConfig+0x614>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8009ef4:	4b41      	ldr	r3, [pc, #260]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009ef6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8009ef8:	4b40      	ldr	r3, [pc, #256]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009efa:	2101      	movs	r1, #1
 8009efc:	430a      	orrs	r2, r1
 8009efe:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8009f00:	f7fd faf0 	bl	80074e4 <HAL_GetTick>
 8009f04:	0003      	movs	r3, r0
 8009f06:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8009f08:	e008      	b.n	8009f1c <HAL_RCC_OscConfig+0x608>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8009f0a:	f7fd faeb 	bl	80074e4 <HAL_GetTick>
 8009f0e:	0002      	movs	r2, r0
 8009f10:	697b      	ldr	r3, [r7, #20]
 8009f12:	1ad3      	subs	r3, r2, r3
 8009f14:	2b02      	cmp	r3, #2
 8009f16:	d901      	bls.n	8009f1c <HAL_RCC_OscConfig+0x608>
        {
          return HAL_TIMEOUT;
 8009f18:	2303      	movs	r3, #3
 8009f1a:	e286      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8009f1c:	4b37      	ldr	r3, [pc, #220]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009f1e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009f20:	2202      	movs	r2, #2
 8009f22:	4013      	ands	r3, r2
 8009f24:	d0f1      	beq.n	8009f0a <HAL_RCC_OscConfig+0x5f6>
 8009f26:	e018      	b.n	8009f5a <HAL_RCC_OscConfig+0x646>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8009f28:	4b34      	ldr	r3, [pc, #208]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009f2a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8009f2c:	4b33      	ldr	r3, [pc, #204]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009f2e:	2101      	movs	r1, #1
 8009f30:	438a      	bics	r2, r1
 8009f32:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8009f34:	f7fd fad6 	bl	80074e4 <HAL_GetTick>
 8009f38:	0003      	movs	r3, r0
 8009f3a:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8009f3c:	e008      	b.n	8009f50 <HAL_RCC_OscConfig+0x63c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8009f3e:	f7fd fad1 	bl	80074e4 <HAL_GetTick>
 8009f42:	0002      	movs	r2, r0
 8009f44:	697b      	ldr	r3, [r7, #20]
 8009f46:	1ad3      	subs	r3, r2, r3
 8009f48:	2b02      	cmp	r3, #2
 8009f4a:	d901      	bls.n	8009f50 <HAL_RCC_OscConfig+0x63c>
        {
          return HAL_TIMEOUT;
 8009f4c:	2303      	movs	r3, #3
 8009f4e:	e26c      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8009f50:	4b2a      	ldr	r3, [pc, #168]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009f52:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009f54:	2202      	movs	r2, #2
 8009f56:	4013      	ands	r3, r2
 8009f58:	d1f1      	bne.n	8009f3e <HAL_RCC_OscConfig+0x62a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8009f5a:	687b      	ldr	r3, [r7, #4]
 8009f5c:	681b      	ldr	r3, [r3, #0]
 8009f5e:	2204      	movs	r2, #4
 8009f60:	4013      	ands	r3, r2
 8009f62:	d100      	bne.n	8009f66 <HAL_RCC_OscConfig+0x652>
 8009f64:	e0de      	b.n	800a124 <HAL_RCC_OscConfig+0x810>
  {
    FlagStatus       pwrclkchanged = RESET;
 8009f66:	2323      	movs	r3, #35	; 0x23
 8009f68:	18fb      	adds	r3, r7, r3
 8009f6a:	2200      	movs	r2, #0
 8009f6c:	701a      	strb	r2, [r3, #0]

    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8009f6e:	687b      	ldr	r3, [r7, #4]
 8009f70:	689b      	ldr	r3, [r3, #8]
 8009f72:	2b00      	cmp	r3, #0
 8009f74:	d011      	beq.n	8009f9a <HAL_RCC_OscConfig+0x686>
 8009f76:	687b      	ldr	r3, [r7, #4]
 8009f78:	689a      	ldr	r2, [r3, #8]
 8009f7a:	2380      	movs	r3, #128	; 0x80
 8009f7c:	005b      	lsls	r3, r3, #1
 8009f7e:	429a      	cmp	r2, r3
 8009f80:	d00b      	beq.n	8009f9a <HAL_RCC_OscConfig+0x686>
 8009f82:	687b      	ldr	r3, [r7, #4]
 8009f84:	689a      	ldr	r2, [r3, #8]
 8009f86:	23a0      	movs	r3, #160	; 0xa0
 8009f88:	00db      	lsls	r3, r3, #3
 8009f8a:	429a      	cmp	r2, r3
 8009f8c:	d005      	beq.n	8009f9a <HAL_RCC_OscConfig+0x686>
 8009f8e:	4a23      	ldr	r2, [pc, #140]	; (800a01c <HAL_RCC_OscConfig+0x708>)
 8009f90:	4b18      	ldr	r3, [pc, #96]	; (8009ff4 <HAL_RCC_OscConfig+0x6e0>)
 8009f92:	0011      	movs	r1, r2
 8009f94:	0018      	movs	r0, r3
 8009f96:	f7fc f97e 	bl	8006296 <assert_failed>

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8009f9a:	4b18      	ldr	r3, [pc, #96]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009f9c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009f9e:	2380      	movs	r3, #128	; 0x80
 8009fa0:	055b      	lsls	r3, r3, #21
 8009fa2:	4013      	ands	r3, r2
 8009fa4:	d10a      	bne.n	8009fbc <HAL_RCC_OscConfig+0x6a8>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8009fa6:	4b15      	ldr	r3, [pc, #84]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009fa8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009faa:	4b14      	ldr	r3, [pc, #80]	; (8009ffc <HAL_RCC_OscConfig+0x6e8>)
 8009fac:	2180      	movs	r1, #128	; 0x80
 8009fae:	0549      	lsls	r1, r1, #21
 8009fb0:	430a      	orrs	r2, r1
 8009fb2:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 8009fb4:	2323      	movs	r3, #35	; 0x23
 8009fb6:	18fb      	adds	r3, r7, r3
 8009fb8:	2201      	movs	r2, #1
 8009fba:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8009fbc:	4b18      	ldr	r3, [pc, #96]	; (800a020 <HAL_RCC_OscConfig+0x70c>)
 8009fbe:	681a      	ldr	r2, [r3, #0]
 8009fc0:	2380      	movs	r3, #128	; 0x80
 8009fc2:	005b      	lsls	r3, r3, #1
 8009fc4:	4013      	ands	r3, r2
 8009fc6:	d133      	bne.n	800a030 <HAL_RCC_OscConfig+0x71c>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8009fc8:	4b15      	ldr	r3, [pc, #84]	; (800a020 <HAL_RCC_OscConfig+0x70c>)
 8009fca:	681a      	ldr	r2, [r3, #0]
 8009fcc:	4b14      	ldr	r3, [pc, #80]	; (800a020 <HAL_RCC_OscConfig+0x70c>)
 8009fce:	2180      	movs	r1, #128	; 0x80
 8009fd0:	0049      	lsls	r1, r1, #1
 8009fd2:	430a      	orrs	r2, r1
 8009fd4:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8009fd6:	f7fd fa85 	bl	80074e4 <HAL_GetTick>
 8009fda:	0003      	movs	r3, r0
 8009fdc:	617b      	str	r3, [r7, #20]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8009fde:	e021      	b.n	800a024 <HAL_RCC_OscConfig+0x710>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8009fe0:	f7fd fa80 	bl	80074e4 <HAL_GetTick>
 8009fe4:	0002      	movs	r2, r0
 8009fe6:	697b      	ldr	r3, [r7, #20]
 8009fe8:	1ad3      	subs	r3, r2, r3
 8009fea:	2b64      	cmp	r3, #100	; 0x64
 8009fec:	d91a      	bls.n	800a024 <HAL_RCC_OscConfig+0x710>
        {
          return HAL_TIMEOUT;
 8009fee:	2303      	movs	r3, #3
 8009ff0:	e21b      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
 8009ff2:	46c0      	nop			; (mov r8, r8)
 8009ff4:	0800de60 	.word	0x0800de60
 8009ff8:	00000201 	.word	0x00000201
 8009ffc:	40021000 	.word	0x40021000
 800a000:	ffff1fff 	.word	0xffff1fff
 800a004:	0800f234 	.word	0x0800f234
 800a008:	2000004c 	.word	0x2000004c
 800a00c:	20000050 	.word	0x20000050
 800a010:	0000022d 	.word	0x0000022d
 800a014:	fffffeff 	.word	0xfffffeff
 800a018:	0000024b 	.word	0x0000024b
 800a01c:	00000277 	.word	0x00000277
 800a020:	40007000 	.word	0x40007000
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800a024:	4bca      	ldr	r3, [pc, #808]	; (800a350 <HAL_RCC_OscConfig+0xa3c>)
 800a026:	681a      	ldr	r2, [r3, #0]
 800a028:	2380      	movs	r3, #128	; 0x80
 800a02a:	005b      	lsls	r3, r3, #1
 800a02c:	4013      	ands	r3, r2
 800a02e:	d0d7      	beq.n	8009fe0 <HAL_RCC_OscConfig+0x6cc>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800a030:	687b      	ldr	r3, [r7, #4]
 800a032:	689a      	ldr	r2, [r3, #8]
 800a034:	2380      	movs	r3, #128	; 0x80
 800a036:	005b      	lsls	r3, r3, #1
 800a038:	429a      	cmp	r2, r3
 800a03a:	d107      	bne.n	800a04c <HAL_RCC_OscConfig+0x738>
 800a03c:	4bc5      	ldr	r3, [pc, #788]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a03e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a040:	4bc4      	ldr	r3, [pc, #784]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a042:	2180      	movs	r1, #128	; 0x80
 800a044:	0049      	lsls	r1, r1, #1
 800a046:	430a      	orrs	r2, r1
 800a048:	651a      	str	r2, [r3, #80]	; 0x50
 800a04a:	e031      	b.n	800a0b0 <HAL_RCC_OscConfig+0x79c>
 800a04c:	687b      	ldr	r3, [r7, #4]
 800a04e:	689b      	ldr	r3, [r3, #8]
 800a050:	2b00      	cmp	r3, #0
 800a052:	d10c      	bne.n	800a06e <HAL_RCC_OscConfig+0x75a>
 800a054:	4bbf      	ldr	r3, [pc, #764]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a056:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a058:	4bbe      	ldr	r3, [pc, #760]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a05a:	49bf      	ldr	r1, [pc, #764]	; (800a358 <HAL_RCC_OscConfig+0xa44>)
 800a05c:	400a      	ands	r2, r1
 800a05e:	651a      	str	r2, [r3, #80]	; 0x50
 800a060:	4bbc      	ldr	r3, [pc, #752]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a062:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a064:	4bbb      	ldr	r3, [pc, #748]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a066:	49bd      	ldr	r1, [pc, #756]	; (800a35c <HAL_RCC_OscConfig+0xa48>)
 800a068:	400a      	ands	r2, r1
 800a06a:	651a      	str	r2, [r3, #80]	; 0x50
 800a06c:	e020      	b.n	800a0b0 <HAL_RCC_OscConfig+0x79c>
 800a06e:	687b      	ldr	r3, [r7, #4]
 800a070:	689a      	ldr	r2, [r3, #8]
 800a072:	23a0      	movs	r3, #160	; 0xa0
 800a074:	00db      	lsls	r3, r3, #3
 800a076:	429a      	cmp	r2, r3
 800a078:	d10e      	bne.n	800a098 <HAL_RCC_OscConfig+0x784>
 800a07a:	4bb6      	ldr	r3, [pc, #728]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a07c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a07e:	4bb5      	ldr	r3, [pc, #724]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a080:	2180      	movs	r1, #128	; 0x80
 800a082:	00c9      	lsls	r1, r1, #3
 800a084:	430a      	orrs	r2, r1
 800a086:	651a      	str	r2, [r3, #80]	; 0x50
 800a088:	4bb2      	ldr	r3, [pc, #712]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a08a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a08c:	4bb1      	ldr	r3, [pc, #708]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a08e:	2180      	movs	r1, #128	; 0x80
 800a090:	0049      	lsls	r1, r1, #1
 800a092:	430a      	orrs	r2, r1
 800a094:	651a      	str	r2, [r3, #80]	; 0x50
 800a096:	e00b      	b.n	800a0b0 <HAL_RCC_OscConfig+0x79c>
 800a098:	4bae      	ldr	r3, [pc, #696]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a09a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a09c:	4bad      	ldr	r3, [pc, #692]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a09e:	49ae      	ldr	r1, [pc, #696]	; (800a358 <HAL_RCC_OscConfig+0xa44>)
 800a0a0:	400a      	ands	r2, r1
 800a0a2:	651a      	str	r2, [r3, #80]	; 0x50
 800a0a4:	4bab      	ldr	r3, [pc, #684]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a0a6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a0a8:	4baa      	ldr	r3, [pc, #680]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a0aa:	49ac      	ldr	r1, [pc, #688]	; (800a35c <HAL_RCC_OscConfig+0xa48>)
 800a0ac:	400a      	ands	r2, r1
 800a0ae:	651a      	str	r2, [r3, #80]	; 0x50

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800a0b0:	687b      	ldr	r3, [r7, #4]
 800a0b2:	689b      	ldr	r3, [r3, #8]
 800a0b4:	2b00      	cmp	r3, #0
 800a0b6:	d015      	beq.n	800a0e4 <HAL_RCC_OscConfig+0x7d0>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800a0b8:	f7fd fa14 	bl	80074e4 <HAL_GetTick>
 800a0bc:	0003      	movs	r3, r0
 800a0be:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800a0c0:	e009      	b.n	800a0d6 <HAL_RCC_OscConfig+0x7c2>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800a0c2:	f7fd fa0f 	bl	80074e4 <HAL_GetTick>
 800a0c6:	0002      	movs	r2, r0
 800a0c8:	697b      	ldr	r3, [r7, #20]
 800a0ca:	1ad3      	subs	r3, r2, r3
 800a0cc:	4aa4      	ldr	r2, [pc, #656]	; (800a360 <HAL_RCC_OscConfig+0xa4c>)
 800a0ce:	4293      	cmp	r3, r2
 800a0d0:	d901      	bls.n	800a0d6 <HAL_RCC_OscConfig+0x7c2>
        {
          return HAL_TIMEOUT;
 800a0d2:	2303      	movs	r3, #3
 800a0d4:	e1a9      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800a0d6:	4b9f      	ldr	r3, [pc, #636]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a0d8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a0da:	2380      	movs	r3, #128	; 0x80
 800a0dc:	009b      	lsls	r3, r3, #2
 800a0de:	4013      	ands	r3, r2
 800a0e0:	d0ef      	beq.n	800a0c2 <HAL_RCC_OscConfig+0x7ae>
 800a0e2:	e014      	b.n	800a10e <HAL_RCC_OscConfig+0x7fa>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800a0e4:	f7fd f9fe 	bl	80074e4 <HAL_GetTick>
 800a0e8:	0003      	movs	r3, r0
 800a0ea:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800a0ec:	e009      	b.n	800a102 <HAL_RCC_OscConfig+0x7ee>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800a0ee:	f7fd f9f9 	bl	80074e4 <HAL_GetTick>
 800a0f2:	0002      	movs	r2, r0
 800a0f4:	697b      	ldr	r3, [r7, #20]
 800a0f6:	1ad3      	subs	r3, r2, r3
 800a0f8:	4a99      	ldr	r2, [pc, #612]	; (800a360 <HAL_RCC_OscConfig+0xa4c>)
 800a0fa:	4293      	cmp	r3, r2
 800a0fc:	d901      	bls.n	800a102 <HAL_RCC_OscConfig+0x7ee>
        {
          return HAL_TIMEOUT;
 800a0fe:	2303      	movs	r3, #3
 800a100:	e193      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800a102:	4b94      	ldr	r3, [pc, #592]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a104:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a106:	2380      	movs	r3, #128	; 0x80
 800a108:	009b      	lsls	r3, r3, #2
 800a10a:	4013      	ands	r3, r2
 800a10c:	d1ef      	bne.n	800a0ee <HAL_RCC_OscConfig+0x7da>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800a10e:	2323      	movs	r3, #35	; 0x23
 800a110:	18fb      	adds	r3, r7, r3
 800a112:	781b      	ldrb	r3, [r3, #0]
 800a114:	2b01      	cmp	r3, #1
 800a116:	d105      	bne.n	800a124 <HAL_RCC_OscConfig+0x810>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800a118:	4b8e      	ldr	r3, [pc, #568]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a11a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a11c:	4b8d      	ldr	r3, [pc, #564]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a11e:	4991      	ldr	r1, [pc, #580]	; (800a364 <HAL_RCC_OscConfig+0xa50>)
 800a120:	400a      	ands	r2, r1
 800a122:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined(RCC_HSI48_SUPPORT)
  /*----------------------------- HSI48 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800a124:	687b      	ldr	r3, [r7, #4]
 800a126:	681b      	ldr	r3, [r3, #0]
 800a128:	2220      	movs	r2, #32
 800a12a:	4013      	ands	r3, r2
 800a12c:	d057      	beq.n	800a1de <HAL_RCC_OscConfig+0x8ca>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 800a12e:	687b      	ldr	r3, [r7, #4]
 800a130:	699b      	ldr	r3, [r3, #24]
 800a132:	2b00      	cmp	r3, #0
 800a134:	d009      	beq.n	800a14a <HAL_RCC_OscConfig+0x836>
 800a136:	687b      	ldr	r3, [r7, #4]
 800a138:	699b      	ldr	r3, [r3, #24]
 800a13a:	2b01      	cmp	r3, #1
 800a13c:	d005      	beq.n	800a14a <HAL_RCC_OscConfig+0x836>
 800a13e:	4a8a      	ldr	r2, [pc, #552]	; (800a368 <HAL_RCC_OscConfig+0xa54>)
 800a140:	4b8a      	ldr	r3, [pc, #552]	; (800a36c <HAL_RCC_OscConfig+0xa58>)
 800a142:	0011      	movs	r1, r2
 800a144:	0018      	movs	r0, r3
 800a146:	f7fc f8a6 	bl	8006296 <assert_failed>

      /* Check the HSI48 State */
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800a14a:	687b      	ldr	r3, [r7, #4]
 800a14c:	699b      	ldr	r3, [r3, #24]
 800a14e:	2b00      	cmp	r3, #0
 800a150:	d026      	beq.n	800a1a0 <HAL_RCC_OscConfig+0x88c>
      {
        /* Enable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_ENABLE();
 800a152:	4b80      	ldr	r3, [pc, #512]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a154:	689a      	ldr	r2, [r3, #8]
 800a156:	4b7f      	ldr	r3, [pc, #508]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a158:	2101      	movs	r1, #1
 800a15a:	430a      	orrs	r2, r1
 800a15c:	609a      	str	r2, [r3, #8]
 800a15e:	4b7d      	ldr	r3, [pc, #500]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a160:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a162:	4b7c      	ldr	r3, [pc, #496]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a164:	2101      	movs	r1, #1
 800a166:	430a      	orrs	r2, r1
 800a168:	635a      	str	r2, [r3, #52]	; 0x34
 800a16a:	4b81      	ldr	r3, [pc, #516]	; (800a370 <HAL_RCC_OscConfig+0xa5c>)
 800a16c:	6a1a      	ldr	r2, [r3, #32]
 800a16e:	4b80      	ldr	r3, [pc, #512]	; (800a370 <HAL_RCC_OscConfig+0xa5c>)
 800a170:	2180      	movs	r1, #128	; 0x80
 800a172:	0189      	lsls	r1, r1, #6
 800a174:	430a      	orrs	r2, r1
 800a176:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800a178:	f7fd f9b4 	bl	80074e4 <HAL_GetTick>
 800a17c:	0003      	movs	r3, r0
 800a17e:	617b      	str	r3, [r7, #20]

        /* Wait till HSI48 is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800a180:	e008      	b.n	800a194 <HAL_RCC_OscConfig+0x880>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800a182:	f7fd f9af 	bl	80074e4 <HAL_GetTick>
 800a186:	0002      	movs	r2, r0
 800a188:	697b      	ldr	r3, [r7, #20]
 800a18a:	1ad3      	subs	r3, r2, r3
 800a18c:	2b02      	cmp	r3, #2
 800a18e:	d901      	bls.n	800a194 <HAL_RCC_OscConfig+0x880>
          {
            return HAL_TIMEOUT;
 800a190:	2303      	movs	r3, #3
 800a192:	e14a      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800a194:	4b6f      	ldr	r3, [pc, #444]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a196:	689b      	ldr	r3, [r3, #8]
 800a198:	2202      	movs	r2, #2
 800a19a:	4013      	ands	r3, r2
 800a19c:	d0f1      	beq.n	800a182 <HAL_RCC_OscConfig+0x86e>
 800a19e:	e01e      	b.n	800a1de <HAL_RCC_OscConfig+0x8ca>
        }
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_DISABLE();
 800a1a0:	4b6c      	ldr	r3, [pc, #432]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a1a2:	689a      	ldr	r2, [r3, #8]
 800a1a4:	4b6b      	ldr	r3, [pc, #428]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a1a6:	2101      	movs	r1, #1
 800a1a8:	438a      	bics	r2, r1
 800a1aa:	609a      	str	r2, [r3, #8]
 800a1ac:	4b70      	ldr	r3, [pc, #448]	; (800a370 <HAL_RCC_OscConfig+0xa5c>)
 800a1ae:	6a1a      	ldr	r2, [r3, #32]
 800a1b0:	4b6f      	ldr	r3, [pc, #444]	; (800a370 <HAL_RCC_OscConfig+0xa5c>)
 800a1b2:	4970      	ldr	r1, [pc, #448]	; (800a374 <HAL_RCC_OscConfig+0xa60>)
 800a1b4:	400a      	ands	r2, r1
 800a1b6:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800a1b8:	f7fd f994 	bl	80074e4 <HAL_GetTick>
 800a1bc:	0003      	movs	r3, r0
 800a1be:	617b      	str	r3, [r7, #20]

        /* Wait till HSI48 is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800a1c0:	e008      	b.n	800a1d4 <HAL_RCC_OscConfig+0x8c0>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800a1c2:	f7fd f98f 	bl	80074e4 <HAL_GetTick>
 800a1c6:	0002      	movs	r2, r0
 800a1c8:	697b      	ldr	r3, [r7, #20]
 800a1ca:	1ad3      	subs	r3, r2, r3
 800a1cc:	2b02      	cmp	r3, #2
 800a1ce:	d901      	bls.n	800a1d4 <HAL_RCC_OscConfig+0x8c0>
          {
            return HAL_TIMEOUT;
 800a1d0:	2303      	movs	r3, #3
 800a1d2:	e12a      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800a1d4:	4b5f      	ldr	r3, [pc, #380]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a1d6:	689b      	ldr	r3, [r3, #8]
 800a1d8:	2202      	movs	r2, #2
 800a1da:	4013      	ands	r3, r2
 800a1dc:	d1f1      	bne.n	800a1c2 <HAL_RCC_OscConfig+0x8ae>
  }
#endif /* RCC_HSI48_SUPPORT */

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 800a1de:	687b      	ldr	r3, [r7, #4]
 800a1e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a1e2:	2b00      	cmp	r3, #0
 800a1e4:	d00d      	beq.n	800a202 <HAL_RCC_OscConfig+0x8ee>
 800a1e6:	687b      	ldr	r3, [r7, #4]
 800a1e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a1ea:	2b01      	cmp	r3, #1
 800a1ec:	d009      	beq.n	800a202 <HAL_RCC_OscConfig+0x8ee>
 800a1ee:	687b      	ldr	r3, [r7, #4]
 800a1f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a1f2:	2b02      	cmp	r3, #2
 800a1f4:	d005      	beq.n	800a202 <HAL_RCC_OscConfig+0x8ee>
 800a1f6:	4a60      	ldr	r2, [pc, #384]	; (800a378 <HAL_RCC_OscConfig+0xa64>)
 800a1f8:	4b5c      	ldr	r3, [pc, #368]	; (800a36c <HAL_RCC_OscConfig+0xa58>)
 800a1fa:	0011      	movs	r1, r2
 800a1fc:	0018      	movs	r0, r3
 800a1fe:	f7fc f84a 	bl	8006296 <assert_failed>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800a202:	687b      	ldr	r3, [r7, #4]
 800a204:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a206:	2b00      	cmp	r3, #0
 800a208:	d100      	bne.n	800a20c <HAL_RCC_OscConfig+0x8f8>
 800a20a:	e10d      	b.n	800a428 <HAL_RCC_OscConfig+0xb14>
  {
    /* Check if the PLL is used as system clock or not */
    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800a20c:	69fb      	ldr	r3, [r7, #28]
 800a20e:	2b0c      	cmp	r3, #12
 800a210:	d100      	bne.n	800a214 <HAL_RCC_OscConfig+0x900>
 800a212:	e0e6      	b.n	800a3e2 <HAL_RCC_OscConfig+0xace>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800a214:	687b      	ldr	r3, [r7, #4]
 800a216:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a218:	2b02      	cmp	r3, #2
 800a21a:	d000      	beq.n	800a21e <HAL_RCC_OscConfig+0x90a>
 800a21c:	e0c6      	b.n	800a3ac <HAL_RCC_OscConfig+0xa98>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 800a21e:	687b      	ldr	r3, [r7, #4]
 800a220:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a222:	2b00      	cmp	r3, #0
 800a224:	d00b      	beq.n	800a23e <HAL_RCC_OscConfig+0x92a>
 800a226:	687b      	ldr	r3, [r7, #4]
 800a228:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a22a:	2380      	movs	r3, #128	; 0x80
 800a22c:	025b      	lsls	r3, r3, #9
 800a22e:	429a      	cmp	r2, r3
 800a230:	d005      	beq.n	800a23e <HAL_RCC_OscConfig+0x92a>
 800a232:	4a52      	ldr	r2, [pc, #328]	; (800a37c <HAL_RCC_OscConfig+0xa68>)
 800a234:	4b4d      	ldr	r3, [pc, #308]	; (800a36c <HAL_RCC_OscConfig+0xa58>)
 800a236:	0011      	movs	r1, r2
 800a238:	0018      	movs	r0, r3
 800a23a:	f7fc f82c 	bl	8006296 <assert_failed>
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
 800a23e:	687b      	ldr	r3, [r7, #4]
 800a240:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a242:	2b00      	cmp	r3, #0
 800a244:	d035      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a246:	687b      	ldr	r3, [r7, #4]
 800a248:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a24a:	2380      	movs	r3, #128	; 0x80
 800a24c:	02db      	lsls	r3, r3, #11
 800a24e:	429a      	cmp	r2, r3
 800a250:	d02f      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a252:	687b      	ldr	r3, [r7, #4]
 800a254:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a256:	2380      	movs	r3, #128	; 0x80
 800a258:	031b      	lsls	r3, r3, #12
 800a25a:	429a      	cmp	r2, r3
 800a25c:	d029      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a25e:	687b      	ldr	r3, [r7, #4]
 800a260:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a262:	23c0      	movs	r3, #192	; 0xc0
 800a264:	031b      	lsls	r3, r3, #12
 800a266:	429a      	cmp	r2, r3
 800a268:	d023      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a26a:	687b      	ldr	r3, [r7, #4]
 800a26c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a26e:	2380      	movs	r3, #128	; 0x80
 800a270:	035b      	lsls	r3, r3, #13
 800a272:	429a      	cmp	r2, r3
 800a274:	d01d      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a276:	687b      	ldr	r3, [r7, #4]
 800a278:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a27a:	23a0      	movs	r3, #160	; 0xa0
 800a27c:	035b      	lsls	r3, r3, #13
 800a27e:	429a      	cmp	r2, r3
 800a280:	d017      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a282:	687b      	ldr	r3, [r7, #4]
 800a284:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a286:	23c0      	movs	r3, #192	; 0xc0
 800a288:	035b      	lsls	r3, r3, #13
 800a28a:	429a      	cmp	r2, r3
 800a28c:	d011      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a28e:	687b      	ldr	r3, [r7, #4]
 800a290:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a292:	23e0      	movs	r3, #224	; 0xe0
 800a294:	035b      	lsls	r3, r3, #13
 800a296:	429a      	cmp	r2, r3
 800a298:	d00b      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a29a:	687b      	ldr	r3, [r7, #4]
 800a29c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a29e:	2380      	movs	r3, #128	; 0x80
 800a2a0:	039b      	lsls	r3, r3, #14
 800a2a2:	429a      	cmp	r2, r3
 800a2a4:	d005      	beq.n	800a2b2 <HAL_RCC_OscConfig+0x99e>
 800a2a6:	4a36      	ldr	r2, [pc, #216]	; (800a380 <HAL_RCC_OscConfig+0xa6c>)
 800a2a8:	4b30      	ldr	r3, [pc, #192]	; (800a36c <HAL_RCC_OscConfig+0xa58>)
 800a2aa:	0011      	movs	r1, r2
 800a2ac:	0018      	movs	r0, r3
 800a2ae:	f7fb fff2 	bl	8006296 <assert_failed>
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
 800a2b2:	687b      	ldr	r3, [r7, #4]
 800a2b4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a2b6:	2380      	movs	r3, #128	; 0x80
 800a2b8:	03db      	lsls	r3, r3, #15
 800a2ba:	429a      	cmp	r2, r3
 800a2bc:	d012      	beq.n	800a2e4 <HAL_RCC_OscConfig+0x9d0>
 800a2be:	687b      	ldr	r3, [r7, #4]
 800a2c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a2c2:	2380      	movs	r3, #128	; 0x80
 800a2c4:	041b      	lsls	r3, r3, #16
 800a2c6:	429a      	cmp	r2, r3
 800a2c8:	d00c      	beq.n	800a2e4 <HAL_RCC_OscConfig+0x9d0>
 800a2ca:	687b      	ldr	r3, [r7, #4]
 800a2cc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a2ce:	23c0      	movs	r3, #192	; 0xc0
 800a2d0:	041b      	lsls	r3, r3, #16
 800a2d2:	429a      	cmp	r2, r3
 800a2d4:	d006      	beq.n	800a2e4 <HAL_RCC_OscConfig+0x9d0>
 800a2d6:	23bd      	movs	r3, #189	; 0xbd
 800a2d8:	009a      	lsls	r2, r3, #2
 800a2da:	4b24      	ldr	r3, [pc, #144]	; (800a36c <HAL_RCC_OscConfig+0xa58>)
 800a2dc:	0011      	movs	r1, r2
 800a2de:	0018      	movs	r0, r3
 800a2e0:	f7fb ffd9 	bl	8006296 <assert_failed>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800a2e4:	4b1b      	ldr	r3, [pc, #108]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a2e6:	681a      	ldr	r2, [r3, #0]
 800a2e8:	4b1a      	ldr	r3, [pc, #104]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a2ea:	4926      	ldr	r1, [pc, #152]	; (800a384 <HAL_RCC_OscConfig+0xa70>)
 800a2ec:	400a      	ands	r2, r1
 800a2ee:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800a2f0:	f7fd f8f8 	bl	80074e4 <HAL_GetTick>
 800a2f4:	0003      	movs	r3, r0
 800a2f6:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800a2f8:	e008      	b.n	800a30c <HAL_RCC_OscConfig+0x9f8>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800a2fa:	f7fd f8f3 	bl	80074e4 <HAL_GetTick>
 800a2fe:	0002      	movs	r2, r0
 800a300:	697b      	ldr	r3, [r7, #20]
 800a302:	1ad3      	subs	r3, r2, r3
 800a304:	2b02      	cmp	r3, #2
 800a306:	d901      	bls.n	800a30c <HAL_RCC_OscConfig+0x9f8>
          {
            return HAL_TIMEOUT;
 800a308:	2303      	movs	r3, #3
 800a30a:	e08e      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800a30c:	4b11      	ldr	r3, [pc, #68]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a30e:	681a      	ldr	r2, [r3, #0]
 800a310:	2380      	movs	r3, #128	; 0x80
 800a312:	049b      	lsls	r3, r3, #18
 800a314:	4013      	ands	r3, r2
 800a316:	d1f0      	bne.n	800a2fa <HAL_RCC_OscConfig+0x9e6>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800a318:	4b0e      	ldr	r3, [pc, #56]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a31a:	68db      	ldr	r3, [r3, #12]
 800a31c:	4a1a      	ldr	r2, [pc, #104]	; (800a388 <HAL_RCC_OscConfig+0xa74>)
 800a31e:	4013      	ands	r3, r2
 800a320:	0019      	movs	r1, r3
 800a322:	687b      	ldr	r3, [r7, #4]
 800a324:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a326:	687b      	ldr	r3, [r7, #4]
 800a328:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a32a:	431a      	orrs	r2, r3
 800a32c:	687b      	ldr	r3, [r7, #4]
 800a32e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a330:	431a      	orrs	r2, r3
 800a332:	4b08      	ldr	r3, [pc, #32]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a334:	430a      	orrs	r2, r1
 800a336:	60da      	str	r2, [r3, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800a338:	4b06      	ldr	r3, [pc, #24]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a33a:	681a      	ldr	r2, [r3, #0]
 800a33c:	4b05      	ldr	r3, [pc, #20]	; (800a354 <HAL_RCC_OscConfig+0xa40>)
 800a33e:	2180      	movs	r1, #128	; 0x80
 800a340:	0449      	lsls	r1, r1, #17
 800a342:	430a      	orrs	r2, r1
 800a344:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800a346:	f7fd f8cd 	bl	80074e4 <HAL_GetTick>
 800a34a:	0003      	movs	r3, r0
 800a34c:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 800a34e:	e026      	b.n	800a39e <HAL_RCC_OscConfig+0xa8a>
 800a350:	40007000 	.word	0x40007000
 800a354:	40021000 	.word	0x40021000
 800a358:	fffffeff 	.word	0xfffffeff
 800a35c:	fffffbff 	.word	0xfffffbff
 800a360:	00001388 	.word	0x00001388
 800a364:	efffffff 	.word	0xefffffff
 800a368:	000002bf 	.word	0x000002bf
 800a36c:	0800de60 	.word	0x0800de60
 800a370:	40010000 	.word	0x40010000
 800a374:	ffffdfff 	.word	0xffffdfff
 800a378:	000002e9 	.word	0x000002e9
 800a37c:	000002f2 	.word	0x000002f2
 800a380:	000002f3 	.word	0x000002f3
 800a384:	feffffff 	.word	0xfeffffff
 800a388:	ff02ffff 	.word	0xff02ffff
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800a38c:	f7fd f8aa 	bl	80074e4 <HAL_GetTick>
 800a390:	0002      	movs	r2, r0
 800a392:	697b      	ldr	r3, [r7, #20]
 800a394:	1ad3      	subs	r3, r2, r3
 800a396:	2b02      	cmp	r3, #2
 800a398:	d901      	bls.n	800a39e <HAL_RCC_OscConfig+0xa8a>
          {
            return HAL_TIMEOUT;
 800a39a:	2303      	movs	r3, #3
 800a39c:	e045      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 800a39e:	4b25      	ldr	r3, [pc, #148]	; (800a434 <HAL_RCC_OscConfig+0xb20>)
 800a3a0:	681a      	ldr	r2, [r3, #0]
 800a3a2:	2380      	movs	r3, #128	; 0x80
 800a3a4:	049b      	lsls	r3, r3, #18
 800a3a6:	4013      	ands	r3, r2
 800a3a8:	d0f0      	beq.n	800a38c <HAL_RCC_OscConfig+0xa78>
 800a3aa:	e03d      	b.n	800a428 <HAL_RCC_OscConfig+0xb14>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800a3ac:	4b21      	ldr	r3, [pc, #132]	; (800a434 <HAL_RCC_OscConfig+0xb20>)
 800a3ae:	681a      	ldr	r2, [r3, #0]
 800a3b0:	4b20      	ldr	r3, [pc, #128]	; (800a434 <HAL_RCC_OscConfig+0xb20>)
 800a3b2:	4921      	ldr	r1, [pc, #132]	; (800a438 <HAL_RCC_OscConfig+0xb24>)
 800a3b4:	400a      	ands	r2, r1
 800a3b6:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800a3b8:	f7fd f894 	bl	80074e4 <HAL_GetTick>
 800a3bc:	0003      	movs	r3, r0
 800a3be:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800a3c0:	e008      	b.n	800a3d4 <HAL_RCC_OscConfig+0xac0>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800a3c2:	f7fd f88f 	bl	80074e4 <HAL_GetTick>
 800a3c6:	0002      	movs	r2, r0
 800a3c8:	697b      	ldr	r3, [r7, #20]
 800a3ca:	1ad3      	subs	r3, r2, r3
 800a3cc:	2b02      	cmp	r3, #2
 800a3ce:	d901      	bls.n	800a3d4 <HAL_RCC_OscConfig+0xac0>
          {
            return HAL_TIMEOUT;
 800a3d0:	2303      	movs	r3, #3
 800a3d2:	e02a      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800a3d4:	4b17      	ldr	r3, [pc, #92]	; (800a434 <HAL_RCC_OscConfig+0xb20>)
 800a3d6:	681a      	ldr	r2, [r3, #0]
 800a3d8:	2380      	movs	r3, #128	; 0x80
 800a3da:	049b      	lsls	r3, r3, #18
 800a3dc:	4013      	ands	r3, r2
 800a3de:	d1f0      	bne.n	800a3c2 <HAL_RCC_OscConfig+0xaae>
 800a3e0:	e022      	b.n	800a428 <HAL_RCC_OscConfig+0xb14>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800a3e2:	687b      	ldr	r3, [r7, #4]
 800a3e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a3e6:	2b01      	cmp	r3, #1
 800a3e8:	d101      	bne.n	800a3ee <HAL_RCC_OscConfig+0xada>
      {
        return HAL_ERROR;
 800a3ea:	2301      	movs	r3, #1
 800a3ec:	e01d      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 800a3ee:	4b11      	ldr	r3, [pc, #68]	; (800a434 <HAL_RCC_OscConfig+0xb20>)
 800a3f0:	68db      	ldr	r3, [r3, #12]
 800a3f2:	61bb      	str	r3, [r7, #24]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800a3f4:	69ba      	ldr	r2, [r7, #24]
 800a3f6:	2380      	movs	r3, #128	; 0x80
 800a3f8:	025b      	lsls	r3, r3, #9
 800a3fa:	401a      	ands	r2, r3
 800a3fc:	687b      	ldr	r3, [r7, #4]
 800a3fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a400:	429a      	cmp	r2, r3
 800a402:	d10f      	bne.n	800a424 <HAL_RCC_OscConfig+0xb10>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 800a404:	69ba      	ldr	r2, [r7, #24]
 800a406:	23f0      	movs	r3, #240	; 0xf0
 800a408:	039b      	lsls	r3, r3, #14
 800a40a:	401a      	ands	r2, r3
 800a40c:	687b      	ldr	r3, [r7, #4]
 800a40e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800a410:	429a      	cmp	r2, r3
 800a412:	d107      	bne.n	800a424 <HAL_RCC_OscConfig+0xb10>
           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
 800a414:	69ba      	ldr	r2, [r7, #24]
 800a416:	23c0      	movs	r3, #192	; 0xc0
 800a418:	041b      	lsls	r3, r3, #16
 800a41a:	401a      	ands	r2, r3
 800a41c:	687b      	ldr	r3, [r7, #4]
 800a41e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 800a420:	429a      	cmp	r2, r3
 800a422:	d001      	beq.n	800a428 <HAL_RCC_OscConfig+0xb14>
        {
          return HAL_ERROR;
 800a424:	2301      	movs	r3, #1
 800a426:	e000      	b.n	800a42a <HAL_RCC_OscConfig+0xb16>
        }
      }
    }
  }
  return HAL_OK;
 800a428:	2300      	movs	r3, #0
}
 800a42a:	0018      	movs	r0, r3
 800a42c:	46bd      	mov	sp, r7
 800a42e:	b00a      	add	sp, #40	; 0x28
 800a430:	bdb0      	pop	{r4, r5, r7, pc}
 800a432:	46c0      	nop			; (mov r8, r8)
 800a434:	40021000 	.word	0x40021000
 800a438:	feffffff 	.word	0xfeffffff

0800a43c <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800a43c:	b5b0      	push	{r4, r5, r7, lr}
 800a43e:	b084      	sub	sp, #16
 800a440:	af00      	add	r7, sp, #0
 800a442:	6078      	str	r0, [r7, #4]
 800a444:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800a446:	687b      	ldr	r3, [r7, #4]
 800a448:	2b00      	cmp	r3, #0
 800a44a:	d101      	bne.n	800a450 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800a44c:	2301      	movs	r3, #1
 800a44e:	e1e1      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
  }

  /* Check the parameters */
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 800a450:	687b      	ldr	r3, [r7, #4]
 800a452:	681b      	ldr	r3, [r3, #0]
 800a454:	2201      	movs	r2, #1
 800a456:	4013      	ands	r3, r2
 800a458:	d114      	bne.n	800a484 <HAL_RCC_ClockConfig+0x48>
 800a45a:	687b      	ldr	r3, [r7, #4]
 800a45c:	681b      	ldr	r3, [r3, #0]
 800a45e:	2202      	movs	r2, #2
 800a460:	4013      	ands	r3, r2
 800a462:	d10f      	bne.n	800a484 <HAL_RCC_ClockConfig+0x48>
 800a464:	687b      	ldr	r3, [r7, #4]
 800a466:	681b      	ldr	r3, [r3, #0]
 800a468:	2204      	movs	r2, #4
 800a46a:	4013      	ands	r3, r2
 800a46c:	d10a      	bne.n	800a484 <HAL_RCC_ClockConfig+0x48>
 800a46e:	687b      	ldr	r3, [r7, #4]
 800a470:	681b      	ldr	r3, [r3, #0]
 800a472:	2208      	movs	r2, #8
 800a474:	4013      	ands	r3, r2
 800a476:	d105      	bne.n	800a484 <HAL_RCC_ClockConfig+0x48>
 800a478:	4a9b      	ldr	r2, [pc, #620]	; (800a6e8 <HAL_RCC_ClockConfig+0x2ac>)
 800a47a:	4b9c      	ldr	r3, [pc, #624]	; (800a6ec <HAL_RCC_ClockConfig+0x2b0>)
 800a47c:	0011      	movs	r1, r2
 800a47e:	0018      	movs	r0, r3
 800a480:	f7fb ff09 	bl	8006296 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
 800a484:	683b      	ldr	r3, [r7, #0]
 800a486:	2b00      	cmp	r3, #0
 800a488:	d009      	beq.n	800a49e <HAL_RCC_ClockConfig+0x62>
 800a48a:	683b      	ldr	r3, [r7, #0]
 800a48c:	2b01      	cmp	r3, #1
 800a48e:	d006      	beq.n	800a49e <HAL_RCC_ClockConfig+0x62>
 800a490:	23da      	movs	r3, #218	; 0xda
 800a492:	009a      	lsls	r2, r3, #2
 800a494:	4b95      	ldr	r3, [pc, #596]	; (800a6ec <HAL_RCC_ClockConfig+0x2b0>)
 800a496:	0011      	movs	r1, r2
 800a498:	0018      	movs	r0, r3
 800a49a:	f7fb fefc 	bl	8006296 <assert_failed>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
  must be correctly programmed according to the frequency of the CPU clock
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800a49e:	4b94      	ldr	r3, [pc, #592]	; (800a6f0 <HAL_RCC_ClockConfig+0x2b4>)
 800a4a0:	681b      	ldr	r3, [r3, #0]
 800a4a2:	2201      	movs	r2, #1
 800a4a4:	4013      	ands	r3, r2
 800a4a6:	683a      	ldr	r2, [r7, #0]
 800a4a8:	429a      	cmp	r2, r3
 800a4aa:	d91e      	bls.n	800a4ea <HAL_RCC_ClockConfig+0xae>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800a4ac:	4b90      	ldr	r3, [pc, #576]	; (800a6f0 <HAL_RCC_ClockConfig+0x2b4>)
 800a4ae:	681b      	ldr	r3, [r3, #0]
 800a4b0:	2201      	movs	r2, #1
 800a4b2:	4393      	bics	r3, r2
 800a4b4:	0019      	movs	r1, r3
 800a4b6:	4b8e      	ldr	r3, [pc, #568]	; (800a6f0 <HAL_RCC_ClockConfig+0x2b4>)
 800a4b8:	683a      	ldr	r2, [r7, #0]
 800a4ba:	430a      	orrs	r2, r1
 800a4bc:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 800a4be:	f7fd f811 	bl	80074e4 <HAL_GetTick>
 800a4c2:	0003      	movs	r3, r0
 800a4c4:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a4c6:	e009      	b.n	800a4dc <HAL_RCC_ClockConfig+0xa0>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a4c8:	f7fd f80c 	bl	80074e4 <HAL_GetTick>
 800a4cc:	0002      	movs	r2, r0
 800a4ce:	68fb      	ldr	r3, [r7, #12]
 800a4d0:	1ad3      	subs	r3, r2, r3
 800a4d2:	4a88      	ldr	r2, [pc, #544]	; (800a6f4 <HAL_RCC_ClockConfig+0x2b8>)
 800a4d4:	4293      	cmp	r3, r2
 800a4d6:	d901      	bls.n	800a4dc <HAL_RCC_ClockConfig+0xa0>
      {
        return HAL_TIMEOUT;
 800a4d8:	2303      	movs	r3, #3
 800a4da:	e19b      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a4dc:	4b84      	ldr	r3, [pc, #528]	; (800a6f0 <HAL_RCC_ClockConfig+0x2b4>)
 800a4de:	681b      	ldr	r3, [r3, #0]
 800a4e0:	2201      	movs	r2, #1
 800a4e2:	4013      	ands	r3, r2
 800a4e4:	683a      	ldr	r2, [r7, #0]
 800a4e6:	429a      	cmp	r2, r3
 800a4e8:	d1ee      	bne.n	800a4c8 <HAL_RCC_ClockConfig+0x8c>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800a4ea:	687b      	ldr	r3, [r7, #4]
 800a4ec:	681b      	ldr	r3, [r3, #0]
 800a4ee:	2202      	movs	r2, #2
 800a4f0:	4013      	ands	r3, r2
 800a4f2:	d034      	beq.n	800a55e <HAL_RCC_ClockConfig+0x122>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 800a4f4:	687b      	ldr	r3, [r7, #4]
 800a4f6:	689b      	ldr	r3, [r3, #8]
 800a4f8:	2b00      	cmp	r3, #0
 800a4fa:	d026      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a4fc:	687b      	ldr	r3, [r7, #4]
 800a4fe:	689b      	ldr	r3, [r3, #8]
 800a500:	2b80      	cmp	r3, #128	; 0x80
 800a502:	d022      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a504:	687b      	ldr	r3, [r7, #4]
 800a506:	689b      	ldr	r3, [r3, #8]
 800a508:	2b90      	cmp	r3, #144	; 0x90
 800a50a:	d01e      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a50c:	687b      	ldr	r3, [r7, #4]
 800a50e:	689b      	ldr	r3, [r3, #8]
 800a510:	2ba0      	cmp	r3, #160	; 0xa0
 800a512:	d01a      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a514:	687b      	ldr	r3, [r7, #4]
 800a516:	689b      	ldr	r3, [r3, #8]
 800a518:	2bb0      	cmp	r3, #176	; 0xb0
 800a51a:	d016      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a51c:	687b      	ldr	r3, [r7, #4]
 800a51e:	689b      	ldr	r3, [r3, #8]
 800a520:	2bc0      	cmp	r3, #192	; 0xc0
 800a522:	d012      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a524:	687b      	ldr	r3, [r7, #4]
 800a526:	689b      	ldr	r3, [r3, #8]
 800a528:	2bd0      	cmp	r3, #208	; 0xd0
 800a52a:	d00e      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a52c:	687b      	ldr	r3, [r7, #4]
 800a52e:	689b      	ldr	r3, [r3, #8]
 800a530:	2be0      	cmp	r3, #224	; 0xe0
 800a532:	d00a      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a534:	687b      	ldr	r3, [r7, #4]
 800a536:	689b      	ldr	r3, [r3, #8]
 800a538:	2bf0      	cmp	r3, #240	; 0xf0
 800a53a:	d006      	beq.n	800a54a <HAL_RCC_ClockConfig+0x10e>
 800a53c:	23e1      	movs	r3, #225	; 0xe1
 800a53e:	009a      	lsls	r2, r3, #2
 800a540:	4b6a      	ldr	r3, [pc, #424]	; (800a6ec <HAL_RCC_ClockConfig+0x2b0>)
 800a542:	0011      	movs	r1, r2
 800a544:	0018      	movs	r0, r3
 800a546:	f7fb fea6 	bl	8006296 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800a54a:	4b6b      	ldr	r3, [pc, #428]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a54c:	68db      	ldr	r3, [r3, #12]
 800a54e:	22f0      	movs	r2, #240	; 0xf0
 800a550:	4393      	bics	r3, r2
 800a552:	0019      	movs	r1, r3
 800a554:	687b      	ldr	r3, [r7, #4]
 800a556:	689a      	ldr	r2, [r3, #8]
 800a558:	4b67      	ldr	r3, [pc, #412]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a55a:	430a      	orrs	r2, r1
 800a55c:	60da      	str	r2, [r3, #12]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800a55e:	687b      	ldr	r3, [r7, #4]
 800a560:	681b      	ldr	r3, [r3, #0]
 800a562:	2201      	movs	r2, #1
 800a564:	4013      	ands	r3, r2
 800a566:	d100      	bne.n	800a56a <HAL_RCC_ClockConfig+0x12e>
 800a568:	e09f      	b.n	800a6aa <HAL_RCC_ClockConfig+0x26e>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 800a56a:	687b      	ldr	r3, [r7, #4]
 800a56c:	685b      	ldr	r3, [r3, #4]
 800a56e:	2b00      	cmp	r3, #0
 800a570:	d011      	beq.n	800a596 <HAL_RCC_ClockConfig+0x15a>
 800a572:	687b      	ldr	r3, [r7, #4]
 800a574:	685b      	ldr	r3, [r3, #4]
 800a576:	2b01      	cmp	r3, #1
 800a578:	d00d      	beq.n	800a596 <HAL_RCC_ClockConfig+0x15a>
 800a57a:	687b      	ldr	r3, [r7, #4]
 800a57c:	685b      	ldr	r3, [r3, #4]
 800a57e:	2b02      	cmp	r3, #2
 800a580:	d009      	beq.n	800a596 <HAL_RCC_ClockConfig+0x15a>
 800a582:	687b      	ldr	r3, [r7, #4]
 800a584:	685b      	ldr	r3, [r3, #4]
 800a586:	2b03      	cmp	r3, #3
 800a588:	d005      	beq.n	800a596 <HAL_RCC_ClockConfig+0x15a>
 800a58a:	4a5c      	ldr	r2, [pc, #368]	; (800a6fc <HAL_RCC_ClockConfig+0x2c0>)
 800a58c:	4b57      	ldr	r3, [pc, #348]	; (800a6ec <HAL_RCC_ClockConfig+0x2b0>)
 800a58e:	0011      	movs	r1, r2
 800a590:	0018      	movs	r0, r3
 800a592:	f7fb fe80 	bl	8006296 <assert_failed>

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800a596:	687b      	ldr	r3, [r7, #4]
 800a598:	685b      	ldr	r3, [r3, #4]
 800a59a:	2b02      	cmp	r3, #2
 800a59c:	d107      	bne.n	800a5ae <HAL_RCC_ClockConfig+0x172>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800a59e:	4b56      	ldr	r3, [pc, #344]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a5a0:	681a      	ldr	r2, [r3, #0]
 800a5a2:	2380      	movs	r3, #128	; 0x80
 800a5a4:	029b      	lsls	r3, r3, #10
 800a5a6:	4013      	ands	r3, r2
 800a5a8:	d120      	bne.n	800a5ec <HAL_RCC_ClockConfig+0x1b0>
      {
        return HAL_ERROR;
 800a5aa:	2301      	movs	r3, #1
 800a5ac:	e132      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800a5ae:	687b      	ldr	r3, [r7, #4]
 800a5b0:	685b      	ldr	r3, [r3, #4]
 800a5b2:	2b03      	cmp	r3, #3
 800a5b4:	d107      	bne.n	800a5c6 <HAL_RCC_ClockConfig+0x18a>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800a5b6:	4b50      	ldr	r3, [pc, #320]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a5b8:	681a      	ldr	r2, [r3, #0]
 800a5ba:	2380      	movs	r3, #128	; 0x80
 800a5bc:	049b      	lsls	r3, r3, #18
 800a5be:	4013      	ands	r3, r2
 800a5c0:	d114      	bne.n	800a5ec <HAL_RCC_ClockConfig+0x1b0>
      {
        return HAL_ERROR;
 800a5c2:	2301      	movs	r3, #1
 800a5c4:	e126      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800a5c6:	687b      	ldr	r3, [r7, #4]
 800a5c8:	685b      	ldr	r3, [r3, #4]
 800a5ca:	2b01      	cmp	r3, #1
 800a5cc:	d106      	bne.n	800a5dc <HAL_RCC_ClockConfig+0x1a0>
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800a5ce:	4b4a      	ldr	r3, [pc, #296]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a5d0:	681b      	ldr	r3, [r3, #0]
 800a5d2:	2204      	movs	r2, #4
 800a5d4:	4013      	ands	r3, r2
 800a5d6:	d109      	bne.n	800a5ec <HAL_RCC_ClockConfig+0x1b0>
      {
        return HAL_ERROR;
 800a5d8:	2301      	movs	r3, #1
 800a5da:	e11b      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800a5dc:	4b46      	ldr	r3, [pc, #280]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a5de:	681a      	ldr	r2, [r3, #0]
 800a5e0:	2380      	movs	r3, #128	; 0x80
 800a5e2:	009b      	lsls	r3, r3, #2
 800a5e4:	4013      	ands	r3, r2
 800a5e6:	d101      	bne.n	800a5ec <HAL_RCC_ClockConfig+0x1b0>
      {
        return HAL_ERROR;
 800a5e8:	2301      	movs	r3, #1
 800a5ea:	e113      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800a5ec:	4b42      	ldr	r3, [pc, #264]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a5ee:	68db      	ldr	r3, [r3, #12]
 800a5f0:	2203      	movs	r2, #3
 800a5f2:	4393      	bics	r3, r2
 800a5f4:	0019      	movs	r1, r3
 800a5f6:	687b      	ldr	r3, [r7, #4]
 800a5f8:	685a      	ldr	r2, [r3, #4]
 800a5fa:	4b3f      	ldr	r3, [pc, #252]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a5fc:	430a      	orrs	r2, r1
 800a5fe:	60da      	str	r2, [r3, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800a600:	f7fc ff70 	bl	80074e4 <HAL_GetTick>
 800a604:	0003      	movs	r3, r0
 800a606:	60fb      	str	r3, [r7, #12]

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800a608:	687b      	ldr	r3, [r7, #4]
 800a60a:	685b      	ldr	r3, [r3, #4]
 800a60c:	2b02      	cmp	r3, #2
 800a60e:	d111      	bne.n	800a634 <HAL_RCC_ClockConfig+0x1f8>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800a610:	e009      	b.n	800a626 <HAL_RCC_ClockConfig+0x1ea>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a612:	f7fc ff67 	bl	80074e4 <HAL_GetTick>
 800a616:	0002      	movs	r2, r0
 800a618:	68fb      	ldr	r3, [r7, #12]
 800a61a:	1ad3      	subs	r3, r2, r3
 800a61c:	4a35      	ldr	r2, [pc, #212]	; (800a6f4 <HAL_RCC_ClockConfig+0x2b8>)
 800a61e:	4293      	cmp	r3, r2
 800a620:	d901      	bls.n	800a626 <HAL_RCC_ClockConfig+0x1ea>
        {
          return HAL_TIMEOUT;
 800a622:	2303      	movs	r3, #3
 800a624:	e0f6      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800a626:	4b34      	ldr	r3, [pc, #208]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a628:	68db      	ldr	r3, [r3, #12]
 800a62a:	220c      	movs	r2, #12
 800a62c:	4013      	ands	r3, r2
 800a62e:	2b08      	cmp	r3, #8
 800a630:	d1ef      	bne.n	800a612 <HAL_RCC_ClockConfig+0x1d6>
 800a632:	e03a      	b.n	800a6aa <HAL_RCC_ClockConfig+0x26e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800a634:	687b      	ldr	r3, [r7, #4]
 800a636:	685b      	ldr	r3, [r3, #4]
 800a638:	2b03      	cmp	r3, #3
 800a63a:	d111      	bne.n	800a660 <HAL_RCC_ClockConfig+0x224>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800a63c:	e009      	b.n	800a652 <HAL_RCC_ClockConfig+0x216>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a63e:	f7fc ff51 	bl	80074e4 <HAL_GetTick>
 800a642:	0002      	movs	r2, r0
 800a644:	68fb      	ldr	r3, [r7, #12]
 800a646:	1ad3      	subs	r3, r2, r3
 800a648:	4a2a      	ldr	r2, [pc, #168]	; (800a6f4 <HAL_RCC_ClockConfig+0x2b8>)
 800a64a:	4293      	cmp	r3, r2
 800a64c:	d901      	bls.n	800a652 <HAL_RCC_ClockConfig+0x216>
        {
          return HAL_TIMEOUT;
 800a64e:	2303      	movs	r3, #3
 800a650:	e0e0      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800a652:	4b29      	ldr	r3, [pc, #164]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a654:	68db      	ldr	r3, [r3, #12]
 800a656:	220c      	movs	r2, #12
 800a658:	4013      	ands	r3, r2
 800a65a:	2b0c      	cmp	r3, #12
 800a65c:	d1ef      	bne.n	800a63e <HAL_RCC_ClockConfig+0x202>
 800a65e:	e024      	b.n	800a6aa <HAL_RCC_ClockConfig+0x26e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800a660:	687b      	ldr	r3, [r7, #4]
 800a662:	685b      	ldr	r3, [r3, #4]
 800a664:	2b01      	cmp	r3, #1
 800a666:	d11b      	bne.n	800a6a0 <HAL_RCC_ClockConfig+0x264>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800a668:	e009      	b.n	800a67e <HAL_RCC_ClockConfig+0x242>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a66a:	f7fc ff3b 	bl	80074e4 <HAL_GetTick>
 800a66e:	0002      	movs	r2, r0
 800a670:	68fb      	ldr	r3, [r7, #12]
 800a672:	1ad3      	subs	r3, r2, r3
 800a674:	4a1f      	ldr	r2, [pc, #124]	; (800a6f4 <HAL_RCC_ClockConfig+0x2b8>)
 800a676:	4293      	cmp	r3, r2
 800a678:	d901      	bls.n	800a67e <HAL_RCC_ClockConfig+0x242>
        {
          return HAL_TIMEOUT;
 800a67a:	2303      	movs	r3, #3
 800a67c:	e0ca      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800a67e:	4b1e      	ldr	r3, [pc, #120]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a680:	68db      	ldr	r3, [r3, #12]
 800a682:	220c      	movs	r2, #12
 800a684:	4013      	ands	r3, r2
 800a686:	2b04      	cmp	r3, #4
 800a688:	d1ef      	bne.n	800a66a <HAL_RCC_ClockConfig+0x22e>
 800a68a:	e00e      	b.n	800a6aa <HAL_RCC_ClockConfig+0x26e>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a68c:	f7fc ff2a 	bl	80074e4 <HAL_GetTick>
 800a690:	0002      	movs	r2, r0
 800a692:	68fb      	ldr	r3, [r7, #12]
 800a694:	1ad3      	subs	r3, r2, r3
 800a696:	4a17      	ldr	r2, [pc, #92]	; (800a6f4 <HAL_RCC_ClockConfig+0x2b8>)
 800a698:	4293      	cmp	r3, r2
 800a69a:	d901      	bls.n	800a6a0 <HAL_RCC_ClockConfig+0x264>
        {
          return HAL_TIMEOUT;
 800a69c:	2303      	movs	r3, #3
 800a69e:	e0b9      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 800a6a0:	4b15      	ldr	r3, [pc, #84]	; (800a6f8 <HAL_RCC_ClockConfig+0x2bc>)
 800a6a2:	68db      	ldr	r3, [r3, #12]
 800a6a4:	220c      	movs	r2, #12
 800a6a6:	4013      	ands	r3, r2
 800a6a8:	d1f0      	bne.n	800a68c <HAL_RCC_ClockConfig+0x250>
        }
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800a6aa:	4b11      	ldr	r3, [pc, #68]	; (800a6f0 <HAL_RCC_ClockConfig+0x2b4>)
 800a6ac:	681b      	ldr	r3, [r3, #0]
 800a6ae:	2201      	movs	r2, #1
 800a6b0:	4013      	ands	r3, r2
 800a6b2:	683a      	ldr	r2, [r7, #0]
 800a6b4:	429a      	cmp	r2, r3
 800a6b6:	d22a      	bcs.n	800a70e <HAL_RCC_ClockConfig+0x2d2>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800a6b8:	4b0d      	ldr	r3, [pc, #52]	; (800a6f0 <HAL_RCC_ClockConfig+0x2b4>)
 800a6ba:	681b      	ldr	r3, [r3, #0]
 800a6bc:	2201      	movs	r2, #1
 800a6be:	4393      	bics	r3, r2
 800a6c0:	0019      	movs	r1, r3
 800a6c2:	4b0b      	ldr	r3, [pc, #44]	; (800a6f0 <HAL_RCC_ClockConfig+0x2b4>)
 800a6c4:	683a      	ldr	r2, [r7, #0]
 800a6c6:	430a      	orrs	r2, r1
 800a6c8:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 800a6ca:	f7fc ff0b 	bl	80074e4 <HAL_GetTick>
 800a6ce:	0003      	movs	r3, r0
 800a6d0:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a6d2:	e015      	b.n	800a700 <HAL_RCC_ClockConfig+0x2c4>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a6d4:	f7fc ff06 	bl	80074e4 <HAL_GetTick>
 800a6d8:	0002      	movs	r2, r0
 800a6da:	68fb      	ldr	r3, [r7, #12]
 800a6dc:	1ad3      	subs	r3, r2, r3
 800a6de:	4a05      	ldr	r2, [pc, #20]	; (800a6f4 <HAL_RCC_ClockConfig+0x2b8>)
 800a6e0:	4293      	cmp	r3, r2
 800a6e2:	d90d      	bls.n	800a700 <HAL_RCC_ClockConfig+0x2c4>
      {
        return HAL_TIMEOUT;
 800a6e4:	2303      	movs	r3, #3
 800a6e6:	e095      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
 800a6e8:	00000367 	.word	0x00000367
 800a6ec:	0800de60 	.word	0x0800de60
 800a6f0:	40022000 	.word	0x40022000
 800a6f4:	00001388 	.word	0x00001388
 800a6f8:	40021000 	.word	0x40021000
 800a6fc:	0000038b 	.word	0x0000038b
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a700:	4b46      	ldr	r3, [pc, #280]	; (800a81c <HAL_RCC_ClockConfig+0x3e0>)
 800a702:	681b      	ldr	r3, [r3, #0]
 800a704:	2201      	movs	r2, #1
 800a706:	4013      	ands	r3, r2
 800a708:	683a      	ldr	r2, [r7, #0]
 800a70a:	429a      	cmp	r2, r3
 800a70c:	d1e2      	bne.n	800a6d4 <HAL_RCC_ClockConfig+0x298>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800a70e:	687b      	ldr	r3, [r7, #4]
 800a710:	681b      	ldr	r3, [r3, #0]
 800a712:	2204      	movs	r2, #4
 800a714:	4013      	ands	r3, r2
 800a716:	d02b      	beq.n	800a770 <HAL_RCC_ClockConfig+0x334>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 800a718:	687b      	ldr	r3, [r7, #4]
 800a71a:	68db      	ldr	r3, [r3, #12]
 800a71c:	2b00      	cmp	r3, #0
 800a71e:	d01d      	beq.n	800a75c <HAL_RCC_ClockConfig+0x320>
 800a720:	687b      	ldr	r3, [r7, #4]
 800a722:	68da      	ldr	r2, [r3, #12]
 800a724:	2380      	movs	r3, #128	; 0x80
 800a726:	00db      	lsls	r3, r3, #3
 800a728:	429a      	cmp	r2, r3
 800a72a:	d017      	beq.n	800a75c <HAL_RCC_ClockConfig+0x320>
 800a72c:	687b      	ldr	r3, [r7, #4]
 800a72e:	68da      	ldr	r2, [r3, #12]
 800a730:	23a0      	movs	r3, #160	; 0xa0
 800a732:	00db      	lsls	r3, r3, #3
 800a734:	429a      	cmp	r2, r3
 800a736:	d011      	beq.n	800a75c <HAL_RCC_ClockConfig+0x320>
 800a738:	687b      	ldr	r3, [r7, #4]
 800a73a:	68da      	ldr	r2, [r3, #12]
 800a73c:	23c0      	movs	r3, #192	; 0xc0
 800a73e:	00db      	lsls	r3, r3, #3
 800a740:	429a      	cmp	r2, r3
 800a742:	d00b      	beq.n	800a75c <HAL_RCC_ClockConfig+0x320>
 800a744:	687b      	ldr	r3, [r7, #4]
 800a746:	68da      	ldr	r2, [r3, #12]
 800a748:	23e0      	movs	r3, #224	; 0xe0
 800a74a:	00db      	lsls	r3, r3, #3
 800a74c:	429a      	cmp	r2, r3
 800a74e:	d005      	beq.n	800a75c <HAL_RCC_ClockConfig+0x320>
 800a750:	4a33      	ldr	r2, [pc, #204]	; (800a820 <HAL_RCC_ClockConfig+0x3e4>)
 800a752:	4b34      	ldr	r3, [pc, #208]	; (800a824 <HAL_RCC_ClockConfig+0x3e8>)
 800a754:	0011      	movs	r1, r2
 800a756:	0018      	movs	r0, r3
 800a758:	f7fb fd9d 	bl	8006296 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800a75c:	4b32      	ldr	r3, [pc, #200]	; (800a828 <HAL_RCC_ClockConfig+0x3ec>)
 800a75e:	68db      	ldr	r3, [r3, #12]
 800a760:	4a32      	ldr	r2, [pc, #200]	; (800a82c <HAL_RCC_ClockConfig+0x3f0>)
 800a762:	4013      	ands	r3, r2
 800a764:	0019      	movs	r1, r3
 800a766:	687b      	ldr	r3, [r7, #4]
 800a768:	68da      	ldr	r2, [r3, #12]
 800a76a:	4b2f      	ldr	r3, [pc, #188]	; (800a828 <HAL_RCC_ClockConfig+0x3ec>)
 800a76c:	430a      	orrs	r2, r1
 800a76e:	60da      	str	r2, [r3, #12]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800a770:	687b      	ldr	r3, [r7, #4]
 800a772:	681b      	ldr	r3, [r3, #0]
 800a774:	2208      	movs	r2, #8
 800a776:	4013      	ands	r3, r2
 800a778:	d02d      	beq.n	800a7d6 <HAL_RCC_ClockConfig+0x39a>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
 800a77a:	687b      	ldr	r3, [r7, #4]
 800a77c:	691b      	ldr	r3, [r3, #16]
 800a77e:	2b00      	cmp	r3, #0
 800a780:	d01e      	beq.n	800a7c0 <HAL_RCC_ClockConfig+0x384>
 800a782:	687b      	ldr	r3, [r7, #4]
 800a784:	691a      	ldr	r2, [r3, #16]
 800a786:	2380      	movs	r3, #128	; 0x80
 800a788:	00db      	lsls	r3, r3, #3
 800a78a:	429a      	cmp	r2, r3
 800a78c:	d018      	beq.n	800a7c0 <HAL_RCC_ClockConfig+0x384>
 800a78e:	687b      	ldr	r3, [r7, #4]
 800a790:	691a      	ldr	r2, [r3, #16]
 800a792:	23a0      	movs	r3, #160	; 0xa0
 800a794:	00db      	lsls	r3, r3, #3
 800a796:	429a      	cmp	r2, r3
 800a798:	d012      	beq.n	800a7c0 <HAL_RCC_ClockConfig+0x384>
 800a79a:	687b      	ldr	r3, [r7, #4]
 800a79c:	691a      	ldr	r2, [r3, #16]
 800a79e:	23c0      	movs	r3, #192	; 0xc0
 800a7a0:	00db      	lsls	r3, r3, #3
 800a7a2:	429a      	cmp	r2, r3
 800a7a4:	d00c      	beq.n	800a7c0 <HAL_RCC_ClockConfig+0x384>
 800a7a6:	687b      	ldr	r3, [r7, #4]
 800a7a8:	691a      	ldr	r2, [r3, #16]
 800a7aa:	23e0      	movs	r3, #224	; 0xe0
 800a7ac:	00db      	lsls	r3, r3, #3
 800a7ae:	429a      	cmp	r2, r3
 800a7b0:	d006      	beq.n	800a7c0 <HAL_RCC_ClockConfig+0x384>
 800a7b2:	23ff      	movs	r3, #255	; 0xff
 800a7b4:	009a      	lsls	r2, r3, #2
 800a7b6:	4b1b      	ldr	r3, [pc, #108]	; (800a824 <HAL_RCC_ClockConfig+0x3e8>)
 800a7b8:	0011      	movs	r1, r2
 800a7ba:	0018      	movs	r0, r3
 800a7bc:	f7fb fd6b 	bl	8006296 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800a7c0:	4b19      	ldr	r3, [pc, #100]	; (800a828 <HAL_RCC_ClockConfig+0x3ec>)
 800a7c2:	68db      	ldr	r3, [r3, #12]
 800a7c4:	4a1a      	ldr	r2, [pc, #104]	; (800a830 <HAL_RCC_ClockConfig+0x3f4>)
 800a7c6:	4013      	ands	r3, r2
 800a7c8:	0019      	movs	r1, r3
 800a7ca:	687b      	ldr	r3, [r7, #4]
 800a7cc:	691b      	ldr	r3, [r3, #16]
 800a7ce:	00da      	lsls	r2, r3, #3
 800a7d0:	4b15      	ldr	r3, [pc, #84]	; (800a828 <HAL_RCC_ClockConfig+0x3ec>)
 800a7d2:	430a      	orrs	r2, r1
 800a7d4:	60da      	str	r2, [r3, #12]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800a7d6:	f000 f833 	bl	800a840 <HAL_RCC_GetSysClockFreq>
 800a7da:	0001      	movs	r1, r0
 800a7dc:	4b12      	ldr	r3, [pc, #72]	; (800a828 <HAL_RCC_ClockConfig+0x3ec>)
 800a7de:	68db      	ldr	r3, [r3, #12]
 800a7e0:	091b      	lsrs	r3, r3, #4
 800a7e2:	220f      	movs	r2, #15
 800a7e4:	4013      	ands	r3, r2
 800a7e6:	4a13      	ldr	r2, [pc, #76]	; (800a834 <HAL_RCC_ClockConfig+0x3f8>)
 800a7e8:	5cd3      	ldrb	r3, [r2, r3]
 800a7ea:	000a      	movs	r2, r1
 800a7ec:	40da      	lsrs	r2, r3
 800a7ee:	4b12      	ldr	r3, [pc, #72]	; (800a838 <HAL_RCC_ClockConfig+0x3fc>)
 800a7f0:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 800a7f2:	4b12      	ldr	r3, [pc, #72]	; (800a83c <HAL_RCC_ClockConfig+0x400>)
 800a7f4:	681b      	ldr	r3, [r3, #0]
 800a7f6:	250b      	movs	r5, #11
 800a7f8:	197c      	adds	r4, r7, r5
 800a7fa:	0018      	movs	r0, r3
 800a7fc:	f7fc fe2c 	bl	8007458 <HAL_InitTick>
 800a800:	0003      	movs	r3, r0
 800a802:	7023      	strb	r3, [r4, #0]
  if(status != HAL_OK)
 800a804:	197b      	adds	r3, r7, r5
 800a806:	781b      	ldrb	r3, [r3, #0]
 800a808:	2b00      	cmp	r3, #0
 800a80a:	d002      	beq.n	800a812 <HAL_RCC_ClockConfig+0x3d6>
  {
    return status;
 800a80c:	197b      	adds	r3, r7, r5
 800a80e:	781b      	ldrb	r3, [r3, #0]
 800a810:	e000      	b.n	800a814 <HAL_RCC_ClockConfig+0x3d8>
  }

  return HAL_OK;
 800a812:	2300      	movs	r3, #0
}
 800a814:	0018      	movs	r0, r3
 800a816:	46bd      	mov	sp, r7
 800a818:	b004      	add	sp, #16
 800a81a:	bdb0      	pop	{r4, r5, r7, pc}
 800a81c:	40022000 	.word	0x40022000
 800a820:	000003f5 	.word	0x000003f5
 800a824:	0800de60 	.word	0x0800de60
 800a828:	40021000 	.word	0x40021000
 800a82c:	fffff8ff 	.word	0xfffff8ff
 800a830:	ffffc7ff 	.word	0xffffc7ff
 800a834:	0800f234 	.word	0x0800f234
 800a838:	2000004c 	.word	0x2000004c
 800a83c:	20000050 	.word	0x20000050

0800a840 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800a840:	b5b0      	push	{r4, r5, r7, lr}
 800a842:	b08e      	sub	sp, #56	; 0x38
 800a844:	af00      	add	r7, sp, #0
  uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
  uint32_t sysclockfreq;

  tmpreg = RCC->CFGR;
 800a846:	4b4c      	ldr	r3, [pc, #304]	; (800a978 <HAL_RCC_GetSysClockFreq+0x138>)
 800a848:	68db      	ldr	r3, [r3, #12]
 800a84a:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 800a84c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a84e:	230c      	movs	r3, #12
 800a850:	4013      	ands	r3, r2
 800a852:	2b0c      	cmp	r3, #12
 800a854:	d014      	beq.n	800a880 <HAL_RCC_GetSysClockFreq+0x40>
 800a856:	d900      	bls.n	800a85a <HAL_RCC_GetSysClockFreq+0x1a>
 800a858:	e07b      	b.n	800a952 <HAL_RCC_GetSysClockFreq+0x112>
 800a85a:	2b04      	cmp	r3, #4
 800a85c:	d002      	beq.n	800a864 <HAL_RCC_GetSysClockFreq+0x24>
 800a85e:	2b08      	cmp	r3, #8
 800a860:	d00b      	beq.n	800a87a <HAL_RCC_GetSysClockFreq+0x3a>
 800a862:	e076      	b.n	800a952 <HAL_RCC_GetSysClockFreq+0x112>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 800a864:	4b44      	ldr	r3, [pc, #272]	; (800a978 <HAL_RCC_GetSysClockFreq+0x138>)
 800a866:	681b      	ldr	r3, [r3, #0]
 800a868:	2210      	movs	r2, #16
 800a86a:	4013      	ands	r3, r2
 800a86c:	d002      	beq.n	800a874 <HAL_RCC_GetSysClockFreq+0x34>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 800a86e:	4b43      	ldr	r3, [pc, #268]	; (800a97c <HAL_RCC_GetSysClockFreq+0x13c>)
 800a870:	633b      	str	r3, [r7, #48]	; 0x30
      }
      else
      {
        sysclockfreq =  HSI_VALUE;
      }
      break;
 800a872:	e07c      	b.n	800a96e <HAL_RCC_GetSysClockFreq+0x12e>
        sysclockfreq =  HSI_VALUE;
 800a874:	4b42      	ldr	r3, [pc, #264]	; (800a980 <HAL_RCC_GetSysClockFreq+0x140>)
 800a876:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 800a878:	e079      	b.n	800a96e <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 800a87a:	4b42      	ldr	r3, [pc, #264]	; (800a984 <HAL_RCC_GetSysClockFreq+0x144>)
 800a87c:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 800a87e:	e076      	b.n	800a96e <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 800a880:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a882:	0c9a      	lsrs	r2, r3, #18
 800a884:	230f      	movs	r3, #15
 800a886:	401a      	ands	r2, r3
 800a888:	4b3f      	ldr	r3, [pc, #252]	; (800a988 <HAL_RCC_GetSysClockFreq+0x148>)
 800a88a:	5c9b      	ldrb	r3, [r3, r2]
 800a88c:	62bb      	str	r3, [r7, #40]	; 0x28
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
 800a88e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a890:	0d9a      	lsrs	r2, r3, #22
 800a892:	2303      	movs	r3, #3
 800a894:	4013      	ands	r3, r2
 800a896:	3301      	adds	r3, #1
 800a898:	627b      	str	r3, [r7, #36]	; 0x24
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800a89a:	4b37      	ldr	r3, [pc, #220]	; (800a978 <HAL_RCC_GetSysClockFreq+0x138>)
 800a89c:	68da      	ldr	r2, [r3, #12]
 800a89e:	2380      	movs	r3, #128	; 0x80
 800a8a0:	025b      	lsls	r3, r3, #9
 800a8a2:	4013      	ands	r3, r2
 800a8a4:	d01a      	beq.n	800a8dc <HAL_RCC_GetSysClockFreq+0x9c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)(((uint64_t)HSE_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 800a8a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a8a8:	61bb      	str	r3, [r7, #24]
 800a8aa:	2300      	movs	r3, #0
 800a8ac:	61fb      	str	r3, [r7, #28]
 800a8ae:	4a35      	ldr	r2, [pc, #212]	; (800a984 <HAL_RCC_GetSysClockFreq+0x144>)
 800a8b0:	2300      	movs	r3, #0
 800a8b2:	69b8      	ldr	r0, [r7, #24]
 800a8b4:	69f9      	ldr	r1, [r7, #28]
 800a8b6:	f7f5 fde1 	bl	800047c <__aeabi_lmul>
 800a8ba:	0002      	movs	r2, r0
 800a8bc:	000b      	movs	r3, r1
 800a8be:	0010      	movs	r0, r2
 800a8c0:	0019      	movs	r1, r3
 800a8c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a8c4:	613b      	str	r3, [r7, #16]
 800a8c6:	2300      	movs	r3, #0
 800a8c8:	617b      	str	r3, [r7, #20]
 800a8ca:	693a      	ldr	r2, [r7, #16]
 800a8cc:	697b      	ldr	r3, [r7, #20]
 800a8ce:	f7f5 fdb5 	bl	800043c <__aeabi_uldivmod>
 800a8d2:	0002      	movs	r2, r0
 800a8d4:	000b      	movs	r3, r1
 800a8d6:	0013      	movs	r3, r2
 800a8d8:	637b      	str	r3, [r7, #52]	; 0x34
 800a8da:	e037      	b.n	800a94c <HAL_RCC_GetSysClockFreq+0x10c>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 800a8dc:	4b26      	ldr	r3, [pc, #152]	; (800a978 <HAL_RCC_GetSysClockFreq+0x138>)
 800a8de:	681b      	ldr	r3, [r3, #0]
 800a8e0:	2210      	movs	r2, #16
 800a8e2:	4013      	ands	r3, r2
 800a8e4:	d01a      	beq.n	800a91c <HAL_RCC_GetSysClockFreq+0xdc>
        {
          pllvco = (uint32_t)((((uint64_t)(HSI_VALUE >> 2)) * (uint64_t)pllm) / (uint64_t)plld);
 800a8e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a8e8:	60bb      	str	r3, [r7, #8]
 800a8ea:	2300      	movs	r3, #0
 800a8ec:	60fb      	str	r3, [r7, #12]
 800a8ee:	4a23      	ldr	r2, [pc, #140]	; (800a97c <HAL_RCC_GetSysClockFreq+0x13c>)
 800a8f0:	2300      	movs	r3, #0
 800a8f2:	68b8      	ldr	r0, [r7, #8]
 800a8f4:	68f9      	ldr	r1, [r7, #12]
 800a8f6:	f7f5 fdc1 	bl	800047c <__aeabi_lmul>
 800a8fa:	0002      	movs	r2, r0
 800a8fc:	000b      	movs	r3, r1
 800a8fe:	0010      	movs	r0, r2
 800a900:	0019      	movs	r1, r3
 800a902:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a904:	603b      	str	r3, [r7, #0]
 800a906:	2300      	movs	r3, #0
 800a908:	607b      	str	r3, [r7, #4]
 800a90a:	683a      	ldr	r2, [r7, #0]
 800a90c:	687b      	ldr	r3, [r7, #4]
 800a90e:	f7f5 fd95 	bl	800043c <__aeabi_uldivmod>
 800a912:	0002      	movs	r2, r0
 800a914:	000b      	movs	r3, r1
 800a916:	0013      	movs	r3, r2
 800a918:	637b      	str	r3, [r7, #52]	; 0x34
 800a91a:	e017      	b.n	800a94c <HAL_RCC_GetSysClockFreq+0x10c>
        }
        else
        {
         pllvco = (uint32_t)(((uint64_t)HSI_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 800a91c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a91e:	0018      	movs	r0, r3
 800a920:	2300      	movs	r3, #0
 800a922:	0019      	movs	r1, r3
 800a924:	4a16      	ldr	r2, [pc, #88]	; (800a980 <HAL_RCC_GetSysClockFreq+0x140>)
 800a926:	2300      	movs	r3, #0
 800a928:	f7f5 fda8 	bl	800047c <__aeabi_lmul>
 800a92c:	0002      	movs	r2, r0
 800a92e:	000b      	movs	r3, r1
 800a930:	0010      	movs	r0, r2
 800a932:	0019      	movs	r1, r3
 800a934:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a936:	001c      	movs	r4, r3
 800a938:	2300      	movs	r3, #0
 800a93a:	001d      	movs	r5, r3
 800a93c:	0022      	movs	r2, r4
 800a93e:	002b      	movs	r3, r5
 800a940:	f7f5 fd7c 	bl	800043c <__aeabi_uldivmod>
 800a944:	0002      	movs	r2, r0
 800a946:	000b      	movs	r3, r1
 800a948:	0013      	movs	r3, r2
 800a94a:	637b      	str	r3, [r7, #52]	; 0x34
        }
      }
      sysclockfreq = pllvco;
 800a94c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a94e:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 800a950:	e00d      	b.n	800a96e <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
 800a952:	4b09      	ldr	r3, [pc, #36]	; (800a978 <HAL_RCC_GetSysClockFreq+0x138>)
 800a954:	685b      	ldr	r3, [r3, #4]
 800a956:	0b5b      	lsrs	r3, r3, #13
 800a958:	2207      	movs	r2, #7
 800a95a:	4013      	ands	r3, r2
 800a95c:	623b      	str	r3, [r7, #32]
      sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
 800a95e:	6a3b      	ldr	r3, [r7, #32]
 800a960:	3301      	adds	r3, #1
 800a962:	2280      	movs	r2, #128	; 0x80
 800a964:	0212      	lsls	r2, r2, #8
 800a966:	409a      	lsls	r2, r3
 800a968:	0013      	movs	r3, r2
 800a96a:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 800a96c:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 800a96e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 800a970:	0018      	movs	r0, r3
 800a972:	46bd      	mov	sp, r7
 800a974:	b00e      	add	sp, #56	; 0x38
 800a976:	bdb0      	pop	{r4, r5, r7, pc}
 800a978:	40021000 	.word	0x40021000
 800a97c:	003d0900 	.word	0x003d0900
 800a980:	00f42400 	.word	0x00f42400
 800a984:	007a1200 	.word	0x007a1200
 800a988:	0800f24c 	.word	0x0800f24c

0800a98c <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800a98c:	b580      	push	{r7, lr}
 800a98e:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800a990:	4b02      	ldr	r3, [pc, #8]	; (800a99c <HAL_RCC_GetHCLKFreq+0x10>)
 800a992:	681b      	ldr	r3, [r3, #0]
}
 800a994:	0018      	movs	r0, r3
 800a996:	46bd      	mov	sp, r7
 800a998:	bd80      	pop	{r7, pc}
 800a99a:	46c0      	nop			; (mov r8, r8)
 800a99c:	2000004c 	.word	0x2000004c

0800a9a0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800a9a0:	b580      	push	{r7, lr}
 800a9a2:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800a9a4:	f7ff fff2 	bl	800a98c <HAL_RCC_GetHCLKFreq>
 800a9a8:	0001      	movs	r1, r0
 800a9aa:	4b06      	ldr	r3, [pc, #24]	; (800a9c4 <HAL_RCC_GetPCLK1Freq+0x24>)
 800a9ac:	68db      	ldr	r3, [r3, #12]
 800a9ae:	0a1b      	lsrs	r3, r3, #8
 800a9b0:	2207      	movs	r2, #7
 800a9b2:	4013      	ands	r3, r2
 800a9b4:	4a04      	ldr	r2, [pc, #16]	; (800a9c8 <HAL_RCC_GetPCLK1Freq+0x28>)
 800a9b6:	5cd3      	ldrb	r3, [r2, r3]
 800a9b8:	40d9      	lsrs	r1, r3
 800a9ba:	000b      	movs	r3, r1
}
 800a9bc:	0018      	movs	r0, r3
 800a9be:	46bd      	mov	sp, r7
 800a9c0:	bd80      	pop	{r7, pc}
 800a9c2:	46c0      	nop			; (mov r8, r8)
 800a9c4:	40021000 	.word	0x40021000
 800a9c8:	0800f244 	.word	0x0800f244

0800a9cc <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800a9cc:	b580      	push	{r7, lr}
 800a9ce:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800a9d0:	f7ff ffdc 	bl	800a98c <HAL_RCC_GetHCLKFreq>
 800a9d4:	0001      	movs	r1, r0
 800a9d6:	4b06      	ldr	r3, [pc, #24]	; (800a9f0 <HAL_RCC_GetPCLK2Freq+0x24>)
 800a9d8:	68db      	ldr	r3, [r3, #12]
 800a9da:	0adb      	lsrs	r3, r3, #11
 800a9dc:	2207      	movs	r2, #7
 800a9de:	4013      	ands	r3, r2
 800a9e0:	4a04      	ldr	r2, [pc, #16]	; (800a9f4 <HAL_RCC_GetPCLK2Freq+0x28>)
 800a9e2:	5cd3      	ldrb	r3, [r2, r3]
 800a9e4:	40d9      	lsrs	r1, r3
 800a9e6:	000b      	movs	r3, r1
}
 800a9e8:	0018      	movs	r0, r3
 800a9ea:	46bd      	mov	sp, r7
 800a9ec:	bd80      	pop	{r7, pc}
 800a9ee:	46c0      	nop			; (mov r8, r8)
 800a9f0:	40021000 	.word	0x40021000
 800a9f4:	0800f244 	.word	0x0800f244

0800a9f8 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800a9f8:	b580      	push	{r7, lr}
 800a9fa:	b086      	sub	sp, #24
 800a9fc:	af00      	add	r7, sp, #0
 800a9fe:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp_reg;
  FlagStatus       pwrclkchanged = RESET;
 800aa00:	2317      	movs	r3, #23
 800aa02:	18fb      	adds	r3, r7, r3
 800aa04:	2200      	movs	r2, #0
 800aa06:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
 800aa08:	687b      	ldr	r3, [r7, #4]
 800aa0a:	681a      	ldr	r2, [r3, #0]
 800aa0c:	23a0      	movs	r3, #160	; 0xa0
 800aa0e:	011b      	lsls	r3, r3, #4
 800aa10:	429a      	cmp	r2, r3
 800aa12:	d304      	bcc.n	800aa1e <HAL_RCCEx_PeriphCLKConfig+0x26>
 800aa14:	4b8f      	ldr	r3, [pc, #572]	; (800ac54 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 800aa16:	2168      	movs	r1, #104	; 0x68
 800aa18:	0018      	movs	r0, r3
 800aa1a:	f7fb fc3c 	bl	8006296 <assert_failed>

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800aa1e:	687b      	ldr	r3, [r7, #4]
 800aa20:	681b      	ldr	r3, [r3, #0]
 800aa22:	2220      	movs	r2, #32
 800aa24:	4013      	ands	r3, r2
 800aa26:	d106      	bne.n	800aa36 <HAL_RCCEx_PeriphCLKConfig+0x3e>
#if defined(LCD)
   || (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
 800aa28:	687b      	ldr	r3, [r7, #4]
 800aa2a:	681a      	ldr	r2, [r3, #0]
 800aa2c:	2380      	movs	r3, #128	; 0x80
 800aa2e:	011b      	lsls	r3, r3, #4
 800aa30:	4013      	ands	r3, r2
 800aa32:	d100      	bne.n	800aa36 <HAL_RCCEx_PeriphCLKConfig+0x3e>
 800aa34:	e14b      	b.n	800acce <HAL_RCCEx_PeriphCLKConfig+0x2d6>
#endif /* LCD */
     )
  {
    /* check for RTC Parameters used to output RTCCLK */
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800aa36:	687b      	ldr	r3, [r7, #4]
 800aa38:	681b      	ldr	r3, [r3, #0]
 800aa3a:	2220      	movs	r2, #32
 800aa3c:	4013      	ands	r3, r2
 800aa3e:	d02c      	beq.n	800aa9a <HAL_RCCEx_PeriphCLKConfig+0xa2>
    {
      assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 800aa40:	687b      	ldr	r3, [r7, #4]
 800aa42:	685b      	ldr	r3, [r3, #4]
 800aa44:	2b00      	cmp	r3, #0
 800aa46:	d028      	beq.n	800aa9a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800aa48:	687b      	ldr	r3, [r7, #4]
 800aa4a:	685a      	ldr	r2, [r3, #4]
 800aa4c:	2380      	movs	r3, #128	; 0x80
 800aa4e:	025b      	lsls	r3, r3, #9
 800aa50:	429a      	cmp	r2, r3
 800aa52:	d022      	beq.n	800aa9a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800aa54:	687b      	ldr	r3, [r7, #4]
 800aa56:	685a      	ldr	r2, [r3, #4]
 800aa58:	2380      	movs	r3, #128	; 0x80
 800aa5a:	029b      	lsls	r3, r3, #10
 800aa5c:	429a      	cmp	r2, r3
 800aa5e:	d01c      	beq.n	800aa9a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800aa60:	687b      	ldr	r3, [r7, #4]
 800aa62:	685a      	ldr	r2, [r3, #4]
 800aa64:	23c0      	movs	r3, #192	; 0xc0
 800aa66:	029b      	lsls	r3, r3, #10
 800aa68:	429a      	cmp	r2, r3
 800aa6a:	d016      	beq.n	800aa9a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800aa6c:	687b      	ldr	r3, [r7, #4]
 800aa6e:	685a      	ldr	r2, [r3, #4]
 800aa70:	2398      	movs	r3, #152	; 0x98
 800aa72:	035b      	lsls	r3, r3, #13
 800aa74:	429a      	cmp	r2, r3
 800aa76:	d010      	beq.n	800aa9a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800aa78:	687b      	ldr	r3, [r7, #4]
 800aa7a:	685a      	ldr	r2, [r3, #4]
 800aa7c:	238c      	movs	r3, #140	; 0x8c
 800aa7e:	039b      	lsls	r3, r3, #14
 800aa80:	429a      	cmp	r2, r3
 800aa82:	d00a      	beq.n	800aa9a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800aa84:	687b      	ldr	r3, [r7, #4]
 800aa86:	685a      	ldr	r2, [r3, #4]
 800aa88:	23cc      	movs	r3, #204	; 0xcc
 800aa8a:	039b      	lsls	r3, r3, #14
 800aa8c:	429a      	cmp	r2, r3
 800aa8e:	d004      	beq.n	800aa9a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800aa90:	4b70      	ldr	r3, [pc, #448]	; (800ac54 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 800aa92:	2174      	movs	r1, #116	; 0x74
 800aa94:	0018      	movs	r0, r3
 800aa96:	f7fb fbfe 	bl	8006296 <assert_failed>
    }

#if defined(LCD)
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
 800aa9a:	687b      	ldr	r3, [r7, #4]
 800aa9c:	681a      	ldr	r2, [r3, #0]
 800aa9e:	2380      	movs	r3, #128	; 0x80
 800aaa0:	011b      	lsls	r3, r3, #4
 800aaa2:	4013      	ands	r3, r2
 800aaa4:	d02c      	beq.n	800ab00 <HAL_RCCEx_PeriphCLKConfig+0x108>
    {
      assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
 800aaa6:	687b      	ldr	r3, [r7, #4]
 800aaa8:	689b      	ldr	r3, [r3, #8]
 800aaaa:	2b00      	cmp	r3, #0
 800aaac:	d028      	beq.n	800ab00 <HAL_RCCEx_PeriphCLKConfig+0x108>
 800aaae:	687b      	ldr	r3, [r7, #4]
 800aab0:	689a      	ldr	r2, [r3, #8]
 800aab2:	2380      	movs	r3, #128	; 0x80
 800aab4:	025b      	lsls	r3, r3, #9
 800aab6:	429a      	cmp	r2, r3
 800aab8:	d022      	beq.n	800ab00 <HAL_RCCEx_PeriphCLKConfig+0x108>
 800aaba:	687b      	ldr	r3, [r7, #4]
 800aabc:	689a      	ldr	r2, [r3, #8]
 800aabe:	2380      	movs	r3, #128	; 0x80
 800aac0:	029b      	lsls	r3, r3, #10
 800aac2:	429a      	cmp	r2, r3
 800aac4:	d01c      	beq.n	800ab00 <HAL_RCCEx_PeriphCLKConfig+0x108>
 800aac6:	687b      	ldr	r3, [r7, #4]
 800aac8:	689a      	ldr	r2, [r3, #8]
 800aaca:	23c0      	movs	r3, #192	; 0xc0
 800aacc:	029b      	lsls	r3, r3, #10
 800aace:	429a      	cmp	r2, r3
 800aad0:	d016      	beq.n	800ab00 <HAL_RCCEx_PeriphCLKConfig+0x108>
 800aad2:	687b      	ldr	r3, [r7, #4]
 800aad4:	689a      	ldr	r2, [r3, #8]
 800aad6:	2398      	movs	r3, #152	; 0x98
 800aad8:	035b      	lsls	r3, r3, #13
 800aada:	429a      	cmp	r2, r3
 800aadc:	d010      	beq.n	800ab00 <HAL_RCCEx_PeriphCLKConfig+0x108>
 800aade:	687b      	ldr	r3, [r7, #4]
 800aae0:	689a      	ldr	r2, [r3, #8]
 800aae2:	238c      	movs	r3, #140	; 0x8c
 800aae4:	039b      	lsls	r3, r3, #14
 800aae6:	429a      	cmp	r2, r3
 800aae8:	d00a      	beq.n	800ab00 <HAL_RCCEx_PeriphCLKConfig+0x108>
 800aaea:	687b      	ldr	r3, [r7, #4]
 800aaec:	689a      	ldr	r2, [r3, #8]
 800aaee:	23cc      	movs	r3, #204	; 0xcc
 800aaf0:	039b      	lsls	r3, r3, #14
 800aaf2:	429a      	cmp	r2, r3
 800aaf4:	d004      	beq.n	800ab00 <HAL_RCCEx_PeriphCLKConfig+0x108>
 800aaf6:	4b57      	ldr	r3, [pc, #348]	; (800ac54 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 800aaf8:	217a      	movs	r1, #122	; 0x7a
 800aafa:	0018      	movs	r0, r3
 800aafc:	f7fb fbcb 	bl	8006296 <assert_failed>
#endif /* LCD */

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800ab00:	4b55      	ldr	r3, [pc, #340]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ab02:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ab04:	2380      	movs	r3, #128	; 0x80
 800ab06:	055b      	lsls	r3, r3, #21
 800ab08:	4013      	ands	r3, r2
 800ab0a:	d10a      	bne.n	800ab22 <HAL_RCCEx_PeriphCLKConfig+0x12a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800ab0c:	4b52      	ldr	r3, [pc, #328]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ab0e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ab10:	4b51      	ldr	r3, [pc, #324]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ab12:	2180      	movs	r1, #128	; 0x80
 800ab14:	0549      	lsls	r1, r1, #21
 800ab16:	430a      	orrs	r2, r1
 800ab18:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 800ab1a:	2317      	movs	r3, #23
 800ab1c:	18fb      	adds	r3, r7, r3
 800ab1e:	2201      	movs	r2, #1
 800ab20:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800ab22:	4b4e      	ldr	r3, [pc, #312]	; (800ac5c <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800ab24:	681a      	ldr	r2, [r3, #0]
 800ab26:	2380      	movs	r3, #128	; 0x80
 800ab28:	005b      	lsls	r3, r3, #1
 800ab2a:	4013      	ands	r3, r2
 800ab2c:	d11a      	bne.n	800ab64 <HAL_RCCEx_PeriphCLKConfig+0x16c>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800ab2e:	4b4b      	ldr	r3, [pc, #300]	; (800ac5c <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800ab30:	681a      	ldr	r2, [r3, #0]
 800ab32:	4b4a      	ldr	r3, [pc, #296]	; (800ac5c <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800ab34:	2180      	movs	r1, #128	; 0x80
 800ab36:	0049      	lsls	r1, r1, #1
 800ab38:	430a      	orrs	r2, r1
 800ab3a:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800ab3c:	f7fc fcd2 	bl	80074e4 <HAL_GetTick>
 800ab40:	0003      	movs	r3, r0
 800ab42:	613b      	str	r3, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800ab44:	e008      	b.n	800ab58 <HAL_RCCEx_PeriphCLKConfig+0x160>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800ab46:	f7fc fccd 	bl	80074e4 <HAL_GetTick>
 800ab4a:	0002      	movs	r2, r0
 800ab4c:	693b      	ldr	r3, [r7, #16]
 800ab4e:	1ad3      	subs	r3, r2, r3
 800ab50:	2b64      	cmp	r3, #100	; 0x64
 800ab52:	d901      	bls.n	800ab58 <HAL_RCCEx_PeriphCLKConfig+0x160>
        {
          return HAL_TIMEOUT;
 800ab54:	2303      	movs	r3, #3
 800ab56:	e1c5      	b.n	800aee4 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800ab58:	4b40      	ldr	r3, [pc, #256]	; (800ac5c <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800ab5a:	681a      	ldr	r2, [r3, #0]
 800ab5c:	2380      	movs	r3, #128	; 0x80
 800ab5e:	005b      	lsls	r3, r3, #1
 800ab60:	4013      	ands	r3, r2
 800ab62:	d0f0      	beq.n	800ab46 <HAL_RCCEx_PeriphCLKConfig+0x14e>
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 800ab64:	4b3c      	ldr	r3, [pc, #240]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ab66:	681a      	ldr	r2, [r3, #0]
 800ab68:	23c0      	movs	r3, #192	; 0xc0
 800ab6a:	039b      	lsls	r3, r3, #14
 800ab6c:	4013      	ands	r3, r2
 800ab6e:	60fb      	str	r3, [r7, #12]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 800ab70:	687b      	ldr	r3, [r7, #4]
 800ab72:	685a      	ldr	r2, [r3, #4]
 800ab74:	23c0      	movs	r3, #192	; 0xc0
 800ab76:	039b      	lsls	r3, r3, #14
 800ab78:	4013      	ands	r3, r2
 800ab7a:	68fa      	ldr	r2, [r7, #12]
 800ab7c:	429a      	cmp	r2, r3
 800ab7e:	d107      	bne.n	800ab90 <HAL_RCCEx_PeriphCLKConfig+0x198>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
 800ab80:	687b      	ldr	r3, [r7, #4]
 800ab82:	689a      	ldr	r2, [r3, #8]
 800ab84:	23c0      	movs	r3, #192	; 0xc0
 800ab86:	039b      	lsls	r3, r3, #14
 800ab88:	4013      	ands	r3, r2
 800ab8a:	68fa      	ldr	r2, [r7, #12]
 800ab8c:	429a      	cmp	r2, r3
 800ab8e:	d013      	beq.n	800abb8 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
#endif /* LCD */
       )
    { /* Check HSE State */
      if ((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE)
 800ab90:	687b      	ldr	r3, [r7, #4]
 800ab92:	685a      	ldr	r2, [r3, #4]
 800ab94:	23c0      	movs	r3, #192	; 0xc0
 800ab96:	029b      	lsls	r3, r3, #10
 800ab98:	401a      	ands	r2, r3
 800ab9a:	23c0      	movs	r3, #192	; 0xc0
 800ab9c:	029b      	lsls	r3, r3, #10
 800ab9e:	429a      	cmp	r2, r3
 800aba0:	d10a      	bne.n	800abb8 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800aba2:	4b2d      	ldr	r3, [pc, #180]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800aba4:	681a      	ldr	r2, [r3, #0]
 800aba6:	2380      	movs	r3, #128	; 0x80
 800aba8:	029b      	lsls	r3, r3, #10
 800abaa:	401a      	ands	r2, r3
 800abac:	2380      	movs	r3, #128	; 0x80
 800abae:	029b      	lsls	r3, r3, #10
 800abb0:	429a      	cmp	r2, r3
 800abb2:	d101      	bne.n	800abb8 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
        {
          /* To update HSE divider, first switch-OFF HSE clock oscillator*/
          return HAL_ERROR;
 800abb4:	2301      	movs	r3, #1
 800abb6:	e195      	b.n	800aee4 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 800abb8:	4b27      	ldr	r3, [pc, #156]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800abba:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800abbc:	23c0      	movs	r3, #192	; 0xc0
 800abbe:	029b      	lsls	r3, r3, #10
 800abc0:	4013      	ands	r3, r2
 800abc2:	60fb      	str	r3, [r7, #12]

    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 800abc4:	68fb      	ldr	r3, [r7, #12]
 800abc6:	2b00      	cmp	r3, #0
 800abc8:	d056      	beq.n	800ac78 <HAL_RCCEx_PeriphCLKConfig+0x280>
 800abca:	687b      	ldr	r3, [r7, #4]
 800abcc:	685a      	ldr	r2, [r3, #4]
 800abce:	23c0      	movs	r3, #192	; 0xc0
 800abd0:	029b      	lsls	r3, r3, #10
 800abd2:	4013      	ands	r3, r2
 800abd4:	68fa      	ldr	r2, [r7, #12]
 800abd6:	429a      	cmp	r2, r3
 800abd8:	d004      	beq.n	800abe4 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 800abda:	687b      	ldr	r3, [r7, #4]
 800abdc:	681b      	ldr	r3, [r3, #0]
 800abde:	2220      	movs	r2, #32
 800abe0:	4013      	ands	r3, r2
 800abe2:	d10d      	bne.n	800ac00 <HAL_RCCEx_PeriphCLKConfig+0x208>
#if defined(LCD)
      || ((temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CSR_RTCSEL)) \
 800abe4:	687b      	ldr	r3, [r7, #4]
 800abe6:	689a      	ldr	r2, [r3, #8]
 800abe8:	23c0      	movs	r3, #192	; 0xc0
 800abea:	029b      	lsls	r3, r3, #10
 800abec:	4013      	ands	r3, r2
 800abee:	68fa      	ldr	r2, [r7, #12]
 800abf0:	429a      	cmp	r2, r3
 800abf2:	d041      	beq.n	800ac78 <HAL_RCCEx_PeriphCLKConfig+0x280>
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
 800abf4:	687b      	ldr	r3, [r7, #4]
 800abf6:	681a      	ldr	r2, [r3, #0]
 800abf8:	2380      	movs	r3, #128	; 0x80
 800abfa:	011b      	lsls	r3, r3, #4
 800abfc:	4013      	ands	r3, r2
 800abfe:	d03b      	beq.n	800ac78 <HAL_RCCEx_PeriphCLKConfig+0x280>
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 800ac00:	4b15      	ldr	r3, [pc, #84]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ac02:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800ac04:	4a16      	ldr	r2, [pc, #88]	; (800ac60 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 800ac06:	4013      	ands	r3, r2
 800ac08:	60fb      	str	r3, [r7, #12]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800ac0a:	4b13      	ldr	r3, [pc, #76]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ac0c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ac0e:	4b12      	ldr	r3, [pc, #72]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ac10:	2180      	movs	r1, #128	; 0x80
 800ac12:	0309      	lsls	r1, r1, #12
 800ac14:	430a      	orrs	r2, r1
 800ac16:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 800ac18:	4b0f      	ldr	r3, [pc, #60]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ac1a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ac1c:	4b0e      	ldr	r3, [pc, #56]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ac1e:	4911      	ldr	r1, [pc, #68]	; (800ac64 <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 800ac20:	400a      	ands	r2, r1
 800ac22:	651a      	str	r2, [r3, #80]	; 0x50

      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 800ac24:	4b0c      	ldr	r3, [pc, #48]	; (800ac58 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 800ac26:	68fa      	ldr	r2, [r7, #12]
 800ac28:	651a      	str	r2, [r3, #80]	; 0x50

       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 800ac2a:	68fa      	ldr	r2, [r7, #12]
 800ac2c:	2380      	movs	r3, #128	; 0x80
 800ac2e:	005b      	lsls	r3, r3, #1
 800ac30:	4013      	ands	r3, r2
 800ac32:	d021      	beq.n	800ac78 <HAL_RCCEx_PeriphCLKConfig+0x280>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800ac34:	f7fc fc56 	bl	80074e4 <HAL_GetTick>
 800ac38:	0003      	movs	r3, r0
 800ac3a:	613b      	str	r3, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800ac3c:	e016      	b.n	800ac6c <HAL_RCCEx_PeriphCLKConfig+0x274>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800ac3e:	f7fc fc51 	bl	80074e4 <HAL_GetTick>
 800ac42:	0002      	movs	r2, r0
 800ac44:	693b      	ldr	r3, [r7, #16]
 800ac46:	1ad3      	subs	r3, r2, r3
 800ac48:	4a07      	ldr	r2, [pc, #28]	; (800ac68 <HAL_RCCEx_PeriphCLKConfig+0x270>)
 800ac4a:	4293      	cmp	r3, r2
 800ac4c:	d90e      	bls.n	800ac6c <HAL_RCCEx_PeriphCLKConfig+0x274>
          {
            return HAL_TIMEOUT;
 800ac4e:	2303      	movs	r3, #3
 800ac50:	e148      	b.n	800aee4 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
 800ac52:	46c0      	nop			; (mov r8, r8)
 800ac54:	0800de98 	.word	0x0800de98
 800ac58:	40021000 	.word	0x40021000
 800ac5c:	40007000 	.word	0x40007000
 800ac60:	fffcffff 	.word	0xfffcffff
 800ac64:	fff7ffff 	.word	0xfff7ffff
 800ac68:	00001388 	.word	0x00001388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800ac6c:	4b9f      	ldr	r3, [pc, #636]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ac6e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ac70:	2380      	movs	r3, #128	; 0x80
 800ac72:	009b      	lsls	r3, r3, #2
 800ac74:	4013      	ands	r3, r2
 800ac76:	d0e2      	beq.n	800ac3e <HAL_RCCEx_PeriphCLKConfig+0x246>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800ac78:	687b      	ldr	r3, [r7, #4]
 800ac7a:	685a      	ldr	r2, [r3, #4]
 800ac7c:	23c0      	movs	r3, #192	; 0xc0
 800ac7e:	029b      	lsls	r3, r3, #10
 800ac80:	401a      	ands	r2, r3
 800ac82:	23c0      	movs	r3, #192	; 0xc0
 800ac84:	029b      	lsls	r3, r3, #10
 800ac86:	429a      	cmp	r2, r3
 800ac88:	d10c      	bne.n	800aca4 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
 800ac8a:	4b98      	ldr	r3, [pc, #608]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ac8c:	681b      	ldr	r3, [r3, #0]
 800ac8e:	4a98      	ldr	r2, [pc, #608]	; (800aef0 <HAL_RCCEx_PeriphCLKConfig+0x4f8>)
 800ac90:	4013      	ands	r3, r2
 800ac92:	0019      	movs	r1, r3
 800ac94:	687b      	ldr	r3, [r7, #4]
 800ac96:	685a      	ldr	r2, [r3, #4]
 800ac98:	23c0      	movs	r3, #192	; 0xc0
 800ac9a:	039b      	lsls	r3, r3, #14
 800ac9c:	401a      	ands	r2, r3
 800ac9e:	4b93      	ldr	r3, [pc, #588]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800aca0:	430a      	orrs	r2, r1
 800aca2:	601a      	str	r2, [r3, #0]
 800aca4:	4b91      	ldr	r3, [pc, #580]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800aca6:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800aca8:	687b      	ldr	r3, [r7, #4]
 800acaa:	685a      	ldr	r2, [r3, #4]
 800acac:	23c0      	movs	r3, #192	; 0xc0
 800acae:	029b      	lsls	r3, r3, #10
 800acb0:	401a      	ands	r2, r3
 800acb2:	4b8e      	ldr	r3, [pc, #568]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800acb4:	430a      	orrs	r2, r1
 800acb6:	651a      	str	r2, [r3, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800acb8:	2317      	movs	r3, #23
 800acba:	18fb      	adds	r3, r7, r3
 800acbc:	781b      	ldrb	r3, [r3, #0]
 800acbe:	2b01      	cmp	r3, #1
 800acc0:	d105      	bne.n	800acce <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800acc2:	4b8a      	ldr	r3, [pc, #552]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800acc4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800acc6:	4b89      	ldr	r3, [pc, #548]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800acc8:	498a      	ldr	r1, [pc, #552]	; (800aef4 <HAL_RCCEx_PeriphCLKConfig+0x4fc>)
 800acca:	400a      	ands	r2, r1
 800accc:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800acce:	687b      	ldr	r3, [r7, #4]
 800acd0:	681b      	ldr	r3, [r3, #0]
 800acd2:	2201      	movs	r2, #1
 800acd4:	4013      	ands	r3, r2
 800acd6:	d01e      	beq.n	800ad16 <HAL_RCCEx_PeriphCLKConfig+0x31e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
 800acd8:	687b      	ldr	r3, [r7, #4]
 800acda:	68db      	ldr	r3, [r3, #12]
 800acdc:	2b00      	cmp	r3, #0
 800acde:	d010      	beq.n	800ad02 <HAL_RCCEx_PeriphCLKConfig+0x30a>
 800ace0:	687b      	ldr	r3, [r7, #4]
 800ace2:	68db      	ldr	r3, [r3, #12]
 800ace4:	2b01      	cmp	r3, #1
 800ace6:	d00c      	beq.n	800ad02 <HAL_RCCEx_PeriphCLKConfig+0x30a>
 800ace8:	687b      	ldr	r3, [r7, #4]
 800acea:	68db      	ldr	r3, [r3, #12]
 800acec:	2b03      	cmp	r3, #3
 800acee:	d008      	beq.n	800ad02 <HAL_RCCEx_PeriphCLKConfig+0x30a>
 800acf0:	687b      	ldr	r3, [r7, #4]
 800acf2:	68db      	ldr	r3, [r3, #12]
 800acf4:	2b02      	cmp	r3, #2
 800acf6:	d004      	beq.n	800ad02 <HAL_RCCEx_PeriphCLKConfig+0x30a>
 800acf8:	4b7f      	ldr	r3, [pc, #508]	; (800aef8 <HAL_RCCEx_PeriphCLKConfig+0x500>)
 800acfa:	21dd      	movs	r1, #221	; 0xdd
 800acfc:	0018      	movs	r0, r3
 800acfe:	f7fb faca 	bl	8006296 <assert_failed>

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800ad02:	4b7a      	ldr	r3, [pc, #488]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ad04:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ad06:	2203      	movs	r2, #3
 800ad08:	4393      	bics	r3, r2
 800ad0a:	0019      	movs	r1, r3
 800ad0c:	687b      	ldr	r3, [r7, #4]
 800ad0e:	68da      	ldr	r2, [r3, #12]
 800ad10:	4b76      	ldr	r3, [pc, #472]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ad12:	430a      	orrs	r2, r1
 800ad14:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */

  /*----------------------------- USART2 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800ad16:	687b      	ldr	r3, [r7, #4]
 800ad18:	681b      	ldr	r3, [r3, #0]
 800ad1a:	2202      	movs	r2, #2
 800ad1c:	4013      	ands	r3, r2
 800ad1e:	d01e      	beq.n	800ad5e <HAL_RCCEx_PeriphCLKConfig+0x366>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
 800ad20:	687b      	ldr	r3, [r7, #4]
 800ad22:	691b      	ldr	r3, [r3, #16]
 800ad24:	2b00      	cmp	r3, #0
 800ad26:	d010      	beq.n	800ad4a <HAL_RCCEx_PeriphCLKConfig+0x352>
 800ad28:	687b      	ldr	r3, [r7, #4]
 800ad2a:	691b      	ldr	r3, [r3, #16]
 800ad2c:	2b04      	cmp	r3, #4
 800ad2e:	d00c      	beq.n	800ad4a <HAL_RCCEx_PeriphCLKConfig+0x352>
 800ad30:	687b      	ldr	r3, [r7, #4]
 800ad32:	691b      	ldr	r3, [r3, #16]
 800ad34:	2b0c      	cmp	r3, #12
 800ad36:	d008      	beq.n	800ad4a <HAL_RCCEx_PeriphCLKConfig+0x352>
 800ad38:	687b      	ldr	r3, [r7, #4]
 800ad3a:	691b      	ldr	r3, [r3, #16]
 800ad3c:	2b08      	cmp	r3, #8
 800ad3e:	d004      	beq.n	800ad4a <HAL_RCCEx_PeriphCLKConfig+0x352>
 800ad40:	4b6d      	ldr	r3, [pc, #436]	; (800aef8 <HAL_RCCEx_PeriphCLKConfig+0x500>)
 800ad42:	21e8      	movs	r1, #232	; 0xe8
 800ad44:	0018      	movs	r0, r3
 800ad46:	f7fb faa6 	bl	8006296 <assert_failed>

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800ad4a:	4b68      	ldr	r3, [pc, #416]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ad4c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ad4e:	220c      	movs	r2, #12
 800ad50:	4393      	bics	r3, r2
 800ad52:	0019      	movs	r1, r3
 800ad54:	687b      	ldr	r3, [r7, #4]
 800ad56:	691a      	ldr	r2, [r3, #16]
 800ad58:	4b64      	ldr	r3, [pc, #400]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ad5a:	430a      	orrs	r2, r1
 800ad5c:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ LPUART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800ad5e:	687b      	ldr	r3, [r7, #4]
 800ad60:	681b      	ldr	r3, [r3, #0]
 800ad62:	2204      	movs	r2, #4
 800ad64:	4013      	ands	r3, r2
 800ad66:	d024      	beq.n	800adb2 <HAL_RCCEx_PeriphCLKConfig+0x3ba>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
 800ad68:	687b      	ldr	r3, [r7, #4]
 800ad6a:	695b      	ldr	r3, [r3, #20]
 800ad6c:	2b00      	cmp	r3, #0
 800ad6e:	d016      	beq.n	800ad9e <HAL_RCCEx_PeriphCLKConfig+0x3a6>
 800ad70:	687b      	ldr	r3, [r7, #4]
 800ad72:	695a      	ldr	r2, [r3, #20]
 800ad74:	2380      	movs	r3, #128	; 0x80
 800ad76:	00db      	lsls	r3, r3, #3
 800ad78:	429a      	cmp	r2, r3
 800ad7a:	d010      	beq.n	800ad9e <HAL_RCCEx_PeriphCLKConfig+0x3a6>
 800ad7c:	687b      	ldr	r3, [r7, #4]
 800ad7e:	695a      	ldr	r2, [r3, #20]
 800ad80:	23c0      	movs	r3, #192	; 0xc0
 800ad82:	011b      	lsls	r3, r3, #4
 800ad84:	429a      	cmp	r2, r3
 800ad86:	d00a      	beq.n	800ad9e <HAL_RCCEx_PeriphCLKConfig+0x3a6>
 800ad88:	687b      	ldr	r3, [r7, #4]
 800ad8a:	695a      	ldr	r2, [r3, #20]
 800ad8c:	2380      	movs	r3, #128	; 0x80
 800ad8e:	011b      	lsls	r3, r3, #4
 800ad90:	429a      	cmp	r2, r3
 800ad92:	d004      	beq.n	800ad9e <HAL_RCCEx_PeriphCLKConfig+0x3a6>
 800ad94:	4b58      	ldr	r3, [pc, #352]	; (800aef8 <HAL_RCCEx_PeriphCLKConfig+0x500>)
 800ad96:	21f2      	movs	r1, #242	; 0xf2
 800ad98:	0018      	movs	r0, r3
 800ad9a:	f7fb fa7c 	bl	8006296 <assert_failed>

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800ad9e:	4b53      	ldr	r3, [pc, #332]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ada0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ada2:	4a56      	ldr	r2, [pc, #344]	; (800aefc <HAL_RCCEx_PeriphCLKConfig+0x504>)
 800ada4:	4013      	ands	r3, r2
 800ada6:	0019      	movs	r1, r3
 800ada8:	687b      	ldr	r3, [r7, #4]
 800adaa:	695a      	ldr	r2, [r3, #20]
 800adac:	4b4f      	ldr	r3, [pc, #316]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800adae:	430a      	orrs	r2, r1
 800adb0:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800adb2:	687b      	ldr	r3, [r7, #4]
 800adb4:	681b      	ldr	r3, [r3, #0]
 800adb6:	2208      	movs	r2, #8
 800adb8:	4013      	ands	r3, r2
 800adba:	d01e      	beq.n	800adfa <HAL_RCCEx_PeriphCLKConfig+0x402>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
 800adbc:	687b      	ldr	r3, [r7, #4]
 800adbe:	699b      	ldr	r3, [r3, #24]
 800adc0:	2b00      	cmp	r3, #0
 800adc2:	d010      	beq.n	800ade6 <HAL_RCCEx_PeriphCLKConfig+0x3ee>
 800adc4:	687b      	ldr	r3, [r7, #4]
 800adc6:	699a      	ldr	r2, [r3, #24]
 800adc8:	2380      	movs	r3, #128	; 0x80
 800adca:	015b      	lsls	r3, r3, #5
 800adcc:	429a      	cmp	r2, r3
 800adce:	d00a      	beq.n	800ade6 <HAL_RCCEx_PeriphCLKConfig+0x3ee>
 800add0:	687b      	ldr	r3, [r7, #4]
 800add2:	699a      	ldr	r2, [r3, #24]
 800add4:	2380      	movs	r3, #128	; 0x80
 800add6:	019b      	lsls	r3, r3, #6
 800add8:	429a      	cmp	r2, r3
 800adda:	d004      	beq.n	800ade6 <HAL_RCCEx_PeriphCLKConfig+0x3ee>
 800addc:	4b46      	ldr	r3, [pc, #280]	; (800aef8 <HAL_RCCEx_PeriphCLKConfig+0x500>)
 800adde:	21fc      	movs	r1, #252	; 0xfc
 800ade0:	0018      	movs	r0, r3
 800ade2:	f7fb fa58 	bl	8006296 <assert_failed>

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800ade6:	4b41      	ldr	r3, [pc, #260]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ade8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800adea:	4a45      	ldr	r2, [pc, #276]	; (800af00 <HAL_RCCEx_PeriphCLKConfig+0x508>)
 800adec:	4013      	ands	r3, r2
 800adee:	0019      	movs	r1, r3
 800adf0:	687b      	ldr	r3, [r7, #4]
 800adf2:	699a      	ldr	r2, [r3, #24]
 800adf4:	4b3d      	ldr	r3, [pc, #244]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800adf6:	430a      	orrs	r2, r1
 800adf8:	64da      	str	r2, [r3, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800adfa:	687b      	ldr	r3, [r7, #4]
 800adfc:	681a      	ldr	r2, [r3, #0]
 800adfe:	2380      	movs	r3, #128	; 0x80
 800ae00:	005b      	lsls	r3, r3, #1
 800ae02:	4013      	ands	r3, r2
 800ae04:	d021      	beq.n	800ae4a <HAL_RCCEx_PeriphCLKConfig+0x452>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
 800ae06:	687b      	ldr	r3, [r7, #4]
 800ae08:	69db      	ldr	r3, [r3, #28]
 800ae0a:	2b00      	cmp	r3, #0
 800ae0c:	d013      	beq.n	800ae36 <HAL_RCCEx_PeriphCLKConfig+0x43e>
 800ae0e:	687b      	ldr	r3, [r7, #4]
 800ae10:	69da      	ldr	r2, [r3, #28]
 800ae12:	2380      	movs	r3, #128	; 0x80
 800ae14:	025b      	lsls	r3, r3, #9
 800ae16:	429a      	cmp	r2, r3
 800ae18:	d00d      	beq.n	800ae36 <HAL_RCCEx_PeriphCLKConfig+0x43e>
 800ae1a:	687b      	ldr	r3, [r7, #4]
 800ae1c:	69da      	ldr	r2, [r3, #28]
 800ae1e:	2380      	movs	r3, #128	; 0x80
 800ae20:	029b      	lsls	r3, r3, #10
 800ae22:	429a      	cmp	r2, r3
 800ae24:	d007      	beq.n	800ae36 <HAL_RCCEx_PeriphCLKConfig+0x43e>
 800ae26:	2308      	movs	r3, #8
 800ae28:	33ff      	adds	r3, #255	; 0xff
 800ae2a:	001a      	movs	r2, r3
 800ae2c:	4b32      	ldr	r3, [pc, #200]	; (800aef8 <HAL_RCCEx_PeriphCLKConfig+0x500>)
 800ae2e:	0011      	movs	r1, r2
 800ae30:	0018      	movs	r0, r3
 800ae32:	f7fb fa30 	bl	8006296 <assert_failed>

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800ae36:	4b2d      	ldr	r3, [pc, #180]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ae38:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ae3a:	4a32      	ldr	r2, [pc, #200]	; (800af04 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
 800ae3c:	4013      	ands	r3, r2
 800ae3e:	0019      	movs	r1, r3
 800ae40:	687b      	ldr	r3, [r7, #4]
 800ae42:	69da      	ldr	r2, [r3, #28]
 800ae44:	4b29      	ldr	r3, [pc, #164]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ae46:	430a      	orrs	r2, r1
 800ae48:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_I2C3SEL */

#if defined(USB)
 /*---------------------------- USB and RNG configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 800ae4a:	687b      	ldr	r3, [r7, #4]
 800ae4c:	681b      	ldr	r3, [r3, #0]
 800ae4e:	2240      	movs	r2, #64	; 0x40
 800ae50:	4013      	ands	r3, r2
 800ae52:	d01a      	beq.n	800ae8a <HAL_RCCEx_PeriphCLKConfig+0x492>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
 800ae54:	687b      	ldr	r3, [r7, #4]
 800ae56:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ae58:	2380      	movs	r3, #128	; 0x80
 800ae5a:	04db      	lsls	r3, r3, #19
 800ae5c:	429a      	cmp	r2, r3
 800ae5e:	d00a      	beq.n	800ae76 <HAL_RCCEx_PeriphCLKConfig+0x47e>
 800ae60:	687b      	ldr	r3, [r7, #4]
 800ae62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ae64:	2b00      	cmp	r3, #0
 800ae66:	d006      	beq.n	800ae76 <HAL_RCCEx_PeriphCLKConfig+0x47e>
 800ae68:	2389      	movs	r3, #137	; 0x89
 800ae6a:	005a      	lsls	r2, r3, #1
 800ae6c:	4b22      	ldr	r3, [pc, #136]	; (800aef8 <HAL_RCCEx_PeriphCLKConfig+0x500>)
 800ae6e:	0011      	movs	r1, r2
 800ae70:	0018      	movs	r0, r3
 800ae72:	f7fb fa10 	bl	8006296 <assert_failed>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800ae76:	4b1d      	ldr	r3, [pc, #116]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ae78:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ae7a:	4a23      	ldr	r2, [pc, #140]	; (800af08 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 800ae7c:	4013      	ands	r3, r2
 800ae7e:	0019      	movs	r1, r3
 800ae80:	687b      	ldr	r3, [r7, #4]
 800ae82:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ae84:	4b19      	ldr	r3, [pc, #100]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800ae86:	430a      	orrs	r2, r1
 800ae88:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* USB */

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800ae8a:	687b      	ldr	r3, [r7, #4]
 800ae8c:	681b      	ldr	r3, [r3, #0]
 800ae8e:	2280      	movs	r2, #128	; 0x80
 800ae90:	4013      	ands	r3, r2
 800ae92:	d026      	beq.n	800aee2 <HAL_RCCEx_PeriphCLKConfig+0x4ea>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
 800ae94:	687b      	ldr	r3, [r7, #4]
 800ae96:	6a1b      	ldr	r3, [r3, #32]
 800ae98:	2b00      	cmp	r3, #0
 800ae9a:	d018      	beq.n	800aece <HAL_RCCEx_PeriphCLKConfig+0x4d6>
 800ae9c:	687b      	ldr	r3, [r7, #4]
 800ae9e:	6a1a      	ldr	r2, [r3, #32]
 800aea0:	2380      	movs	r3, #128	; 0x80
 800aea2:	02db      	lsls	r3, r3, #11
 800aea4:	429a      	cmp	r2, r3
 800aea6:	d012      	beq.n	800aece <HAL_RCCEx_PeriphCLKConfig+0x4d6>
 800aea8:	687b      	ldr	r3, [r7, #4]
 800aeaa:	6a1a      	ldr	r2, [r3, #32]
 800aeac:	2380      	movs	r3, #128	; 0x80
 800aeae:	031b      	lsls	r3, r3, #12
 800aeb0:	429a      	cmp	r2, r3
 800aeb2:	d00c      	beq.n	800aece <HAL_RCCEx_PeriphCLKConfig+0x4d6>
 800aeb4:	687b      	ldr	r3, [r7, #4]
 800aeb6:	6a1a      	ldr	r2, [r3, #32]
 800aeb8:	23c0      	movs	r3, #192	; 0xc0
 800aeba:	031b      	lsls	r3, r3, #12
 800aebc:	429a      	cmp	r2, r3
 800aebe:	d006      	beq.n	800aece <HAL_RCCEx_PeriphCLKConfig+0x4d6>
 800aec0:	238d      	movs	r3, #141	; 0x8d
 800aec2:	005a      	lsls	r2, r3, #1
 800aec4:	4b0c      	ldr	r3, [pc, #48]	; (800aef8 <HAL_RCCEx_PeriphCLKConfig+0x500>)
 800aec6:	0011      	movs	r1, r2
 800aec8:	0018      	movs	r0, r3
 800aeca:	f7fb f9e4 	bl	8006296 <assert_failed>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 800aece:	4b07      	ldr	r3, [pc, #28]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800aed0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800aed2:	4a0e      	ldr	r2, [pc, #56]	; (800af0c <HAL_RCCEx_PeriphCLKConfig+0x514>)
 800aed4:	4013      	ands	r3, r2
 800aed6:	0019      	movs	r1, r3
 800aed8:	687b      	ldr	r3, [r7, #4]
 800aeda:	6a1a      	ldr	r2, [r3, #32]
 800aedc:	4b03      	ldr	r3, [pc, #12]	; (800aeec <HAL_RCCEx_PeriphCLKConfig+0x4f4>)
 800aede:	430a      	orrs	r2, r1
 800aee0:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 800aee2:	2300      	movs	r3, #0
}
 800aee4:	0018      	movs	r0, r3
 800aee6:	46bd      	mov	sp, r7
 800aee8:	b006      	add	sp, #24
 800aeea:	bd80      	pop	{r7, pc}
 800aeec:	40021000 	.word	0x40021000
 800aef0:	ffcfffff 	.word	0xffcfffff
 800aef4:	efffffff 	.word	0xefffffff
 800aef8:	0800de98 	.word	0x0800de98
 800aefc:	fffff3ff 	.word	0xfffff3ff
 800af00:	ffffcfff 	.word	0xffffcfff
 800af04:	fffcffff 	.word	0xfffcffff
 800af08:	fbffffff 	.word	0xfbffffff
 800af0c:	fff3ffff 	.word	0xfff3ffff

0800af10 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800af10:	b580      	push	{r7, lr}
 800af12:	b082      	sub	sp, #8
 800af14:	af00      	add	r7, sp, #0
 800af16:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800af18:	687b      	ldr	r3, [r7, #4]
 800af1a:	2b00      	cmp	r3, #0
 800af1c:	d101      	bne.n	800af22 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 800af1e:	2301      	movs	r3, #1
 800af20:	e1a4      	b.n	800b26c <HAL_SPI_Init+0x35c>
  }

  /* Check the parameters */
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
 800af22:	687b      	ldr	r3, [r7, #4]
 800af24:	681b      	ldr	r3, [r3, #0]
 800af26:	4a7f      	ldr	r2, [pc, #508]	; (800b124 <HAL_SPI_Init+0x214>)
 800af28:	4293      	cmp	r3, r2
 800af2a:	d00b      	beq.n	800af44 <HAL_SPI_Init+0x34>
 800af2c:	687b      	ldr	r3, [r7, #4]
 800af2e:	681b      	ldr	r3, [r3, #0]
 800af30:	4a7d      	ldr	r2, [pc, #500]	; (800b128 <HAL_SPI_Init+0x218>)
 800af32:	4293      	cmp	r3, r2
 800af34:	d006      	beq.n	800af44 <HAL_SPI_Init+0x34>
 800af36:	23a5      	movs	r3, #165	; 0xa5
 800af38:	005a      	lsls	r2, r3, #1
 800af3a:	4b7c      	ldr	r3, [pc, #496]	; (800b12c <HAL_SPI_Init+0x21c>)
 800af3c:	0011      	movs	r1, r2
 800af3e:	0018      	movs	r0, r3
 800af40:	f7fb f9a9 	bl	8006296 <assert_failed>
  assert_param(IS_SPI_MODE(hspi->Init.Mode));
 800af44:	687b      	ldr	r3, [r7, #4]
 800af46:	685b      	ldr	r3, [r3, #4]
 800af48:	2b00      	cmp	r3, #0
 800af4a:	d00d      	beq.n	800af68 <HAL_SPI_Init+0x58>
 800af4c:	687b      	ldr	r3, [r7, #4]
 800af4e:	685a      	ldr	r2, [r3, #4]
 800af50:	2382      	movs	r3, #130	; 0x82
 800af52:	005b      	lsls	r3, r3, #1
 800af54:	429a      	cmp	r2, r3
 800af56:	d007      	beq.n	800af68 <HAL_SPI_Init+0x58>
 800af58:	234c      	movs	r3, #76	; 0x4c
 800af5a:	33ff      	adds	r3, #255	; 0xff
 800af5c:	001a      	movs	r2, r3
 800af5e:	4b73      	ldr	r3, [pc, #460]	; (800b12c <HAL_SPI_Init+0x21c>)
 800af60:	0011      	movs	r1, r2
 800af62:	0018      	movs	r0, r3
 800af64:	f7fb f997 	bl	8006296 <assert_failed>
  assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
 800af68:	687b      	ldr	r3, [r7, #4]
 800af6a:	689b      	ldr	r3, [r3, #8]
 800af6c:	2b00      	cmp	r3, #0
 800af6e:	d012      	beq.n	800af96 <HAL_SPI_Init+0x86>
 800af70:	687b      	ldr	r3, [r7, #4]
 800af72:	689a      	ldr	r2, [r3, #8]
 800af74:	2380      	movs	r3, #128	; 0x80
 800af76:	00db      	lsls	r3, r3, #3
 800af78:	429a      	cmp	r2, r3
 800af7a:	d00c      	beq.n	800af96 <HAL_SPI_Init+0x86>
 800af7c:	687b      	ldr	r3, [r7, #4]
 800af7e:	689a      	ldr	r2, [r3, #8]
 800af80:	2380      	movs	r3, #128	; 0x80
 800af82:	021b      	lsls	r3, r3, #8
 800af84:	429a      	cmp	r2, r3
 800af86:	d006      	beq.n	800af96 <HAL_SPI_Init+0x86>
 800af88:	23a6      	movs	r3, #166	; 0xa6
 800af8a:	005a      	lsls	r2, r3, #1
 800af8c:	4b67      	ldr	r3, [pc, #412]	; (800b12c <HAL_SPI_Init+0x21c>)
 800af8e:	0011      	movs	r1, r2
 800af90:	0018      	movs	r0, r3
 800af92:	f7fb f980 	bl	8006296 <assert_failed>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
 800af96:	687b      	ldr	r3, [r7, #4]
 800af98:	68da      	ldr	r2, [r3, #12]
 800af9a:	2380      	movs	r3, #128	; 0x80
 800af9c:	011b      	lsls	r3, r3, #4
 800af9e:	429a      	cmp	r2, r3
 800afa0:	d00b      	beq.n	800afba <HAL_SPI_Init+0xaa>
 800afa2:	687b      	ldr	r3, [r7, #4]
 800afa4:	68db      	ldr	r3, [r3, #12]
 800afa6:	2b00      	cmp	r3, #0
 800afa8:	d007      	beq.n	800afba <HAL_SPI_Init+0xaa>
 800afaa:	234e      	movs	r3, #78	; 0x4e
 800afac:	33ff      	adds	r3, #255	; 0xff
 800afae:	001a      	movs	r2, r3
 800afb0:	4b5e      	ldr	r3, [pc, #376]	; (800b12c <HAL_SPI_Init+0x21c>)
 800afb2:	0011      	movs	r1, r2
 800afb4:	0018      	movs	r0, r3
 800afb6:	f7fb f96e 	bl	8006296 <assert_failed>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
 800afba:	687b      	ldr	r3, [r7, #4]
 800afbc:	699a      	ldr	r2, [r3, #24]
 800afbe:	2380      	movs	r3, #128	; 0x80
 800afc0:	009b      	lsls	r3, r3, #2
 800afc2:	429a      	cmp	r2, r3
 800afc4:	d010      	beq.n	800afe8 <HAL_SPI_Init+0xd8>
 800afc6:	687b      	ldr	r3, [r7, #4]
 800afc8:	699b      	ldr	r3, [r3, #24]
 800afca:	2b00      	cmp	r3, #0
 800afcc:	d00c      	beq.n	800afe8 <HAL_SPI_Init+0xd8>
 800afce:	687b      	ldr	r3, [r7, #4]
 800afd0:	699a      	ldr	r2, [r3, #24]
 800afd2:	2380      	movs	r3, #128	; 0x80
 800afd4:	02db      	lsls	r3, r3, #11
 800afd6:	429a      	cmp	r2, r3
 800afd8:	d006      	beq.n	800afe8 <HAL_SPI_Init+0xd8>
 800afda:	23a7      	movs	r3, #167	; 0xa7
 800afdc:	005a      	lsls	r2, r3, #1
 800afde:	4b53      	ldr	r3, [pc, #332]	; (800b12c <HAL_SPI_Init+0x21c>)
 800afe0:	0011      	movs	r1, r2
 800afe2:	0018      	movs	r0, r3
 800afe4:	f7fb f957 	bl	8006296 <assert_failed>
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
 800afe8:	687b      	ldr	r3, [r7, #4]
 800afea:	69db      	ldr	r3, [r3, #28]
 800afec:	2b00      	cmp	r3, #0
 800afee:	d023      	beq.n	800b038 <HAL_SPI_Init+0x128>
 800aff0:	687b      	ldr	r3, [r7, #4]
 800aff2:	69db      	ldr	r3, [r3, #28]
 800aff4:	2b08      	cmp	r3, #8
 800aff6:	d01f      	beq.n	800b038 <HAL_SPI_Init+0x128>
 800aff8:	687b      	ldr	r3, [r7, #4]
 800affa:	69db      	ldr	r3, [r3, #28]
 800affc:	2b10      	cmp	r3, #16
 800affe:	d01b      	beq.n	800b038 <HAL_SPI_Init+0x128>
 800b000:	687b      	ldr	r3, [r7, #4]
 800b002:	69db      	ldr	r3, [r3, #28]
 800b004:	2b18      	cmp	r3, #24
 800b006:	d017      	beq.n	800b038 <HAL_SPI_Init+0x128>
 800b008:	687b      	ldr	r3, [r7, #4]
 800b00a:	69db      	ldr	r3, [r3, #28]
 800b00c:	2b20      	cmp	r3, #32
 800b00e:	d013      	beq.n	800b038 <HAL_SPI_Init+0x128>
 800b010:	687b      	ldr	r3, [r7, #4]
 800b012:	69db      	ldr	r3, [r3, #28]
 800b014:	2b28      	cmp	r3, #40	; 0x28
 800b016:	d00f      	beq.n	800b038 <HAL_SPI_Init+0x128>
 800b018:	687b      	ldr	r3, [r7, #4]
 800b01a:	69db      	ldr	r3, [r3, #28]
 800b01c:	2b30      	cmp	r3, #48	; 0x30
 800b01e:	d00b      	beq.n	800b038 <HAL_SPI_Init+0x128>
 800b020:	687b      	ldr	r3, [r7, #4]
 800b022:	69db      	ldr	r3, [r3, #28]
 800b024:	2b38      	cmp	r3, #56	; 0x38
 800b026:	d007      	beq.n	800b038 <HAL_SPI_Init+0x128>
 800b028:	2350      	movs	r3, #80	; 0x50
 800b02a:	33ff      	adds	r3, #255	; 0xff
 800b02c:	001a      	movs	r2, r3
 800b02e:	4b3f      	ldr	r3, [pc, #252]	; (800b12c <HAL_SPI_Init+0x21c>)
 800b030:	0011      	movs	r1, r2
 800b032:	0018      	movs	r0, r3
 800b034:	f7fb f92f 	bl	8006296 <assert_failed>
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
 800b038:	687b      	ldr	r3, [r7, #4]
 800b03a:	6a1b      	ldr	r3, [r3, #32]
 800b03c:	2b00      	cmp	r3, #0
 800b03e:	d00a      	beq.n	800b056 <HAL_SPI_Init+0x146>
 800b040:	687b      	ldr	r3, [r7, #4]
 800b042:	6a1b      	ldr	r3, [r3, #32]
 800b044:	2b80      	cmp	r3, #128	; 0x80
 800b046:	d006      	beq.n	800b056 <HAL_SPI_Init+0x146>
 800b048:	23a8      	movs	r3, #168	; 0xa8
 800b04a:	005a      	lsls	r2, r3, #1
 800b04c:	4b37      	ldr	r3, [pc, #220]	; (800b12c <HAL_SPI_Init+0x21c>)
 800b04e:	0011      	movs	r1, r2
 800b050:	0018      	movs	r0, r3
 800b052:	f7fb f920 	bl	8006296 <assert_failed>
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
 800b056:	687b      	ldr	r3, [r7, #4]
 800b058:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b05a:	2b00      	cmp	r3, #0
 800b05c:	d00b      	beq.n	800b076 <HAL_SPI_Init+0x166>
 800b05e:	687b      	ldr	r3, [r7, #4]
 800b060:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b062:	2b10      	cmp	r3, #16
 800b064:	d007      	beq.n	800b076 <HAL_SPI_Init+0x166>
 800b066:	2352      	movs	r3, #82	; 0x52
 800b068:	33ff      	adds	r3, #255	; 0xff
 800b06a:	001a      	movs	r2, r3
 800b06c:	4b2f      	ldr	r3, [pc, #188]	; (800b12c <HAL_SPI_Init+0x21c>)
 800b06e:	0011      	movs	r1, r2
 800b070:	0018      	movs	r0, r3
 800b072:	f7fb f910 	bl	8006296 <assert_failed>
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 800b076:	687b      	ldr	r3, [r7, #4]
 800b078:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b07a:	2b00      	cmp	r3, #0
 800b07c:	d158      	bne.n	800b130 <HAL_SPI_Init+0x220>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
 800b07e:	687b      	ldr	r3, [r7, #4]
 800b080:	691b      	ldr	r3, [r3, #16]
 800b082:	2b00      	cmp	r3, #0
 800b084:	d00a      	beq.n	800b09c <HAL_SPI_Init+0x18c>
 800b086:	687b      	ldr	r3, [r7, #4]
 800b088:	691b      	ldr	r3, [r3, #16]
 800b08a:	2b02      	cmp	r3, #2
 800b08c:	d006      	beq.n	800b09c <HAL_SPI_Init+0x18c>
 800b08e:	23aa      	movs	r3, #170	; 0xaa
 800b090:	005a      	lsls	r2, r3, #1
 800b092:	4b26      	ldr	r3, [pc, #152]	; (800b12c <HAL_SPI_Init+0x21c>)
 800b094:	0011      	movs	r1, r2
 800b096:	0018      	movs	r0, r3
 800b098:	f7fb f8fd 	bl	8006296 <assert_failed>
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
 800b09c:	687b      	ldr	r3, [r7, #4]
 800b09e:	695b      	ldr	r3, [r3, #20]
 800b0a0:	2b00      	cmp	r3, #0
 800b0a2:	d00b      	beq.n	800b0bc <HAL_SPI_Init+0x1ac>
 800b0a4:	687b      	ldr	r3, [r7, #4]
 800b0a6:	695b      	ldr	r3, [r3, #20]
 800b0a8:	2b01      	cmp	r3, #1
 800b0aa:	d007      	beq.n	800b0bc <HAL_SPI_Init+0x1ac>
 800b0ac:	2356      	movs	r3, #86	; 0x56
 800b0ae:	33ff      	adds	r3, #255	; 0xff
 800b0b0:	001a      	movs	r2, r3
 800b0b2:	4b1e      	ldr	r3, [pc, #120]	; (800b12c <HAL_SPI_Init+0x21c>)
 800b0b4:	0011      	movs	r1, r2
 800b0b6:	0018      	movs	r0, r3
 800b0b8:	f7fb f8ed 	bl	8006296 <assert_failed>

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 800b0bc:	687b      	ldr	r3, [r7, #4]
 800b0be:	685a      	ldr	r2, [r3, #4]
 800b0c0:	2382      	movs	r3, #130	; 0x82
 800b0c2:	005b      	lsls	r3, r3, #1
 800b0c4:	429a      	cmp	r2, r3
 800b0c6:	d129      	bne.n	800b11c <HAL_SPI_Init+0x20c>
    {
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
 800b0c8:	687b      	ldr	r3, [r7, #4]
 800b0ca:	69db      	ldr	r3, [r3, #28]
 800b0cc:	2b00      	cmp	r3, #0
 800b0ce:	d100      	bne.n	800b0d2 <HAL_SPI_Init+0x1c2>
 800b0d0:	e05c      	b.n	800b18c <HAL_SPI_Init+0x27c>
 800b0d2:	687b      	ldr	r3, [r7, #4]
 800b0d4:	69db      	ldr	r3, [r3, #28]
 800b0d6:	2b08      	cmp	r3, #8
 800b0d8:	d058      	beq.n	800b18c <HAL_SPI_Init+0x27c>
 800b0da:	687b      	ldr	r3, [r7, #4]
 800b0dc:	69db      	ldr	r3, [r3, #28]
 800b0de:	2b10      	cmp	r3, #16
 800b0e0:	d054      	beq.n	800b18c <HAL_SPI_Init+0x27c>
 800b0e2:	687b      	ldr	r3, [r7, #4]
 800b0e4:	69db      	ldr	r3, [r3, #28]
 800b0e6:	2b18      	cmp	r3, #24
 800b0e8:	d050      	beq.n	800b18c <HAL_SPI_Init+0x27c>
 800b0ea:	687b      	ldr	r3, [r7, #4]
 800b0ec:	69db      	ldr	r3, [r3, #28]
 800b0ee:	2b20      	cmp	r3, #32
 800b0f0:	d04c      	beq.n	800b18c <HAL_SPI_Init+0x27c>
 800b0f2:	687b      	ldr	r3, [r7, #4]
 800b0f4:	69db      	ldr	r3, [r3, #28]
 800b0f6:	2b28      	cmp	r3, #40	; 0x28
 800b0f8:	d048      	beq.n	800b18c <HAL_SPI_Init+0x27c>
 800b0fa:	687b      	ldr	r3, [r7, #4]
 800b0fc:	69db      	ldr	r3, [r3, #28]
 800b0fe:	2b30      	cmp	r3, #48	; 0x30
 800b100:	d044      	beq.n	800b18c <HAL_SPI_Init+0x27c>
 800b102:	687b      	ldr	r3, [r7, #4]
 800b104:	69db      	ldr	r3, [r3, #28]
 800b106:	2b38      	cmp	r3, #56	; 0x38
 800b108:	d040      	beq.n	800b18c <HAL_SPI_Init+0x27c>
 800b10a:	235a      	movs	r3, #90	; 0x5a
 800b10c:	33ff      	adds	r3, #255	; 0xff
 800b10e:	001a      	movs	r2, r3
 800b110:	4b06      	ldr	r3, [pc, #24]	; (800b12c <HAL_SPI_Init+0x21c>)
 800b112:	0011      	movs	r1, r2
 800b114:	0018      	movs	r0, r3
 800b116:	f7fb f8be 	bl	8006296 <assert_failed>
 800b11a:	e037      	b.n	800b18c <HAL_SPI_Init+0x27c>
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800b11c:	687b      	ldr	r3, [r7, #4]
 800b11e:	2200      	movs	r2, #0
 800b120:	61da      	str	r2, [r3, #28]
 800b122:	e033      	b.n	800b18c <HAL_SPI_Init+0x27c>
 800b124:	40013000 	.word	0x40013000
 800b128:	40003800 	.word	0x40003800
 800b12c:	0800ded4 	.word	0x0800ded4
    }
  }
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
 800b130:	687b      	ldr	r3, [r7, #4]
 800b132:	69db      	ldr	r3, [r3, #28]
 800b134:	2b00      	cmp	r3, #0
 800b136:	d023      	beq.n	800b180 <HAL_SPI_Init+0x270>
 800b138:	687b      	ldr	r3, [r7, #4]
 800b13a:	69db      	ldr	r3, [r3, #28]
 800b13c:	2b08      	cmp	r3, #8
 800b13e:	d01f      	beq.n	800b180 <HAL_SPI_Init+0x270>
 800b140:	687b      	ldr	r3, [r7, #4]
 800b142:	69db      	ldr	r3, [r3, #28]
 800b144:	2b10      	cmp	r3, #16
 800b146:	d01b      	beq.n	800b180 <HAL_SPI_Init+0x270>
 800b148:	687b      	ldr	r3, [r7, #4]
 800b14a:	69db      	ldr	r3, [r3, #28]
 800b14c:	2b18      	cmp	r3, #24
 800b14e:	d017      	beq.n	800b180 <HAL_SPI_Init+0x270>
 800b150:	687b      	ldr	r3, [r7, #4]
 800b152:	69db      	ldr	r3, [r3, #28]
 800b154:	2b20      	cmp	r3, #32
 800b156:	d013      	beq.n	800b180 <HAL_SPI_Init+0x270>
 800b158:	687b      	ldr	r3, [r7, #4]
 800b15a:	69db      	ldr	r3, [r3, #28]
 800b15c:	2b28      	cmp	r3, #40	; 0x28
 800b15e:	d00f      	beq.n	800b180 <HAL_SPI_Init+0x270>
 800b160:	687b      	ldr	r3, [r7, #4]
 800b162:	69db      	ldr	r3, [r3, #28]
 800b164:	2b30      	cmp	r3, #48	; 0x30
 800b166:	d00b      	beq.n	800b180 <HAL_SPI_Init+0x270>
 800b168:	687b      	ldr	r3, [r7, #4]
 800b16a:	69db      	ldr	r3, [r3, #28]
 800b16c:	2b38      	cmp	r3, #56	; 0x38
 800b16e:	d007      	beq.n	800b180 <HAL_SPI_Init+0x270>
 800b170:	2364      	movs	r3, #100	; 0x64
 800b172:	33ff      	adds	r3, #255	; 0xff
 800b174:	001a      	movs	r2, r3
 800b176:	4b3f      	ldr	r3, [pc, #252]	; (800b274 <HAL_SPI_Init+0x364>)
 800b178:	0011      	movs	r1, r2
 800b17a:	0018      	movs	r0, r3
 800b17c:	f7fb f88b 	bl	8006296 <assert_failed>

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 800b180:	687b      	ldr	r3, [r7, #4]
 800b182:	2200      	movs	r2, #0
 800b184:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 800b186:	687b      	ldr	r3, [r7, #4]
 800b188:	2200      	movs	r2, #0
 800b18a:	615a      	str	r2, [r3, #20]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800b18c:	687b      	ldr	r3, [r7, #4]
 800b18e:	2200      	movs	r2, #0
 800b190:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800b192:	687b      	ldr	r3, [r7, #4]
 800b194:	2251      	movs	r2, #81	; 0x51
 800b196:	5c9b      	ldrb	r3, [r3, r2]
 800b198:	b2db      	uxtb	r3, r3
 800b19a:	2b00      	cmp	r3, #0
 800b19c:	d107      	bne.n	800b1ae <HAL_SPI_Init+0x29e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800b19e:	687b      	ldr	r3, [r7, #4]
 800b1a0:	2250      	movs	r2, #80	; 0x50
 800b1a2:	2100      	movs	r1, #0
 800b1a4:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800b1a6:	687b      	ldr	r3, [r7, #4]
 800b1a8:	0018      	movs	r0, r3
 800b1aa:	f7fc f805 	bl	80071b8 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800b1ae:	687b      	ldr	r3, [r7, #4]
 800b1b0:	2251      	movs	r2, #81	; 0x51
 800b1b2:	2102      	movs	r1, #2
 800b1b4:	5499      	strb	r1, [r3, r2]

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800b1b6:	687b      	ldr	r3, [r7, #4]
 800b1b8:	681b      	ldr	r3, [r3, #0]
 800b1ba:	681a      	ldr	r2, [r3, #0]
 800b1bc:	687b      	ldr	r3, [r7, #4]
 800b1be:	681b      	ldr	r3, [r3, #0]
 800b1c0:	2140      	movs	r1, #64	; 0x40
 800b1c2:	438a      	bics	r2, r1
 800b1c4:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800b1c6:	687b      	ldr	r3, [r7, #4]
 800b1c8:	685a      	ldr	r2, [r3, #4]
 800b1ca:	2382      	movs	r3, #130	; 0x82
 800b1cc:	005b      	lsls	r3, r3, #1
 800b1ce:	401a      	ands	r2, r3
 800b1d0:	687b      	ldr	r3, [r7, #4]
 800b1d2:	6899      	ldr	r1, [r3, #8]
 800b1d4:	2384      	movs	r3, #132	; 0x84
 800b1d6:	021b      	lsls	r3, r3, #8
 800b1d8:	400b      	ands	r3, r1
 800b1da:	431a      	orrs	r2, r3
 800b1dc:	687b      	ldr	r3, [r7, #4]
 800b1de:	68d9      	ldr	r1, [r3, #12]
 800b1e0:	2380      	movs	r3, #128	; 0x80
 800b1e2:	011b      	lsls	r3, r3, #4
 800b1e4:	400b      	ands	r3, r1
 800b1e6:	431a      	orrs	r2, r3
 800b1e8:	687b      	ldr	r3, [r7, #4]
 800b1ea:	691b      	ldr	r3, [r3, #16]
 800b1ec:	2102      	movs	r1, #2
 800b1ee:	400b      	ands	r3, r1
 800b1f0:	431a      	orrs	r2, r3
 800b1f2:	687b      	ldr	r3, [r7, #4]
 800b1f4:	695b      	ldr	r3, [r3, #20]
 800b1f6:	2101      	movs	r1, #1
 800b1f8:	400b      	ands	r3, r1
 800b1fa:	431a      	orrs	r2, r3
 800b1fc:	687b      	ldr	r3, [r7, #4]
 800b1fe:	6999      	ldr	r1, [r3, #24]
 800b200:	2380      	movs	r3, #128	; 0x80
 800b202:	009b      	lsls	r3, r3, #2
 800b204:	400b      	ands	r3, r1
 800b206:	431a      	orrs	r2, r3
 800b208:	687b      	ldr	r3, [r7, #4]
 800b20a:	69db      	ldr	r3, [r3, #28]
 800b20c:	2138      	movs	r1, #56	; 0x38
 800b20e:	400b      	ands	r3, r1
 800b210:	431a      	orrs	r2, r3
 800b212:	687b      	ldr	r3, [r7, #4]
 800b214:	6a1b      	ldr	r3, [r3, #32]
 800b216:	2180      	movs	r1, #128	; 0x80
 800b218:	400b      	ands	r3, r1
 800b21a:	431a      	orrs	r2, r3
 800b21c:	0011      	movs	r1, r2
 800b21e:	687b      	ldr	r3, [r7, #4]
 800b220:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b222:	2380      	movs	r3, #128	; 0x80
 800b224:	019b      	lsls	r3, r3, #6
 800b226:	401a      	ands	r2, r3
 800b228:	687b      	ldr	r3, [r7, #4]
 800b22a:	681b      	ldr	r3, [r3, #0]
 800b22c:	430a      	orrs	r2, r1
 800b22e:	601a      	str	r2, [r3, #0]
                                  (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
                                  (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
                                  (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 800b230:	687b      	ldr	r3, [r7, #4]
 800b232:	699b      	ldr	r3, [r3, #24]
 800b234:	0c1b      	lsrs	r3, r3, #16
 800b236:	2204      	movs	r2, #4
 800b238:	4013      	ands	r3, r2
 800b23a:	0019      	movs	r1, r3
 800b23c:	687b      	ldr	r3, [r7, #4]
 800b23e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b240:	2210      	movs	r2, #16
 800b242:	401a      	ands	r2, r3
 800b244:	687b      	ldr	r3, [r7, #4]
 800b246:	681b      	ldr	r3, [r3, #0]
 800b248:	430a      	orrs	r2, r1
 800b24a:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800b24c:	687b      	ldr	r3, [r7, #4]
 800b24e:	681b      	ldr	r3, [r3, #0]
 800b250:	69da      	ldr	r2, [r3, #28]
 800b252:	687b      	ldr	r3, [r7, #4]
 800b254:	681b      	ldr	r3, [r3, #0]
 800b256:	4908      	ldr	r1, [pc, #32]	; (800b278 <HAL_SPI_Init+0x368>)
 800b258:	400a      	ands	r2, r1
 800b25a:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800b25c:	687b      	ldr	r3, [r7, #4]
 800b25e:	2200      	movs	r2, #0
 800b260:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 800b262:	687b      	ldr	r3, [r7, #4]
 800b264:	2251      	movs	r2, #81	; 0x51
 800b266:	2101      	movs	r1, #1
 800b268:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800b26a:	2300      	movs	r3, #0
}
 800b26c:	0018      	movs	r0, r3
 800b26e:	46bd      	mov	sp, r7
 800b270:	b002      	add	sp, #8
 800b272:	bd80      	pop	{r7, pc}
 800b274:	0800ded4 	.word	0x0800ded4
 800b278:	fffff7ff 	.word	0xfffff7ff

0800b27c <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800b27c:	b580      	push	{r7, lr}
 800b27e:	b08c      	sub	sp, #48	; 0x30
 800b280:	af00      	add	r7, sp, #0
 800b282:	60f8      	str	r0, [r7, #12]
 800b284:	60b9      	str	r1, [r7, #8]
 800b286:	607a      	str	r2, [r7, #4]
 800b288:	001a      	movs	r2, r3
 800b28a:	1cbb      	adds	r3, r7, #2
 800b28c:	801a      	strh	r2, [r3, #0]
  uint32_t             tmp_mode;
  HAL_SPI_StateTypeDef tmp_state;
  uint32_t             tickstart;

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 800b28e:	2301      	movs	r3, #1
 800b290:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_StatusTypeDef    errorcode = HAL_OK;
 800b292:	232b      	movs	r3, #43	; 0x2b
 800b294:	18fb      	adds	r3, r7, r3
 800b296:	2200      	movs	r2, #0
 800b298:	701a      	strb	r2, [r3, #0]

  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800b29a:	68fb      	ldr	r3, [r7, #12]
 800b29c:	68db      	ldr	r3, [r3, #12]
 800b29e:	2b00      	cmp	r3, #0
 800b2a0:	d014      	beq.n	800b2cc <HAL_SPI_TransmitReceive+0x50>
  {
    /* in this case, 16-bit access is performed on Data
       So, check Data is 16-bit aligned address */
    assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pTxData));
 800b2a2:	68bb      	ldr	r3, [r7, #8]
 800b2a4:	2201      	movs	r2, #1
 800b2a6:	4013      	ands	r3, r2
 800b2a8:	d005      	beq.n	800b2b6 <HAL_SPI_TransmitReceive+0x3a>
 800b2aa:	4ac6      	ldr	r2, [pc, #792]	; (800b5c4 <HAL_SPI_TransmitReceive+0x348>)
 800b2ac:	4bc6      	ldr	r3, [pc, #792]	; (800b5c8 <HAL_SPI_TransmitReceive+0x34c>)
 800b2ae:	0011      	movs	r1, r2
 800b2b0:	0018      	movs	r0, r3
 800b2b2:	f7fa fff0 	bl	8006296 <assert_failed>
    assert_param(IS_SPI_16BIT_ALIGNED_ADDRESS(pRxData));
 800b2b6:	687b      	ldr	r3, [r7, #4]
 800b2b8:	2201      	movs	r2, #1
 800b2ba:	4013      	ands	r3, r2
 800b2bc:	d006      	beq.n	800b2cc <HAL_SPI_TransmitReceive+0x50>
 800b2be:	2392      	movs	r3, #146	; 0x92
 800b2c0:	00da      	lsls	r2, r3, #3
 800b2c2:	4bc1      	ldr	r3, [pc, #772]	; (800b5c8 <HAL_SPI_TransmitReceive+0x34c>)
 800b2c4:	0011      	movs	r1, r2
 800b2c6:	0018      	movs	r0, r3
 800b2c8:	f7fa ffe5 	bl	8006296 <assert_failed>
  }

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
 800b2cc:	68fb      	ldr	r3, [r7, #12]
 800b2ce:	689b      	ldr	r3, [r3, #8]
 800b2d0:	2b00      	cmp	r3, #0
 800b2d2:	d005      	beq.n	800b2e0 <HAL_SPI_TransmitReceive+0x64>
 800b2d4:	4abd      	ldr	r2, [pc, #756]	; (800b5cc <HAL_SPI_TransmitReceive+0x350>)
 800b2d6:	4bbc      	ldr	r3, [pc, #752]	; (800b5c8 <HAL_SPI_TransmitReceive+0x34c>)
 800b2d8:	0011      	movs	r1, r2
 800b2da:	0018      	movs	r0, r3
 800b2dc:	f7fa ffdb 	bl	8006296 <assert_failed>

  /* Process Locked */
  __HAL_LOCK(hspi);
 800b2e0:	68fb      	ldr	r3, [r7, #12]
 800b2e2:	2250      	movs	r2, #80	; 0x50
 800b2e4:	5c9b      	ldrb	r3, [r3, r2]
 800b2e6:	2b01      	cmp	r3, #1
 800b2e8:	d101      	bne.n	800b2ee <HAL_SPI_TransmitReceive+0x72>
 800b2ea:	2302      	movs	r3, #2
 800b2ec:	e1a6      	b.n	800b63c <HAL_SPI_TransmitReceive+0x3c0>
 800b2ee:	68fb      	ldr	r3, [r7, #12]
 800b2f0:	2250      	movs	r2, #80	; 0x50
 800b2f2:	2101      	movs	r1, #1
 800b2f4:	5499      	strb	r1, [r3, r2]

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800b2f6:	f7fc f8f5 	bl	80074e4 <HAL_GetTick>
 800b2fa:	0003      	movs	r3, r0
 800b2fc:	627b      	str	r3, [r7, #36]	; 0x24

  /* Init temporary variables */
  tmp_state           = hspi->State;
 800b2fe:	2023      	movs	r0, #35	; 0x23
 800b300:	183b      	adds	r3, r7, r0
 800b302:	68fa      	ldr	r2, [r7, #12]
 800b304:	2151      	movs	r1, #81	; 0x51
 800b306:	5c52      	ldrb	r2, [r2, r1]
 800b308:	701a      	strb	r2, [r3, #0]
  tmp_mode            = hspi->Init.Mode;
 800b30a:	68fb      	ldr	r3, [r7, #12]
 800b30c:	685b      	ldr	r3, [r3, #4]
 800b30e:	61fb      	str	r3, [r7, #28]
  initial_TxXferCount = Size;
 800b310:	231a      	movs	r3, #26
 800b312:	18fb      	adds	r3, r7, r3
 800b314:	1cba      	adds	r2, r7, #2
 800b316:	8812      	ldrh	r2, [r2, #0]
 800b318:	801a      	strh	r2, [r3, #0]

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 800b31a:	183b      	adds	r3, r7, r0
 800b31c:	781b      	ldrb	r3, [r3, #0]
 800b31e:	2b01      	cmp	r3, #1
 800b320:	d011      	beq.n	800b346 <HAL_SPI_TransmitReceive+0xca>
 800b322:	69fa      	ldr	r2, [r7, #28]
 800b324:	2382      	movs	r3, #130	; 0x82
 800b326:	005b      	lsls	r3, r3, #1
 800b328:	429a      	cmp	r2, r3
 800b32a:	d107      	bne.n	800b33c <HAL_SPI_TransmitReceive+0xc0>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 800b32c:	68fb      	ldr	r3, [r7, #12]
 800b32e:	689b      	ldr	r3, [r3, #8]
 800b330:	2b00      	cmp	r3, #0
 800b332:	d103      	bne.n	800b33c <HAL_SPI_TransmitReceive+0xc0>
 800b334:	183b      	adds	r3, r7, r0
 800b336:	781b      	ldrb	r3, [r3, #0]
 800b338:	2b04      	cmp	r3, #4
 800b33a:	d004      	beq.n	800b346 <HAL_SPI_TransmitReceive+0xca>
  {
    errorcode = HAL_BUSY;
 800b33c:	232b      	movs	r3, #43	; 0x2b
 800b33e:	18fb      	adds	r3, r7, r3
 800b340:	2202      	movs	r2, #2
 800b342:	701a      	strb	r2, [r3, #0]
    goto error;
 800b344:	e16f      	b.n	800b626 <HAL_SPI_TransmitReceive+0x3aa>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 800b346:	68bb      	ldr	r3, [r7, #8]
 800b348:	2b00      	cmp	r3, #0
 800b34a:	d006      	beq.n	800b35a <HAL_SPI_TransmitReceive+0xde>
 800b34c:	687b      	ldr	r3, [r7, #4]
 800b34e:	2b00      	cmp	r3, #0
 800b350:	d003      	beq.n	800b35a <HAL_SPI_TransmitReceive+0xde>
 800b352:	1cbb      	adds	r3, r7, #2
 800b354:	881b      	ldrh	r3, [r3, #0]
 800b356:	2b00      	cmp	r3, #0
 800b358:	d104      	bne.n	800b364 <HAL_SPI_TransmitReceive+0xe8>
  {
    errorcode = HAL_ERROR;
 800b35a:	232b      	movs	r3, #43	; 0x2b
 800b35c:	18fb      	adds	r3, r7, r3
 800b35e:	2201      	movs	r2, #1
 800b360:	701a      	strb	r2, [r3, #0]
    goto error;
 800b362:	e160      	b.n	800b626 <HAL_SPI_TransmitReceive+0x3aa>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 800b364:	68fb      	ldr	r3, [r7, #12]
 800b366:	2251      	movs	r2, #81	; 0x51
 800b368:	5c9b      	ldrb	r3, [r3, r2]
 800b36a:	b2db      	uxtb	r3, r3
 800b36c:	2b04      	cmp	r3, #4
 800b36e:	d003      	beq.n	800b378 <HAL_SPI_TransmitReceive+0xfc>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800b370:	68fb      	ldr	r3, [r7, #12]
 800b372:	2251      	movs	r2, #81	; 0x51
 800b374:	2105      	movs	r1, #5
 800b376:	5499      	strb	r1, [r3, r2]
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800b378:	68fb      	ldr	r3, [r7, #12]
 800b37a:	2200      	movs	r2, #0
 800b37c:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 800b37e:	68fb      	ldr	r3, [r7, #12]
 800b380:	687a      	ldr	r2, [r7, #4]
 800b382:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferCount = Size;
 800b384:	68fb      	ldr	r3, [r7, #12]
 800b386:	1cba      	adds	r2, r7, #2
 800b388:	8812      	ldrh	r2, [r2, #0]
 800b38a:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->RxXferSize  = Size;
 800b38c:	68fb      	ldr	r3, [r7, #12]
 800b38e:	1cba      	adds	r2, r7, #2
 800b390:	8812      	ldrh	r2, [r2, #0]
 800b392:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 800b394:	68fb      	ldr	r3, [r7, #12]
 800b396:	68ba      	ldr	r2, [r7, #8]
 800b398:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferCount = Size;
 800b39a:	68fb      	ldr	r3, [r7, #12]
 800b39c:	1cba      	adds	r2, r7, #2
 800b39e:	8812      	ldrh	r2, [r2, #0]
 800b3a0:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->TxXferSize  = Size;
 800b3a2:	68fb      	ldr	r3, [r7, #12]
 800b3a4:	1cba      	adds	r2, r7, #2
 800b3a6:	8812      	ldrh	r2, [r2, #0]
 800b3a8:	869a      	strh	r2, [r3, #52]	; 0x34

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 800b3aa:	68fb      	ldr	r3, [r7, #12]
 800b3ac:	2200      	movs	r2, #0
 800b3ae:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->TxISR       = NULL;
 800b3b0:	68fb      	ldr	r3, [r7, #12]
 800b3b2:	2200      	movs	r2, #0
 800b3b4:	645a      	str	r2, [r3, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800b3b6:	68fb      	ldr	r3, [r7, #12]
 800b3b8:	681b      	ldr	r3, [r3, #0]
 800b3ba:	681b      	ldr	r3, [r3, #0]
 800b3bc:	2240      	movs	r2, #64	; 0x40
 800b3be:	4013      	ands	r3, r2
 800b3c0:	2b40      	cmp	r3, #64	; 0x40
 800b3c2:	d007      	beq.n	800b3d4 <HAL_SPI_TransmitReceive+0x158>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800b3c4:	68fb      	ldr	r3, [r7, #12]
 800b3c6:	681b      	ldr	r3, [r3, #0]
 800b3c8:	681a      	ldr	r2, [r3, #0]
 800b3ca:	68fb      	ldr	r3, [r7, #12]
 800b3cc:	681b      	ldr	r3, [r3, #0]
 800b3ce:	2140      	movs	r1, #64	; 0x40
 800b3d0:	430a      	orrs	r2, r1
 800b3d2:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800b3d4:	68fb      	ldr	r3, [r7, #12]
 800b3d6:	68da      	ldr	r2, [r3, #12]
 800b3d8:	2380      	movs	r3, #128	; 0x80
 800b3da:	011b      	lsls	r3, r3, #4
 800b3dc:	429a      	cmp	r2, r3
 800b3de:	d000      	beq.n	800b3e2 <HAL_SPI_TransmitReceive+0x166>
 800b3e0:	e07a      	b.n	800b4d8 <HAL_SPI_TransmitReceive+0x25c>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800b3e2:	68fb      	ldr	r3, [r7, #12]
 800b3e4:	685b      	ldr	r3, [r3, #4]
 800b3e6:	2b00      	cmp	r3, #0
 800b3e8:	d004      	beq.n	800b3f4 <HAL_SPI_TransmitReceive+0x178>
 800b3ea:	231a      	movs	r3, #26
 800b3ec:	18fb      	adds	r3, r7, r3
 800b3ee:	881b      	ldrh	r3, [r3, #0]
 800b3f0:	2b01      	cmp	r3, #1
 800b3f2:	d166      	bne.n	800b4c2 <HAL_SPI_TransmitReceive+0x246>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800b3f4:	68fb      	ldr	r3, [r7, #12]
 800b3f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b3f8:	881a      	ldrh	r2, [r3, #0]
 800b3fa:	68fb      	ldr	r3, [r7, #12]
 800b3fc:	681b      	ldr	r3, [r3, #0]
 800b3fe:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 800b400:	68fb      	ldr	r3, [r7, #12]
 800b402:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b404:	1c9a      	adds	r2, r3, #2
 800b406:	68fb      	ldr	r3, [r7, #12]
 800b408:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 800b40a:	68fb      	ldr	r3, [r7, #12]
 800b40c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b40e:	b29b      	uxth	r3, r3
 800b410:	3b01      	subs	r3, #1
 800b412:	b29a      	uxth	r2, r3
 800b414:	68fb      	ldr	r3, [r7, #12]
 800b416:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800b418:	e053      	b.n	800b4c2 <HAL_SPI_TransmitReceive+0x246>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800b41a:	68fb      	ldr	r3, [r7, #12]
 800b41c:	681b      	ldr	r3, [r3, #0]
 800b41e:	689b      	ldr	r3, [r3, #8]
 800b420:	2202      	movs	r2, #2
 800b422:	4013      	ands	r3, r2
 800b424:	2b02      	cmp	r3, #2
 800b426:	d11b      	bne.n	800b460 <HAL_SPI_TransmitReceive+0x1e4>
 800b428:	68fb      	ldr	r3, [r7, #12]
 800b42a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b42c:	b29b      	uxth	r3, r3
 800b42e:	2b00      	cmp	r3, #0
 800b430:	d016      	beq.n	800b460 <HAL_SPI_TransmitReceive+0x1e4>
 800b432:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b434:	2b01      	cmp	r3, #1
 800b436:	d113      	bne.n	800b460 <HAL_SPI_TransmitReceive+0x1e4>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800b438:	68fb      	ldr	r3, [r7, #12]
 800b43a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b43c:	881a      	ldrh	r2, [r3, #0]
 800b43e:	68fb      	ldr	r3, [r7, #12]
 800b440:	681b      	ldr	r3, [r3, #0]
 800b442:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800b444:	68fb      	ldr	r3, [r7, #12]
 800b446:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b448:	1c9a      	adds	r2, r3, #2
 800b44a:	68fb      	ldr	r3, [r7, #12]
 800b44c:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 800b44e:	68fb      	ldr	r3, [r7, #12]
 800b450:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b452:	b29b      	uxth	r3, r3
 800b454:	3b01      	subs	r3, #1
 800b456:	b29a      	uxth	r2, r3
 800b458:	68fb      	ldr	r3, [r7, #12]
 800b45a:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 800b45c:	2300      	movs	r3, #0
 800b45e:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800b460:	68fb      	ldr	r3, [r7, #12]
 800b462:	681b      	ldr	r3, [r3, #0]
 800b464:	689b      	ldr	r3, [r3, #8]
 800b466:	2201      	movs	r2, #1
 800b468:	4013      	ands	r3, r2
 800b46a:	2b01      	cmp	r3, #1
 800b46c:	d119      	bne.n	800b4a2 <HAL_SPI_TransmitReceive+0x226>
 800b46e:	68fb      	ldr	r3, [r7, #12]
 800b470:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b472:	b29b      	uxth	r3, r3
 800b474:	2b00      	cmp	r3, #0
 800b476:	d014      	beq.n	800b4a2 <HAL_SPI_TransmitReceive+0x226>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 800b478:	68fb      	ldr	r3, [r7, #12]
 800b47a:	681b      	ldr	r3, [r3, #0]
 800b47c:	68da      	ldr	r2, [r3, #12]
 800b47e:	68fb      	ldr	r3, [r7, #12]
 800b480:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b482:	b292      	uxth	r2, r2
 800b484:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 800b486:	68fb      	ldr	r3, [r7, #12]
 800b488:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b48a:	1c9a      	adds	r2, r3, #2
 800b48c:	68fb      	ldr	r3, [r7, #12]
 800b48e:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 800b490:	68fb      	ldr	r3, [r7, #12]
 800b492:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b494:	b29b      	uxth	r3, r3
 800b496:	3b01      	subs	r3, #1
 800b498:	b29a      	uxth	r2, r3
 800b49a:	68fb      	ldr	r3, [r7, #12]
 800b49c:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800b49e:	2301      	movs	r3, #1
 800b4a0:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 800b4a2:	f7fc f81f 	bl	80074e4 <HAL_GetTick>
 800b4a6:	0002      	movs	r2, r0
 800b4a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b4aa:	1ad3      	subs	r3, r2, r3
 800b4ac:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b4ae:	429a      	cmp	r2, r3
 800b4b0:	d807      	bhi.n	800b4c2 <HAL_SPI_TransmitReceive+0x246>
 800b4b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b4b4:	3301      	adds	r3, #1
 800b4b6:	d004      	beq.n	800b4c2 <HAL_SPI_TransmitReceive+0x246>
      {
        errorcode = HAL_TIMEOUT;
 800b4b8:	232b      	movs	r3, #43	; 0x2b
 800b4ba:	18fb      	adds	r3, r7, r3
 800b4bc:	2203      	movs	r2, #3
 800b4be:	701a      	strb	r2, [r3, #0]
        goto error;
 800b4c0:	e0b1      	b.n	800b626 <HAL_SPI_TransmitReceive+0x3aa>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800b4c2:	68fb      	ldr	r3, [r7, #12]
 800b4c4:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b4c6:	b29b      	uxth	r3, r3
 800b4c8:	2b00      	cmp	r3, #0
 800b4ca:	d1a6      	bne.n	800b41a <HAL_SPI_TransmitReceive+0x19e>
 800b4cc:	68fb      	ldr	r3, [r7, #12]
 800b4ce:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b4d0:	b29b      	uxth	r3, r3
 800b4d2:	2b00      	cmp	r3, #0
 800b4d4:	d1a1      	bne.n	800b41a <HAL_SPI_TransmitReceive+0x19e>
 800b4d6:	e085      	b.n	800b5e4 <HAL_SPI_TransmitReceive+0x368>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800b4d8:	68fb      	ldr	r3, [r7, #12]
 800b4da:	685b      	ldr	r3, [r3, #4]
 800b4dc:	2b00      	cmp	r3, #0
 800b4de:	d005      	beq.n	800b4ec <HAL_SPI_TransmitReceive+0x270>
 800b4e0:	231a      	movs	r3, #26
 800b4e2:	18fb      	adds	r3, r7, r3
 800b4e4:	881b      	ldrh	r3, [r3, #0]
 800b4e6:	2b01      	cmp	r3, #1
 800b4e8:	d000      	beq.n	800b4ec <HAL_SPI_TransmitReceive+0x270>
 800b4ea:	e071      	b.n	800b5d0 <HAL_SPI_TransmitReceive+0x354>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 800b4ec:	68fb      	ldr	r3, [r7, #12]
 800b4ee:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b4f0:	68fb      	ldr	r3, [r7, #12]
 800b4f2:	681b      	ldr	r3, [r3, #0]
 800b4f4:	330c      	adds	r3, #12
 800b4f6:	7812      	ldrb	r2, [r2, #0]
 800b4f8:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 800b4fa:	68fb      	ldr	r3, [r7, #12]
 800b4fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b4fe:	1c5a      	adds	r2, r3, #1
 800b500:	68fb      	ldr	r3, [r7, #12]
 800b502:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 800b504:	68fb      	ldr	r3, [r7, #12]
 800b506:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b508:	b29b      	uxth	r3, r3
 800b50a:	3b01      	subs	r3, #1
 800b50c:	b29a      	uxth	r2, r3
 800b50e:	68fb      	ldr	r3, [r7, #12]
 800b510:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800b512:	e05d      	b.n	800b5d0 <HAL_SPI_TransmitReceive+0x354>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800b514:	68fb      	ldr	r3, [r7, #12]
 800b516:	681b      	ldr	r3, [r3, #0]
 800b518:	689b      	ldr	r3, [r3, #8]
 800b51a:	2202      	movs	r2, #2
 800b51c:	4013      	ands	r3, r2
 800b51e:	2b02      	cmp	r3, #2
 800b520:	d11c      	bne.n	800b55c <HAL_SPI_TransmitReceive+0x2e0>
 800b522:	68fb      	ldr	r3, [r7, #12]
 800b524:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b526:	b29b      	uxth	r3, r3
 800b528:	2b00      	cmp	r3, #0
 800b52a:	d017      	beq.n	800b55c <HAL_SPI_TransmitReceive+0x2e0>
 800b52c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b52e:	2b01      	cmp	r3, #1
 800b530:	d114      	bne.n	800b55c <HAL_SPI_TransmitReceive+0x2e0>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800b532:	68fb      	ldr	r3, [r7, #12]
 800b534:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b536:	68fb      	ldr	r3, [r7, #12]
 800b538:	681b      	ldr	r3, [r3, #0]
 800b53a:	330c      	adds	r3, #12
 800b53c:	7812      	ldrb	r2, [r2, #0]
 800b53e:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 800b540:	68fb      	ldr	r3, [r7, #12]
 800b542:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b544:	1c5a      	adds	r2, r3, #1
 800b546:	68fb      	ldr	r3, [r7, #12]
 800b548:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 800b54a:	68fb      	ldr	r3, [r7, #12]
 800b54c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b54e:	b29b      	uxth	r3, r3
 800b550:	3b01      	subs	r3, #1
 800b552:	b29a      	uxth	r2, r3
 800b554:	68fb      	ldr	r3, [r7, #12]
 800b556:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 800b558:	2300      	movs	r3, #0
 800b55a:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800b55c:	68fb      	ldr	r3, [r7, #12]
 800b55e:	681b      	ldr	r3, [r3, #0]
 800b560:	689b      	ldr	r3, [r3, #8]
 800b562:	2201      	movs	r2, #1
 800b564:	4013      	ands	r3, r2
 800b566:	2b01      	cmp	r3, #1
 800b568:	d119      	bne.n	800b59e <HAL_SPI_TransmitReceive+0x322>
 800b56a:	68fb      	ldr	r3, [r7, #12]
 800b56c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b56e:	b29b      	uxth	r3, r3
 800b570:	2b00      	cmp	r3, #0
 800b572:	d014      	beq.n	800b59e <HAL_SPI_TransmitReceive+0x322>
      {
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800b574:	68fb      	ldr	r3, [r7, #12]
 800b576:	681b      	ldr	r3, [r3, #0]
 800b578:	68da      	ldr	r2, [r3, #12]
 800b57a:	68fb      	ldr	r3, [r7, #12]
 800b57c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b57e:	b2d2      	uxtb	r2, r2
 800b580:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr++;
 800b582:	68fb      	ldr	r3, [r7, #12]
 800b584:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b586:	1c5a      	adds	r2, r3, #1
 800b588:	68fb      	ldr	r3, [r7, #12]
 800b58a:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 800b58c:	68fb      	ldr	r3, [r7, #12]
 800b58e:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b590:	b29b      	uxth	r3, r3
 800b592:	3b01      	subs	r3, #1
 800b594:	b29a      	uxth	r2, r3
 800b596:	68fb      	ldr	r3, [r7, #12]
 800b598:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800b59a:	2301      	movs	r3, #1
 800b59c:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 800b59e:	f7fb ffa1 	bl	80074e4 <HAL_GetTick>
 800b5a2:	0002      	movs	r2, r0
 800b5a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5a6:	1ad3      	subs	r3, r2, r3
 800b5a8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b5aa:	429a      	cmp	r2, r3
 800b5ac:	d802      	bhi.n	800b5b4 <HAL_SPI_TransmitReceive+0x338>
 800b5ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5b0:	3301      	adds	r3, #1
 800b5b2:	d102      	bne.n	800b5ba <HAL_SPI_TransmitReceive+0x33e>
 800b5b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5b6:	2b00      	cmp	r3, #0
 800b5b8:	d10a      	bne.n	800b5d0 <HAL_SPI_TransmitReceive+0x354>
      {
        errorcode = HAL_TIMEOUT;
 800b5ba:	232b      	movs	r3, #43	; 0x2b
 800b5bc:	18fb      	adds	r3, r7, r3
 800b5be:	2203      	movs	r2, #3
 800b5c0:	701a      	strb	r2, [r3, #0]
        goto error;
 800b5c2:	e030      	b.n	800b626 <HAL_SPI_TransmitReceive+0x3aa>
 800b5c4:	0000048f 	.word	0x0000048f
 800b5c8:	0800ded4 	.word	0x0800ded4
 800b5cc:	00000494 	.word	0x00000494
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800b5d0:	68fb      	ldr	r3, [r7, #12]
 800b5d2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b5d4:	b29b      	uxth	r3, r3
 800b5d6:	2b00      	cmp	r3, #0
 800b5d8:	d19c      	bne.n	800b514 <HAL_SPI_TransmitReceive+0x298>
 800b5da:	68fb      	ldr	r3, [r7, #12]
 800b5dc:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800b5de:	b29b      	uxth	r3, r3
 800b5e0:	2b00      	cmp	r3, #0
 800b5e2:	d197      	bne.n	800b514 <HAL_SPI_TransmitReceive+0x298>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 800b5e4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b5e6:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800b5e8:	68fb      	ldr	r3, [r7, #12]
 800b5ea:	0018      	movs	r0, r3
 800b5ec:	f000 f8b8 	bl	800b760 <SPI_EndRxTxTransaction>
 800b5f0:	1e03      	subs	r3, r0, #0
 800b5f2:	d007      	beq.n	800b604 <HAL_SPI_TransmitReceive+0x388>
  {
    errorcode = HAL_ERROR;
 800b5f4:	232b      	movs	r3, #43	; 0x2b
 800b5f6:	18fb      	adds	r3, r7, r3
 800b5f8:	2201      	movs	r2, #1
 800b5fa:	701a      	strb	r2, [r3, #0]
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800b5fc:	68fb      	ldr	r3, [r7, #12]
 800b5fe:	2220      	movs	r2, #32
 800b600:	655a      	str	r2, [r3, #84]	; 0x54
    goto error;
 800b602:	e010      	b.n	800b626 <HAL_SPI_TransmitReceive+0x3aa>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800b604:	68fb      	ldr	r3, [r7, #12]
 800b606:	689b      	ldr	r3, [r3, #8]
 800b608:	2b00      	cmp	r3, #0
 800b60a:	d10b      	bne.n	800b624 <HAL_SPI_TransmitReceive+0x3a8>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800b60c:	2300      	movs	r3, #0
 800b60e:	617b      	str	r3, [r7, #20]
 800b610:	68fb      	ldr	r3, [r7, #12]
 800b612:	681b      	ldr	r3, [r3, #0]
 800b614:	68db      	ldr	r3, [r3, #12]
 800b616:	617b      	str	r3, [r7, #20]
 800b618:	68fb      	ldr	r3, [r7, #12]
 800b61a:	681b      	ldr	r3, [r3, #0]
 800b61c:	689b      	ldr	r3, [r3, #8]
 800b61e:	617b      	str	r3, [r7, #20]
 800b620:	697b      	ldr	r3, [r7, #20]
 800b622:	e000      	b.n	800b626 <HAL_SPI_TransmitReceive+0x3aa>
  }

error :
 800b624:	46c0      	nop			; (mov r8, r8)
  hspi->State = HAL_SPI_STATE_READY;
 800b626:	68fb      	ldr	r3, [r7, #12]
 800b628:	2251      	movs	r2, #81	; 0x51
 800b62a:	2101      	movs	r1, #1
 800b62c:	5499      	strb	r1, [r3, r2]
  __HAL_UNLOCK(hspi);
 800b62e:	68fb      	ldr	r3, [r7, #12]
 800b630:	2250      	movs	r2, #80	; 0x50
 800b632:	2100      	movs	r1, #0
 800b634:	5499      	strb	r1, [r3, r2]
  return errorcode;
 800b636:	232b      	movs	r3, #43	; 0x2b
 800b638:	18fb      	adds	r3, r7, r3
 800b63a:	781b      	ldrb	r3, [r3, #0]
}
 800b63c:	0018      	movs	r0, r3
 800b63e:	46bd      	mov	sp, r7
 800b640:	b00c      	add	sp, #48	; 0x30
 800b642:	bd80      	pop	{r7, pc}

0800b644 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 800b644:	b580      	push	{r7, lr}
 800b646:	b088      	sub	sp, #32
 800b648:	af00      	add	r7, sp, #0
 800b64a:	60f8      	str	r0, [r7, #12]
 800b64c:	60b9      	str	r1, [r7, #8]
 800b64e:	603b      	str	r3, [r7, #0]
 800b650:	1dfb      	adds	r3, r7, #7
 800b652:	701a      	strb	r2, [r3, #0]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 800b654:	f7fb ff46 	bl	80074e4 <HAL_GetTick>
 800b658:	0002      	movs	r2, r0
 800b65a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b65c:	1a9b      	subs	r3, r3, r2
 800b65e:	683a      	ldr	r2, [r7, #0]
 800b660:	18d3      	adds	r3, r2, r3
 800b662:	61fb      	str	r3, [r7, #28]
  tmp_tickstart = HAL_GetTick();
 800b664:	f7fb ff3e 	bl	80074e4 <HAL_GetTick>
 800b668:	0003      	movs	r3, r0
 800b66a:	61bb      	str	r3, [r7, #24]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 800b66c:	4b3a      	ldr	r3, [pc, #232]	; (800b758 <SPI_WaitFlagStateUntilTimeout+0x114>)
 800b66e:	681b      	ldr	r3, [r3, #0]
 800b670:	015b      	lsls	r3, r3, #5
 800b672:	0d1b      	lsrs	r3, r3, #20
 800b674:	69fa      	ldr	r2, [r7, #28]
 800b676:	4353      	muls	r3, r2
 800b678:	617b      	str	r3, [r7, #20]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800b67a:	e058      	b.n	800b72e <SPI_WaitFlagStateUntilTimeout+0xea>
  {
    if (Timeout != HAL_MAX_DELAY)
 800b67c:	683b      	ldr	r3, [r7, #0]
 800b67e:	3301      	adds	r3, #1
 800b680:	d055      	beq.n	800b72e <SPI_WaitFlagStateUntilTimeout+0xea>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 800b682:	f7fb ff2f 	bl	80074e4 <HAL_GetTick>
 800b686:	0002      	movs	r2, r0
 800b688:	69bb      	ldr	r3, [r7, #24]
 800b68a:	1ad3      	subs	r3, r2, r3
 800b68c:	69fa      	ldr	r2, [r7, #28]
 800b68e:	429a      	cmp	r2, r3
 800b690:	d902      	bls.n	800b698 <SPI_WaitFlagStateUntilTimeout+0x54>
 800b692:	69fb      	ldr	r3, [r7, #28]
 800b694:	2b00      	cmp	r3, #0
 800b696:	d142      	bne.n	800b71e <SPI_WaitFlagStateUntilTimeout+0xda>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800b698:	68fb      	ldr	r3, [r7, #12]
 800b69a:	681b      	ldr	r3, [r3, #0]
 800b69c:	685a      	ldr	r2, [r3, #4]
 800b69e:	68fb      	ldr	r3, [r7, #12]
 800b6a0:	681b      	ldr	r3, [r3, #0]
 800b6a2:	21e0      	movs	r1, #224	; 0xe0
 800b6a4:	438a      	bics	r2, r1
 800b6a6:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800b6a8:	68fb      	ldr	r3, [r7, #12]
 800b6aa:	685a      	ldr	r2, [r3, #4]
 800b6ac:	2382      	movs	r3, #130	; 0x82
 800b6ae:	005b      	lsls	r3, r3, #1
 800b6b0:	429a      	cmp	r2, r3
 800b6b2:	d113      	bne.n	800b6dc <SPI_WaitFlagStateUntilTimeout+0x98>
 800b6b4:	68fb      	ldr	r3, [r7, #12]
 800b6b6:	689a      	ldr	r2, [r3, #8]
 800b6b8:	2380      	movs	r3, #128	; 0x80
 800b6ba:	021b      	lsls	r3, r3, #8
 800b6bc:	429a      	cmp	r2, r3
 800b6be:	d005      	beq.n	800b6cc <SPI_WaitFlagStateUntilTimeout+0x88>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800b6c0:	68fb      	ldr	r3, [r7, #12]
 800b6c2:	689a      	ldr	r2, [r3, #8]
 800b6c4:	2380      	movs	r3, #128	; 0x80
 800b6c6:	00db      	lsls	r3, r3, #3
 800b6c8:	429a      	cmp	r2, r3
 800b6ca:	d107      	bne.n	800b6dc <SPI_WaitFlagStateUntilTimeout+0x98>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800b6cc:	68fb      	ldr	r3, [r7, #12]
 800b6ce:	681b      	ldr	r3, [r3, #0]
 800b6d0:	681a      	ldr	r2, [r3, #0]
 800b6d2:	68fb      	ldr	r3, [r7, #12]
 800b6d4:	681b      	ldr	r3, [r3, #0]
 800b6d6:	2140      	movs	r1, #64	; 0x40
 800b6d8:	438a      	bics	r2, r1
 800b6da:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800b6dc:	68fb      	ldr	r3, [r7, #12]
 800b6de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b6e0:	2380      	movs	r3, #128	; 0x80
 800b6e2:	019b      	lsls	r3, r3, #6
 800b6e4:	429a      	cmp	r2, r3
 800b6e6:	d110      	bne.n	800b70a <SPI_WaitFlagStateUntilTimeout+0xc6>
        {
          SPI_RESET_CRC(hspi);
 800b6e8:	68fb      	ldr	r3, [r7, #12]
 800b6ea:	681b      	ldr	r3, [r3, #0]
 800b6ec:	681a      	ldr	r2, [r3, #0]
 800b6ee:	68fb      	ldr	r3, [r7, #12]
 800b6f0:	681b      	ldr	r3, [r3, #0]
 800b6f2:	491a      	ldr	r1, [pc, #104]	; (800b75c <SPI_WaitFlagStateUntilTimeout+0x118>)
 800b6f4:	400a      	ands	r2, r1
 800b6f6:	601a      	str	r2, [r3, #0]
 800b6f8:	68fb      	ldr	r3, [r7, #12]
 800b6fa:	681b      	ldr	r3, [r3, #0]
 800b6fc:	681a      	ldr	r2, [r3, #0]
 800b6fe:	68fb      	ldr	r3, [r7, #12]
 800b700:	681b      	ldr	r3, [r3, #0]
 800b702:	2180      	movs	r1, #128	; 0x80
 800b704:	0189      	lsls	r1, r1, #6
 800b706:	430a      	orrs	r2, r1
 800b708:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 800b70a:	68fb      	ldr	r3, [r7, #12]
 800b70c:	2251      	movs	r2, #81	; 0x51
 800b70e:	2101      	movs	r1, #1
 800b710:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 800b712:	68fb      	ldr	r3, [r7, #12]
 800b714:	2250      	movs	r2, #80	; 0x50
 800b716:	2100      	movs	r1, #0
 800b718:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800b71a:	2303      	movs	r3, #3
 800b71c:	e017      	b.n	800b74e <SPI_WaitFlagStateUntilTimeout+0x10a>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if(count == 0U)
 800b71e:	697b      	ldr	r3, [r7, #20]
 800b720:	2b00      	cmp	r3, #0
 800b722:	d101      	bne.n	800b728 <SPI_WaitFlagStateUntilTimeout+0xe4>
      {
        tmp_timeout = 0U;
 800b724:	2300      	movs	r3, #0
 800b726:	61fb      	str	r3, [r7, #28]
      }
      count--;
 800b728:	697b      	ldr	r3, [r7, #20]
 800b72a:	3b01      	subs	r3, #1
 800b72c:	617b      	str	r3, [r7, #20]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800b72e:	68fb      	ldr	r3, [r7, #12]
 800b730:	681b      	ldr	r3, [r3, #0]
 800b732:	689b      	ldr	r3, [r3, #8]
 800b734:	68ba      	ldr	r2, [r7, #8]
 800b736:	4013      	ands	r3, r2
 800b738:	68ba      	ldr	r2, [r7, #8]
 800b73a:	1ad3      	subs	r3, r2, r3
 800b73c:	425a      	negs	r2, r3
 800b73e:	4153      	adcs	r3, r2
 800b740:	b2db      	uxtb	r3, r3
 800b742:	001a      	movs	r2, r3
 800b744:	1dfb      	adds	r3, r7, #7
 800b746:	781b      	ldrb	r3, [r3, #0]
 800b748:	429a      	cmp	r2, r3
 800b74a:	d197      	bne.n	800b67c <SPI_WaitFlagStateUntilTimeout+0x38>
    }
  }

  return HAL_OK;
 800b74c:	2300      	movs	r3, #0
}
 800b74e:	0018      	movs	r0, r3
 800b750:	46bd      	mov	sp, r7
 800b752:	b008      	add	sp, #32
 800b754:	bd80      	pop	{r7, pc}
 800b756:	46c0      	nop			; (mov r8, r8)
 800b758:	2000004c 	.word	0x2000004c
 800b75c:	ffffdfff 	.word	0xffffdfff

0800b760 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 800b760:	b580      	push	{r7, lr}
 800b762:	b088      	sub	sp, #32
 800b764:	af02      	add	r7, sp, #8
 800b766:	60f8      	str	r0, [r7, #12]
 800b768:	60b9      	str	r1, [r7, #8]
 800b76a:	607a      	str	r2, [r7, #4]
  /* Timeout in µs */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 800b76c:	4b1d      	ldr	r3, [pc, #116]	; (800b7e4 <SPI_EndRxTxTransaction+0x84>)
 800b76e:	681b      	ldr	r3, [r3, #0]
 800b770:	491d      	ldr	r1, [pc, #116]	; (800b7e8 <SPI_EndRxTxTransaction+0x88>)
 800b772:	0018      	movs	r0, r3
 800b774:	f7f4 fcc8 	bl	8000108 <__udivsi3>
 800b778:	0003      	movs	r3, r0
 800b77a:	001a      	movs	r2, r3
 800b77c:	0013      	movs	r3, r2
 800b77e:	015b      	lsls	r3, r3, #5
 800b780:	1a9b      	subs	r3, r3, r2
 800b782:	009b      	lsls	r3, r3, #2
 800b784:	189b      	adds	r3, r3, r2
 800b786:	00db      	lsls	r3, r3, #3
 800b788:	617b      	str	r3, [r7, #20]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 800b78a:	68fb      	ldr	r3, [r7, #12]
 800b78c:	685a      	ldr	r2, [r3, #4]
 800b78e:	2382      	movs	r3, #130	; 0x82
 800b790:	005b      	lsls	r3, r3, #1
 800b792:	429a      	cmp	r2, r3
 800b794:	d112      	bne.n	800b7bc <SPI_EndRxTxTransaction+0x5c>
  {
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800b796:	68ba      	ldr	r2, [r7, #8]
 800b798:	68f8      	ldr	r0, [r7, #12]
 800b79a:	687b      	ldr	r3, [r7, #4]
 800b79c:	9300      	str	r3, [sp, #0]
 800b79e:	0013      	movs	r3, r2
 800b7a0:	2200      	movs	r2, #0
 800b7a2:	2180      	movs	r1, #128	; 0x80
 800b7a4:	f7ff ff4e 	bl	800b644 <SPI_WaitFlagStateUntilTimeout>
 800b7a8:	1e03      	subs	r3, r0, #0
 800b7aa:	d016      	beq.n	800b7da <SPI_EndRxTxTransaction+0x7a>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800b7ac:	68fb      	ldr	r3, [r7, #12]
 800b7ae:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b7b0:	2220      	movs	r2, #32
 800b7b2:	431a      	orrs	r2, r3
 800b7b4:	68fb      	ldr	r3, [r7, #12]
 800b7b6:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 800b7b8:	2303      	movs	r3, #3
 800b7ba:	e00f      	b.n	800b7dc <SPI_EndRxTxTransaction+0x7c>
    * User have to calculate the timeout value to fit with the time of 1 byte transfer.
    * This time is directly link with the SPI clock from Master device.
    */
    do
    {
      if (count == 0U)
 800b7bc:	697b      	ldr	r3, [r7, #20]
 800b7be:	2b00      	cmp	r3, #0
 800b7c0:	d00a      	beq.n	800b7d8 <SPI_EndRxTxTransaction+0x78>
      {
        break;
      }
      count--;
 800b7c2:	697b      	ldr	r3, [r7, #20]
 800b7c4:	3b01      	subs	r3, #1
 800b7c6:	617b      	str	r3, [r7, #20]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 800b7c8:	68fb      	ldr	r3, [r7, #12]
 800b7ca:	681b      	ldr	r3, [r3, #0]
 800b7cc:	689b      	ldr	r3, [r3, #8]
 800b7ce:	2280      	movs	r2, #128	; 0x80
 800b7d0:	4013      	ands	r3, r2
 800b7d2:	2b80      	cmp	r3, #128	; 0x80
 800b7d4:	d0f2      	beq.n	800b7bc <SPI_EndRxTxTransaction+0x5c>
 800b7d6:	e000      	b.n	800b7da <SPI_EndRxTxTransaction+0x7a>
        break;
 800b7d8:	46c0      	nop			; (mov r8, r8)
  }

  return HAL_OK;
 800b7da:	2300      	movs	r3, #0
}
 800b7dc:	0018      	movs	r0, r3
 800b7de:	46bd      	mov	sp, r7
 800b7e0:	b006      	add	sp, #24
 800b7e2:	bd80      	pop	{r7, pc}
 800b7e4:	2000004c 	.word	0x2000004c
 800b7e8:	016e3600 	.word	0x016e3600

0800b7ec <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800b7ec:	b580      	push	{r7, lr}
 800b7ee:	b082      	sub	sp, #8
 800b7f0:	af00      	add	r7, sp, #0
 800b7f2:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800b7f4:	687b      	ldr	r3, [r7, #4]
 800b7f6:	2b00      	cmp	r3, #0
 800b7f8:	d101      	bne.n	800b7fe <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 800b7fa:	2301      	movs	r3, #1
 800b7fc:	e0b6      	b.n	800b96c <HAL_TIM_Base_Init+0x180>
  }

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800b7fe:	687b      	ldr	r3, [r7, #4]
 800b800:	681a      	ldr	r2, [r3, #0]
 800b802:	2380      	movs	r3, #128	; 0x80
 800b804:	05db      	lsls	r3, r3, #23
 800b806:	429a      	cmp	r2, r3
 800b808:	d01f      	beq.n	800b84a <HAL_TIM_Base_Init+0x5e>
 800b80a:	687b      	ldr	r3, [r7, #4]
 800b80c:	681b      	ldr	r3, [r3, #0]
 800b80e:	4a59      	ldr	r2, [pc, #356]	; (800b974 <HAL_TIM_Base_Init+0x188>)
 800b810:	4293      	cmp	r3, r2
 800b812:	d01a      	beq.n	800b84a <HAL_TIM_Base_Init+0x5e>
 800b814:	687b      	ldr	r3, [r7, #4]
 800b816:	681b      	ldr	r3, [r3, #0]
 800b818:	4a57      	ldr	r2, [pc, #348]	; (800b978 <HAL_TIM_Base_Init+0x18c>)
 800b81a:	4293      	cmp	r3, r2
 800b81c:	d015      	beq.n	800b84a <HAL_TIM_Base_Init+0x5e>
 800b81e:	687b      	ldr	r3, [r7, #4]
 800b820:	681b      	ldr	r3, [r3, #0]
 800b822:	4a56      	ldr	r2, [pc, #344]	; (800b97c <HAL_TIM_Base_Init+0x190>)
 800b824:	4293      	cmp	r3, r2
 800b826:	d010      	beq.n	800b84a <HAL_TIM_Base_Init+0x5e>
 800b828:	687b      	ldr	r3, [r7, #4]
 800b82a:	681b      	ldr	r3, [r3, #0]
 800b82c:	4a54      	ldr	r2, [pc, #336]	; (800b980 <HAL_TIM_Base_Init+0x194>)
 800b82e:	4293      	cmp	r3, r2
 800b830:	d00b      	beq.n	800b84a <HAL_TIM_Base_Init+0x5e>
 800b832:	687b      	ldr	r3, [r7, #4]
 800b834:	681b      	ldr	r3, [r3, #0]
 800b836:	4a53      	ldr	r2, [pc, #332]	; (800b984 <HAL_TIM_Base_Init+0x198>)
 800b838:	4293      	cmp	r3, r2
 800b83a:	d006      	beq.n	800b84a <HAL_TIM_Base_Init+0x5e>
 800b83c:	238b      	movs	r3, #139	; 0x8b
 800b83e:	005a      	lsls	r2, r3, #1
 800b840:	4b51      	ldr	r3, [pc, #324]	; (800b988 <HAL_TIM_Base_Init+0x19c>)
 800b842:	0011      	movs	r1, r2
 800b844:	0018      	movs	r0, r3
 800b846:	f7fa fd26 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800b84a:	687b      	ldr	r3, [r7, #4]
 800b84c:	689b      	ldr	r3, [r3, #8]
 800b84e:	2b00      	cmp	r3, #0
 800b850:	d017      	beq.n	800b882 <HAL_TIM_Base_Init+0x96>
 800b852:	687b      	ldr	r3, [r7, #4]
 800b854:	689b      	ldr	r3, [r3, #8]
 800b856:	2b10      	cmp	r3, #16
 800b858:	d013      	beq.n	800b882 <HAL_TIM_Base_Init+0x96>
 800b85a:	687b      	ldr	r3, [r7, #4]
 800b85c:	689b      	ldr	r3, [r3, #8]
 800b85e:	2b20      	cmp	r3, #32
 800b860:	d00f      	beq.n	800b882 <HAL_TIM_Base_Init+0x96>
 800b862:	687b      	ldr	r3, [r7, #4]
 800b864:	689b      	ldr	r3, [r3, #8]
 800b866:	2b40      	cmp	r3, #64	; 0x40
 800b868:	d00b      	beq.n	800b882 <HAL_TIM_Base_Init+0x96>
 800b86a:	687b      	ldr	r3, [r7, #4]
 800b86c:	689b      	ldr	r3, [r3, #8]
 800b86e:	2b60      	cmp	r3, #96	; 0x60
 800b870:	d007      	beq.n	800b882 <HAL_TIM_Base_Init+0x96>
 800b872:	2318      	movs	r3, #24
 800b874:	33ff      	adds	r3, #255	; 0xff
 800b876:	001a      	movs	r2, r3
 800b878:	4b43      	ldr	r3, [pc, #268]	; (800b988 <HAL_TIM_Base_Init+0x19c>)
 800b87a:	0011      	movs	r1, r2
 800b87c:	0018      	movs	r0, r3
 800b87e:	f7fa fd0a 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800b882:	687b      	ldr	r3, [r7, #4]
 800b884:	691b      	ldr	r3, [r3, #16]
 800b886:	2b00      	cmp	r3, #0
 800b888:	d012      	beq.n	800b8b0 <HAL_TIM_Base_Init+0xc4>
 800b88a:	687b      	ldr	r3, [r7, #4]
 800b88c:	691a      	ldr	r2, [r3, #16]
 800b88e:	2380      	movs	r3, #128	; 0x80
 800b890:	005b      	lsls	r3, r3, #1
 800b892:	429a      	cmp	r2, r3
 800b894:	d00c      	beq.n	800b8b0 <HAL_TIM_Base_Init+0xc4>
 800b896:	687b      	ldr	r3, [r7, #4]
 800b898:	691a      	ldr	r2, [r3, #16]
 800b89a:	2380      	movs	r3, #128	; 0x80
 800b89c:	009b      	lsls	r3, r3, #2
 800b89e:	429a      	cmp	r2, r3
 800b8a0:	d006      	beq.n	800b8b0 <HAL_TIM_Base_Init+0xc4>
 800b8a2:	238c      	movs	r3, #140	; 0x8c
 800b8a4:	005a      	lsls	r2, r3, #1
 800b8a6:	4b38      	ldr	r3, [pc, #224]	; (800b988 <HAL_TIM_Base_Init+0x19c>)
 800b8a8:	0011      	movs	r1, r2
 800b8aa:	0018      	movs	r0, r3
 800b8ac:	f7fa fcf3 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_PERIOD(htim->Init.Period));
 800b8b0:	687b      	ldr	r3, [r7, #4]
 800b8b2:	68da      	ldr	r2, [r3, #12]
 800b8b4:	2380      	movs	r3, #128	; 0x80
 800b8b6:	025b      	lsls	r3, r3, #9
 800b8b8:	429a      	cmp	r2, r3
 800b8ba:	d307      	bcc.n	800b8cc <HAL_TIM_Base_Init+0xe0>
 800b8bc:	231a      	movs	r3, #26
 800b8be:	33ff      	adds	r3, #255	; 0xff
 800b8c0:	001a      	movs	r2, r3
 800b8c2:	4b31      	ldr	r3, [pc, #196]	; (800b988 <HAL_TIM_Base_Init+0x19c>)
 800b8c4:	0011      	movs	r1, r2
 800b8c6:	0018      	movs	r0, r3
 800b8c8:	f7fa fce5 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
 800b8cc:	687b      	ldr	r3, [r7, #4]
 800b8ce:	685a      	ldr	r2, [r3, #4]
 800b8d0:	2380      	movs	r3, #128	; 0x80
 800b8d2:	025b      	lsls	r3, r3, #9
 800b8d4:	429a      	cmp	r2, r3
 800b8d6:	d306      	bcc.n	800b8e6 <HAL_TIM_Base_Init+0xfa>
 800b8d8:	238d      	movs	r3, #141	; 0x8d
 800b8da:	005a      	lsls	r2, r3, #1
 800b8dc:	4b2a      	ldr	r3, [pc, #168]	; (800b988 <HAL_TIM_Base_Init+0x19c>)
 800b8de:	0011      	movs	r1, r2
 800b8e0:	0018      	movs	r0, r3
 800b8e2:	f7fa fcd8 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800b8e6:	687b      	ldr	r3, [r7, #4]
 800b8e8:	695b      	ldr	r3, [r3, #20]
 800b8ea:	2b00      	cmp	r3, #0
 800b8ec:	d00b      	beq.n	800b906 <HAL_TIM_Base_Init+0x11a>
 800b8ee:	687b      	ldr	r3, [r7, #4]
 800b8f0:	695b      	ldr	r3, [r3, #20]
 800b8f2:	2b80      	cmp	r3, #128	; 0x80
 800b8f4:	d007      	beq.n	800b906 <HAL_TIM_Base_Init+0x11a>
 800b8f6:	231c      	movs	r3, #28
 800b8f8:	33ff      	adds	r3, #255	; 0xff
 800b8fa:	001a      	movs	r2, r3
 800b8fc:	4b22      	ldr	r3, [pc, #136]	; (800b988 <HAL_TIM_Base_Init+0x19c>)
 800b8fe:	0011      	movs	r1, r2
 800b900:	0018      	movs	r0, r3
 800b902:	f7fa fcc8 	bl	8006296 <assert_failed>

  if (htim->State == HAL_TIM_STATE_RESET)
 800b906:	687b      	ldr	r3, [r7, #4]
 800b908:	2239      	movs	r2, #57	; 0x39
 800b90a:	5c9b      	ldrb	r3, [r3, r2]
 800b90c:	b2db      	uxtb	r3, r3
 800b90e:	2b00      	cmp	r3, #0
 800b910:	d107      	bne.n	800b922 <HAL_TIM_Base_Init+0x136>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800b912:	687b      	ldr	r3, [r7, #4]
 800b914:	2238      	movs	r2, #56	; 0x38
 800b916:	2100      	movs	r1, #0
 800b918:	5499      	strb	r1, [r3, r2]
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800b91a:	687b      	ldr	r3, [r7, #4]
 800b91c:	0018      	movs	r0, r3
 800b91e:	f7fb fcb1 	bl	8007284 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800b922:	687b      	ldr	r3, [r7, #4]
 800b924:	2239      	movs	r2, #57	; 0x39
 800b926:	2102      	movs	r1, #2
 800b928:	5499      	strb	r1, [r3, r2]

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800b92a:	687b      	ldr	r3, [r7, #4]
 800b92c:	681a      	ldr	r2, [r3, #0]
 800b92e:	687b      	ldr	r3, [r7, #4]
 800b930:	3304      	adds	r3, #4
 800b932:	0019      	movs	r1, r3
 800b934:	0010      	movs	r0, r2
 800b936:	f000 fe7b 	bl	800c630 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800b93a:	687b      	ldr	r3, [r7, #4]
 800b93c:	223e      	movs	r2, #62	; 0x3e
 800b93e:	2101      	movs	r1, #1
 800b940:	5499      	strb	r1, [r3, r2]

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800b942:	687b      	ldr	r3, [r7, #4]
 800b944:	223a      	movs	r2, #58	; 0x3a
 800b946:	2101      	movs	r1, #1
 800b948:	5499      	strb	r1, [r3, r2]
 800b94a:	687b      	ldr	r3, [r7, #4]
 800b94c:	223b      	movs	r2, #59	; 0x3b
 800b94e:	2101      	movs	r1, #1
 800b950:	5499      	strb	r1, [r3, r2]
 800b952:	687b      	ldr	r3, [r7, #4]
 800b954:	223c      	movs	r2, #60	; 0x3c
 800b956:	2101      	movs	r1, #1
 800b958:	5499      	strb	r1, [r3, r2]
 800b95a:	687b      	ldr	r3, [r7, #4]
 800b95c:	223d      	movs	r2, #61	; 0x3d
 800b95e:	2101      	movs	r1, #1
 800b960:	5499      	strb	r1, [r3, r2]

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800b962:	687b      	ldr	r3, [r7, #4]
 800b964:	2239      	movs	r2, #57	; 0x39
 800b966:	2101      	movs	r1, #1
 800b968:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800b96a:	2300      	movs	r3, #0
}
 800b96c:	0018      	movs	r0, r3
 800b96e:	46bd      	mov	sp, r7
 800b970:	b002      	add	sp, #8
 800b972:	bd80      	pop	{r7, pc}
 800b974:	40000400 	.word	0x40000400
 800b978:	40001000 	.word	0x40001000
 800b97c:	40001400 	.word	0x40001400
 800b980:	40010800 	.word	0x40010800
 800b984:	40011400 	.word	0x40011400
 800b988:	0800df0c 	.word	0x0800df0c

0800b98c <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 800b98c:	b580      	push	{r7, lr}
 800b98e:	b084      	sub	sp, #16
 800b990:	af00      	add	r7, sp, #0
 800b992:	6078      	str	r0, [r7, #4]
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800b994:	687b      	ldr	r3, [r7, #4]
 800b996:	681a      	ldr	r2, [r3, #0]
 800b998:	2380      	movs	r3, #128	; 0x80
 800b99a:	05db      	lsls	r3, r3, #23
 800b99c:	429a      	cmp	r2, r3
 800b99e:	d01f      	beq.n	800b9e0 <HAL_TIM_Base_Start_IT+0x54>
 800b9a0:	687b      	ldr	r3, [r7, #4]
 800b9a2:	681b      	ldr	r3, [r3, #0]
 800b9a4:	4a32      	ldr	r2, [pc, #200]	; (800ba70 <HAL_TIM_Base_Start_IT+0xe4>)
 800b9a6:	4293      	cmp	r3, r2
 800b9a8:	d01a      	beq.n	800b9e0 <HAL_TIM_Base_Start_IT+0x54>
 800b9aa:	687b      	ldr	r3, [r7, #4]
 800b9ac:	681b      	ldr	r3, [r3, #0]
 800b9ae:	4a31      	ldr	r2, [pc, #196]	; (800ba74 <HAL_TIM_Base_Start_IT+0xe8>)
 800b9b0:	4293      	cmp	r3, r2
 800b9b2:	d015      	beq.n	800b9e0 <HAL_TIM_Base_Start_IT+0x54>
 800b9b4:	687b      	ldr	r3, [r7, #4]
 800b9b6:	681b      	ldr	r3, [r3, #0]
 800b9b8:	4a2f      	ldr	r2, [pc, #188]	; (800ba78 <HAL_TIM_Base_Start_IT+0xec>)
 800b9ba:	4293      	cmp	r3, r2
 800b9bc:	d010      	beq.n	800b9e0 <HAL_TIM_Base_Start_IT+0x54>
 800b9be:	687b      	ldr	r3, [r7, #4]
 800b9c0:	681b      	ldr	r3, [r3, #0]
 800b9c2:	4a2e      	ldr	r2, [pc, #184]	; (800ba7c <HAL_TIM_Base_Start_IT+0xf0>)
 800b9c4:	4293      	cmp	r3, r2
 800b9c6:	d00b      	beq.n	800b9e0 <HAL_TIM_Base_Start_IT+0x54>
 800b9c8:	687b      	ldr	r3, [r7, #4]
 800b9ca:	681b      	ldr	r3, [r3, #0]
 800b9cc:	4a2c      	ldr	r2, [pc, #176]	; (800ba80 <HAL_TIM_Base_Start_IT+0xf4>)
 800b9ce:	4293      	cmp	r3, r2
 800b9d0:	d006      	beq.n	800b9e0 <HAL_TIM_Base_Start_IT+0x54>
 800b9d2:	23e9      	movs	r3, #233	; 0xe9
 800b9d4:	005a      	lsls	r2, r3, #1
 800b9d6:	4b2b      	ldr	r3, [pc, #172]	; (800ba84 <HAL_TIM_Base_Start_IT+0xf8>)
 800b9d8:	0011      	movs	r1, r2
 800b9da:	0018      	movs	r0, r3
 800b9dc:	f7fa fc5b 	bl	8006296 <assert_failed>

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800b9e0:	687b      	ldr	r3, [r7, #4]
 800b9e2:	2239      	movs	r2, #57	; 0x39
 800b9e4:	5c9b      	ldrb	r3, [r3, r2]
 800b9e6:	b2db      	uxtb	r3, r3
 800b9e8:	2b01      	cmp	r3, #1
 800b9ea:	d001      	beq.n	800b9f0 <HAL_TIM_Base_Start_IT+0x64>
  {
    return HAL_ERROR;
 800b9ec:	2301      	movs	r3, #1
 800b9ee:	e03b      	b.n	800ba68 <HAL_TIM_Base_Start_IT+0xdc>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800b9f0:	687b      	ldr	r3, [r7, #4]
 800b9f2:	2239      	movs	r2, #57	; 0x39
 800b9f4:	2102      	movs	r1, #2
 800b9f6:	5499      	strb	r1, [r3, r2]

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800b9f8:	687b      	ldr	r3, [r7, #4]
 800b9fa:	681b      	ldr	r3, [r3, #0]
 800b9fc:	68da      	ldr	r2, [r3, #12]
 800b9fe:	687b      	ldr	r3, [r7, #4]
 800ba00:	681b      	ldr	r3, [r3, #0]
 800ba02:	2101      	movs	r1, #1
 800ba04:	430a      	orrs	r2, r1
 800ba06:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800ba08:	687b      	ldr	r3, [r7, #4]
 800ba0a:	681a      	ldr	r2, [r3, #0]
 800ba0c:	2380      	movs	r3, #128	; 0x80
 800ba0e:	05db      	lsls	r3, r3, #23
 800ba10:	429a      	cmp	r2, r3
 800ba12:	d00e      	beq.n	800ba32 <HAL_TIM_Base_Start_IT+0xa6>
 800ba14:	687b      	ldr	r3, [r7, #4]
 800ba16:	681b      	ldr	r3, [r3, #0]
 800ba18:	4a15      	ldr	r2, [pc, #84]	; (800ba70 <HAL_TIM_Base_Start_IT+0xe4>)
 800ba1a:	4293      	cmp	r3, r2
 800ba1c:	d009      	beq.n	800ba32 <HAL_TIM_Base_Start_IT+0xa6>
 800ba1e:	687b      	ldr	r3, [r7, #4]
 800ba20:	681b      	ldr	r3, [r3, #0]
 800ba22:	4a16      	ldr	r2, [pc, #88]	; (800ba7c <HAL_TIM_Base_Start_IT+0xf0>)
 800ba24:	4293      	cmp	r3, r2
 800ba26:	d004      	beq.n	800ba32 <HAL_TIM_Base_Start_IT+0xa6>
 800ba28:	687b      	ldr	r3, [r7, #4]
 800ba2a:	681b      	ldr	r3, [r3, #0]
 800ba2c:	4a14      	ldr	r2, [pc, #80]	; (800ba80 <HAL_TIM_Base_Start_IT+0xf4>)
 800ba2e:	4293      	cmp	r3, r2
 800ba30:	d111      	bne.n	800ba56 <HAL_TIM_Base_Start_IT+0xca>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800ba32:	687b      	ldr	r3, [r7, #4]
 800ba34:	681b      	ldr	r3, [r3, #0]
 800ba36:	689b      	ldr	r3, [r3, #8]
 800ba38:	2207      	movs	r2, #7
 800ba3a:	4013      	ands	r3, r2
 800ba3c:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ba3e:	68fb      	ldr	r3, [r7, #12]
 800ba40:	2b06      	cmp	r3, #6
 800ba42:	d010      	beq.n	800ba66 <HAL_TIM_Base_Start_IT+0xda>
    {
      __HAL_TIM_ENABLE(htim);
 800ba44:	687b      	ldr	r3, [r7, #4]
 800ba46:	681b      	ldr	r3, [r3, #0]
 800ba48:	681a      	ldr	r2, [r3, #0]
 800ba4a:	687b      	ldr	r3, [r7, #4]
 800ba4c:	681b      	ldr	r3, [r3, #0]
 800ba4e:	2101      	movs	r1, #1
 800ba50:	430a      	orrs	r2, r1
 800ba52:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ba54:	e007      	b.n	800ba66 <HAL_TIM_Base_Start_IT+0xda>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800ba56:	687b      	ldr	r3, [r7, #4]
 800ba58:	681b      	ldr	r3, [r3, #0]
 800ba5a:	681a      	ldr	r2, [r3, #0]
 800ba5c:	687b      	ldr	r3, [r7, #4]
 800ba5e:	681b      	ldr	r3, [r3, #0]
 800ba60:	2101      	movs	r1, #1
 800ba62:	430a      	orrs	r2, r1
 800ba64:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 800ba66:	2300      	movs	r3, #0
}
 800ba68:	0018      	movs	r0, r3
 800ba6a:	46bd      	mov	sp, r7
 800ba6c:	b004      	add	sp, #16
 800ba6e:	bd80      	pop	{r7, pc}
 800ba70:	40000400 	.word	0x40000400
 800ba74:	40001000 	.word	0x40001000
 800ba78:	40001400 	.word	0x40001400
 800ba7c:	40010800 	.word	0x40010800
 800ba80:	40011400 	.word	0x40011400
 800ba84:	0800df0c 	.word	0x0800df0c

0800ba88 <HAL_TIM_OC_Init>:
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
{
 800ba88:	b580      	push	{r7, lr}
 800ba8a:	b082      	sub	sp, #8
 800ba8c:	af00      	add	r7, sp, #0
 800ba8e:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800ba90:	687b      	ldr	r3, [r7, #4]
 800ba92:	2b00      	cmp	r3, #0
 800ba94:	d101      	bne.n	800ba9a <HAL_TIM_OC_Init+0x12>
  {
    return HAL_ERROR;
 800ba96:	2301      	movs	r3, #1
 800ba98:	e0af      	b.n	800bbfa <HAL_TIM_OC_Init+0x172>
  }

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800ba9a:	687b      	ldr	r3, [r7, #4]
 800ba9c:	681a      	ldr	r2, [r3, #0]
 800ba9e:	2380      	movs	r3, #128	; 0x80
 800baa0:	05db      	lsls	r3, r3, #23
 800baa2:	429a      	cmp	r2, r3
 800baa4:	d01f      	beq.n	800bae6 <HAL_TIM_OC_Init+0x5e>
 800baa6:	687b      	ldr	r3, [r7, #4]
 800baa8:	681b      	ldr	r3, [r3, #0]
 800baaa:	4a56      	ldr	r2, [pc, #344]	; (800bc04 <HAL_TIM_OC_Init+0x17c>)
 800baac:	4293      	cmp	r3, r2
 800baae:	d01a      	beq.n	800bae6 <HAL_TIM_OC_Init+0x5e>
 800bab0:	687b      	ldr	r3, [r7, #4]
 800bab2:	681b      	ldr	r3, [r3, #0]
 800bab4:	4a54      	ldr	r2, [pc, #336]	; (800bc08 <HAL_TIM_OC_Init+0x180>)
 800bab6:	4293      	cmp	r3, r2
 800bab8:	d015      	beq.n	800bae6 <HAL_TIM_OC_Init+0x5e>
 800baba:	687b      	ldr	r3, [r7, #4]
 800babc:	681b      	ldr	r3, [r3, #0]
 800babe:	4a53      	ldr	r2, [pc, #332]	; (800bc0c <HAL_TIM_OC_Init+0x184>)
 800bac0:	4293      	cmp	r3, r2
 800bac2:	d010      	beq.n	800bae6 <HAL_TIM_OC_Init+0x5e>
 800bac4:	687b      	ldr	r3, [r7, #4]
 800bac6:	681b      	ldr	r3, [r3, #0]
 800bac8:	4a51      	ldr	r2, [pc, #324]	; (800bc10 <HAL_TIM_OC_Init+0x188>)
 800baca:	4293      	cmp	r3, r2
 800bacc:	d00b      	beq.n	800bae6 <HAL_TIM_OC_Init+0x5e>
 800bace:	687b      	ldr	r3, [r7, #4]
 800bad0:	681b      	ldr	r3, [r3, #0]
 800bad2:	4a50      	ldr	r2, [pc, #320]	; (800bc14 <HAL_TIM_OC_Init+0x18c>)
 800bad4:	4293      	cmp	r3, r2
 800bad6:	d006      	beq.n	800bae6 <HAL_TIM_OC_Init+0x5e>
 800bad8:	23a5      	movs	r3, #165	; 0xa5
 800bada:	009a      	lsls	r2, r3, #2
 800badc:	4b4e      	ldr	r3, [pc, #312]	; (800bc18 <HAL_TIM_OC_Init+0x190>)
 800bade:	0011      	movs	r1, r2
 800bae0:	0018      	movs	r0, r3
 800bae2:	f7fa fbd8 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800bae6:	687b      	ldr	r3, [r7, #4]
 800bae8:	689b      	ldr	r3, [r3, #8]
 800baea:	2b00      	cmp	r3, #0
 800baec:	d015      	beq.n	800bb1a <HAL_TIM_OC_Init+0x92>
 800baee:	687b      	ldr	r3, [r7, #4]
 800baf0:	689b      	ldr	r3, [r3, #8]
 800baf2:	2b10      	cmp	r3, #16
 800baf4:	d011      	beq.n	800bb1a <HAL_TIM_OC_Init+0x92>
 800baf6:	687b      	ldr	r3, [r7, #4]
 800baf8:	689b      	ldr	r3, [r3, #8]
 800bafa:	2b20      	cmp	r3, #32
 800bafc:	d00d      	beq.n	800bb1a <HAL_TIM_OC_Init+0x92>
 800bafe:	687b      	ldr	r3, [r7, #4]
 800bb00:	689b      	ldr	r3, [r3, #8]
 800bb02:	2b40      	cmp	r3, #64	; 0x40
 800bb04:	d009      	beq.n	800bb1a <HAL_TIM_OC_Init+0x92>
 800bb06:	687b      	ldr	r3, [r7, #4]
 800bb08:	689b      	ldr	r3, [r3, #8]
 800bb0a:	2b60      	cmp	r3, #96	; 0x60
 800bb0c:	d005      	beq.n	800bb1a <HAL_TIM_OC_Init+0x92>
 800bb0e:	4a43      	ldr	r2, [pc, #268]	; (800bc1c <HAL_TIM_OC_Init+0x194>)
 800bb10:	4b41      	ldr	r3, [pc, #260]	; (800bc18 <HAL_TIM_OC_Init+0x190>)
 800bb12:	0011      	movs	r1, r2
 800bb14:	0018      	movs	r0, r3
 800bb16:	f7fa fbbe 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800bb1a:	687b      	ldr	r3, [r7, #4]
 800bb1c:	691b      	ldr	r3, [r3, #16]
 800bb1e:	2b00      	cmp	r3, #0
 800bb20:	d011      	beq.n	800bb46 <HAL_TIM_OC_Init+0xbe>
 800bb22:	687b      	ldr	r3, [r7, #4]
 800bb24:	691a      	ldr	r2, [r3, #16]
 800bb26:	2380      	movs	r3, #128	; 0x80
 800bb28:	005b      	lsls	r3, r3, #1
 800bb2a:	429a      	cmp	r2, r3
 800bb2c:	d00b      	beq.n	800bb46 <HAL_TIM_OC_Init+0xbe>
 800bb2e:	687b      	ldr	r3, [r7, #4]
 800bb30:	691a      	ldr	r2, [r3, #16]
 800bb32:	2380      	movs	r3, #128	; 0x80
 800bb34:	009b      	lsls	r3, r3, #2
 800bb36:	429a      	cmp	r2, r3
 800bb38:	d005      	beq.n	800bb46 <HAL_TIM_OC_Init+0xbe>
 800bb3a:	4a39      	ldr	r2, [pc, #228]	; (800bc20 <HAL_TIM_OC_Init+0x198>)
 800bb3c:	4b36      	ldr	r3, [pc, #216]	; (800bc18 <HAL_TIM_OC_Init+0x190>)
 800bb3e:	0011      	movs	r1, r2
 800bb40:	0018      	movs	r0, r3
 800bb42:	f7fa fba8 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_PERIOD(htim->Init.Period));
 800bb46:	687b      	ldr	r3, [r7, #4]
 800bb48:	68da      	ldr	r2, [r3, #12]
 800bb4a:	2380      	movs	r3, #128	; 0x80
 800bb4c:	025b      	lsls	r3, r3, #9
 800bb4e:	429a      	cmp	r2, r3
 800bb50:	d305      	bcc.n	800bb5e <HAL_TIM_OC_Init+0xd6>
 800bb52:	4a34      	ldr	r2, [pc, #208]	; (800bc24 <HAL_TIM_OC_Init+0x19c>)
 800bb54:	4b30      	ldr	r3, [pc, #192]	; (800bc18 <HAL_TIM_OC_Init+0x190>)
 800bb56:	0011      	movs	r1, r2
 800bb58:	0018      	movs	r0, r3
 800bb5a:	f7fa fb9c 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
 800bb5e:	687b      	ldr	r3, [r7, #4]
 800bb60:	685a      	ldr	r2, [r3, #4]
 800bb62:	2380      	movs	r3, #128	; 0x80
 800bb64:	025b      	lsls	r3, r3, #9
 800bb66:	429a      	cmp	r2, r3
 800bb68:	d306      	bcc.n	800bb78 <HAL_TIM_OC_Init+0xf0>
 800bb6a:	23a6      	movs	r3, #166	; 0xa6
 800bb6c:	009a      	lsls	r2, r3, #2
 800bb6e:	4b2a      	ldr	r3, [pc, #168]	; (800bc18 <HAL_TIM_OC_Init+0x190>)
 800bb70:	0011      	movs	r1, r2
 800bb72:	0018      	movs	r0, r3
 800bb74:	f7fa fb8f 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800bb78:	687b      	ldr	r3, [r7, #4]
 800bb7a:	695b      	ldr	r3, [r3, #20]
 800bb7c:	2b00      	cmp	r3, #0
 800bb7e:	d009      	beq.n	800bb94 <HAL_TIM_OC_Init+0x10c>
 800bb80:	687b      	ldr	r3, [r7, #4]
 800bb82:	695b      	ldr	r3, [r3, #20]
 800bb84:	2b80      	cmp	r3, #128	; 0x80
 800bb86:	d005      	beq.n	800bb94 <HAL_TIM_OC_Init+0x10c>
 800bb88:	4a27      	ldr	r2, [pc, #156]	; (800bc28 <HAL_TIM_OC_Init+0x1a0>)
 800bb8a:	4b23      	ldr	r3, [pc, #140]	; (800bc18 <HAL_TIM_OC_Init+0x190>)
 800bb8c:	0011      	movs	r1, r2
 800bb8e:	0018      	movs	r0, r3
 800bb90:	f7fa fb81 	bl	8006296 <assert_failed>

  if (htim->State == HAL_TIM_STATE_RESET)
 800bb94:	687b      	ldr	r3, [r7, #4]
 800bb96:	2239      	movs	r2, #57	; 0x39
 800bb98:	5c9b      	ldrb	r3, [r3, r2]
 800bb9a:	b2db      	uxtb	r3, r3
 800bb9c:	2b00      	cmp	r3, #0
 800bb9e:	d107      	bne.n	800bbb0 <HAL_TIM_OC_Init+0x128>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800bba0:	687b      	ldr	r3, [r7, #4]
 800bba2:	2238      	movs	r2, #56	; 0x38
 800bba4:	2100      	movs	r1, #0
 800bba6:	5499      	strb	r1, [r3, r2]
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->OC_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_OC_MspInit(htim);
 800bba8:	687b      	ldr	r3, [r7, #4]
 800bbaa:	0018      	movs	r0, r3
 800bbac:	f000 f83e 	bl	800bc2c <HAL_TIM_OC_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800bbb0:	687b      	ldr	r3, [r7, #4]
 800bbb2:	2239      	movs	r2, #57	; 0x39
 800bbb4:	2102      	movs	r1, #2
 800bbb6:	5499      	strb	r1, [r3, r2]

  /* Init the base time for the Output Compare */
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 800bbb8:	687b      	ldr	r3, [r7, #4]
 800bbba:	681a      	ldr	r2, [r3, #0]
 800bbbc:	687b      	ldr	r3, [r7, #4]
 800bbbe:	3304      	adds	r3, #4
 800bbc0:	0019      	movs	r1, r3
 800bbc2:	0010      	movs	r0, r2
 800bbc4:	f000 fd34 	bl	800c630 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800bbc8:	687b      	ldr	r3, [r7, #4]
 800bbca:	223e      	movs	r2, #62	; 0x3e
 800bbcc:	2101      	movs	r1, #1
 800bbce:	5499      	strb	r1, [r3, r2]

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800bbd0:	687b      	ldr	r3, [r7, #4]
 800bbd2:	223a      	movs	r2, #58	; 0x3a
 800bbd4:	2101      	movs	r1, #1
 800bbd6:	5499      	strb	r1, [r3, r2]
 800bbd8:	687b      	ldr	r3, [r7, #4]
 800bbda:	223b      	movs	r2, #59	; 0x3b
 800bbdc:	2101      	movs	r1, #1
 800bbde:	5499      	strb	r1, [r3, r2]
 800bbe0:	687b      	ldr	r3, [r7, #4]
 800bbe2:	223c      	movs	r2, #60	; 0x3c
 800bbe4:	2101      	movs	r1, #1
 800bbe6:	5499      	strb	r1, [r3, r2]
 800bbe8:	687b      	ldr	r3, [r7, #4]
 800bbea:	223d      	movs	r2, #61	; 0x3d
 800bbec:	2101      	movs	r1, #1
 800bbee:	5499      	strb	r1, [r3, r2]

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800bbf0:	687b      	ldr	r3, [r7, #4]
 800bbf2:	2239      	movs	r2, #57	; 0x39
 800bbf4:	2101      	movs	r1, #1
 800bbf6:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800bbf8:	2300      	movs	r3, #0
}
 800bbfa:	0018      	movs	r0, r3
 800bbfc:	46bd      	mov	sp, r7
 800bbfe:	b002      	add	sp, #8
 800bc00:	bd80      	pop	{r7, pc}
 800bc02:	46c0      	nop			; (mov r8, r8)
 800bc04:	40000400 	.word	0x40000400
 800bc08:	40001000 	.word	0x40001000
 800bc0c:	40001400 	.word	0x40001400
 800bc10:	40010800 	.word	0x40010800
 800bc14:	40011400 	.word	0x40011400
 800bc18:	0800df0c 	.word	0x0800df0c
 800bc1c:	00000295 	.word	0x00000295
 800bc20:	00000296 	.word	0x00000296
 800bc24:	00000297 	.word	0x00000297
 800bc28:	00000299 	.word	0x00000299

0800bc2c <HAL_TIM_OC_MspInit>:
  * @brief  Initializes the TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  */
__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
{
 800bc2c:	b580      	push	{r7, lr}
 800bc2e:	b082      	sub	sp, #8
 800bc30:	af00      	add	r7, sp, #0
 800bc32:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspInit could be implemented in the user file
   */
}
 800bc34:	46c0      	nop			; (mov r8, r8)
 800bc36:	46bd      	mov	sp, r7
 800bc38:	b002      	add	sp, #8
 800bc3a:	bd80      	pop	{r7, pc}

0800bc3c <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800bc3c:	b580      	push	{r7, lr}
 800bc3e:	b082      	sub	sp, #8
 800bc40:	af00      	add	r7, sp, #0
 800bc42:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800bc44:	687b      	ldr	r3, [r7, #4]
 800bc46:	681b      	ldr	r3, [r3, #0]
 800bc48:	691b      	ldr	r3, [r3, #16]
 800bc4a:	2202      	movs	r2, #2
 800bc4c:	4013      	ands	r3, r2
 800bc4e:	2b02      	cmp	r3, #2
 800bc50:	d124      	bne.n	800bc9c <HAL_TIM_IRQHandler+0x60>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800bc52:	687b      	ldr	r3, [r7, #4]
 800bc54:	681b      	ldr	r3, [r3, #0]
 800bc56:	68db      	ldr	r3, [r3, #12]
 800bc58:	2202      	movs	r2, #2
 800bc5a:	4013      	ands	r3, r2
 800bc5c:	2b02      	cmp	r3, #2
 800bc5e:	d11d      	bne.n	800bc9c <HAL_TIM_IRQHandler+0x60>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800bc60:	687b      	ldr	r3, [r7, #4]
 800bc62:	681b      	ldr	r3, [r3, #0]
 800bc64:	2203      	movs	r2, #3
 800bc66:	4252      	negs	r2, r2
 800bc68:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800bc6a:	687b      	ldr	r3, [r7, #4]
 800bc6c:	2201      	movs	r2, #1
 800bc6e:	761a      	strb	r2, [r3, #24]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800bc70:	687b      	ldr	r3, [r7, #4]
 800bc72:	681b      	ldr	r3, [r3, #0]
 800bc74:	699b      	ldr	r3, [r3, #24]
 800bc76:	2203      	movs	r2, #3
 800bc78:	4013      	ands	r3, r2
 800bc7a:	d004      	beq.n	800bc86 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 800bc7c:	687b      	ldr	r3, [r7, #4]
 800bc7e:	0018      	movs	r0, r3
 800bc80:	f000 fcbe 	bl	800c600 <HAL_TIM_IC_CaptureCallback>
 800bc84:	e007      	b.n	800bc96 <HAL_TIM_IRQHandler+0x5a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800bc86:	687b      	ldr	r3, [r7, #4]
 800bc88:	0018      	movs	r0, r3
 800bc8a:	f000 fcb1 	bl	800c5f0 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bc8e:	687b      	ldr	r3, [r7, #4]
 800bc90:	0018      	movs	r0, r3
 800bc92:	f000 fcbd 	bl	800c610 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bc96:	687b      	ldr	r3, [r7, #4]
 800bc98:	2200      	movs	r2, #0
 800bc9a:	761a      	strb	r2, [r3, #24]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800bc9c:	687b      	ldr	r3, [r7, #4]
 800bc9e:	681b      	ldr	r3, [r3, #0]
 800bca0:	691b      	ldr	r3, [r3, #16]
 800bca2:	2204      	movs	r2, #4
 800bca4:	4013      	ands	r3, r2
 800bca6:	2b04      	cmp	r3, #4
 800bca8:	d125      	bne.n	800bcf6 <HAL_TIM_IRQHandler+0xba>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800bcaa:	687b      	ldr	r3, [r7, #4]
 800bcac:	681b      	ldr	r3, [r3, #0]
 800bcae:	68db      	ldr	r3, [r3, #12]
 800bcb0:	2204      	movs	r2, #4
 800bcb2:	4013      	ands	r3, r2
 800bcb4:	2b04      	cmp	r3, #4
 800bcb6:	d11e      	bne.n	800bcf6 <HAL_TIM_IRQHandler+0xba>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800bcb8:	687b      	ldr	r3, [r7, #4]
 800bcba:	681b      	ldr	r3, [r3, #0]
 800bcbc:	2205      	movs	r2, #5
 800bcbe:	4252      	negs	r2, r2
 800bcc0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800bcc2:	687b      	ldr	r3, [r7, #4]
 800bcc4:	2202      	movs	r2, #2
 800bcc6:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800bcc8:	687b      	ldr	r3, [r7, #4]
 800bcca:	681b      	ldr	r3, [r3, #0]
 800bccc:	699a      	ldr	r2, [r3, #24]
 800bcce:	23c0      	movs	r3, #192	; 0xc0
 800bcd0:	009b      	lsls	r3, r3, #2
 800bcd2:	4013      	ands	r3, r2
 800bcd4:	d004      	beq.n	800bce0 <HAL_TIM_IRQHandler+0xa4>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800bcd6:	687b      	ldr	r3, [r7, #4]
 800bcd8:	0018      	movs	r0, r3
 800bcda:	f000 fc91 	bl	800c600 <HAL_TIM_IC_CaptureCallback>
 800bcde:	e007      	b.n	800bcf0 <HAL_TIM_IRQHandler+0xb4>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800bce0:	687b      	ldr	r3, [r7, #4]
 800bce2:	0018      	movs	r0, r3
 800bce4:	f000 fc84 	bl	800c5f0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bce8:	687b      	ldr	r3, [r7, #4]
 800bcea:	0018      	movs	r0, r3
 800bcec:	f000 fc90 	bl	800c610 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bcf0:	687b      	ldr	r3, [r7, #4]
 800bcf2:	2200      	movs	r2, #0
 800bcf4:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800bcf6:	687b      	ldr	r3, [r7, #4]
 800bcf8:	681b      	ldr	r3, [r3, #0]
 800bcfa:	691b      	ldr	r3, [r3, #16]
 800bcfc:	2208      	movs	r2, #8
 800bcfe:	4013      	ands	r3, r2
 800bd00:	2b08      	cmp	r3, #8
 800bd02:	d124      	bne.n	800bd4e <HAL_TIM_IRQHandler+0x112>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800bd04:	687b      	ldr	r3, [r7, #4]
 800bd06:	681b      	ldr	r3, [r3, #0]
 800bd08:	68db      	ldr	r3, [r3, #12]
 800bd0a:	2208      	movs	r2, #8
 800bd0c:	4013      	ands	r3, r2
 800bd0e:	2b08      	cmp	r3, #8
 800bd10:	d11d      	bne.n	800bd4e <HAL_TIM_IRQHandler+0x112>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800bd12:	687b      	ldr	r3, [r7, #4]
 800bd14:	681b      	ldr	r3, [r3, #0]
 800bd16:	2209      	movs	r2, #9
 800bd18:	4252      	negs	r2, r2
 800bd1a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800bd1c:	687b      	ldr	r3, [r7, #4]
 800bd1e:	2204      	movs	r2, #4
 800bd20:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800bd22:	687b      	ldr	r3, [r7, #4]
 800bd24:	681b      	ldr	r3, [r3, #0]
 800bd26:	69db      	ldr	r3, [r3, #28]
 800bd28:	2203      	movs	r2, #3
 800bd2a:	4013      	ands	r3, r2
 800bd2c:	d004      	beq.n	800bd38 <HAL_TIM_IRQHandler+0xfc>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800bd2e:	687b      	ldr	r3, [r7, #4]
 800bd30:	0018      	movs	r0, r3
 800bd32:	f000 fc65 	bl	800c600 <HAL_TIM_IC_CaptureCallback>
 800bd36:	e007      	b.n	800bd48 <HAL_TIM_IRQHandler+0x10c>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800bd38:	687b      	ldr	r3, [r7, #4]
 800bd3a:	0018      	movs	r0, r3
 800bd3c:	f000 fc58 	bl	800c5f0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bd40:	687b      	ldr	r3, [r7, #4]
 800bd42:	0018      	movs	r0, r3
 800bd44:	f000 fc64 	bl	800c610 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bd48:	687b      	ldr	r3, [r7, #4]
 800bd4a:	2200      	movs	r2, #0
 800bd4c:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800bd4e:	687b      	ldr	r3, [r7, #4]
 800bd50:	681b      	ldr	r3, [r3, #0]
 800bd52:	691b      	ldr	r3, [r3, #16]
 800bd54:	2210      	movs	r2, #16
 800bd56:	4013      	ands	r3, r2
 800bd58:	2b10      	cmp	r3, #16
 800bd5a:	d125      	bne.n	800bda8 <HAL_TIM_IRQHandler+0x16c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800bd5c:	687b      	ldr	r3, [r7, #4]
 800bd5e:	681b      	ldr	r3, [r3, #0]
 800bd60:	68db      	ldr	r3, [r3, #12]
 800bd62:	2210      	movs	r2, #16
 800bd64:	4013      	ands	r3, r2
 800bd66:	2b10      	cmp	r3, #16
 800bd68:	d11e      	bne.n	800bda8 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800bd6a:	687b      	ldr	r3, [r7, #4]
 800bd6c:	681b      	ldr	r3, [r3, #0]
 800bd6e:	2211      	movs	r2, #17
 800bd70:	4252      	negs	r2, r2
 800bd72:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800bd74:	687b      	ldr	r3, [r7, #4]
 800bd76:	2208      	movs	r2, #8
 800bd78:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800bd7a:	687b      	ldr	r3, [r7, #4]
 800bd7c:	681b      	ldr	r3, [r3, #0]
 800bd7e:	69da      	ldr	r2, [r3, #28]
 800bd80:	23c0      	movs	r3, #192	; 0xc0
 800bd82:	009b      	lsls	r3, r3, #2
 800bd84:	4013      	ands	r3, r2
 800bd86:	d004      	beq.n	800bd92 <HAL_TIM_IRQHandler+0x156>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800bd88:	687b      	ldr	r3, [r7, #4]
 800bd8a:	0018      	movs	r0, r3
 800bd8c:	f000 fc38 	bl	800c600 <HAL_TIM_IC_CaptureCallback>
 800bd90:	e007      	b.n	800bda2 <HAL_TIM_IRQHandler+0x166>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800bd92:	687b      	ldr	r3, [r7, #4]
 800bd94:	0018      	movs	r0, r3
 800bd96:	f000 fc2b 	bl	800c5f0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bd9a:	687b      	ldr	r3, [r7, #4]
 800bd9c:	0018      	movs	r0, r3
 800bd9e:	f000 fc37 	bl	800c610 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bda2:	687b      	ldr	r3, [r7, #4]
 800bda4:	2200      	movs	r2, #0
 800bda6:	761a      	strb	r2, [r3, #24]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800bda8:	687b      	ldr	r3, [r7, #4]
 800bdaa:	681b      	ldr	r3, [r3, #0]
 800bdac:	691b      	ldr	r3, [r3, #16]
 800bdae:	2201      	movs	r2, #1
 800bdb0:	4013      	ands	r3, r2
 800bdb2:	2b01      	cmp	r3, #1
 800bdb4:	d10f      	bne.n	800bdd6 <HAL_TIM_IRQHandler+0x19a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800bdb6:	687b      	ldr	r3, [r7, #4]
 800bdb8:	681b      	ldr	r3, [r3, #0]
 800bdba:	68db      	ldr	r3, [r3, #12]
 800bdbc:	2201      	movs	r2, #1
 800bdbe:	4013      	ands	r3, r2
 800bdc0:	2b01      	cmp	r3, #1
 800bdc2:	d108      	bne.n	800bdd6 <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800bdc4:	687b      	ldr	r3, [r7, #4]
 800bdc6:	681b      	ldr	r3, [r3, #0]
 800bdc8:	2202      	movs	r2, #2
 800bdca:	4252      	negs	r2, r2
 800bdcc:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800bdce:	687b      	ldr	r3, [r7, #4]
 800bdd0:	0018      	movs	r0, r3
 800bdd2:	f7f6 f9e5 	bl	80021a0 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800bdd6:	687b      	ldr	r3, [r7, #4]
 800bdd8:	681b      	ldr	r3, [r3, #0]
 800bdda:	691b      	ldr	r3, [r3, #16]
 800bddc:	2240      	movs	r2, #64	; 0x40
 800bdde:	4013      	ands	r3, r2
 800bde0:	2b40      	cmp	r3, #64	; 0x40
 800bde2:	d10f      	bne.n	800be04 <HAL_TIM_IRQHandler+0x1c8>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 800bde4:	687b      	ldr	r3, [r7, #4]
 800bde6:	681b      	ldr	r3, [r3, #0]
 800bde8:	68db      	ldr	r3, [r3, #12]
 800bdea:	2240      	movs	r2, #64	; 0x40
 800bdec:	4013      	ands	r3, r2
 800bdee:	2b40      	cmp	r3, #64	; 0x40
 800bdf0:	d108      	bne.n	800be04 <HAL_TIM_IRQHandler+0x1c8>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800bdf2:	687b      	ldr	r3, [r7, #4]
 800bdf4:	681b      	ldr	r3, [r3, #0]
 800bdf6:	2241      	movs	r2, #65	; 0x41
 800bdf8:	4252      	negs	r2, r2
 800bdfa:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 800bdfc:	687b      	ldr	r3, [r7, #4]
 800bdfe:	0018      	movs	r0, r3
 800be00:	f000 fc0e 	bl	800c620 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 800be04:	46c0      	nop			; (mov r8, r8)
 800be06:	46bd      	mov	sp, r7
 800be08:	b002      	add	sp, #8
 800be0a:	bd80      	pop	{r7, pc}

0800be0c <HAL_TIM_OC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
                                           TIM_OC_InitTypeDef *sConfig,
                                           uint32_t Channel)
{
 800be0c:	b580      	push	{r7, lr}
 800be0e:	b084      	sub	sp, #16
 800be10:	af00      	add	r7, sp, #0
 800be12:	60f8      	str	r0, [r7, #12]
 800be14:	60b9      	str	r1, [r7, #8]
 800be16:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_CHANNELS(Channel));
 800be18:	687b      	ldr	r3, [r7, #4]
 800be1a:	2b00      	cmp	r3, #0
 800be1c:	d011      	beq.n	800be42 <HAL_TIM_OC_ConfigChannel+0x36>
 800be1e:	687b      	ldr	r3, [r7, #4]
 800be20:	2b04      	cmp	r3, #4
 800be22:	d00e      	beq.n	800be42 <HAL_TIM_OC_ConfigChannel+0x36>
 800be24:	687b      	ldr	r3, [r7, #4]
 800be26:	2b08      	cmp	r3, #8
 800be28:	d00b      	beq.n	800be42 <HAL_TIM_OC_ConfigChannel+0x36>
 800be2a:	687b      	ldr	r3, [r7, #4]
 800be2c:	2b0c      	cmp	r3, #12
 800be2e:	d008      	beq.n	800be42 <HAL_TIM_OC_ConfigChannel+0x36>
 800be30:	687b      	ldr	r3, [r7, #4]
 800be32:	2b3c      	cmp	r3, #60	; 0x3c
 800be34:	d005      	beq.n	800be42 <HAL_TIM_OC_ConfigChannel+0x36>
 800be36:	4a6b      	ldr	r2, [pc, #428]	; (800bfe4 <HAL_TIM_OC_ConfigChannel+0x1d8>)
 800be38:	4b6b      	ldr	r3, [pc, #428]	; (800bfe8 <HAL_TIM_OC_ConfigChannel+0x1dc>)
 800be3a:	0011      	movs	r1, r2
 800be3c:	0018      	movs	r0, r3
 800be3e:	f7fa fa2a 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
 800be42:	68bb      	ldr	r3, [r7, #8]
 800be44:	681b      	ldr	r3, [r3, #0]
 800be46:	2b00      	cmp	r3, #0
 800be48:	d019      	beq.n	800be7e <HAL_TIM_OC_ConfigChannel+0x72>
 800be4a:	68bb      	ldr	r3, [r7, #8]
 800be4c:	681b      	ldr	r3, [r3, #0]
 800be4e:	2b10      	cmp	r3, #16
 800be50:	d015      	beq.n	800be7e <HAL_TIM_OC_ConfigChannel+0x72>
 800be52:	68bb      	ldr	r3, [r7, #8]
 800be54:	681b      	ldr	r3, [r3, #0]
 800be56:	2b20      	cmp	r3, #32
 800be58:	d011      	beq.n	800be7e <HAL_TIM_OC_ConfigChannel+0x72>
 800be5a:	68bb      	ldr	r3, [r7, #8]
 800be5c:	681b      	ldr	r3, [r3, #0]
 800be5e:	2b30      	cmp	r3, #48	; 0x30
 800be60:	d00d      	beq.n	800be7e <HAL_TIM_OC_ConfigChannel+0x72>
 800be62:	68bb      	ldr	r3, [r7, #8]
 800be64:	681b      	ldr	r3, [r3, #0]
 800be66:	2b50      	cmp	r3, #80	; 0x50
 800be68:	d009      	beq.n	800be7e <HAL_TIM_OC_ConfigChannel+0x72>
 800be6a:	68bb      	ldr	r3, [r7, #8]
 800be6c:	681b      	ldr	r3, [r3, #0]
 800be6e:	2b40      	cmp	r3, #64	; 0x40
 800be70:	d005      	beq.n	800be7e <HAL_TIM_OC_ConfigChannel+0x72>
 800be72:	4a5e      	ldr	r2, [pc, #376]	; (800bfec <HAL_TIM_OC_ConfigChannel+0x1e0>)
 800be74:	4b5c      	ldr	r3, [pc, #368]	; (800bfe8 <HAL_TIM_OC_ConfigChannel+0x1dc>)
 800be76:	0011      	movs	r1, r2
 800be78:	0018      	movs	r0, r3
 800be7a:	f7fa fa0c 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
 800be7e:	68bb      	ldr	r3, [r7, #8]
 800be80:	689b      	ldr	r3, [r3, #8]
 800be82:	2b00      	cmp	r3, #0
 800be84:	d009      	beq.n	800be9a <HAL_TIM_OC_ConfigChannel+0x8e>
 800be86:	68bb      	ldr	r3, [r7, #8]
 800be88:	689b      	ldr	r3, [r3, #8]
 800be8a:	2b02      	cmp	r3, #2
 800be8c:	d005      	beq.n	800be9a <HAL_TIM_OC_ConfigChannel+0x8e>
 800be8e:	4a58      	ldr	r2, [pc, #352]	; (800bff0 <HAL_TIM_OC_ConfigChannel+0x1e4>)
 800be90:	4b55      	ldr	r3, [pc, #340]	; (800bfe8 <HAL_TIM_OC_ConfigChannel+0x1dc>)
 800be92:	0011      	movs	r1, r2
 800be94:	0018      	movs	r0, r3
 800be96:	f7fa f9fe 	bl	8006296 <assert_failed>

  /* Process Locked */
  __HAL_LOCK(htim);
 800be9a:	68fb      	ldr	r3, [r7, #12]
 800be9c:	2238      	movs	r2, #56	; 0x38
 800be9e:	5c9b      	ldrb	r3, [r3, r2]
 800bea0:	2b01      	cmp	r3, #1
 800bea2:	d101      	bne.n	800bea8 <HAL_TIM_OC_ConfigChannel+0x9c>
 800bea4:	2302      	movs	r3, #2
 800bea6:	e098      	b.n	800bfda <HAL_TIM_OC_ConfigChannel+0x1ce>
 800bea8:	68fb      	ldr	r3, [r7, #12]
 800beaa:	2238      	movs	r2, #56	; 0x38
 800beac:	2101      	movs	r1, #1
 800beae:	5499      	strb	r1, [r3, r2]

  switch (Channel)
 800beb0:	687b      	ldr	r3, [r7, #4]
 800beb2:	2b0c      	cmp	r3, #12
 800beb4:	d100      	bne.n	800beb8 <HAL_TIM_OC_ConfigChannel+0xac>
 800beb6:	e070      	b.n	800bf9a <HAL_TIM_OC_ConfigChannel+0x18e>
 800beb8:	687b      	ldr	r3, [r7, #4]
 800beba:	2b0c      	cmp	r3, #12
 800bebc:	d900      	bls.n	800bec0 <HAL_TIM_OC_ConfigChannel+0xb4>
 800bebe:	e086      	b.n	800bfce <HAL_TIM_OC_ConfigChannel+0x1c2>
 800bec0:	687b      	ldr	r3, [r7, #4]
 800bec2:	2b08      	cmp	r3, #8
 800bec4:	d050      	beq.n	800bf68 <HAL_TIM_OC_ConfigChannel+0x15c>
 800bec6:	687b      	ldr	r3, [r7, #4]
 800bec8:	2b08      	cmp	r3, #8
 800beca:	d900      	bls.n	800bece <HAL_TIM_OC_ConfigChannel+0xc2>
 800becc:	e07f      	b.n	800bfce <HAL_TIM_OC_ConfigChannel+0x1c2>
 800bece:	687b      	ldr	r3, [r7, #4]
 800bed0:	2b00      	cmp	r3, #0
 800bed2:	d003      	beq.n	800bedc <HAL_TIM_OC_ConfigChannel+0xd0>
 800bed4:	687b      	ldr	r3, [r7, #4]
 800bed6:	2b04      	cmp	r3, #4
 800bed8:	d023      	beq.n	800bf22 <HAL_TIM_OC_ConfigChannel+0x116>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
      break;
    }

    default:
      break;
 800beda:	e078      	b.n	800bfce <HAL_TIM_OC_ConfigChannel+0x1c2>
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
 800bedc:	68fb      	ldr	r3, [r7, #12]
 800bede:	681a      	ldr	r2, [r3, #0]
 800bee0:	2380      	movs	r3, #128	; 0x80
 800bee2:	05db      	lsls	r3, r3, #23
 800bee4:	429a      	cmp	r2, r3
 800bee6:	d014      	beq.n	800bf12 <HAL_TIM_OC_ConfigChannel+0x106>
 800bee8:	68fb      	ldr	r3, [r7, #12]
 800beea:	681b      	ldr	r3, [r3, #0]
 800beec:	4a41      	ldr	r2, [pc, #260]	; (800bff4 <HAL_TIM_OC_ConfigChannel+0x1e8>)
 800beee:	4293      	cmp	r3, r2
 800bef0:	d00f      	beq.n	800bf12 <HAL_TIM_OC_ConfigChannel+0x106>
 800bef2:	68fb      	ldr	r3, [r7, #12]
 800bef4:	681b      	ldr	r3, [r3, #0]
 800bef6:	4a40      	ldr	r2, [pc, #256]	; (800bff8 <HAL_TIM_OC_ConfigChannel+0x1ec>)
 800bef8:	4293      	cmp	r3, r2
 800befa:	d00a      	beq.n	800bf12 <HAL_TIM_OC_ConfigChannel+0x106>
 800befc:	68fb      	ldr	r3, [r7, #12]
 800befe:	681b      	ldr	r3, [r3, #0]
 800bf00:	4a3e      	ldr	r2, [pc, #248]	; (800bffc <HAL_TIM_OC_ConfigChannel+0x1f0>)
 800bf02:	4293      	cmp	r3, r2
 800bf04:	d005      	beq.n	800bf12 <HAL_TIM_OC_ConfigChannel+0x106>
 800bf06:	4a3e      	ldr	r2, [pc, #248]	; (800c000 <HAL_TIM_OC_ConfigChannel+0x1f4>)
 800bf08:	4b37      	ldr	r3, [pc, #220]	; (800bfe8 <HAL_TIM_OC_ConfigChannel+0x1dc>)
 800bf0a:	0011      	movs	r1, r2
 800bf0c:	0018      	movs	r0, r3
 800bf0e:	f7fa f9c2 	bl	8006296 <assert_failed>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800bf12:	68fb      	ldr	r3, [r7, #12]
 800bf14:	681b      	ldr	r3, [r3, #0]
 800bf16:	68ba      	ldr	r2, [r7, #8]
 800bf18:	0011      	movs	r1, r2
 800bf1a:	0018      	movs	r0, r3
 800bf1c:	f000 fbe6 	bl	800c6ec <TIM_OC1_SetConfig>
      break;
 800bf20:	e056      	b.n	800bfd0 <HAL_TIM_OC_ConfigChannel+0x1c4>
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
 800bf22:	68fb      	ldr	r3, [r7, #12]
 800bf24:	681a      	ldr	r2, [r3, #0]
 800bf26:	2380      	movs	r3, #128	; 0x80
 800bf28:	05db      	lsls	r3, r3, #23
 800bf2a:	429a      	cmp	r2, r3
 800bf2c:	d014      	beq.n	800bf58 <HAL_TIM_OC_ConfigChannel+0x14c>
 800bf2e:	68fb      	ldr	r3, [r7, #12]
 800bf30:	681b      	ldr	r3, [r3, #0]
 800bf32:	4a30      	ldr	r2, [pc, #192]	; (800bff4 <HAL_TIM_OC_ConfigChannel+0x1e8>)
 800bf34:	4293      	cmp	r3, r2
 800bf36:	d00f      	beq.n	800bf58 <HAL_TIM_OC_ConfigChannel+0x14c>
 800bf38:	68fb      	ldr	r3, [r7, #12]
 800bf3a:	681b      	ldr	r3, [r3, #0]
 800bf3c:	4a2e      	ldr	r2, [pc, #184]	; (800bff8 <HAL_TIM_OC_ConfigChannel+0x1ec>)
 800bf3e:	4293      	cmp	r3, r2
 800bf40:	d00a      	beq.n	800bf58 <HAL_TIM_OC_ConfigChannel+0x14c>
 800bf42:	68fb      	ldr	r3, [r7, #12]
 800bf44:	681b      	ldr	r3, [r3, #0]
 800bf46:	4a2d      	ldr	r2, [pc, #180]	; (800bffc <HAL_TIM_OC_ConfigChannel+0x1f0>)
 800bf48:	4293      	cmp	r3, r2
 800bf4a:	d005      	beq.n	800bf58 <HAL_TIM_OC_ConfigChannel+0x14c>
 800bf4c:	4a2d      	ldr	r2, [pc, #180]	; (800c004 <HAL_TIM_OC_ConfigChannel+0x1f8>)
 800bf4e:	4b26      	ldr	r3, [pc, #152]	; (800bfe8 <HAL_TIM_OC_ConfigChannel+0x1dc>)
 800bf50:	0011      	movs	r1, r2
 800bf52:	0018      	movs	r0, r3
 800bf54:	f7fa f99f 	bl	8006296 <assert_failed>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800bf58:	68fb      	ldr	r3, [r7, #12]
 800bf5a:	681b      	ldr	r3, [r3, #0]
 800bf5c:	68ba      	ldr	r2, [r7, #8]
 800bf5e:	0011      	movs	r1, r2
 800bf60:	0018      	movs	r0, r3
 800bf62:	f000 fbff 	bl	800c764 <TIM_OC2_SetConfig>
      break;
 800bf66:	e033      	b.n	800bfd0 <HAL_TIM_OC_ConfigChannel+0x1c4>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
 800bf68:	68fb      	ldr	r3, [r7, #12]
 800bf6a:	681a      	ldr	r2, [r3, #0]
 800bf6c:	2380      	movs	r3, #128	; 0x80
 800bf6e:	05db      	lsls	r3, r3, #23
 800bf70:	429a      	cmp	r2, r3
 800bf72:	d00a      	beq.n	800bf8a <HAL_TIM_OC_ConfigChannel+0x17e>
 800bf74:	68fb      	ldr	r3, [r7, #12]
 800bf76:	681b      	ldr	r3, [r3, #0]
 800bf78:	4a1e      	ldr	r2, [pc, #120]	; (800bff4 <HAL_TIM_OC_ConfigChannel+0x1e8>)
 800bf7a:	4293      	cmp	r3, r2
 800bf7c:	d005      	beq.n	800bf8a <HAL_TIM_OC_ConfigChannel+0x17e>
 800bf7e:	4a22      	ldr	r2, [pc, #136]	; (800c008 <HAL_TIM_OC_ConfigChannel+0x1fc>)
 800bf80:	4b19      	ldr	r3, [pc, #100]	; (800bfe8 <HAL_TIM_OC_ConfigChannel+0x1dc>)
 800bf82:	0011      	movs	r1, r2
 800bf84:	0018      	movs	r0, r3
 800bf86:	f7fa f986 	bl	8006296 <assert_failed>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800bf8a:	68fb      	ldr	r3, [r7, #12]
 800bf8c:	681b      	ldr	r3, [r3, #0]
 800bf8e:	68ba      	ldr	r2, [r7, #8]
 800bf90:	0011      	movs	r1, r2
 800bf92:	0018      	movs	r0, r3
 800bf94:	f000 fc28 	bl	800c7e8 <TIM_OC3_SetConfig>
      break;
 800bf98:	e01a      	b.n	800bfd0 <HAL_TIM_OC_ConfigChannel+0x1c4>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
 800bf9a:	68fb      	ldr	r3, [r7, #12]
 800bf9c:	681a      	ldr	r2, [r3, #0]
 800bf9e:	2380      	movs	r3, #128	; 0x80
 800bfa0:	05db      	lsls	r3, r3, #23
 800bfa2:	429a      	cmp	r2, r3
 800bfa4:	d00b      	beq.n	800bfbe <HAL_TIM_OC_ConfigChannel+0x1b2>
 800bfa6:	68fb      	ldr	r3, [r7, #12]
 800bfa8:	681b      	ldr	r3, [r3, #0]
 800bfaa:	4a12      	ldr	r2, [pc, #72]	; (800bff4 <HAL_TIM_OC_ConfigChannel+0x1e8>)
 800bfac:	4293      	cmp	r3, r2
 800bfae:	d006      	beq.n	800bfbe <HAL_TIM_OC_ConfigChannel+0x1b2>
 800bfb0:	23ed      	movs	r3, #237	; 0xed
 800bfb2:	011a      	lsls	r2, r3, #4
 800bfb4:	4b0c      	ldr	r3, [pc, #48]	; (800bfe8 <HAL_TIM_OC_ConfigChannel+0x1dc>)
 800bfb6:	0011      	movs	r1, r2
 800bfb8:	0018      	movs	r0, r3
 800bfba:	f7fa f96c 	bl	8006296 <assert_failed>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 800bfbe:	68fb      	ldr	r3, [r7, #12]
 800bfc0:	681b      	ldr	r3, [r3, #0]
 800bfc2:	68ba      	ldr	r2, [r7, #8]
 800bfc4:	0011      	movs	r1, r2
 800bfc6:	0018      	movs	r0, r3
 800bfc8:	f000 fc4e 	bl	800c868 <TIM_OC4_SetConfig>
      break;
 800bfcc:	e000      	b.n	800bfd0 <HAL_TIM_OC_ConfigChannel+0x1c4>
      break;
 800bfce:	46c0      	nop			; (mov r8, r8)
  }

  __HAL_UNLOCK(htim);
 800bfd0:	68fb      	ldr	r3, [r7, #12]
 800bfd2:	2238      	movs	r2, #56	; 0x38
 800bfd4:	2100      	movs	r1, #0
 800bfd6:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800bfd8:	2300      	movs	r3, #0
}
 800bfda:	0018      	movs	r0, r3
 800bfdc:	46bd      	mov	sp, r7
 800bfde:	b004      	add	sp, #16
 800bfe0:	bd80      	pop	{r7, pc}
 800bfe2:	46c0      	nop			; (mov r8, r8)
 800bfe4:	00000ea6 	.word	0x00000ea6
 800bfe8:	0800df0c 	.word	0x0800df0c
 800bfec:	00000ea7 	.word	0x00000ea7
 800bff0:	00000ea8 	.word	0x00000ea8
 800bff4:	40000400 	.word	0x40000400
 800bff8:	40010800 	.word	0x40010800
 800bffc:	40011400 	.word	0x40011400
 800c000:	00000eb2 	.word	0x00000eb2
 800c004:	00000ebc 	.word	0x00000ebc
 800c008:	00000ec6 	.word	0x00000ec6

0800c00c <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 800c00c:	b580      	push	{r7, lr}
 800c00e:	b084      	sub	sp, #16
 800c010:	af00      	add	r7, sp, #0
 800c012:	6078      	str	r0, [r7, #4]
 800c014:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 800c016:	687b      	ldr	r3, [r7, #4]
 800c018:	2238      	movs	r2, #56	; 0x38
 800c01a:	5c9b      	ldrb	r3, [r3, r2]
 800c01c:	2b01      	cmp	r3, #1
 800c01e:	d101      	bne.n	800c024 <HAL_TIM_ConfigClockSource+0x18>
 800c020:	2302      	movs	r3, #2
 800c022:	e2c5      	b.n	800c5b0 <HAL_TIM_ConfigClockSource+0x5a4>
 800c024:	687b      	ldr	r3, [r7, #4]
 800c026:	2238      	movs	r2, #56	; 0x38
 800c028:	2101      	movs	r1, #1
 800c02a:	5499      	strb	r1, [r3, r2]

  htim->State = HAL_TIM_STATE_BUSY;
 800c02c:	687b      	ldr	r3, [r7, #4]
 800c02e:	2239      	movs	r2, #57	; 0x39
 800c030:	2102      	movs	r1, #2
 800c032:	5499      	strb	r1, [r3, r2]

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
 800c034:	683b      	ldr	r3, [r7, #0]
 800c036:	681a      	ldr	r2, [r3, #0]
 800c038:	2380      	movs	r3, #128	; 0x80
 800c03a:	015b      	lsls	r3, r3, #5
 800c03c:	429a      	cmp	r2, r3
 800c03e:	d02b      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c040:	683b      	ldr	r3, [r7, #0]
 800c042:	681a      	ldr	r2, [r3, #0]
 800c044:	2380      	movs	r3, #128	; 0x80
 800c046:	019b      	lsls	r3, r3, #6
 800c048:	429a      	cmp	r2, r3
 800c04a:	d025      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c04c:	683b      	ldr	r3, [r7, #0]
 800c04e:	681b      	ldr	r3, [r3, #0]
 800c050:	2b00      	cmp	r3, #0
 800c052:	d021      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c054:	683b      	ldr	r3, [r7, #0]
 800c056:	681b      	ldr	r3, [r3, #0]
 800c058:	2b10      	cmp	r3, #16
 800c05a:	d01d      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c05c:	683b      	ldr	r3, [r7, #0]
 800c05e:	681b      	ldr	r3, [r3, #0]
 800c060:	2b20      	cmp	r3, #32
 800c062:	d019      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c064:	683b      	ldr	r3, [r7, #0]
 800c066:	681b      	ldr	r3, [r3, #0]
 800c068:	2b30      	cmp	r3, #48	; 0x30
 800c06a:	d015      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c06c:	683b      	ldr	r3, [r7, #0]
 800c06e:	681b      	ldr	r3, [r3, #0]
 800c070:	2b40      	cmp	r3, #64	; 0x40
 800c072:	d011      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c074:	683b      	ldr	r3, [r7, #0]
 800c076:	681b      	ldr	r3, [r3, #0]
 800c078:	2b50      	cmp	r3, #80	; 0x50
 800c07a:	d00d      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c07c:	683b      	ldr	r3, [r7, #0]
 800c07e:	681b      	ldr	r3, [r3, #0]
 800c080:	2b60      	cmp	r3, #96	; 0x60
 800c082:	d009      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c084:	683b      	ldr	r3, [r7, #0]
 800c086:	681b      	ldr	r3, [r3, #0]
 800c088:	2b70      	cmp	r3, #112	; 0x70
 800c08a:	d005      	beq.n	800c098 <HAL_TIM_ConfigClockSource+0x8c>
 800c08c:	4aad      	ldr	r2, [pc, #692]	; (800c344 <HAL_TIM_ConfigClockSource+0x338>)
 800c08e:	4bae      	ldr	r3, [pc, #696]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c090:	0011      	movs	r1, r2
 800c092:	0018      	movs	r0, r3
 800c094:	f7fa f8ff 	bl	8006296 <assert_failed>

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800c098:	687b      	ldr	r3, [r7, #4]
 800c09a:	681b      	ldr	r3, [r3, #0]
 800c09c:	689b      	ldr	r3, [r3, #8]
 800c09e:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 800c0a0:	68fb      	ldr	r3, [r7, #12]
 800c0a2:	2277      	movs	r2, #119	; 0x77
 800c0a4:	4393      	bics	r3, r2
 800c0a6:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c0a8:	68fb      	ldr	r3, [r7, #12]
 800c0aa:	4aa8      	ldr	r2, [pc, #672]	; (800c34c <HAL_TIM_ConfigClockSource+0x340>)
 800c0ac:	4013      	ands	r3, r2
 800c0ae:	60fb      	str	r3, [r7, #12]
  htim->Instance->SMCR = tmpsmcr;
 800c0b0:	687b      	ldr	r3, [r7, #4]
 800c0b2:	681b      	ldr	r3, [r3, #0]
 800c0b4:	68fa      	ldr	r2, [r7, #12]
 800c0b6:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 800c0b8:	683b      	ldr	r3, [r7, #0]
 800c0ba:	681b      	ldr	r3, [r3, #0]
 800c0bc:	2280      	movs	r2, #128	; 0x80
 800c0be:	0192      	lsls	r2, r2, #6
 800c0c0:	4293      	cmp	r3, r2
 800c0c2:	d100      	bne.n	800c0c6 <HAL_TIM_ConfigClockSource+0xba>
 800c0c4:	e0cc      	b.n	800c260 <HAL_TIM_ConfigClockSource+0x254>
 800c0c6:	2280      	movs	r2, #128	; 0x80
 800c0c8:	0192      	lsls	r2, r2, #6
 800c0ca:	4293      	cmp	r3, r2
 800c0cc:	d900      	bls.n	800c0d0 <HAL_TIM_ConfigClockSource+0xc4>
 800c0ce:	e263      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
 800c0d0:	2280      	movs	r2, #128	; 0x80
 800c0d2:	0152      	lsls	r2, r2, #5
 800c0d4:	4293      	cmp	r3, r2
 800c0d6:	d028      	beq.n	800c12a <HAL_TIM_ConfigClockSource+0x11e>
 800c0d8:	2280      	movs	r2, #128	; 0x80
 800c0da:	0152      	lsls	r2, r2, #5
 800c0dc:	4293      	cmp	r3, r2
 800c0de:	d900      	bls.n	800c0e2 <HAL_TIM_ConfigClockSource+0xd6>
 800c0e0:	e25a      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
 800c0e2:	2b70      	cmp	r3, #112	; 0x70
 800c0e4:	d04d      	beq.n	800c182 <HAL_TIM_ConfigClockSource+0x176>
 800c0e6:	d900      	bls.n	800c0ea <HAL_TIM_ConfigClockSource+0xde>
 800c0e8:	e256      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
 800c0ea:	2b60      	cmp	r3, #96	; 0x60
 800c0ec:	d100      	bne.n	800c0f0 <HAL_TIM_ConfigClockSource+0xe4>
 800c0ee:	e197      	b.n	800c420 <HAL_TIM_ConfigClockSource+0x414>
 800c0f0:	d900      	bls.n	800c0f4 <HAL_TIM_ConfigClockSource+0xe8>
 800c0f2:	e251      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
 800c0f4:	2b50      	cmp	r3, #80	; 0x50
 800c0f6:	d100      	bne.n	800c0fa <HAL_TIM_ConfigClockSource+0xee>
 800c0f8:	e146      	b.n	800c388 <HAL_TIM_ConfigClockSource+0x37c>
 800c0fa:	d900      	bls.n	800c0fe <HAL_TIM_ConfigClockSource+0xf2>
 800c0fc:	e24c      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
 800c0fe:	2b40      	cmp	r3, #64	; 0x40
 800c100:	d100      	bne.n	800c104 <HAL_TIM_ConfigClockSource+0xf8>
 800c102:	e1d9      	b.n	800c4b8 <HAL_TIM_ConfigClockSource+0x4ac>
 800c104:	d900      	bls.n	800c108 <HAL_TIM_ConfigClockSource+0xfc>
 800c106:	e247      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
 800c108:	2b30      	cmp	r3, #48	; 0x30
 800c10a:	d100      	bne.n	800c10e <HAL_TIM_ConfigClockSource+0x102>
 800c10c:	e220      	b.n	800c550 <HAL_TIM_ConfigClockSource+0x544>
 800c10e:	d900      	bls.n	800c112 <HAL_TIM_ConfigClockSource+0x106>
 800c110:	e242      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
 800c112:	2b20      	cmp	r3, #32
 800c114:	d100      	bne.n	800c118 <HAL_TIM_ConfigClockSource+0x10c>
 800c116:	e21b      	b.n	800c550 <HAL_TIM_ConfigClockSource+0x544>
 800c118:	d900      	bls.n	800c11c <HAL_TIM_ConfigClockSource+0x110>
 800c11a:	e23d      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
 800c11c:	2b00      	cmp	r3, #0
 800c11e:	d100      	bne.n	800c122 <HAL_TIM_ConfigClockSource+0x116>
 800c120:	e216      	b.n	800c550 <HAL_TIM_ConfigClockSource+0x544>
 800c122:	2b10      	cmp	r3, #16
 800c124:	d100      	bne.n	800c128 <HAL_TIM_ConfigClockSource+0x11c>
 800c126:	e213      	b.n	800c550 <HAL_TIM_ConfigClockSource+0x544>
        TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
        break;
      }

    default:
      break;
 800c128:	e236      	b.n	800c598 <HAL_TIM_ConfigClockSource+0x58c>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c12a:	687b      	ldr	r3, [r7, #4]
 800c12c:	681a      	ldr	r2, [r3, #0]
 800c12e:	2380      	movs	r3, #128	; 0x80
 800c130:	05db      	lsls	r3, r3, #23
 800c132:	429a      	cmp	r2, r3
 800c134:	d100      	bne.n	800c138 <HAL_TIM_ConfigClockSource+0x12c>
 800c136:	e231      	b.n	800c59c <HAL_TIM_ConfigClockSource+0x590>
 800c138:	687b      	ldr	r3, [r7, #4]
 800c13a:	681b      	ldr	r3, [r3, #0]
 800c13c:	4a84      	ldr	r2, [pc, #528]	; (800c350 <HAL_TIM_ConfigClockSource+0x344>)
 800c13e:	4293      	cmp	r3, r2
 800c140:	d100      	bne.n	800c144 <HAL_TIM_ConfigClockSource+0x138>
 800c142:	e22b      	b.n	800c59c <HAL_TIM_ConfigClockSource+0x590>
 800c144:	687b      	ldr	r3, [r7, #4]
 800c146:	681b      	ldr	r3, [r3, #0]
 800c148:	4a82      	ldr	r2, [pc, #520]	; (800c354 <HAL_TIM_ConfigClockSource+0x348>)
 800c14a:	4293      	cmp	r3, r2
 800c14c:	d100      	bne.n	800c150 <HAL_TIM_ConfigClockSource+0x144>
 800c14e:	e225      	b.n	800c59c <HAL_TIM_ConfigClockSource+0x590>
 800c150:	687b      	ldr	r3, [r7, #4]
 800c152:	681b      	ldr	r3, [r3, #0]
 800c154:	4a80      	ldr	r2, [pc, #512]	; (800c358 <HAL_TIM_ConfigClockSource+0x34c>)
 800c156:	4293      	cmp	r3, r2
 800c158:	d100      	bne.n	800c15c <HAL_TIM_ConfigClockSource+0x150>
 800c15a:	e21f      	b.n	800c59c <HAL_TIM_ConfigClockSource+0x590>
 800c15c:	687b      	ldr	r3, [r7, #4]
 800c15e:	681b      	ldr	r3, [r3, #0]
 800c160:	4a7e      	ldr	r2, [pc, #504]	; (800c35c <HAL_TIM_ConfigClockSource+0x350>)
 800c162:	4293      	cmp	r3, r2
 800c164:	d100      	bne.n	800c168 <HAL_TIM_ConfigClockSource+0x15c>
 800c166:	e219      	b.n	800c59c <HAL_TIM_ConfigClockSource+0x590>
 800c168:	687b      	ldr	r3, [r7, #4]
 800c16a:	681b      	ldr	r3, [r3, #0]
 800c16c:	4a7c      	ldr	r2, [pc, #496]	; (800c360 <HAL_TIM_ConfigClockSource+0x354>)
 800c16e:	4293      	cmp	r3, r2
 800c170:	d100      	bne.n	800c174 <HAL_TIM_ConfigClockSource+0x168>
 800c172:	e213      	b.n	800c59c <HAL_TIM_ConfigClockSource+0x590>
 800c174:	4a7b      	ldr	r2, [pc, #492]	; (800c364 <HAL_TIM_ConfigClockSource+0x358>)
 800c176:	4b74      	ldr	r3, [pc, #464]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c178:	0011      	movs	r1, r2
 800c17a:	0018      	movs	r0, r3
 800c17c:	f7fa f88b 	bl	8006296 <assert_failed>
      break;
 800c180:	e20c      	b.n	800c59c <HAL_TIM_ConfigClockSource+0x590>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
 800c182:	687b      	ldr	r3, [r7, #4]
 800c184:	681a      	ldr	r2, [r3, #0]
 800c186:	2380      	movs	r3, #128	; 0x80
 800c188:	05db      	lsls	r3, r3, #23
 800c18a:	429a      	cmp	r2, r3
 800c18c:	d00f      	beq.n	800c1ae <HAL_TIM_ConfigClockSource+0x1a2>
 800c18e:	687b      	ldr	r3, [r7, #4]
 800c190:	681b      	ldr	r3, [r3, #0]
 800c192:	4a6f      	ldr	r2, [pc, #444]	; (800c350 <HAL_TIM_ConfigClockSource+0x344>)
 800c194:	4293      	cmp	r3, r2
 800c196:	d00a      	beq.n	800c1ae <HAL_TIM_ConfigClockSource+0x1a2>
 800c198:	687b      	ldr	r3, [r7, #4]
 800c19a:	681b      	ldr	r3, [r3, #0]
 800c19c:	4a6f      	ldr	r2, [pc, #444]	; (800c35c <HAL_TIM_ConfigClockSource+0x350>)
 800c19e:	4293      	cmp	r3, r2
 800c1a0:	d005      	beq.n	800c1ae <HAL_TIM_ConfigClockSource+0x1a2>
 800c1a2:	4a71      	ldr	r2, [pc, #452]	; (800c368 <HAL_TIM_ConfigClockSource+0x35c>)
 800c1a4:	4b68      	ldr	r3, [pc, #416]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c1a6:	0011      	movs	r1, r2
 800c1a8:	0018      	movs	r0, r3
 800c1aa:	f7fa f874 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800c1ae:	683b      	ldr	r3, [r7, #0]
 800c1b0:	689b      	ldr	r3, [r3, #8]
 800c1b2:	2b00      	cmp	r3, #0
 800c1b4:	d017      	beq.n	800c1e6 <HAL_TIM_ConfigClockSource+0x1da>
 800c1b6:	683b      	ldr	r3, [r7, #0]
 800c1b8:	689a      	ldr	r2, [r3, #8]
 800c1ba:	2380      	movs	r3, #128	; 0x80
 800c1bc:	015b      	lsls	r3, r3, #5
 800c1be:	429a      	cmp	r2, r3
 800c1c0:	d011      	beq.n	800c1e6 <HAL_TIM_ConfigClockSource+0x1da>
 800c1c2:	683b      	ldr	r3, [r7, #0]
 800c1c4:	689a      	ldr	r2, [r3, #8]
 800c1c6:	2380      	movs	r3, #128	; 0x80
 800c1c8:	019b      	lsls	r3, r3, #6
 800c1ca:	429a      	cmp	r2, r3
 800c1cc:	d00b      	beq.n	800c1e6 <HAL_TIM_ConfigClockSource+0x1da>
 800c1ce:	683b      	ldr	r3, [r7, #0]
 800c1d0:	689a      	ldr	r2, [r3, #8]
 800c1d2:	23c0      	movs	r3, #192	; 0xc0
 800c1d4:	019b      	lsls	r3, r3, #6
 800c1d6:	429a      	cmp	r2, r3
 800c1d8:	d005      	beq.n	800c1e6 <HAL_TIM_ConfigClockSource+0x1da>
 800c1da:	4a64      	ldr	r2, [pc, #400]	; (800c36c <HAL_TIM_ConfigClockSource+0x360>)
 800c1dc:	4b5a      	ldr	r3, [pc, #360]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c1de:	0011      	movs	r1, r2
 800c1e0:	0018      	movs	r0, r3
 800c1e2:	f7fa f858 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800c1e6:	683b      	ldr	r3, [r7, #0]
 800c1e8:	685a      	ldr	r2, [r3, #4]
 800c1ea:	2380      	movs	r3, #128	; 0x80
 800c1ec:	021b      	lsls	r3, r3, #8
 800c1ee:	429a      	cmp	r2, r3
 800c1f0:	d015      	beq.n	800c21e <HAL_TIM_ConfigClockSource+0x212>
 800c1f2:	683b      	ldr	r3, [r7, #0]
 800c1f4:	685b      	ldr	r3, [r3, #4]
 800c1f6:	2b00      	cmp	r3, #0
 800c1f8:	d011      	beq.n	800c21e <HAL_TIM_ConfigClockSource+0x212>
 800c1fa:	683b      	ldr	r3, [r7, #0]
 800c1fc:	685b      	ldr	r3, [r3, #4]
 800c1fe:	2b00      	cmp	r3, #0
 800c200:	d00d      	beq.n	800c21e <HAL_TIM_ConfigClockSource+0x212>
 800c202:	683b      	ldr	r3, [r7, #0]
 800c204:	685b      	ldr	r3, [r3, #4]
 800c206:	2b02      	cmp	r3, #2
 800c208:	d009      	beq.n	800c21e <HAL_TIM_ConfigClockSource+0x212>
 800c20a:	683b      	ldr	r3, [r7, #0]
 800c20c:	685b      	ldr	r3, [r3, #4]
 800c20e:	2b0a      	cmp	r3, #10
 800c210:	d005      	beq.n	800c21e <HAL_TIM_ConfigClockSource+0x212>
 800c212:	4a57      	ldr	r2, [pc, #348]	; (800c370 <HAL_TIM_ConfigClockSource+0x364>)
 800c214:	4b4c      	ldr	r3, [pc, #304]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c216:	0011      	movs	r1, r2
 800c218:	0018      	movs	r0, r3
 800c21a:	f7fa f83c 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800c21e:	683b      	ldr	r3, [r7, #0]
 800c220:	68db      	ldr	r3, [r3, #12]
 800c222:	2b0f      	cmp	r3, #15
 800c224:	d905      	bls.n	800c232 <HAL_TIM_ConfigClockSource+0x226>
 800c226:	4a53      	ldr	r2, [pc, #332]	; (800c374 <HAL_TIM_ConfigClockSource+0x368>)
 800c228:	4b47      	ldr	r3, [pc, #284]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c22a:	0011      	movs	r1, r2
 800c22c:	0018      	movs	r0, r3
 800c22e:	f7fa f832 	bl	8006296 <assert_failed>
      TIM_ETR_SetConfig(htim->Instance,
 800c232:	687b      	ldr	r3, [r7, #4]
 800c234:	6818      	ldr	r0, [r3, #0]
 800c236:	683b      	ldr	r3, [r7, #0]
 800c238:	6899      	ldr	r1, [r3, #8]
 800c23a:	683b      	ldr	r3, [r7, #0]
 800c23c:	685a      	ldr	r2, [r3, #4]
 800c23e:	683b      	ldr	r3, [r7, #0]
 800c240:	68db      	ldr	r3, [r3, #12]
 800c242:	f000 fbd1 	bl	800c9e8 <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
 800c246:	687b      	ldr	r3, [r7, #4]
 800c248:	681b      	ldr	r3, [r3, #0]
 800c24a:	689b      	ldr	r3, [r3, #8]
 800c24c:	60fb      	str	r3, [r7, #12]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800c24e:	68fb      	ldr	r3, [r7, #12]
 800c250:	2277      	movs	r2, #119	; 0x77
 800c252:	4313      	orrs	r3, r2
 800c254:	60fb      	str	r3, [r7, #12]
      htim->Instance->SMCR = tmpsmcr;
 800c256:	687b      	ldr	r3, [r7, #4]
 800c258:	681b      	ldr	r3, [r3, #0]
 800c25a:	68fa      	ldr	r2, [r7, #12]
 800c25c:	609a      	str	r2, [r3, #8]
      break;
 800c25e:	e19e      	b.n	800c59e <HAL_TIM_ConfigClockSource+0x592>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
 800c260:	687b      	ldr	r3, [r7, #4]
 800c262:	681a      	ldr	r2, [r3, #0]
 800c264:	2380      	movs	r3, #128	; 0x80
 800c266:	05db      	lsls	r3, r3, #23
 800c268:	429a      	cmp	r2, r3
 800c26a:	d014      	beq.n	800c296 <HAL_TIM_ConfigClockSource+0x28a>
 800c26c:	687b      	ldr	r3, [r7, #4]
 800c26e:	681b      	ldr	r3, [r3, #0]
 800c270:	4a37      	ldr	r2, [pc, #220]	; (800c350 <HAL_TIM_ConfigClockSource+0x344>)
 800c272:	4293      	cmp	r3, r2
 800c274:	d00f      	beq.n	800c296 <HAL_TIM_ConfigClockSource+0x28a>
 800c276:	687b      	ldr	r3, [r7, #4]
 800c278:	681b      	ldr	r3, [r3, #0]
 800c27a:	4a38      	ldr	r2, [pc, #224]	; (800c35c <HAL_TIM_ConfigClockSource+0x350>)
 800c27c:	4293      	cmp	r3, r2
 800c27e:	d00a      	beq.n	800c296 <HAL_TIM_ConfigClockSource+0x28a>
 800c280:	687b      	ldr	r3, [r7, #4]
 800c282:	681b      	ldr	r3, [r3, #0]
 800c284:	4a36      	ldr	r2, [pc, #216]	; (800c360 <HAL_TIM_ConfigClockSource+0x354>)
 800c286:	4293      	cmp	r3, r2
 800c288:	d005      	beq.n	800c296 <HAL_TIM_ConfigClockSource+0x28a>
 800c28a:	4a3b      	ldr	r2, [pc, #236]	; (800c378 <HAL_TIM_ConfigClockSource+0x36c>)
 800c28c:	4b2e      	ldr	r3, [pc, #184]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c28e:	0011      	movs	r1, r2
 800c290:	0018      	movs	r0, r3
 800c292:	f7fa f800 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800c296:	683b      	ldr	r3, [r7, #0]
 800c298:	689b      	ldr	r3, [r3, #8]
 800c29a:	2b00      	cmp	r3, #0
 800c29c:	d017      	beq.n	800c2ce <HAL_TIM_ConfigClockSource+0x2c2>
 800c29e:	683b      	ldr	r3, [r7, #0]
 800c2a0:	689a      	ldr	r2, [r3, #8]
 800c2a2:	2380      	movs	r3, #128	; 0x80
 800c2a4:	015b      	lsls	r3, r3, #5
 800c2a6:	429a      	cmp	r2, r3
 800c2a8:	d011      	beq.n	800c2ce <HAL_TIM_ConfigClockSource+0x2c2>
 800c2aa:	683b      	ldr	r3, [r7, #0]
 800c2ac:	689a      	ldr	r2, [r3, #8]
 800c2ae:	2380      	movs	r3, #128	; 0x80
 800c2b0:	019b      	lsls	r3, r3, #6
 800c2b2:	429a      	cmp	r2, r3
 800c2b4:	d00b      	beq.n	800c2ce <HAL_TIM_ConfigClockSource+0x2c2>
 800c2b6:	683b      	ldr	r3, [r7, #0]
 800c2b8:	689a      	ldr	r2, [r3, #8]
 800c2ba:	23c0      	movs	r3, #192	; 0xc0
 800c2bc:	019b      	lsls	r3, r3, #6
 800c2be:	429a      	cmp	r2, r3
 800c2c0:	d005      	beq.n	800c2ce <HAL_TIM_ConfigClockSource+0x2c2>
 800c2c2:	4a2e      	ldr	r2, [pc, #184]	; (800c37c <HAL_TIM_ConfigClockSource+0x370>)
 800c2c4:	4b20      	ldr	r3, [pc, #128]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c2c6:	0011      	movs	r1, r2
 800c2c8:	0018      	movs	r0, r3
 800c2ca:	f7f9 ffe4 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800c2ce:	683b      	ldr	r3, [r7, #0]
 800c2d0:	685a      	ldr	r2, [r3, #4]
 800c2d2:	2380      	movs	r3, #128	; 0x80
 800c2d4:	021b      	lsls	r3, r3, #8
 800c2d6:	429a      	cmp	r2, r3
 800c2d8:	d015      	beq.n	800c306 <HAL_TIM_ConfigClockSource+0x2fa>
 800c2da:	683b      	ldr	r3, [r7, #0]
 800c2dc:	685b      	ldr	r3, [r3, #4]
 800c2de:	2b00      	cmp	r3, #0
 800c2e0:	d011      	beq.n	800c306 <HAL_TIM_ConfigClockSource+0x2fa>
 800c2e2:	683b      	ldr	r3, [r7, #0]
 800c2e4:	685b      	ldr	r3, [r3, #4]
 800c2e6:	2b00      	cmp	r3, #0
 800c2e8:	d00d      	beq.n	800c306 <HAL_TIM_ConfigClockSource+0x2fa>
 800c2ea:	683b      	ldr	r3, [r7, #0]
 800c2ec:	685b      	ldr	r3, [r3, #4]
 800c2ee:	2b02      	cmp	r3, #2
 800c2f0:	d009      	beq.n	800c306 <HAL_TIM_ConfigClockSource+0x2fa>
 800c2f2:	683b      	ldr	r3, [r7, #0]
 800c2f4:	685b      	ldr	r3, [r3, #4]
 800c2f6:	2b0a      	cmp	r3, #10
 800c2f8:	d005      	beq.n	800c306 <HAL_TIM_ConfigClockSource+0x2fa>
 800c2fa:	4a21      	ldr	r2, [pc, #132]	; (800c380 <HAL_TIM_ConfigClockSource+0x374>)
 800c2fc:	4b12      	ldr	r3, [pc, #72]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c2fe:	0011      	movs	r1, r2
 800c300:	0018      	movs	r0, r3
 800c302:	f7f9 ffc8 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800c306:	683b      	ldr	r3, [r7, #0]
 800c308:	68db      	ldr	r3, [r3, #12]
 800c30a:	2b0f      	cmp	r3, #15
 800c30c:	d905      	bls.n	800c31a <HAL_TIM_ConfigClockSource+0x30e>
 800c30e:	4a1d      	ldr	r2, [pc, #116]	; (800c384 <HAL_TIM_ConfigClockSource+0x378>)
 800c310:	4b0d      	ldr	r3, [pc, #52]	; (800c348 <HAL_TIM_ConfigClockSource+0x33c>)
 800c312:	0011      	movs	r1, r2
 800c314:	0018      	movs	r0, r3
 800c316:	f7f9 ffbe 	bl	8006296 <assert_failed>
      TIM_ETR_SetConfig(htim->Instance,
 800c31a:	687b      	ldr	r3, [r7, #4]
 800c31c:	6818      	ldr	r0, [r3, #0]
 800c31e:	683b      	ldr	r3, [r7, #0]
 800c320:	6899      	ldr	r1, [r3, #8]
 800c322:	683b      	ldr	r3, [r7, #0]
 800c324:	685a      	ldr	r2, [r3, #4]
 800c326:	683b      	ldr	r3, [r7, #0]
 800c328:	68db      	ldr	r3, [r3, #12]
 800c32a:	f000 fb5d 	bl	800c9e8 <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800c32e:	687b      	ldr	r3, [r7, #4]
 800c330:	681b      	ldr	r3, [r3, #0]
 800c332:	689a      	ldr	r2, [r3, #8]
 800c334:	687b      	ldr	r3, [r7, #4]
 800c336:	681b      	ldr	r3, [r3, #0]
 800c338:	2180      	movs	r1, #128	; 0x80
 800c33a:	01c9      	lsls	r1, r1, #7
 800c33c:	430a      	orrs	r2, r1
 800c33e:	609a      	str	r2, [r3, #8]
      break;
 800c340:	e12d      	b.n	800c59e <HAL_TIM_ConfigClockSource+0x592>
 800c342:	46c0      	nop			; (mov r8, r8)
 800c344:	0000131c 	.word	0x0000131c
 800c348:	0800df0c 	.word	0x0800df0c
 800c34c:	ffff00ff 	.word	0xffff00ff
 800c350:	40000400 	.word	0x40000400
 800c354:	40001000 	.word	0x40001000
 800c358:	40001400 	.word	0x40001400
 800c35c:	40010800 	.word	0x40010800
 800c360:	40011400 	.word	0x40011400
 800c364:	00001328 	.word	0x00001328
 800c368:	0000132f 	.word	0x0000132f
 800c36c:	00001332 	.word	0x00001332
 800c370:	00001333 	.word	0x00001333
 800c374:	00001334 	.word	0x00001334
 800c378:	00001347 	.word	0x00001347
 800c37c:	0000134a 	.word	0x0000134a
 800c380:	0000134b 	.word	0x0000134b
 800c384:	0000134c 	.word	0x0000134c
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800c388:	687b      	ldr	r3, [r7, #4]
 800c38a:	681a      	ldr	r2, [r3, #0]
 800c38c:	2380      	movs	r3, #128	; 0x80
 800c38e:	05db      	lsls	r3, r3, #23
 800c390:	429a      	cmp	r2, r3
 800c392:	d00f      	beq.n	800c3b4 <HAL_TIM_ConfigClockSource+0x3a8>
 800c394:	687b      	ldr	r3, [r7, #4]
 800c396:	681b      	ldr	r3, [r3, #0]
 800c398:	4a87      	ldr	r2, [pc, #540]	; (800c5b8 <HAL_TIM_ConfigClockSource+0x5ac>)
 800c39a:	4293      	cmp	r3, r2
 800c39c:	d00a      	beq.n	800c3b4 <HAL_TIM_ConfigClockSource+0x3a8>
 800c39e:	687b      	ldr	r3, [r7, #4]
 800c3a0:	681b      	ldr	r3, [r3, #0]
 800c3a2:	4a86      	ldr	r2, [pc, #536]	; (800c5bc <HAL_TIM_ConfigClockSource+0x5b0>)
 800c3a4:	4293      	cmp	r3, r2
 800c3a6:	d005      	beq.n	800c3b4 <HAL_TIM_ConfigClockSource+0x3a8>
 800c3a8:	4a85      	ldr	r2, [pc, #532]	; (800c5c0 <HAL_TIM_ConfigClockSource+0x5b4>)
 800c3aa:	4b86      	ldr	r3, [pc, #536]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c3ac:	0011      	movs	r1, r2
 800c3ae:	0018      	movs	r0, r3
 800c3b0:	f7f9 ff71 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800c3b4:	683b      	ldr	r3, [r7, #0]
 800c3b6:	685a      	ldr	r2, [r3, #4]
 800c3b8:	2380      	movs	r3, #128	; 0x80
 800c3ba:	021b      	lsls	r3, r3, #8
 800c3bc:	429a      	cmp	r2, r3
 800c3be:	d015      	beq.n	800c3ec <HAL_TIM_ConfigClockSource+0x3e0>
 800c3c0:	683b      	ldr	r3, [r7, #0]
 800c3c2:	685b      	ldr	r3, [r3, #4]
 800c3c4:	2b00      	cmp	r3, #0
 800c3c6:	d011      	beq.n	800c3ec <HAL_TIM_ConfigClockSource+0x3e0>
 800c3c8:	683b      	ldr	r3, [r7, #0]
 800c3ca:	685b      	ldr	r3, [r3, #4]
 800c3cc:	2b00      	cmp	r3, #0
 800c3ce:	d00d      	beq.n	800c3ec <HAL_TIM_ConfigClockSource+0x3e0>
 800c3d0:	683b      	ldr	r3, [r7, #0]
 800c3d2:	685b      	ldr	r3, [r3, #4]
 800c3d4:	2b02      	cmp	r3, #2
 800c3d6:	d009      	beq.n	800c3ec <HAL_TIM_ConfigClockSource+0x3e0>
 800c3d8:	683b      	ldr	r3, [r7, #0]
 800c3da:	685b      	ldr	r3, [r3, #4]
 800c3dc:	2b0a      	cmp	r3, #10
 800c3de:	d005      	beq.n	800c3ec <HAL_TIM_ConfigClockSource+0x3e0>
 800c3e0:	4a79      	ldr	r2, [pc, #484]	; (800c5c8 <HAL_TIM_ConfigClockSource+0x5bc>)
 800c3e2:	4b78      	ldr	r3, [pc, #480]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c3e4:	0011      	movs	r1, r2
 800c3e6:	0018      	movs	r0, r3
 800c3e8:	f7f9 ff55 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800c3ec:	683b      	ldr	r3, [r7, #0]
 800c3ee:	68db      	ldr	r3, [r3, #12]
 800c3f0:	2b0f      	cmp	r3, #15
 800c3f2:	d905      	bls.n	800c400 <HAL_TIM_ConfigClockSource+0x3f4>
 800c3f4:	4a75      	ldr	r2, [pc, #468]	; (800c5cc <HAL_TIM_ConfigClockSource+0x5c0>)
 800c3f6:	4b73      	ldr	r3, [pc, #460]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c3f8:	0011      	movs	r1, r2
 800c3fa:	0018      	movs	r0, r3
 800c3fc:	f7f9 ff4b 	bl	8006296 <assert_failed>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800c400:	687b      	ldr	r3, [r7, #4]
 800c402:	6818      	ldr	r0, [r3, #0]
 800c404:	683b      	ldr	r3, [r7, #0]
 800c406:	6859      	ldr	r1, [r3, #4]
 800c408:	683b      	ldr	r3, [r7, #0]
 800c40a:	68db      	ldr	r3, [r3, #12]
 800c40c:	001a      	movs	r2, r3
 800c40e:	f000 fa71 	bl	800c8f4 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800c412:	687b      	ldr	r3, [r7, #4]
 800c414:	681b      	ldr	r3, [r3, #0]
 800c416:	2150      	movs	r1, #80	; 0x50
 800c418:	0018      	movs	r0, r3
 800c41a:	f000 facb 	bl	800c9b4 <TIM_ITRx_SetConfig>
      break;
 800c41e:	e0be      	b.n	800c59e <HAL_TIM_ConfigClockSource+0x592>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800c420:	687b      	ldr	r3, [r7, #4]
 800c422:	681a      	ldr	r2, [r3, #0]
 800c424:	2380      	movs	r3, #128	; 0x80
 800c426:	05db      	lsls	r3, r3, #23
 800c428:	429a      	cmp	r2, r3
 800c42a:	d00f      	beq.n	800c44c <HAL_TIM_ConfigClockSource+0x440>
 800c42c:	687b      	ldr	r3, [r7, #4]
 800c42e:	681b      	ldr	r3, [r3, #0]
 800c430:	4a61      	ldr	r2, [pc, #388]	; (800c5b8 <HAL_TIM_ConfigClockSource+0x5ac>)
 800c432:	4293      	cmp	r3, r2
 800c434:	d00a      	beq.n	800c44c <HAL_TIM_ConfigClockSource+0x440>
 800c436:	687b      	ldr	r3, [r7, #4]
 800c438:	681b      	ldr	r3, [r3, #0]
 800c43a:	4a60      	ldr	r2, [pc, #384]	; (800c5bc <HAL_TIM_ConfigClockSource+0x5b0>)
 800c43c:	4293      	cmp	r3, r2
 800c43e:	d005      	beq.n	800c44c <HAL_TIM_ConfigClockSource+0x440>
 800c440:	4a63      	ldr	r2, [pc, #396]	; (800c5d0 <HAL_TIM_ConfigClockSource+0x5c4>)
 800c442:	4b60      	ldr	r3, [pc, #384]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c444:	0011      	movs	r1, r2
 800c446:	0018      	movs	r0, r3
 800c448:	f7f9 ff25 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800c44c:	683b      	ldr	r3, [r7, #0]
 800c44e:	685a      	ldr	r2, [r3, #4]
 800c450:	2380      	movs	r3, #128	; 0x80
 800c452:	021b      	lsls	r3, r3, #8
 800c454:	429a      	cmp	r2, r3
 800c456:	d015      	beq.n	800c484 <HAL_TIM_ConfigClockSource+0x478>
 800c458:	683b      	ldr	r3, [r7, #0]
 800c45a:	685b      	ldr	r3, [r3, #4]
 800c45c:	2b00      	cmp	r3, #0
 800c45e:	d011      	beq.n	800c484 <HAL_TIM_ConfigClockSource+0x478>
 800c460:	683b      	ldr	r3, [r7, #0]
 800c462:	685b      	ldr	r3, [r3, #4]
 800c464:	2b00      	cmp	r3, #0
 800c466:	d00d      	beq.n	800c484 <HAL_TIM_ConfigClockSource+0x478>
 800c468:	683b      	ldr	r3, [r7, #0]
 800c46a:	685b      	ldr	r3, [r3, #4]
 800c46c:	2b02      	cmp	r3, #2
 800c46e:	d009      	beq.n	800c484 <HAL_TIM_ConfigClockSource+0x478>
 800c470:	683b      	ldr	r3, [r7, #0]
 800c472:	685b      	ldr	r3, [r3, #4]
 800c474:	2b0a      	cmp	r3, #10
 800c476:	d005      	beq.n	800c484 <HAL_TIM_ConfigClockSource+0x478>
 800c478:	4a56      	ldr	r2, [pc, #344]	; (800c5d4 <HAL_TIM_ConfigClockSource+0x5c8>)
 800c47a:	4b52      	ldr	r3, [pc, #328]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c47c:	0011      	movs	r1, r2
 800c47e:	0018      	movs	r0, r3
 800c480:	f7f9 ff09 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800c484:	683b      	ldr	r3, [r7, #0]
 800c486:	68db      	ldr	r3, [r3, #12]
 800c488:	2b0f      	cmp	r3, #15
 800c48a:	d905      	bls.n	800c498 <HAL_TIM_ConfigClockSource+0x48c>
 800c48c:	4a52      	ldr	r2, [pc, #328]	; (800c5d8 <HAL_TIM_ConfigClockSource+0x5cc>)
 800c48e:	4b4d      	ldr	r3, [pc, #308]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c490:	0011      	movs	r1, r2
 800c492:	0018      	movs	r0, r3
 800c494:	f7f9 feff 	bl	8006296 <assert_failed>
      TIM_TI2_ConfigInputStage(htim->Instance,
 800c498:	687b      	ldr	r3, [r7, #4]
 800c49a:	6818      	ldr	r0, [r3, #0]
 800c49c:	683b      	ldr	r3, [r7, #0]
 800c49e:	6859      	ldr	r1, [r3, #4]
 800c4a0:	683b      	ldr	r3, [r7, #0]
 800c4a2:	68db      	ldr	r3, [r3, #12]
 800c4a4:	001a      	movs	r2, r3
 800c4a6:	f000 fa53 	bl	800c950 <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800c4aa:	687b      	ldr	r3, [r7, #4]
 800c4ac:	681b      	ldr	r3, [r3, #0]
 800c4ae:	2160      	movs	r1, #96	; 0x60
 800c4b0:	0018      	movs	r0, r3
 800c4b2:	f000 fa7f 	bl	800c9b4 <TIM_ITRx_SetConfig>
      break;
 800c4b6:	e072      	b.n	800c59e <HAL_TIM_ConfigClockSource+0x592>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800c4b8:	687b      	ldr	r3, [r7, #4]
 800c4ba:	681a      	ldr	r2, [r3, #0]
 800c4bc:	2380      	movs	r3, #128	; 0x80
 800c4be:	05db      	lsls	r3, r3, #23
 800c4c0:	429a      	cmp	r2, r3
 800c4c2:	d00f      	beq.n	800c4e4 <HAL_TIM_ConfigClockSource+0x4d8>
 800c4c4:	687b      	ldr	r3, [r7, #4]
 800c4c6:	681b      	ldr	r3, [r3, #0]
 800c4c8:	4a3b      	ldr	r2, [pc, #236]	; (800c5b8 <HAL_TIM_ConfigClockSource+0x5ac>)
 800c4ca:	4293      	cmp	r3, r2
 800c4cc:	d00a      	beq.n	800c4e4 <HAL_TIM_ConfigClockSource+0x4d8>
 800c4ce:	687b      	ldr	r3, [r7, #4]
 800c4d0:	681b      	ldr	r3, [r3, #0]
 800c4d2:	4a3a      	ldr	r2, [pc, #232]	; (800c5bc <HAL_TIM_ConfigClockSource+0x5b0>)
 800c4d4:	4293      	cmp	r3, r2
 800c4d6:	d005      	beq.n	800c4e4 <HAL_TIM_ConfigClockSource+0x4d8>
 800c4d8:	4a40      	ldr	r2, [pc, #256]	; (800c5dc <HAL_TIM_ConfigClockSource+0x5d0>)
 800c4da:	4b3a      	ldr	r3, [pc, #232]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c4dc:	0011      	movs	r1, r2
 800c4de:	0018      	movs	r0, r3
 800c4e0:	f7f9 fed9 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800c4e4:	683b      	ldr	r3, [r7, #0]
 800c4e6:	685a      	ldr	r2, [r3, #4]
 800c4e8:	2380      	movs	r3, #128	; 0x80
 800c4ea:	021b      	lsls	r3, r3, #8
 800c4ec:	429a      	cmp	r2, r3
 800c4ee:	d015      	beq.n	800c51c <HAL_TIM_ConfigClockSource+0x510>
 800c4f0:	683b      	ldr	r3, [r7, #0]
 800c4f2:	685b      	ldr	r3, [r3, #4]
 800c4f4:	2b00      	cmp	r3, #0
 800c4f6:	d011      	beq.n	800c51c <HAL_TIM_ConfigClockSource+0x510>
 800c4f8:	683b      	ldr	r3, [r7, #0]
 800c4fa:	685b      	ldr	r3, [r3, #4]
 800c4fc:	2b00      	cmp	r3, #0
 800c4fe:	d00d      	beq.n	800c51c <HAL_TIM_ConfigClockSource+0x510>
 800c500:	683b      	ldr	r3, [r7, #0]
 800c502:	685b      	ldr	r3, [r3, #4]
 800c504:	2b02      	cmp	r3, #2
 800c506:	d009      	beq.n	800c51c <HAL_TIM_ConfigClockSource+0x510>
 800c508:	683b      	ldr	r3, [r7, #0]
 800c50a:	685b      	ldr	r3, [r3, #4]
 800c50c:	2b0a      	cmp	r3, #10
 800c50e:	d005      	beq.n	800c51c <HAL_TIM_ConfigClockSource+0x510>
 800c510:	4a33      	ldr	r2, [pc, #204]	; (800c5e0 <HAL_TIM_ConfigClockSource+0x5d4>)
 800c512:	4b2c      	ldr	r3, [pc, #176]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c514:	0011      	movs	r1, r2
 800c516:	0018      	movs	r0, r3
 800c518:	f7f9 febd 	bl	8006296 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800c51c:	683b      	ldr	r3, [r7, #0]
 800c51e:	68db      	ldr	r3, [r3, #12]
 800c520:	2b0f      	cmp	r3, #15
 800c522:	d905      	bls.n	800c530 <HAL_TIM_ConfigClockSource+0x524>
 800c524:	4a2f      	ldr	r2, [pc, #188]	; (800c5e4 <HAL_TIM_ConfigClockSource+0x5d8>)
 800c526:	4b27      	ldr	r3, [pc, #156]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c528:	0011      	movs	r1, r2
 800c52a:	0018      	movs	r0, r3
 800c52c:	f7f9 feb3 	bl	8006296 <assert_failed>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800c530:	687b      	ldr	r3, [r7, #4]
 800c532:	6818      	ldr	r0, [r3, #0]
 800c534:	683b      	ldr	r3, [r7, #0]
 800c536:	6859      	ldr	r1, [r3, #4]
 800c538:	683b      	ldr	r3, [r7, #0]
 800c53a:	68db      	ldr	r3, [r3, #12]
 800c53c:	001a      	movs	r2, r3
 800c53e:	f000 f9d9 	bl	800c8f4 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800c542:	687b      	ldr	r3, [r7, #4]
 800c544:	681b      	ldr	r3, [r3, #0]
 800c546:	2140      	movs	r1, #64	; 0x40
 800c548:	0018      	movs	r0, r3
 800c54a:	f000 fa33 	bl	800c9b4 <TIM_ITRx_SetConfig>
      break;
 800c54e:	e026      	b.n	800c59e <HAL_TIM_ConfigClockSource+0x592>
        assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
 800c550:	687b      	ldr	r3, [r7, #4]
 800c552:	681a      	ldr	r2, [r3, #0]
 800c554:	2380      	movs	r3, #128	; 0x80
 800c556:	05db      	lsls	r3, r3, #23
 800c558:	429a      	cmp	r2, r3
 800c55a:	d014      	beq.n	800c586 <HAL_TIM_ConfigClockSource+0x57a>
 800c55c:	687b      	ldr	r3, [r7, #4]
 800c55e:	681b      	ldr	r3, [r3, #0]
 800c560:	4a15      	ldr	r2, [pc, #84]	; (800c5b8 <HAL_TIM_ConfigClockSource+0x5ac>)
 800c562:	4293      	cmp	r3, r2
 800c564:	d00f      	beq.n	800c586 <HAL_TIM_ConfigClockSource+0x57a>
 800c566:	687b      	ldr	r3, [r7, #4]
 800c568:	681b      	ldr	r3, [r3, #0]
 800c56a:	4a14      	ldr	r2, [pc, #80]	; (800c5bc <HAL_TIM_ConfigClockSource+0x5b0>)
 800c56c:	4293      	cmp	r3, r2
 800c56e:	d00a      	beq.n	800c586 <HAL_TIM_ConfigClockSource+0x57a>
 800c570:	687b      	ldr	r3, [r7, #4]
 800c572:	681b      	ldr	r3, [r3, #0]
 800c574:	4a1c      	ldr	r2, [pc, #112]	; (800c5e8 <HAL_TIM_ConfigClockSource+0x5dc>)
 800c576:	4293      	cmp	r3, r2
 800c578:	d005      	beq.n	800c586 <HAL_TIM_ConfigClockSource+0x57a>
 800c57a:	4a1c      	ldr	r2, [pc, #112]	; (800c5ec <HAL_TIM_ConfigClockSource+0x5e0>)
 800c57c:	4b11      	ldr	r3, [pc, #68]	; (800c5c4 <HAL_TIM_ConfigClockSource+0x5b8>)
 800c57e:	0011      	movs	r1, r2
 800c580:	0018      	movs	r0, r3
 800c582:	f7f9 fe88 	bl	8006296 <assert_failed>
        TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800c586:	687b      	ldr	r3, [r7, #4]
 800c588:	681a      	ldr	r2, [r3, #0]
 800c58a:	683b      	ldr	r3, [r7, #0]
 800c58c:	681b      	ldr	r3, [r3, #0]
 800c58e:	0019      	movs	r1, r3
 800c590:	0010      	movs	r0, r2
 800c592:	f000 fa0f 	bl	800c9b4 <TIM_ITRx_SetConfig>
        break;
 800c596:	e002      	b.n	800c59e <HAL_TIM_ConfigClockSource+0x592>
      break;
 800c598:	46c0      	nop			; (mov r8, r8)
 800c59a:	e000      	b.n	800c59e <HAL_TIM_ConfigClockSource+0x592>
      break;
 800c59c:	46c0      	nop			; (mov r8, r8)
  }
  htim->State = HAL_TIM_STATE_READY;
 800c59e:	687b      	ldr	r3, [r7, #4]
 800c5a0:	2239      	movs	r2, #57	; 0x39
 800c5a2:	2101      	movs	r1, #1
 800c5a4:	5499      	strb	r1, [r3, r2]

  __HAL_UNLOCK(htim);
 800c5a6:	687b      	ldr	r3, [r7, #4]
 800c5a8:	2238      	movs	r2, #56	; 0x38
 800c5aa:	2100      	movs	r1, #0
 800c5ac:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800c5ae:	2300      	movs	r3, #0
}
 800c5b0:	0018      	movs	r0, r3
 800c5b2:	46bd      	mov	sp, r7
 800c5b4:	b004      	add	sp, #16
 800c5b6:	bd80      	pop	{r7, pc}
 800c5b8:	40000400 	.word	0x40000400
 800c5bc:	40010800 	.word	0x40010800
 800c5c0:	0000135b 	.word	0x0000135b
 800c5c4:	0800df0c 	.word	0x0800df0c
 800c5c8:	0000135e 	.word	0x0000135e
 800c5cc:	0000135f 	.word	0x0000135f
 800c5d0:	0000136b 	.word	0x0000136b
 800c5d4:	0000136e 	.word	0x0000136e
 800c5d8:	0000136f 	.word	0x0000136f
 800c5dc:	0000137b 	.word	0x0000137b
 800c5e0:	0000137e 	.word	0x0000137e
 800c5e4:	0000137f 	.word	0x0000137f
 800c5e8:	40011400 	.word	0x40011400
 800c5ec:	0000138e 	.word	0x0000138e

0800c5f0 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800c5f0:	b580      	push	{r7, lr}
 800c5f2:	b082      	sub	sp, #8
 800c5f4:	af00      	add	r7, sp, #0
 800c5f6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 800c5f8:	46c0      	nop			; (mov r8, r8)
 800c5fa:	46bd      	mov	sp, r7
 800c5fc:	b002      	add	sp, #8
 800c5fe:	bd80      	pop	{r7, pc}

0800c600 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 800c600:	b580      	push	{r7, lr}
 800c602:	b082      	sub	sp, #8
 800c604:	af00      	add	r7, sp, #0
 800c606:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800c608:	46c0      	nop			; (mov r8, r8)
 800c60a:	46bd      	mov	sp, r7
 800c60c:	b002      	add	sp, #8
 800c60e:	bd80      	pop	{r7, pc}

0800c610 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800c610:	b580      	push	{r7, lr}
 800c612:	b082      	sub	sp, #8
 800c614:	af00      	add	r7, sp, #0
 800c616:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800c618:	46c0      	nop			; (mov r8, r8)
 800c61a:	46bd      	mov	sp, r7
 800c61c:	b002      	add	sp, #8
 800c61e:	bd80      	pop	{r7, pc}

0800c620 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800c620:	b580      	push	{r7, lr}
 800c622:	b082      	sub	sp, #8
 800c624:	af00      	add	r7, sp, #0
 800c626:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800c628:	46c0      	nop			; (mov r8, r8)
 800c62a:	46bd      	mov	sp, r7
 800c62c:	b002      	add	sp, #8
 800c62e:	bd80      	pop	{r7, pc}

0800c630 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
static void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 800c630:	b580      	push	{r7, lr}
 800c632:	b084      	sub	sp, #16
 800c634:	af00      	add	r7, sp, #0
 800c636:	6078      	str	r0, [r7, #4]
 800c638:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800c63a:	687b      	ldr	r3, [r7, #4]
 800c63c:	681b      	ldr	r3, [r3, #0]
 800c63e:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c640:	687a      	ldr	r2, [r7, #4]
 800c642:	2380      	movs	r3, #128	; 0x80
 800c644:	05db      	lsls	r3, r3, #23
 800c646:	429a      	cmp	r2, r3
 800c648:	d00b      	beq.n	800c662 <TIM_Base_SetConfig+0x32>
 800c64a:	687b      	ldr	r3, [r7, #4]
 800c64c:	4a23      	ldr	r2, [pc, #140]	; (800c6dc <TIM_Base_SetConfig+0xac>)
 800c64e:	4293      	cmp	r3, r2
 800c650:	d007      	beq.n	800c662 <TIM_Base_SetConfig+0x32>
 800c652:	687b      	ldr	r3, [r7, #4]
 800c654:	4a22      	ldr	r2, [pc, #136]	; (800c6e0 <TIM_Base_SetConfig+0xb0>)
 800c656:	4293      	cmp	r3, r2
 800c658:	d003      	beq.n	800c662 <TIM_Base_SetConfig+0x32>
 800c65a:	687b      	ldr	r3, [r7, #4]
 800c65c:	4a21      	ldr	r2, [pc, #132]	; (800c6e4 <TIM_Base_SetConfig+0xb4>)
 800c65e:	4293      	cmp	r3, r2
 800c660:	d108      	bne.n	800c674 <TIM_Base_SetConfig+0x44>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800c662:	68fb      	ldr	r3, [r7, #12]
 800c664:	2270      	movs	r2, #112	; 0x70
 800c666:	4393      	bics	r3, r2
 800c668:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800c66a:	683b      	ldr	r3, [r7, #0]
 800c66c:	685b      	ldr	r3, [r3, #4]
 800c66e:	68fa      	ldr	r2, [r7, #12]
 800c670:	4313      	orrs	r3, r2
 800c672:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c674:	687a      	ldr	r2, [r7, #4]
 800c676:	2380      	movs	r3, #128	; 0x80
 800c678:	05db      	lsls	r3, r3, #23
 800c67a:	429a      	cmp	r2, r3
 800c67c:	d00b      	beq.n	800c696 <TIM_Base_SetConfig+0x66>
 800c67e:	687b      	ldr	r3, [r7, #4]
 800c680:	4a16      	ldr	r2, [pc, #88]	; (800c6dc <TIM_Base_SetConfig+0xac>)
 800c682:	4293      	cmp	r3, r2
 800c684:	d007      	beq.n	800c696 <TIM_Base_SetConfig+0x66>
 800c686:	687b      	ldr	r3, [r7, #4]
 800c688:	4a15      	ldr	r2, [pc, #84]	; (800c6e0 <TIM_Base_SetConfig+0xb0>)
 800c68a:	4293      	cmp	r3, r2
 800c68c:	d003      	beq.n	800c696 <TIM_Base_SetConfig+0x66>
 800c68e:	687b      	ldr	r3, [r7, #4]
 800c690:	4a14      	ldr	r2, [pc, #80]	; (800c6e4 <TIM_Base_SetConfig+0xb4>)
 800c692:	4293      	cmp	r3, r2
 800c694:	d108      	bne.n	800c6a8 <TIM_Base_SetConfig+0x78>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800c696:	68fb      	ldr	r3, [r7, #12]
 800c698:	4a13      	ldr	r2, [pc, #76]	; (800c6e8 <TIM_Base_SetConfig+0xb8>)
 800c69a:	4013      	ands	r3, r2
 800c69c:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800c69e:	683b      	ldr	r3, [r7, #0]
 800c6a0:	68db      	ldr	r3, [r3, #12]
 800c6a2:	68fa      	ldr	r2, [r7, #12]
 800c6a4:	4313      	orrs	r3, r2
 800c6a6:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800c6a8:	68fb      	ldr	r3, [r7, #12]
 800c6aa:	2280      	movs	r2, #128	; 0x80
 800c6ac:	4393      	bics	r3, r2
 800c6ae:	001a      	movs	r2, r3
 800c6b0:	683b      	ldr	r3, [r7, #0]
 800c6b2:	691b      	ldr	r3, [r3, #16]
 800c6b4:	4313      	orrs	r3, r2
 800c6b6:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 800c6b8:	687b      	ldr	r3, [r7, #4]
 800c6ba:	68fa      	ldr	r2, [r7, #12]
 800c6bc:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800c6be:	683b      	ldr	r3, [r7, #0]
 800c6c0:	689a      	ldr	r2, [r3, #8]
 800c6c2:	687b      	ldr	r3, [r7, #4]
 800c6c4:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800c6c6:	683b      	ldr	r3, [r7, #0]
 800c6c8:	681a      	ldr	r2, [r3, #0]
 800c6ca:	687b      	ldr	r3, [r7, #4]
 800c6cc:	629a      	str	r2, [r3, #40]	; 0x28

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800c6ce:	687b      	ldr	r3, [r7, #4]
 800c6d0:	2201      	movs	r2, #1
 800c6d2:	615a      	str	r2, [r3, #20]
}
 800c6d4:	46c0      	nop			; (mov r8, r8)
 800c6d6:	46bd      	mov	sp, r7
 800c6d8:	b004      	add	sp, #16
 800c6da:	bd80      	pop	{r7, pc}
 800c6dc:	40000400 	.word	0x40000400
 800c6e0:	40010800 	.word	0x40010800
 800c6e4:	40011400 	.word	0x40011400
 800c6e8:	fffffcff 	.word	0xfffffcff

0800c6ec <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c6ec:	b580      	push	{r7, lr}
 800c6ee:	b086      	sub	sp, #24
 800c6f0:	af00      	add	r7, sp, #0
 800c6f2:	6078      	str	r0, [r7, #4]
 800c6f4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	6a1b      	ldr	r3, [r3, #32]
 800c6fa:	2201      	movs	r2, #1
 800c6fc:	4393      	bics	r3, r2
 800c6fe:	001a      	movs	r2, r3
 800c700:	687b      	ldr	r3, [r7, #4]
 800c702:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c704:	687b      	ldr	r3, [r7, #4]
 800c706:	6a1b      	ldr	r3, [r3, #32]
 800c708:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c70a:	687b      	ldr	r3, [r7, #4]
 800c70c:	685b      	ldr	r3, [r3, #4]
 800c70e:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800c710:	687b      	ldr	r3, [r7, #4]
 800c712:	699b      	ldr	r3, [r3, #24]
 800c714:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 800c716:	68fb      	ldr	r3, [r7, #12]
 800c718:	2270      	movs	r2, #112	; 0x70
 800c71a:	4393      	bics	r3, r2
 800c71c:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800c71e:	68fb      	ldr	r3, [r7, #12]
 800c720:	2203      	movs	r2, #3
 800c722:	4393      	bics	r3, r2
 800c724:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800c726:	683b      	ldr	r3, [r7, #0]
 800c728:	681b      	ldr	r3, [r3, #0]
 800c72a:	68fa      	ldr	r2, [r7, #12]
 800c72c:	4313      	orrs	r3, r2
 800c72e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 800c730:	697b      	ldr	r3, [r7, #20]
 800c732:	2202      	movs	r2, #2
 800c734:	4393      	bics	r3, r2
 800c736:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 800c738:	683b      	ldr	r3, [r7, #0]
 800c73a:	689b      	ldr	r3, [r3, #8]
 800c73c:	697a      	ldr	r2, [r7, #20]
 800c73e:	4313      	orrs	r3, r2
 800c740:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c742:	687b      	ldr	r3, [r7, #4]
 800c744:	693a      	ldr	r2, [r7, #16]
 800c746:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800c748:	687b      	ldr	r3, [r7, #4]
 800c74a:	68fa      	ldr	r2, [r7, #12]
 800c74c:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800c74e:	683b      	ldr	r3, [r7, #0]
 800c750:	685a      	ldr	r2, [r3, #4]
 800c752:	687b      	ldr	r3, [r7, #4]
 800c754:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c756:	687b      	ldr	r3, [r7, #4]
 800c758:	697a      	ldr	r2, [r7, #20]
 800c75a:	621a      	str	r2, [r3, #32]
}
 800c75c:	46c0      	nop			; (mov r8, r8)
 800c75e:	46bd      	mov	sp, r7
 800c760:	b006      	add	sp, #24
 800c762:	bd80      	pop	{r7, pc}

0800c764 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c764:	b580      	push	{r7, lr}
 800c766:	b086      	sub	sp, #24
 800c768:	af00      	add	r7, sp, #0
 800c76a:	6078      	str	r0, [r7, #4]
 800c76c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800c76e:	687b      	ldr	r3, [r7, #4]
 800c770:	6a1b      	ldr	r3, [r3, #32]
 800c772:	2210      	movs	r2, #16
 800c774:	4393      	bics	r3, r2
 800c776:	001a      	movs	r2, r3
 800c778:	687b      	ldr	r3, [r7, #4]
 800c77a:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c77c:	687b      	ldr	r3, [r7, #4]
 800c77e:	6a1b      	ldr	r3, [r3, #32]
 800c780:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c782:	687b      	ldr	r3, [r7, #4]
 800c784:	685b      	ldr	r3, [r3, #4]
 800c786:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800c788:	687b      	ldr	r3, [r7, #4]
 800c78a:	699b      	ldr	r3, [r3, #24]
 800c78c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 800c78e:	68fb      	ldr	r3, [r7, #12]
 800c790:	4a13      	ldr	r2, [pc, #76]	; (800c7e0 <TIM_OC2_SetConfig+0x7c>)
 800c792:	4013      	ands	r3, r2
 800c794:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800c796:	68fb      	ldr	r3, [r7, #12]
 800c798:	4a12      	ldr	r2, [pc, #72]	; (800c7e4 <TIM_OC2_SetConfig+0x80>)
 800c79a:	4013      	ands	r3, r2
 800c79c:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800c79e:	683b      	ldr	r3, [r7, #0]
 800c7a0:	681b      	ldr	r3, [r3, #0]
 800c7a2:	021b      	lsls	r3, r3, #8
 800c7a4:	68fa      	ldr	r2, [r7, #12]
 800c7a6:	4313      	orrs	r3, r2
 800c7a8:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 800c7aa:	697b      	ldr	r3, [r7, #20]
 800c7ac:	2220      	movs	r2, #32
 800c7ae:	4393      	bics	r3, r2
 800c7b0:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800c7b2:	683b      	ldr	r3, [r7, #0]
 800c7b4:	689b      	ldr	r3, [r3, #8]
 800c7b6:	011b      	lsls	r3, r3, #4
 800c7b8:	697a      	ldr	r2, [r7, #20]
 800c7ba:	4313      	orrs	r3, r2
 800c7bc:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c7be:	687b      	ldr	r3, [r7, #4]
 800c7c0:	693a      	ldr	r2, [r7, #16]
 800c7c2:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800c7c4:	687b      	ldr	r3, [r7, #4]
 800c7c6:	68fa      	ldr	r2, [r7, #12]
 800c7c8:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800c7ca:	683b      	ldr	r3, [r7, #0]
 800c7cc:	685a      	ldr	r2, [r3, #4]
 800c7ce:	687b      	ldr	r3, [r7, #4]
 800c7d0:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c7d2:	687b      	ldr	r3, [r7, #4]
 800c7d4:	697a      	ldr	r2, [r7, #20]
 800c7d6:	621a      	str	r2, [r3, #32]
}
 800c7d8:	46c0      	nop			; (mov r8, r8)
 800c7da:	46bd      	mov	sp, r7
 800c7dc:	b006      	add	sp, #24
 800c7de:	bd80      	pop	{r7, pc}
 800c7e0:	ffff8fff 	.word	0xffff8fff
 800c7e4:	fffffcff 	.word	0xfffffcff

0800c7e8 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c7e8:	b580      	push	{r7, lr}
 800c7ea:	b086      	sub	sp, #24
 800c7ec:	af00      	add	r7, sp, #0
 800c7ee:	6078      	str	r0, [r7, #4]
 800c7f0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800c7f2:	687b      	ldr	r3, [r7, #4]
 800c7f4:	6a1b      	ldr	r3, [r3, #32]
 800c7f6:	4a1a      	ldr	r2, [pc, #104]	; (800c860 <TIM_OC3_SetConfig+0x78>)
 800c7f8:	401a      	ands	r2, r3
 800c7fa:	687b      	ldr	r3, [r7, #4]
 800c7fc:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c7fe:	687b      	ldr	r3, [r7, #4]
 800c800:	6a1b      	ldr	r3, [r3, #32]
 800c802:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c804:	687b      	ldr	r3, [r7, #4]
 800c806:	685b      	ldr	r3, [r3, #4]
 800c808:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800c80a:	687b      	ldr	r3, [r7, #4]
 800c80c:	69db      	ldr	r3, [r3, #28]
 800c80e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 800c810:	68fb      	ldr	r3, [r7, #12]
 800c812:	2270      	movs	r2, #112	; 0x70
 800c814:	4393      	bics	r3, r2
 800c816:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 800c818:	68fb      	ldr	r3, [r7, #12]
 800c81a:	2203      	movs	r2, #3
 800c81c:	4393      	bics	r3, r2
 800c81e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800c820:	683b      	ldr	r3, [r7, #0]
 800c822:	681b      	ldr	r3, [r3, #0]
 800c824:	68fa      	ldr	r2, [r7, #12]
 800c826:	4313      	orrs	r3, r2
 800c828:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 800c82a:	697b      	ldr	r3, [r7, #20]
 800c82c:	4a0d      	ldr	r2, [pc, #52]	; (800c864 <TIM_OC3_SetConfig+0x7c>)
 800c82e:	4013      	ands	r3, r2
 800c830:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800c832:	683b      	ldr	r3, [r7, #0]
 800c834:	689b      	ldr	r3, [r3, #8]
 800c836:	021b      	lsls	r3, r3, #8
 800c838:	697a      	ldr	r2, [r7, #20]
 800c83a:	4313      	orrs	r3, r2
 800c83c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c83e:	687b      	ldr	r3, [r7, #4]
 800c840:	693a      	ldr	r2, [r7, #16]
 800c842:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800c844:	687b      	ldr	r3, [r7, #4]
 800c846:	68fa      	ldr	r2, [r7, #12]
 800c848:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800c84a:	683b      	ldr	r3, [r7, #0]
 800c84c:	685a      	ldr	r2, [r3, #4]
 800c84e:	687b      	ldr	r3, [r7, #4]
 800c850:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c852:	687b      	ldr	r3, [r7, #4]
 800c854:	697a      	ldr	r2, [r7, #20]
 800c856:	621a      	str	r2, [r3, #32]
}
 800c858:	46c0      	nop			; (mov r8, r8)
 800c85a:	46bd      	mov	sp, r7
 800c85c:	b006      	add	sp, #24
 800c85e:	bd80      	pop	{r7, pc}
 800c860:	fffffeff 	.word	0xfffffeff
 800c864:	fffffdff 	.word	0xfffffdff

0800c868 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800c868:	b580      	push	{r7, lr}
 800c86a:	b086      	sub	sp, #24
 800c86c:	af00      	add	r7, sp, #0
 800c86e:	6078      	str	r0, [r7, #4]
 800c870:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800c872:	687b      	ldr	r3, [r7, #4]
 800c874:	6a1b      	ldr	r3, [r3, #32]
 800c876:	4a1b      	ldr	r2, [pc, #108]	; (800c8e4 <TIM_OC4_SetConfig+0x7c>)
 800c878:	401a      	ands	r2, r3
 800c87a:	687b      	ldr	r3, [r7, #4]
 800c87c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c87e:	687b      	ldr	r3, [r7, #4]
 800c880:	6a1b      	ldr	r3, [r3, #32]
 800c882:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c884:	687b      	ldr	r3, [r7, #4]
 800c886:	685b      	ldr	r3, [r3, #4]
 800c888:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800c88a:	687b      	ldr	r3, [r7, #4]
 800c88c:	69db      	ldr	r3, [r3, #28]
 800c88e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 800c890:	68fb      	ldr	r3, [r7, #12]
 800c892:	4a15      	ldr	r2, [pc, #84]	; (800c8e8 <TIM_OC4_SetConfig+0x80>)
 800c894:	4013      	ands	r3, r2
 800c896:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800c898:	68fb      	ldr	r3, [r7, #12]
 800c89a:	4a14      	ldr	r2, [pc, #80]	; (800c8ec <TIM_OC4_SetConfig+0x84>)
 800c89c:	4013      	ands	r3, r2
 800c89e:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800c8a0:	683b      	ldr	r3, [r7, #0]
 800c8a2:	681b      	ldr	r3, [r3, #0]
 800c8a4:	021b      	lsls	r3, r3, #8
 800c8a6:	68fa      	ldr	r2, [r7, #12]
 800c8a8:	4313      	orrs	r3, r2
 800c8aa:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 800c8ac:	697b      	ldr	r3, [r7, #20]
 800c8ae:	4a10      	ldr	r2, [pc, #64]	; (800c8f0 <TIM_OC4_SetConfig+0x88>)
 800c8b0:	4013      	ands	r3, r2
 800c8b2:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800c8b4:	683b      	ldr	r3, [r7, #0]
 800c8b6:	689b      	ldr	r3, [r3, #8]
 800c8b8:	031b      	lsls	r3, r3, #12
 800c8ba:	697a      	ldr	r2, [r7, #20]
 800c8bc:	4313      	orrs	r3, r2
 800c8be:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c8c0:	687b      	ldr	r3, [r7, #4]
 800c8c2:	693a      	ldr	r2, [r7, #16]
 800c8c4:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800c8c6:	687b      	ldr	r3, [r7, #4]
 800c8c8:	68fa      	ldr	r2, [r7, #12]
 800c8ca:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800c8cc:	683b      	ldr	r3, [r7, #0]
 800c8ce:	685a      	ldr	r2, [r3, #4]
 800c8d0:	687b      	ldr	r3, [r7, #4]
 800c8d2:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c8d4:	687b      	ldr	r3, [r7, #4]
 800c8d6:	697a      	ldr	r2, [r7, #20]
 800c8d8:	621a      	str	r2, [r3, #32]
}
 800c8da:	46c0      	nop			; (mov r8, r8)
 800c8dc:	46bd      	mov	sp, r7
 800c8de:	b006      	add	sp, #24
 800c8e0:	bd80      	pop	{r7, pc}
 800c8e2:	46c0      	nop			; (mov r8, r8)
 800c8e4:	ffffefff 	.word	0xffffefff
 800c8e8:	ffff8fff 	.word	0xffff8fff
 800c8ec:	fffffcff 	.word	0xfffffcff
 800c8f0:	ffffdfff 	.word	0xffffdfff

0800c8f4 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800c8f4:	b580      	push	{r7, lr}
 800c8f6:	b086      	sub	sp, #24
 800c8f8:	af00      	add	r7, sp, #0
 800c8fa:	60f8      	str	r0, [r7, #12]
 800c8fc:	60b9      	str	r1, [r7, #8]
 800c8fe:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 800c900:	68fb      	ldr	r3, [r7, #12]
 800c902:	6a1b      	ldr	r3, [r3, #32]
 800c904:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c906:	68fb      	ldr	r3, [r7, #12]
 800c908:	6a1b      	ldr	r3, [r3, #32]
 800c90a:	2201      	movs	r2, #1
 800c90c:	4393      	bics	r3, r2
 800c90e:	001a      	movs	r2, r3
 800c910:	68fb      	ldr	r3, [r7, #12]
 800c912:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800c914:	68fb      	ldr	r3, [r7, #12]
 800c916:	699b      	ldr	r3, [r3, #24]
 800c918:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800c91a:	693b      	ldr	r3, [r7, #16]
 800c91c:	22f0      	movs	r2, #240	; 0xf0
 800c91e:	4393      	bics	r3, r2
 800c920:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800c922:	687b      	ldr	r3, [r7, #4]
 800c924:	011b      	lsls	r3, r3, #4
 800c926:	693a      	ldr	r2, [r7, #16]
 800c928:	4313      	orrs	r3, r2
 800c92a:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800c92c:	697b      	ldr	r3, [r7, #20]
 800c92e:	220a      	movs	r2, #10
 800c930:	4393      	bics	r3, r2
 800c932:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 800c934:	697a      	ldr	r2, [r7, #20]
 800c936:	68bb      	ldr	r3, [r7, #8]
 800c938:	4313      	orrs	r3, r2
 800c93a:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800c93c:	68fb      	ldr	r3, [r7, #12]
 800c93e:	693a      	ldr	r2, [r7, #16]
 800c940:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800c942:	68fb      	ldr	r3, [r7, #12]
 800c944:	697a      	ldr	r2, [r7, #20]
 800c946:	621a      	str	r2, [r3, #32]
}
 800c948:	46c0      	nop			; (mov r8, r8)
 800c94a:	46bd      	mov	sp, r7
 800c94c:	b006      	add	sp, #24
 800c94e:	bd80      	pop	{r7, pc}

0800c950 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800c950:	b580      	push	{r7, lr}
 800c952:	b086      	sub	sp, #24
 800c954:	af00      	add	r7, sp, #0
 800c956:	60f8      	str	r0, [r7, #12]
 800c958:	60b9      	str	r1, [r7, #8]
 800c95a:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800c95c:	68fb      	ldr	r3, [r7, #12]
 800c95e:	6a1b      	ldr	r3, [r3, #32]
 800c960:	2210      	movs	r2, #16
 800c962:	4393      	bics	r3, r2
 800c964:	001a      	movs	r2, r3
 800c966:	68fb      	ldr	r3, [r7, #12]
 800c968:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800c96a:	68fb      	ldr	r3, [r7, #12]
 800c96c:	699b      	ldr	r3, [r3, #24]
 800c96e:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 800c970:	68fb      	ldr	r3, [r7, #12]
 800c972:	6a1b      	ldr	r3, [r3, #32]
 800c974:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800c976:	697b      	ldr	r3, [r7, #20]
 800c978:	4a0d      	ldr	r2, [pc, #52]	; (800c9b0 <TIM_TI2_ConfigInputStage+0x60>)
 800c97a:	4013      	ands	r3, r2
 800c97c:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800c97e:	687b      	ldr	r3, [r7, #4]
 800c980:	031b      	lsls	r3, r3, #12
 800c982:	697a      	ldr	r2, [r7, #20]
 800c984:	4313      	orrs	r3, r2
 800c986:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800c988:	693b      	ldr	r3, [r7, #16]
 800c98a:	22a0      	movs	r2, #160	; 0xa0
 800c98c:	4393      	bics	r3, r2
 800c98e:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 800c990:	68bb      	ldr	r3, [r7, #8]
 800c992:	011b      	lsls	r3, r3, #4
 800c994:	693a      	ldr	r2, [r7, #16]
 800c996:	4313      	orrs	r3, r2
 800c998:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800c99a:	68fb      	ldr	r3, [r7, #12]
 800c99c:	697a      	ldr	r2, [r7, #20]
 800c99e:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800c9a0:	68fb      	ldr	r3, [r7, #12]
 800c9a2:	693a      	ldr	r2, [r7, #16]
 800c9a4:	621a      	str	r2, [r3, #32]
}
 800c9a6:	46c0      	nop			; (mov r8, r8)
 800c9a8:	46bd      	mov	sp, r7
 800c9aa:	b006      	add	sp, #24
 800c9ac:	bd80      	pop	{r7, pc}
 800c9ae:	46c0      	nop			; (mov r8, r8)
 800c9b0:	ffff0fff 	.word	0xffff0fff

0800c9b4 <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 800c9b4:	b580      	push	{r7, lr}
 800c9b6:	b084      	sub	sp, #16
 800c9b8:	af00      	add	r7, sp, #0
 800c9ba:	6078      	str	r0, [r7, #4]
 800c9bc:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800c9be:	687b      	ldr	r3, [r7, #4]
 800c9c0:	689b      	ldr	r3, [r3, #8]
 800c9c2:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 800c9c4:	68fb      	ldr	r3, [r7, #12]
 800c9c6:	2270      	movs	r2, #112	; 0x70
 800c9c8:	4393      	bics	r3, r2
 800c9ca:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800c9cc:	683a      	ldr	r2, [r7, #0]
 800c9ce:	68fb      	ldr	r3, [r7, #12]
 800c9d0:	4313      	orrs	r3, r2
 800c9d2:	2207      	movs	r2, #7
 800c9d4:	4313      	orrs	r3, r2
 800c9d6:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800c9d8:	687b      	ldr	r3, [r7, #4]
 800c9da:	68fa      	ldr	r2, [r7, #12]
 800c9dc:	609a      	str	r2, [r3, #8]
}
 800c9de:	46c0      	nop			; (mov r8, r8)
 800c9e0:	46bd      	mov	sp, r7
 800c9e2:	b004      	add	sp, #16
 800c9e4:	bd80      	pop	{r7, pc}
	...

0800c9e8 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
static void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                              uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800c9e8:	b580      	push	{r7, lr}
 800c9ea:	b086      	sub	sp, #24
 800c9ec:	af00      	add	r7, sp, #0
 800c9ee:	60f8      	str	r0, [r7, #12]
 800c9f0:	60b9      	str	r1, [r7, #8]
 800c9f2:	607a      	str	r2, [r7, #4]
 800c9f4:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800c9f6:	68fb      	ldr	r3, [r7, #12]
 800c9f8:	689b      	ldr	r3, [r3, #8]
 800c9fa:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c9fc:	697b      	ldr	r3, [r7, #20]
 800c9fe:	4a09      	ldr	r2, [pc, #36]	; (800ca24 <TIM_ETR_SetConfig+0x3c>)
 800ca00:	4013      	ands	r3, r2
 800ca02:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800ca04:	683b      	ldr	r3, [r7, #0]
 800ca06:	021a      	lsls	r2, r3, #8
 800ca08:	687b      	ldr	r3, [r7, #4]
 800ca0a:	431a      	orrs	r2, r3
 800ca0c:	68bb      	ldr	r3, [r7, #8]
 800ca0e:	4313      	orrs	r3, r2
 800ca10:	697a      	ldr	r2, [r7, #20]
 800ca12:	4313      	orrs	r3, r2
 800ca14:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800ca16:	68fb      	ldr	r3, [r7, #12]
 800ca18:	697a      	ldr	r2, [r7, #20]
 800ca1a:	609a      	str	r2, [r3, #8]
}
 800ca1c:	46c0      	nop			; (mov r8, r8)
 800ca1e:	46bd      	mov	sp, r7
 800ca20:	b006      	add	sp, #24
 800ca22:	bd80      	pop	{r7, pc}
 800ca24:	ffff00ff 	.word	0xffff00ff

0800ca28 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 800ca28:	b580      	push	{r7, lr}
 800ca2a:	b084      	sub	sp, #16
 800ca2c:	af00      	add	r7, sp, #0
 800ca2e:	6078      	str	r0, [r7, #4]
 800ca30:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800ca32:	687b      	ldr	r3, [r7, #4]
 800ca34:	681a      	ldr	r2, [r3, #0]
 800ca36:	2380      	movs	r3, #128	; 0x80
 800ca38:	05db      	lsls	r3, r3, #23
 800ca3a:	429a      	cmp	r2, r3
 800ca3c:	d01d      	beq.n	800ca7a <HAL_TIMEx_MasterConfigSynchronization+0x52>
 800ca3e:	687b      	ldr	r3, [r7, #4]
 800ca40:	681b      	ldr	r3, [r3, #0]
 800ca42:	4a50      	ldr	r2, [pc, #320]	; (800cb84 <HAL_TIMEx_MasterConfigSynchronization+0x15c>)
 800ca44:	4293      	cmp	r3, r2
 800ca46:	d018      	beq.n	800ca7a <HAL_TIMEx_MasterConfigSynchronization+0x52>
 800ca48:	687b      	ldr	r3, [r7, #4]
 800ca4a:	681b      	ldr	r3, [r3, #0]
 800ca4c:	4a4e      	ldr	r2, [pc, #312]	; (800cb88 <HAL_TIMEx_MasterConfigSynchronization+0x160>)
 800ca4e:	4293      	cmp	r3, r2
 800ca50:	d013      	beq.n	800ca7a <HAL_TIMEx_MasterConfigSynchronization+0x52>
 800ca52:	687b      	ldr	r3, [r7, #4]
 800ca54:	681b      	ldr	r3, [r3, #0]
 800ca56:	4a4d      	ldr	r2, [pc, #308]	; (800cb8c <HAL_TIMEx_MasterConfigSynchronization+0x164>)
 800ca58:	4293      	cmp	r3, r2
 800ca5a:	d00e      	beq.n	800ca7a <HAL_TIMEx_MasterConfigSynchronization+0x52>
 800ca5c:	687b      	ldr	r3, [r7, #4]
 800ca5e:	681b      	ldr	r3, [r3, #0]
 800ca60:	4a4b      	ldr	r2, [pc, #300]	; (800cb90 <HAL_TIMEx_MasterConfigSynchronization+0x168>)
 800ca62:	4293      	cmp	r3, r2
 800ca64:	d009      	beq.n	800ca7a <HAL_TIMEx_MasterConfigSynchronization+0x52>
 800ca66:	687b      	ldr	r3, [r7, #4]
 800ca68:	681b      	ldr	r3, [r3, #0]
 800ca6a:	4a4a      	ldr	r2, [pc, #296]	; (800cb94 <HAL_TIMEx_MasterConfigSynchronization+0x16c>)
 800ca6c:	4293      	cmp	r3, r2
 800ca6e:	d004      	beq.n	800ca7a <HAL_TIMEx_MasterConfigSynchronization+0x52>
 800ca70:	4b49      	ldr	r3, [pc, #292]	; (800cb98 <HAL_TIMEx_MasterConfigSynchronization+0x170>)
 800ca72:	2159      	movs	r1, #89	; 0x59
 800ca74:	0018      	movs	r0, r3
 800ca76:	f7f9 fc0e 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 800ca7a:	683b      	ldr	r3, [r7, #0]
 800ca7c:	681b      	ldr	r3, [r3, #0]
 800ca7e:	2b00      	cmp	r3, #0
 800ca80:	d020      	beq.n	800cac4 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
 800ca82:	683b      	ldr	r3, [r7, #0]
 800ca84:	681b      	ldr	r3, [r3, #0]
 800ca86:	2b10      	cmp	r3, #16
 800ca88:	d01c      	beq.n	800cac4 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
 800ca8a:	683b      	ldr	r3, [r7, #0]
 800ca8c:	681b      	ldr	r3, [r3, #0]
 800ca8e:	2b20      	cmp	r3, #32
 800ca90:	d018      	beq.n	800cac4 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
 800ca92:	683b      	ldr	r3, [r7, #0]
 800ca94:	681b      	ldr	r3, [r3, #0]
 800ca96:	2b30      	cmp	r3, #48	; 0x30
 800ca98:	d014      	beq.n	800cac4 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
 800ca9a:	683b      	ldr	r3, [r7, #0]
 800ca9c:	681b      	ldr	r3, [r3, #0]
 800ca9e:	2b40      	cmp	r3, #64	; 0x40
 800caa0:	d010      	beq.n	800cac4 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
 800caa2:	683b      	ldr	r3, [r7, #0]
 800caa4:	681b      	ldr	r3, [r3, #0]
 800caa6:	2b50      	cmp	r3, #80	; 0x50
 800caa8:	d00c      	beq.n	800cac4 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
 800caaa:	683b      	ldr	r3, [r7, #0]
 800caac:	681b      	ldr	r3, [r3, #0]
 800caae:	2b60      	cmp	r3, #96	; 0x60
 800cab0:	d008      	beq.n	800cac4 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
 800cab2:	683b      	ldr	r3, [r7, #0]
 800cab4:	681b      	ldr	r3, [r3, #0]
 800cab6:	2b70      	cmp	r3, #112	; 0x70
 800cab8:	d004      	beq.n	800cac4 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
 800caba:	4b37      	ldr	r3, [pc, #220]	; (800cb98 <HAL_TIMEx_MasterConfigSynchronization+0x170>)
 800cabc:	215a      	movs	r1, #90	; 0x5a
 800cabe:	0018      	movs	r0, r3
 800cac0:	f7f9 fbe9 	bl	8006296 <assert_failed>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 800cac4:	683b      	ldr	r3, [r7, #0]
 800cac6:	685b      	ldr	r3, [r3, #4]
 800cac8:	2b80      	cmp	r3, #128	; 0x80
 800caca:	d008      	beq.n	800cade <HAL_TIMEx_MasterConfigSynchronization+0xb6>
 800cacc:	683b      	ldr	r3, [r7, #0]
 800cace:	685b      	ldr	r3, [r3, #4]
 800cad0:	2b00      	cmp	r3, #0
 800cad2:	d004      	beq.n	800cade <HAL_TIMEx_MasterConfigSynchronization+0xb6>
 800cad4:	4b30      	ldr	r3, [pc, #192]	; (800cb98 <HAL_TIMEx_MasterConfigSynchronization+0x170>)
 800cad6:	215b      	movs	r1, #91	; 0x5b
 800cad8:	0018      	movs	r0, r3
 800cada:	f7f9 fbdc 	bl	8006296 <assert_failed>

  /* Check input state */
  __HAL_LOCK(htim);
 800cade:	687b      	ldr	r3, [r7, #4]
 800cae0:	2238      	movs	r2, #56	; 0x38
 800cae2:	5c9b      	ldrb	r3, [r3, r2]
 800cae4:	2b01      	cmp	r3, #1
 800cae6:	d101      	bne.n	800caec <HAL_TIMEx_MasterConfigSynchronization+0xc4>
 800cae8:	2302      	movs	r3, #2
 800caea:	e047      	b.n	800cb7c <HAL_TIMEx_MasterConfigSynchronization+0x154>
 800caec:	687b      	ldr	r3, [r7, #4]
 800caee:	2238      	movs	r2, #56	; 0x38
 800caf0:	2101      	movs	r1, #1
 800caf2:	5499      	strb	r1, [r3, r2]

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800caf4:	687b      	ldr	r3, [r7, #4]
 800caf6:	2239      	movs	r2, #57	; 0x39
 800caf8:	2102      	movs	r1, #2
 800cafa:	5499      	strb	r1, [r3, r2]

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800cafc:	687b      	ldr	r3, [r7, #4]
 800cafe:	681b      	ldr	r3, [r3, #0]
 800cb00:	685b      	ldr	r3, [r3, #4]
 800cb02:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800cb04:	687b      	ldr	r3, [r7, #4]
 800cb06:	681b      	ldr	r3, [r3, #0]
 800cb08:	689b      	ldr	r3, [r3, #8]
 800cb0a:	60bb      	str	r3, [r7, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800cb0c:	68fb      	ldr	r3, [r7, #12]
 800cb0e:	2270      	movs	r2, #112	; 0x70
 800cb10:	4393      	bics	r3, r2
 800cb12:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800cb14:	683b      	ldr	r3, [r7, #0]
 800cb16:	681b      	ldr	r3, [r3, #0]
 800cb18:	68fa      	ldr	r2, [r7, #12]
 800cb1a:	4313      	orrs	r3, r2
 800cb1c:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800cb1e:	687b      	ldr	r3, [r7, #4]
 800cb20:	681b      	ldr	r3, [r3, #0]
 800cb22:	68fa      	ldr	r2, [r7, #12]
 800cb24:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800cb26:	687b      	ldr	r3, [r7, #4]
 800cb28:	681a      	ldr	r2, [r3, #0]
 800cb2a:	2380      	movs	r3, #128	; 0x80
 800cb2c:	05db      	lsls	r3, r3, #23
 800cb2e:	429a      	cmp	r2, r3
 800cb30:	d00e      	beq.n	800cb50 <HAL_TIMEx_MasterConfigSynchronization+0x128>
 800cb32:	687b      	ldr	r3, [r7, #4]
 800cb34:	681b      	ldr	r3, [r3, #0]
 800cb36:	4a13      	ldr	r2, [pc, #76]	; (800cb84 <HAL_TIMEx_MasterConfigSynchronization+0x15c>)
 800cb38:	4293      	cmp	r3, r2
 800cb3a:	d009      	beq.n	800cb50 <HAL_TIMEx_MasterConfigSynchronization+0x128>
 800cb3c:	687b      	ldr	r3, [r7, #4]
 800cb3e:	681b      	ldr	r3, [r3, #0]
 800cb40:	4a13      	ldr	r2, [pc, #76]	; (800cb90 <HAL_TIMEx_MasterConfigSynchronization+0x168>)
 800cb42:	4293      	cmp	r3, r2
 800cb44:	d004      	beq.n	800cb50 <HAL_TIMEx_MasterConfigSynchronization+0x128>
 800cb46:	687b      	ldr	r3, [r7, #4]
 800cb48:	681b      	ldr	r3, [r3, #0]
 800cb4a:	4a12      	ldr	r2, [pc, #72]	; (800cb94 <HAL_TIMEx_MasterConfigSynchronization+0x16c>)
 800cb4c:	4293      	cmp	r3, r2
 800cb4e:	d10c      	bne.n	800cb6a <HAL_TIMEx_MasterConfigSynchronization+0x142>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800cb50:	68bb      	ldr	r3, [r7, #8]
 800cb52:	2280      	movs	r2, #128	; 0x80
 800cb54:	4393      	bics	r3, r2
 800cb56:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800cb58:	683b      	ldr	r3, [r7, #0]
 800cb5a:	685b      	ldr	r3, [r3, #4]
 800cb5c:	68ba      	ldr	r2, [r7, #8]
 800cb5e:	4313      	orrs	r3, r2
 800cb60:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800cb62:	687b      	ldr	r3, [r7, #4]
 800cb64:	681b      	ldr	r3, [r3, #0]
 800cb66:	68ba      	ldr	r2, [r7, #8]
 800cb68:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800cb6a:	687b      	ldr	r3, [r7, #4]
 800cb6c:	2239      	movs	r2, #57	; 0x39
 800cb6e:	2101      	movs	r1, #1
 800cb70:	5499      	strb	r1, [r3, r2]

  __HAL_UNLOCK(htim);
 800cb72:	687b      	ldr	r3, [r7, #4]
 800cb74:	2238      	movs	r2, #56	; 0x38
 800cb76:	2100      	movs	r1, #0
 800cb78:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800cb7a:	2300      	movs	r3, #0
}
 800cb7c:	0018      	movs	r0, r3
 800cb7e:	46bd      	mov	sp, r7
 800cb80:	b004      	add	sp, #16
 800cb82:	bd80      	pop	{r7, pc}
 800cb84:	40000400 	.word	0x40000400
 800cb88:	40001000 	.word	0x40001000
 800cb8c:	40001400 	.word	0x40001400
 800cb90:	40010800 	.word	0x40010800
 800cb94:	40011400 	.word	0x40011400
 800cb98:	0800df44 	.word	0x0800df44

0800cb9c <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800cb9c:	b580      	push	{r7, lr}
 800cb9e:	b082      	sub	sp, #8
 800cba0:	af00      	add	r7, sp, #0
 800cba2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800cba4:	687b      	ldr	r3, [r7, #4]
 800cba6:	2b00      	cmp	r3, #0
 800cba8:	d101      	bne.n	800cbae <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800cbaa:	2301      	movs	r3, #1
 800cbac:	e08a      	b.n	800ccc4 <HAL_UART_Init+0x128>
  }

  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
 800cbae:	687b      	ldr	r3, [r7, #4]
 800cbb0:	699b      	ldr	r3, [r3, #24]
 800cbb2:	2b00      	cmp	r3, #0
 800cbb4:	d021      	beq.n	800cbfa <HAL_UART_Init+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
 800cbb6:	687b      	ldr	r3, [r7, #4]
 800cbb8:	681b      	ldr	r3, [r3, #0]
 800cbba:	4a44      	ldr	r2, [pc, #272]	; (800cccc <HAL_UART_Init+0x130>)
 800cbbc:	4293      	cmp	r3, r2
 800cbbe:	d03c      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cbc0:	687b      	ldr	r3, [r7, #4]
 800cbc2:	681b      	ldr	r3, [r3, #0]
 800cbc4:	4a42      	ldr	r2, [pc, #264]	; (800ccd0 <HAL_UART_Init+0x134>)
 800cbc6:	4293      	cmp	r3, r2
 800cbc8:	d037      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cbca:	687b      	ldr	r3, [r7, #4]
 800cbcc:	681b      	ldr	r3, [r3, #0]
 800cbce:	4a41      	ldr	r2, [pc, #260]	; (800ccd4 <HAL_UART_Init+0x138>)
 800cbd0:	4293      	cmp	r3, r2
 800cbd2:	d032      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cbd4:	687b      	ldr	r3, [r7, #4]
 800cbd6:	681b      	ldr	r3, [r3, #0]
 800cbd8:	4a3f      	ldr	r2, [pc, #252]	; (800ccd8 <HAL_UART_Init+0x13c>)
 800cbda:	4293      	cmp	r3, r2
 800cbdc:	d02d      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cbde:	687b      	ldr	r3, [r7, #4]
 800cbe0:	681b      	ldr	r3, [r3, #0]
 800cbe2:	4a3e      	ldr	r2, [pc, #248]	; (800ccdc <HAL_UART_Init+0x140>)
 800cbe4:	4293      	cmp	r3, r2
 800cbe6:	d028      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cbe8:	232e      	movs	r3, #46	; 0x2e
 800cbea:	33ff      	adds	r3, #255	; 0xff
 800cbec:	001a      	movs	r2, r3
 800cbee:	4b3c      	ldr	r3, [pc, #240]	; (800cce0 <HAL_UART_Init+0x144>)
 800cbf0:	0011      	movs	r1, r2
 800cbf2:	0018      	movs	r0, r3
 800cbf4:	f7f9 fb4f 	bl	8006296 <assert_failed>
 800cbf8:	e01f      	b.n	800cc3a <HAL_UART_Init+0x9e>
  }
  else
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
 800cbfa:	687b      	ldr	r3, [r7, #4]
 800cbfc:	681b      	ldr	r3, [r3, #0]
 800cbfe:	4a33      	ldr	r2, [pc, #204]	; (800cccc <HAL_UART_Init+0x130>)
 800cc00:	4293      	cmp	r3, r2
 800cc02:	d01a      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cc04:	687b      	ldr	r3, [r7, #4]
 800cc06:	681b      	ldr	r3, [r3, #0]
 800cc08:	4a31      	ldr	r2, [pc, #196]	; (800ccd0 <HAL_UART_Init+0x134>)
 800cc0a:	4293      	cmp	r3, r2
 800cc0c:	d015      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cc0e:	687b      	ldr	r3, [r7, #4]
 800cc10:	681b      	ldr	r3, [r3, #0]
 800cc12:	4a30      	ldr	r2, [pc, #192]	; (800ccd4 <HAL_UART_Init+0x138>)
 800cc14:	4293      	cmp	r3, r2
 800cc16:	d010      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cc18:	687b      	ldr	r3, [r7, #4]
 800cc1a:	681b      	ldr	r3, [r3, #0]
 800cc1c:	4a2e      	ldr	r2, [pc, #184]	; (800ccd8 <HAL_UART_Init+0x13c>)
 800cc1e:	4293      	cmp	r3, r2
 800cc20:	d00b      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cc22:	687b      	ldr	r3, [r7, #4]
 800cc24:	681b      	ldr	r3, [r3, #0]
 800cc26:	4a2d      	ldr	r2, [pc, #180]	; (800ccdc <HAL_UART_Init+0x140>)
 800cc28:	4293      	cmp	r3, r2
 800cc2a:	d006      	beq.n	800cc3a <HAL_UART_Init+0x9e>
 800cc2c:	2399      	movs	r3, #153	; 0x99
 800cc2e:	005a      	lsls	r2, r3, #1
 800cc30:	4b2b      	ldr	r3, [pc, #172]	; (800cce0 <HAL_UART_Init+0x144>)
 800cc32:	0011      	movs	r1, r2
 800cc34:	0018      	movs	r0, r3
 800cc36:	f7f9 fb2e 	bl	8006296 <assert_failed>
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 800cc3a:	687b      	ldr	r3, [r7, #4]
 800cc3c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800cc3e:	2b00      	cmp	r3, #0
 800cc40:	d107      	bne.n	800cc52 <HAL_UART_Init+0xb6>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800cc42:	687b      	ldr	r3, [r7, #4]
 800cc44:	2274      	movs	r2, #116	; 0x74
 800cc46:	2100      	movs	r1, #0
 800cc48:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800cc4a:	687b      	ldr	r3, [r7, #4]
 800cc4c:	0018      	movs	r0, r3
 800cc4e:	f7fa fb39 	bl	80072c4 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800cc52:	687b      	ldr	r3, [r7, #4]
 800cc54:	2224      	movs	r2, #36	; 0x24
 800cc56:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 800cc58:	687b      	ldr	r3, [r7, #4]
 800cc5a:	681b      	ldr	r3, [r3, #0]
 800cc5c:	681a      	ldr	r2, [r3, #0]
 800cc5e:	687b      	ldr	r3, [r7, #4]
 800cc60:	681b      	ldr	r3, [r3, #0]
 800cc62:	2101      	movs	r1, #1
 800cc64:	438a      	bics	r2, r1
 800cc66:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800cc68:	687b      	ldr	r3, [r7, #4]
 800cc6a:	0018      	movs	r0, r3
 800cc6c:	f000 f8e4 	bl	800ce38 <UART_SetConfig>
 800cc70:	0003      	movs	r3, r0
 800cc72:	2b01      	cmp	r3, #1
 800cc74:	d101      	bne.n	800cc7a <HAL_UART_Init+0xde>
  {
    return HAL_ERROR;
 800cc76:	2301      	movs	r3, #1
 800cc78:	e024      	b.n	800ccc4 <HAL_UART_Init+0x128>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800cc7a:	687b      	ldr	r3, [r7, #4]
 800cc7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800cc7e:	2b00      	cmp	r3, #0
 800cc80:	d003      	beq.n	800cc8a <HAL_UART_Init+0xee>
  {
    UART_AdvFeatureConfig(huart);
 800cc82:	687b      	ldr	r3, [r7, #4]
 800cc84:	0018      	movs	r0, r3
 800cc86:	f000 fc5d 	bl	800d544 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800cc8a:	687b      	ldr	r3, [r7, #4]
 800cc8c:	681b      	ldr	r3, [r3, #0]
 800cc8e:	685a      	ldr	r2, [r3, #4]
 800cc90:	687b      	ldr	r3, [r7, #4]
 800cc92:	681b      	ldr	r3, [r3, #0]
 800cc94:	4913      	ldr	r1, [pc, #76]	; (800cce4 <HAL_UART_Init+0x148>)
 800cc96:	400a      	ands	r2, r1
 800cc98:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800cc9a:	687b      	ldr	r3, [r7, #4]
 800cc9c:	681b      	ldr	r3, [r3, #0]
 800cc9e:	689a      	ldr	r2, [r3, #8]
 800cca0:	687b      	ldr	r3, [r7, #4]
 800cca2:	681b      	ldr	r3, [r3, #0]
 800cca4:	212a      	movs	r1, #42	; 0x2a
 800cca6:	438a      	bics	r2, r1
 800cca8:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 800ccaa:	687b      	ldr	r3, [r7, #4]
 800ccac:	681b      	ldr	r3, [r3, #0]
 800ccae:	681a      	ldr	r2, [r3, #0]
 800ccb0:	687b      	ldr	r3, [r7, #4]
 800ccb2:	681b      	ldr	r3, [r3, #0]
 800ccb4:	2101      	movs	r1, #1
 800ccb6:	430a      	orrs	r2, r1
 800ccb8:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800ccba:	687b      	ldr	r3, [r7, #4]
 800ccbc:	0018      	movs	r0, r3
 800ccbe:	f000 fdc7 	bl	800d850 <UART_CheckIdleState>
 800ccc2:	0003      	movs	r3, r0
}
 800ccc4:	0018      	movs	r0, r3
 800ccc6:	46bd      	mov	sp, r7
 800ccc8:	b002      	add	sp, #8
 800ccca:	bd80      	pop	{r7, pc}
 800cccc:	40013800 	.word	0x40013800
 800ccd0:	40004400 	.word	0x40004400
 800ccd4:	40004c00 	.word	0x40004c00
 800ccd8:	40005000 	.word	0x40005000
 800ccdc:	40004800 	.word	0x40004800
 800cce0:	0800df80 	.word	0x0800df80
 800cce4:	ffffb7ff 	.word	0xffffb7ff

0800cce8 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800cce8:	b580      	push	{r7, lr}
 800ccea:	b08a      	sub	sp, #40	; 0x28
 800ccec:	af02      	add	r7, sp, #8
 800ccee:	60f8      	str	r0, [r7, #12]
 800ccf0:	60b9      	str	r1, [r7, #8]
 800ccf2:	603b      	str	r3, [r7, #0]
 800ccf4:	1dbb      	adds	r3, r7, #6
 800ccf6:	801a      	strh	r2, [r3, #0]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800ccf8:	68fb      	ldr	r3, [r7, #12]
 800ccfa:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ccfc:	2b20      	cmp	r3, #32
 800ccfe:	d000      	beq.n	800cd02 <HAL_UART_Transmit+0x1a>
 800cd00:	e095      	b.n	800ce2e <HAL_UART_Transmit+0x146>
  {
    if ((pData == NULL) || (Size == 0U))
 800cd02:	68bb      	ldr	r3, [r7, #8]
 800cd04:	2b00      	cmp	r3, #0
 800cd06:	d003      	beq.n	800cd10 <HAL_UART_Transmit+0x28>
 800cd08:	1dbb      	adds	r3, r7, #6
 800cd0a:	881b      	ldrh	r3, [r3, #0]
 800cd0c:	2b00      	cmp	r3, #0
 800cd0e:	d101      	bne.n	800cd14 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 800cd10:	2301      	movs	r3, #1
 800cd12:	e08d      	b.n	800ce30 <HAL_UART_Transmit+0x148>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cd14:	68fb      	ldr	r3, [r7, #12]
 800cd16:	689a      	ldr	r2, [r3, #8]
 800cd18:	2380      	movs	r3, #128	; 0x80
 800cd1a:	015b      	lsls	r3, r3, #5
 800cd1c:	429a      	cmp	r2, r3
 800cd1e:	d109      	bne.n	800cd34 <HAL_UART_Transmit+0x4c>
 800cd20:	68fb      	ldr	r3, [r7, #12]
 800cd22:	691b      	ldr	r3, [r3, #16]
 800cd24:	2b00      	cmp	r3, #0
 800cd26:	d105      	bne.n	800cd34 <HAL_UART_Transmit+0x4c>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 800cd28:	68bb      	ldr	r3, [r7, #8]
 800cd2a:	2201      	movs	r2, #1
 800cd2c:	4013      	ands	r3, r2
 800cd2e:	d001      	beq.n	800cd34 <HAL_UART_Transmit+0x4c>
      {
        return  HAL_ERROR;
 800cd30:	2301      	movs	r3, #1
 800cd32:	e07d      	b.n	800ce30 <HAL_UART_Transmit+0x148>
      }
    }

    __HAL_LOCK(huart);
 800cd34:	68fb      	ldr	r3, [r7, #12]
 800cd36:	2274      	movs	r2, #116	; 0x74
 800cd38:	5c9b      	ldrb	r3, [r3, r2]
 800cd3a:	2b01      	cmp	r3, #1
 800cd3c:	d101      	bne.n	800cd42 <HAL_UART_Transmit+0x5a>
 800cd3e:	2302      	movs	r3, #2
 800cd40:	e076      	b.n	800ce30 <HAL_UART_Transmit+0x148>
 800cd42:	68fb      	ldr	r3, [r7, #12]
 800cd44:	2274      	movs	r2, #116	; 0x74
 800cd46:	2101      	movs	r1, #1
 800cd48:	5499      	strb	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800cd4a:	68fb      	ldr	r3, [r7, #12]
 800cd4c:	2280      	movs	r2, #128	; 0x80
 800cd4e:	2100      	movs	r1, #0
 800cd50:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800cd52:	68fb      	ldr	r3, [r7, #12]
 800cd54:	2221      	movs	r2, #33	; 0x21
 800cd56:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800cd58:	f7fa fbc4 	bl	80074e4 <HAL_GetTick>
 800cd5c:	0003      	movs	r3, r0
 800cd5e:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
 800cd60:	68fb      	ldr	r3, [r7, #12]
 800cd62:	1dba      	adds	r2, r7, #6
 800cd64:	2150      	movs	r1, #80	; 0x50
 800cd66:	8812      	ldrh	r2, [r2, #0]
 800cd68:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 800cd6a:	68fb      	ldr	r3, [r7, #12]
 800cd6c:	1dba      	adds	r2, r7, #6
 800cd6e:	2152      	movs	r1, #82	; 0x52
 800cd70:	8812      	ldrh	r2, [r2, #0]
 800cd72:	525a      	strh	r2, [r3, r1]

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cd74:	68fb      	ldr	r3, [r7, #12]
 800cd76:	689a      	ldr	r2, [r3, #8]
 800cd78:	2380      	movs	r3, #128	; 0x80
 800cd7a:	015b      	lsls	r3, r3, #5
 800cd7c:	429a      	cmp	r2, r3
 800cd7e:	d108      	bne.n	800cd92 <HAL_UART_Transmit+0xaa>
 800cd80:	68fb      	ldr	r3, [r7, #12]
 800cd82:	691b      	ldr	r3, [r3, #16]
 800cd84:	2b00      	cmp	r3, #0
 800cd86:	d104      	bne.n	800cd92 <HAL_UART_Transmit+0xaa>
    {
      pdata8bits  = NULL;
 800cd88:	2300      	movs	r3, #0
 800cd8a:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 800cd8c:	68bb      	ldr	r3, [r7, #8]
 800cd8e:	61bb      	str	r3, [r7, #24]
 800cd90:	e003      	b.n	800cd9a <HAL_UART_Transmit+0xb2>
    }
    else
    {
      pdata8bits  = pData;
 800cd92:	68bb      	ldr	r3, [r7, #8]
 800cd94:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 800cd96:	2300      	movs	r3, #0
 800cd98:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 800cd9a:	68fb      	ldr	r3, [r7, #12]
 800cd9c:	2274      	movs	r2, #116	; 0x74
 800cd9e:	2100      	movs	r1, #0
 800cda0:	5499      	strb	r1, [r3, r2]

    while (huart->TxXferCount > 0U)
 800cda2:	e02c      	b.n	800cdfe <HAL_UART_Transmit+0x116>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800cda4:	697a      	ldr	r2, [r7, #20]
 800cda6:	68f8      	ldr	r0, [r7, #12]
 800cda8:	683b      	ldr	r3, [r7, #0]
 800cdaa:	9300      	str	r3, [sp, #0]
 800cdac:	0013      	movs	r3, r2
 800cdae:	2200      	movs	r2, #0
 800cdb0:	2180      	movs	r1, #128	; 0x80
 800cdb2:	f000 fd95 	bl	800d8e0 <UART_WaitOnFlagUntilTimeout>
 800cdb6:	1e03      	subs	r3, r0, #0
 800cdb8:	d001      	beq.n	800cdbe <HAL_UART_Transmit+0xd6>
      {
        return HAL_TIMEOUT;
 800cdba:	2303      	movs	r3, #3
 800cdbc:	e038      	b.n	800ce30 <HAL_UART_Transmit+0x148>
      }
      if (pdata8bits == NULL)
 800cdbe:	69fb      	ldr	r3, [r7, #28]
 800cdc0:	2b00      	cmp	r3, #0
 800cdc2:	d10b      	bne.n	800cddc <HAL_UART_Transmit+0xf4>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800cdc4:	69bb      	ldr	r3, [r7, #24]
 800cdc6:	881b      	ldrh	r3, [r3, #0]
 800cdc8:	001a      	movs	r2, r3
 800cdca:	68fb      	ldr	r3, [r7, #12]
 800cdcc:	681b      	ldr	r3, [r3, #0]
 800cdce:	05d2      	lsls	r2, r2, #23
 800cdd0:	0dd2      	lsrs	r2, r2, #23
 800cdd2:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 800cdd4:	69bb      	ldr	r3, [r7, #24]
 800cdd6:	3302      	adds	r3, #2
 800cdd8:	61bb      	str	r3, [r7, #24]
 800cdda:	e007      	b.n	800cdec <HAL_UART_Transmit+0x104>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800cddc:	69fb      	ldr	r3, [r7, #28]
 800cdde:	781a      	ldrb	r2, [r3, #0]
 800cde0:	68fb      	ldr	r3, [r7, #12]
 800cde2:	681b      	ldr	r3, [r3, #0]
 800cde4:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 800cde6:	69fb      	ldr	r3, [r7, #28]
 800cde8:	3301      	adds	r3, #1
 800cdea:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 800cdec:	68fb      	ldr	r3, [r7, #12]
 800cdee:	2252      	movs	r2, #82	; 0x52
 800cdf0:	5a9b      	ldrh	r3, [r3, r2]
 800cdf2:	b29b      	uxth	r3, r3
 800cdf4:	3b01      	subs	r3, #1
 800cdf6:	b299      	uxth	r1, r3
 800cdf8:	68fb      	ldr	r3, [r7, #12]
 800cdfa:	2252      	movs	r2, #82	; 0x52
 800cdfc:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
 800cdfe:	68fb      	ldr	r3, [r7, #12]
 800ce00:	2252      	movs	r2, #82	; 0x52
 800ce02:	5a9b      	ldrh	r3, [r3, r2]
 800ce04:	b29b      	uxth	r3, r3
 800ce06:	2b00      	cmp	r3, #0
 800ce08:	d1cc      	bne.n	800cda4 <HAL_UART_Transmit+0xbc>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800ce0a:	697a      	ldr	r2, [r7, #20]
 800ce0c:	68f8      	ldr	r0, [r7, #12]
 800ce0e:	683b      	ldr	r3, [r7, #0]
 800ce10:	9300      	str	r3, [sp, #0]
 800ce12:	0013      	movs	r3, r2
 800ce14:	2200      	movs	r2, #0
 800ce16:	2140      	movs	r1, #64	; 0x40
 800ce18:	f000 fd62 	bl	800d8e0 <UART_WaitOnFlagUntilTimeout>
 800ce1c:	1e03      	subs	r3, r0, #0
 800ce1e:	d001      	beq.n	800ce24 <HAL_UART_Transmit+0x13c>
    {
      return HAL_TIMEOUT;
 800ce20:	2303      	movs	r3, #3
 800ce22:	e005      	b.n	800ce30 <HAL_UART_Transmit+0x148>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 800ce24:	68fb      	ldr	r3, [r7, #12]
 800ce26:	2220      	movs	r2, #32
 800ce28:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 800ce2a:	2300      	movs	r3, #0
 800ce2c:	e000      	b.n	800ce30 <HAL_UART_Transmit+0x148>
  }
  else
  {
    return HAL_BUSY;
 800ce2e:	2302      	movs	r3, #2
  }
}
 800ce30:	0018      	movs	r0, r3
 800ce32:	46bd      	mov	sp, r7
 800ce34:	b008      	add	sp, #32
 800ce36:	bd80      	pop	{r7, pc}

0800ce38 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800ce38:	b5b0      	push	{r4, r5, r7, lr}
 800ce3a:	b08e      	sub	sp, #56	; 0x38
 800ce3c:	af00      	add	r7, sp, #0
 800ce3e:	61f8      	str	r0, [r7, #28]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 800ce40:	231a      	movs	r3, #26
 800ce42:	2218      	movs	r2, #24
 800ce44:	4694      	mov	ip, r2
 800ce46:	44bc      	add	ip, r7
 800ce48:	4463      	add	r3, ip
 800ce4a:	2200      	movs	r2, #0
 800ce4c:	701a      	strb	r2, [r3, #0]
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 800ce4e:	69fb      	ldr	r3, [r7, #28]
 800ce50:	685b      	ldr	r3, [r3, #4]
 800ce52:	4abf      	ldr	r2, [pc, #764]	; (800d150 <UART_SetConfig+0x318>)
 800ce54:	4293      	cmp	r3, r2
 800ce56:	d905      	bls.n	800ce64 <UART_SetConfig+0x2c>
 800ce58:	4abe      	ldr	r2, [pc, #760]	; (800d154 <UART_SetConfig+0x31c>)
 800ce5a:	4bbf      	ldr	r3, [pc, #764]	; (800d158 <UART_SetConfig+0x320>)
 800ce5c:	0011      	movs	r1, r2
 800ce5e:	0018      	movs	r0, r3
 800ce60:	f7f9 fa19 	bl	8006296 <assert_failed>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
 800ce64:	69fb      	ldr	r3, [r7, #28]
 800ce66:	689a      	ldr	r2, [r3, #8]
 800ce68:	2380      	movs	r3, #128	; 0x80
 800ce6a:	055b      	lsls	r3, r3, #21
 800ce6c:	429a      	cmp	r2, r3
 800ce6e:	d00f      	beq.n	800ce90 <UART_SetConfig+0x58>
 800ce70:	69fb      	ldr	r3, [r7, #28]
 800ce72:	689b      	ldr	r3, [r3, #8]
 800ce74:	2b00      	cmp	r3, #0
 800ce76:	d00b      	beq.n	800ce90 <UART_SetConfig+0x58>
 800ce78:	69fb      	ldr	r3, [r7, #28]
 800ce7a:	689a      	ldr	r2, [r3, #8]
 800ce7c:	2380      	movs	r3, #128	; 0x80
 800ce7e:	015b      	lsls	r3, r3, #5
 800ce80:	429a      	cmp	r2, r3
 800ce82:	d005      	beq.n	800ce90 <UART_SetConfig+0x58>
 800ce84:	4ab5      	ldr	r2, [pc, #724]	; (800d15c <UART_SetConfig+0x324>)
 800ce86:	4bb4      	ldr	r3, [pc, #720]	; (800d158 <UART_SetConfig+0x320>)
 800ce88:	0011      	movs	r1, r2
 800ce8a:	0018      	movs	r0, r3
 800ce8c:	f7f9 fa03 	bl	8006296 <assert_failed>
  if (UART_INSTANCE_LOWPOWER(huart))
 800ce90:	69fb      	ldr	r3, [r7, #28]
 800ce92:	681b      	ldr	r3, [r3, #0]
 800ce94:	4ab2      	ldr	r2, [pc, #712]	; (800d160 <UART_SetConfig+0x328>)
 800ce96:	4293      	cmp	r3, r2
 800ce98:	d110      	bne.n	800cebc <UART_SetConfig+0x84>
  {
    assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
 800ce9a:	69fb      	ldr	r3, [r7, #28]
 800ce9c:	68db      	ldr	r3, [r3, #12]
 800ce9e:	2b00      	cmp	r3, #0
 800cea0:	d038      	beq.n	800cf14 <UART_SetConfig+0xdc>
 800cea2:	69fb      	ldr	r3, [r7, #28]
 800cea4:	68da      	ldr	r2, [r3, #12]
 800cea6:	2380      	movs	r3, #128	; 0x80
 800cea8:	019b      	lsls	r3, r3, #6
 800ceaa:	429a      	cmp	r2, r3
 800ceac:	d032      	beq.n	800cf14 <UART_SetConfig+0xdc>
 800ceae:	4aad      	ldr	r2, [pc, #692]	; (800d164 <UART_SetConfig+0x32c>)
 800ceb0:	4ba9      	ldr	r3, [pc, #676]	; (800d158 <UART_SetConfig+0x320>)
 800ceb2:	0011      	movs	r1, r2
 800ceb4:	0018      	movs	r0, r3
 800ceb6:	f7f9 f9ee 	bl	8006296 <assert_failed>
 800ceba:	e02b      	b.n	800cf14 <UART_SetConfig+0xdc>
  }
  else
  {
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
 800cebc:	69fb      	ldr	r3, [r7, #28]
 800cebe:	68da      	ldr	r2, [r3, #12]
 800cec0:	2380      	movs	r3, #128	; 0x80
 800cec2:	015b      	lsls	r3, r3, #5
 800cec4:	429a      	cmp	r2, r3
 800cec6:	d015      	beq.n	800cef4 <UART_SetConfig+0xbc>
 800cec8:	69fb      	ldr	r3, [r7, #28]
 800ceca:	68db      	ldr	r3, [r3, #12]
 800cecc:	2b00      	cmp	r3, #0
 800cece:	d011      	beq.n	800cef4 <UART_SetConfig+0xbc>
 800ced0:	69fb      	ldr	r3, [r7, #28]
 800ced2:	68da      	ldr	r2, [r3, #12]
 800ced4:	23c0      	movs	r3, #192	; 0xc0
 800ced6:	019b      	lsls	r3, r3, #6
 800ced8:	429a      	cmp	r2, r3
 800ceda:	d00b      	beq.n	800cef4 <UART_SetConfig+0xbc>
 800cedc:	69fb      	ldr	r3, [r7, #28]
 800cede:	68da      	ldr	r2, [r3, #12]
 800cee0:	2380      	movs	r3, #128	; 0x80
 800cee2:	019b      	lsls	r3, r3, #6
 800cee4:	429a      	cmp	r2, r3
 800cee6:	d005      	beq.n	800cef4 <UART_SetConfig+0xbc>
 800cee8:	4a9f      	ldr	r2, [pc, #636]	; (800d168 <UART_SetConfig+0x330>)
 800ceea:	4b9b      	ldr	r3, [pc, #620]	; (800d158 <UART_SetConfig+0x320>)
 800ceec:	0011      	movs	r1, r2
 800ceee:	0018      	movs	r0, r3
 800cef0:	f7f9 f9d1 	bl	8006296 <assert_failed>
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
 800cef4:	69fb      	ldr	r3, [r7, #28]
 800cef6:	6a1b      	ldr	r3, [r3, #32]
 800cef8:	2b00      	cmp	r3, #0
 800cefa:	d00b      	beq.n	800cf14 <UART_SetConfig+0xdc>
 800cefc:	69fb      	ldr	r3, [r7, #28]
 800cefe:	6a1a      	ldr	r2, [r3, #32]
 800cf00:	2380      	movs	r3, #128	; 0x80
 800cf02:	011b      	lsls	r3, r3, #4
 800cf04:	429a      	cmp	r2, r3
 800cf06:	d005      	beq.n	800cf14 <UART_SetConfig+0xdc>
 800cf08:	4a98      	ldr	r2, [pc, #608]	; (800d16c <UART_SetConfig+0x334>)
 800cf0a:	4b93      	ldr	r3, [pc, #588]	; (800d158 <UART_SetConfig+0x320>)
 800cf0c:	0011      	movs	r1, r2
 800cf0e:	0018      	movs	r0, r3
 800cf10:	f7f9 f9c1 	bl	8006296 <assert_failed>
  }

  assert_param(IS_UART_PARITY(huart->Init.Parity));
 800cf14:	69fb      	ldr	r3, [r7, #28]
 800cf16:	691b      	ldr	r3, [r3, #16]
 800cf18:	2b00      	cmp	r3, #0
 800cf1a:	d011      	beq.n	800cf40 <UART_SetConfig+0x108>
 800cf1c:	69fb      	ldr	r3, [r7, #28]
 800cf1e:	691a      	ldr	r2, [r3, #16]
 800cf20:	2380      	movs	r3, #128	; 0x80
 800cf22:	00db      	lsls	r3, r3, #3
 800cf24:	429a      	cmp	r2, r3
 800cf26:	d00b      	beq.n	800cf40 <UART_SetConfig+0x108>
 800cf28:	69fb      	ldr	r3, [r7, #28]
 800cf2a:	691a      	ldr	r2, [r3, #16]
 800cf2c:	23c0      	movs	r3, #192	; 0xc0
 800cf2e:	00db      	lsls	r3, r3, #3
 800cf30:	429a      	cmp	r2, r3
 800cf32:	d005      	beq.n	800cf40 <UART_SetConfig+0x108>
 800cf34:	4a8e      	ldr	r2, [pc, #568]	; (800d170 <UART_SetConfig+0x338>)
 800cf36:	4b88      	ldr	r3, [pc, #544]	; (800d158 <UART_SetConfig+0x320>)
 800cf38:	0011      	movs	r1, r2
 800cf3a:	0018      	movs	r0, r3
 800cf3c:	f7f9 f9ab 	bl	8006296 <assert_failed>
  assert_param(IS_UART_MODE(huart->Init.Mode));
 800cf40:	69fb      	ldr	r3, [r7, #28]
 800cf42:	695b      	ldr	r3, [r3, #20]
 800cf44:	220c      	movs	r2, #12
 800cf46:	4393      	bics	r3, r2
 800cf48:	d103      	bne.n	800cf52 <UART_SetConfig+0x11a>
 800cf4a:	69fb      	ldr	r3, [r7, #28]
 800cf4c:	695b      	ldr	r3, [r3, #20]
 800cf4e:	2b00      	cmp	r3, #0
 800cf50:	d105      	bne.n	800cf5e <UART_SetConfig+0x126>
 800cf52:	4a88      	ldr	r2, [pc, #544]	; (800d174 <UART_SetConfig+0x33c>)
 800cf54:	4b80      	ldr	r3, [pc, #512]	; (800d158 <UART_SetConfig+0x320>)
 800cf56:	0011      	movs	r1, r2
 800cf58:	0018      	movs	r0, r3
 800cf5a:	f7f9 f99c 	bl	8006296 <assert_failed>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
 800cf5e:	69fb      	ldr	r3, [r7, #28]
 800cf60:	699b      	ldr	r3, [r3, #24]
 800cf62:	2b00      	cmp	r3, #0
 800cf64:	d017      	beq.n	800cf96 <UART_SetConfig+0x15e>
 800cf66:	69fb      	ldr	r3, [r7, #28]
 800cf68:	699a      	ldr	r2, [r3, #24]
 800cf6a:	2380      	movs	r3, #128	; 0x80
 800cf6c:	005b      	lsls	r3, r3, #1
 800cf6e:	429a      	cmp	r2, r3
 800cf70:	d011      	beq.n	800cf96 <UART_SetConfig+0x15e>
 800cf72:	69fb      	ldr	r3, [r7, #28]
 800cf74:	699a      	ldr	r2, [r3, #24]
 800cf76:	2380      	movs	r3, #128	; 0x80
 800cf78:	009b      	lsls	r3, r3, #2
 800cf7a:	429a      	cmp	r2, r3
 800cf7c:	d00b      	beq.n	800cf96 <UART_SetConfig+0x15e>
 800cf7e:	69fb      	ldr	r3, [r7, #28]
 800cf80:	699a      	ldr	r2, [r3, #24]
 800cf82:	23c0      	movs	r3, #192	; 0xc0
 800cf84:	009b      	lsls	r3, r3, #2
 800cf86:	429a      	cmp	r2, r3
 800cf88:	d005      	beq.n	800cf96 <UART_SetConfig+0x15e>
 800cf8a:	4a7b      	ldr	r2, [pc, #492]	; (800d178 <UART_SetConfig+0x340>)
 800cf8c:	4b72      	ldr	r3, [pc, #456]	; (800d158 <UART_SetConfig+0x320>)
 800cf8e:	0011      	movs	r1, r2
 800cf90:	0018      	movs	r0, r3
 800cf92:	f7f9 f980 	bl	8006296 <assert_failed>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
 800cf96:	69fb      	ldr	r3, [r7, #28]
 800cf98:	69db      	ldr	r3, [r3, #28]
 800cf9a:	2b00      	cmp	r3, #0
 800cf9c:	d00b      	beq.n	800cfb6 <UART_SetConfig+0x17e>
 800cf9e:	69fb      	ldr	r3, [r7, #28]
 800cfa0:	69da      	ldr	r2, [r3, #28]
 800cfa2:	2380      	movs	r3, #128	; 0x80
 800cfa4:	021b      	lsls	r3, r3, #8
 800cfa6:	429a      	cmp	r2, r3
 800cfa8:	d005      	beq.n	800cfb6 <UART_SetConfig+0x17e>
 800cfaa:	4a74      	ldr	r2, [pc, #464]	; (800d17c <UART_SetConfig+0x344>)
 800cfac:	4b6a      	ldr	r3, [pc, #424]	; (800d158 <UART_SetConfig+0x320>)
 800cfae:	0011      	movs	r1, r2
 800cfb0:	0018      	movs	r0, r3
 800cfb2:	f7f9 f970 	bl	8006296 <assert_failed>
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cfb6:	69fb      	ldr	r3, [r7, #28]
 800cfb8:	689a      	ldr	r2, [r3, #8]
 800cfba:	69fb      	ldr	r3, [r7, #28]
 800cfbc:	691b      	ldr	r3, [r3, #16]
 800cfbe:	431a      	orrs	r2, r3
 800cfc0:	69fb      	ldr	r3, [r7, #28]
 800cfc2:	695b      	ldr	r3, [r3, #20]
 800cfc4:	431a      	orrs	r2, r3
 800cfc6:	69fb      	ldr	r3, [r7, #28]
 800cfc8:	69db      	ldr	r3, [r3, #28]
 800cfca:	4313      	orrs	r3, r2
 800cfcc:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cfce:	69fb      	ldr	r3, [r7, #28]
 800cfd0:	681b      	ldr	r3, [r3, #0]
 800cfd2:	681b      	ldr	r3, [r3, #0]
 800cfd4:	4a6a      	ldr	r2, [pc, #424]	; (800d180 <UART_SetConfig+0x348>)
 800cfd6:	4013      	ands	r3, r2
 800cfd8:	0019      	movs	r1, r3
 800cfda:	69fb      	ldr	r3, [r7, #28]
 800cfdc:	681b      	ldr	r3, [r3, #0]
 800cfde:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800cfe0:	430a      	orrs	r2, r1
 800cfe2:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800cfe4:	69fb      	ldr	r3, [r7, #28]
 800cfe6:	681b      	ldr	r3, [r3, #0]
 800cfe8:	685b      	ldr	r3, [r3, #4]
 800cfea:	4a66      	ldr	r2, [pc, #408]	; (800d184 <UART_SetConfig+0x34c>)
 800cfec:	4013      	ands	r3, r2
 800cfee:	0019      	movs	r1, r3
 800cff0:	69fb      	ldr	r3, [r7, #28]
 800cff2:	68da      	ldr	r2, [r3, #12]
 800cff4:	69fb      	ldr	r3, [r7, #28]
 800cff6:	681b      	ldr	r3, [r3, #0]
 800cff8:	430a      	orrs	r2, r1
 800cffa:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800cffc:	69fb      	ldr	r3, [r7, #28]
 800cffe:	699b      	ldr	r3, [r3, #24]
 800d000:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800d002:	69fb      	ldr	r3, [r7, #28]
 800d004:	681b      	ldr	r3, [r3, #0]
 800d006:	4a56      	ldr	r2, [pc, #344]	; (800d160 <UART_SetConfig+0x328>)
 800d008:	4293      	cmp	r3, r2
 800d00a:	d004      	beq.n	800d016 <UART_SetConfig+0x1de>
  {
    tmpreg |= huart->Init.OneBitSampling;
 800d00c:	69fb      	ldr	r3, [r7, #28]
 800d00e:	6a1b      	ldr	r3, [r3, #32]
 800d010:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d012:	4313      	orrs	r3, r2
 800d014:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800d016:	69fb      	ldr	r3, [r7, #28]
 800d018:	681b      	ldr	r3, [r3, #0]
 800d01a:	689b      	ldr	r3, [r3, #8]
 800d01c:	4a5a      	ldr	r2, [pc, #360]	; (800d188 <UART_SetConfig+0x350>)
 800d01e:	4013      	ands	r3, r2
 800d020:	0019      	movs	r1, r3
 800d022:	69fb      	ldr	r3, [r7, #28]
 800d024:	681b      	ldr	r3, [r3, #0]
 800d026:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d028:	430a      	orrs	r2, r1
 800d02a:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800d02c:	69fb      	ldr	r3, [r7, #28]
 800d02e:	681b      	ldr	r3, [r3, #0]
 800d030:	4a56      	ldr	r2, [pc, #344]	; (800d18c <UART_SetConfig+0x354>)
 800d032:	4293      	cmp	r3, r2
 800d034:	d136      	bne.n	800d0a4 <UART_SetConfig+0x26c>
 800d036:	4b56      	ldr	r3, [pc, #344]	; (800d190 <UART_SetConfig+0x358>)
 800d038:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800d03a:	2203      	movs	r2, #3
 800d03c:	4013      	ands	r3, r2
 800d03e:	2b03      	cmp	r3, #3
 800d040:	d020      	beq.n	800d084 <UART_SetConfig+0x24c>
 800d042:	d827      	bhi.n	800d094 <UART_SetConfig+0x25c>
 800d044:	2b02      	cmp	r3, #2
 800d046:	d00d      	beq.n	800d064 <UART_SetConfig+0x22c>
 800d048:	d824      	bhi.n	800d094 <UART_SetConfig+0x25c>
 800d04a:	2b00      	cmp	r3, #0
 800d04c:	d002      	beq.n	800d054 <UART_SetConfig+0x21c>
 800d04e:	2b01      	cmp	r3, #1
 800d050:	d010      	beq.n	800d074 <UART_SetConfig+0x23c>
 800d052:	e01f      	b.n	800d094 <UART_SetConfig+0x25c>
 800d054:	231b      	movs	r3, #27
 800d056:	2218      	movs	r2, #24
 800d058:	4694      	mov	ip, r2
 800d05a:	44bc      	add	ip, r7
 800d05c:	4463      	add	r3, ip
 800d05e:	2201      	movs	r2, #1
 800d060:	701a      	strb	r2, [r3, #0]
 800d062:	e0ed      	b.n	800d240 <UART_SetConfig+0x408>
 800d064:	231b      	movs	r3, #27
 800d066:	2218      	movs	r2, #24
 800d068:	4694      	mov	ip, r2
 800d06a:	44bc      	add	ip, r7
 800d06c:	4463      	add	r3, ip
 800d06e:	2202      	movs	r2, #2
 800d070:	701a      	strb	r2, [r3, #0]
 800d072:	e0e5      	b.n	800d240 <UART_SetConfig+0x408>
 800d074:	231b      	movs	r3, #27
 800d076:	2218      	movs	r2, #24
 800d078:	4694      	mov	ip, r2
 800d07a:	44bc      	add	ip, r7
 800d07c:	4463      	add	r3, ip
 800d07e:	2204      	movs	r2, #4
 800d080:	701a      	strb	r2, [r3, #0]
 800d082:	e0dd      	b.n	800d240 <UART_SetConfig+0x408>
 800d084:	231b      	movs	r3, #27
 800d086:	2218      	movs	r2, #24
 800d088:	4694      	mov	ip, r2
 800d08a:	44bc      	add	ip, r7
 800d08c:	4463      	add	r3, ip
 800d08e:	2208      	movs	r2, #8
 800d090:	701a      	strb	r2, [r3, #0]
 800d092:	e0d5      	b.n	800d240 <UART_SetConfig+0x408>
 800d094:	231b      	movs	r3, #27
 800d096:	2218      	movs	r2, #24
 800d098:	4694      	mov	ip, r2
 800d09a:	44bc      	add	ip, r7
 800d09c:	4463      	add	r3, ip
 800d09e:	2210      	movs	r2, #16
 800d0a0:	701a      	strb	r2, [r3, #0]
 800d0a2:	e0cd      	b.n	800d240 <UART_SetConfig+0x408>
 800d0a4:	69fb      	ldr	r3, [r7, #28]
 800d0a6:	681b      	ldr	r3, [r3, #0]
 800d0a8:	4a3a      	ldr	r2, [pc, #232]	; (800d194 <UART_SetConfig+0x35c>)
 800d0aa:	4293      	cmp	r3, r2
 800d0ac:	d136      	bne.n	800d11c <UART_SetConfig+0x2e4>
 800d0ae:	4b38      	ldr	r3, [pc, #224]	; (800d190 <UART_SetConfig+0x358>)
 800d0b0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800d0b2:	220c      	movs	r2, #12
 800d0b4:	4013      	ands	r3, r2
 800d0b6:	2b0c      	cmp	r3, #12
 800d0b8:	d020      	beq.n	800d0fc <UART_SetConfig+0x2c4>
 800d0ba:	d827      	bhi.n	800d10c <UART_SetConfig+0x2d4>
 800d0bc:	2b08      	cmp	r3, #8
 800d0be:	d00d      	beq.n	800d0dc <UART_SetConfig+0x2a4>
 800d0c0:	d824      	bhi.n	800d10c <UART_SetConfig+0x2d4>
 800d0c2:	2b00      	cmp	r3, #0
 800d0c4:	d002      	beq.n	800d0cc <UART_SetConfig+0x294>
 800d0c6:	2b04      	cmp	r3, #4
 800d0c8:	d010      	beq.n	800d0ec <UART_SetConfig+0x2b4>
 800d0ca:	e01f      	b.n	800d10c <UART_SetConfig+0x2d4>
 800d0cc:	231b      	movs	r3, #27
 800d0ce:	2218      	movs	r2, #24
 800d0d0:	4694      	mov	ip, r2
 800d0d2:	44bc      	add	ip, r7
 800d0d4:	4463      	add	r3, ip
 800d0d6:	2200      	movs	r2, #0
 800d0d8:	701a      	strb	r2, [r3, #0]
 800d0da:	e0b1      	b.n	800d240 <UART_SetConfig+0x408>
 800d0dc:	231b      	movs	r3, #27
 800d0de:	2218      	movs	r2, #24
 800d0e0:	4694      	mov	ip, r2
 800d0e2:	44bc      	add	ip, r7
 800d0e4:	4463      	add	r3, ip
 800d0e6:	2202      	movs	r2, #2
 800d0e8:	701a      	strb	r2, [r3, #0]
 800d0ea:	e0a9      	b.n	800d240 <UART_SetConfig+0x408>
 800d0ec:	231b      	movs	r3, #27
 800d0ee:	2218      	movs	r2, #24
 800d0f0:	4694      	mov	ip, r2
 800d0f2:	44bc      	add	ip, r7
 800d0f4:	4463      	add	r3, ip
 800d0f6:	2204      	movs	r2, #4
 800d0f8:	701a      	strb	r2, [r3, #0]
 800d0fa:	e0a1      	b.n	800d240 <UART_SetConfig+0x408>
 800d0fc:	231b      	movs	r3, #27
 800d0fe:	2218      	movs	r2, #24
 800d100:	4694      	mov	ip, r2
 800d102:	44bc      	add	ip, r7
 800d104:	4463      	add	r3, ip
 800d106:	2208      	movs	r2, #8
 800d108:	701a      	strb	r2, [r3, #0]
 800d10a:	e099      	b.n	800d240 <UART_SetConfig+0x408>
 800d10c:	231b      	movs	r3, #27
 800d10e:	2218      	movs	r2, #24
 800d110:	4694      	mov	ip, r2
 800d112:	44bc      	add	ip, r7
 800d114:	4463      	add	r3, ip
 800d116:	2210      	movs	r2, #16
 800d118:	701a      	strb	r2, [r3, #0]
 800d11a:	e091      	b.n	800d240 <UART_SetConfig+0x408>
 800d11c:	69fb      	ldr	r3, [r7, #28]
 800d11e:	681b      	ldr	r3, [r3, #0]
 800d120:	4a1d      	ldr	r2, [pc, #116]	; (800d198 <UART_SetConfig+0x360>)
 800d122:	4293      	cmp	r3, r2
 800d124:	d107      	bne.n	800d136 <UART_SetConfig+0x2fe>
 800d126:	231b      	movs	r3, #27
 800d128:	2218      	movs	r2, #24
 800d12a:	4694      	mov	ip, r2
 800d12c:	44bc      	add	ip, r7
 800d12e:	4463      	add	r3, ip
 800d130:	2200      	movs	r2, #0
 800d132:	701a      	strb	r2, [r3, #0]
 800d134:	e084      	b.n	800d240 <UART_SetConfig+0x408>
 800d136:	69fb      	ldr	r3, [r7, #28]
 800d138:	681b      	ldr	r3, [r3, #0]
 800d13a:	4a18      	ldr	r2, [pc, #96]	; (800d19c <UART_SetConfig+0x364>)
 800d13c:	4293      	cmp	r3, r2
 800d13e:	d12f      	bne.n	800d1a0 <UART_SetConfig+0x368>
 800d140:	231b      	movs	r3, #27
 800d142:	2218      	movs	r2, #24
 800d144:	4694      	mov	ip, r2
 800d146:	44bc      	add	ip, r7
 800d148:	4463      	add	r3, ip
 800d14a:	2200      	movs	r2, #0
 800d14c:	701a      	strb	r2, [r3, #0]
 800d14e:	e077      	b.n	800d240 <UART_SetConfig+0x408>
 800d150:	003d0900 	.word	0x003d0900
 800d154:	00000bb6 	.word	0x00000bb6
 800d158:	0800df80 	.word	0x0800df80
 800d15c:	00000bb7 	.word	0x00000bb7
 800d160:	40004800 	.word	0x40004800
 800d164:	00000bba 	.word	0x00000bba
 800d168:	00000bbe 	.word	0x00000bbe
 800d16c:	00000bbf 	.word	0x00000bbf
 800d170:	00000bc2 	.word	0x00000bc2
 800d174:	00000bc3 	.word	0x00000bc3
 800d178:	00000bc4 	.word	0x00000bc4
 800d17c:	00000bc5 	.word	0x00000bc5
 800d180:	efff69f3 	.word	0xefff69f3
 800d184:	ffffcfff 	.word	0xffffcfff
 800d188:	fffff4ff 	.word	0xfffff4ff
 800d18c:	40013800 	.word	0x40013800
 800d190:	40021000 	.word	0x40021000
 800d194:	40004400 	.word	0x40004400
 800d198:	40004c00 	.word	0x40004c00
 800d19c:	40005000 	.word	0x40005000
 800d1a0:	69fb      	ldr	r3, [r7, #28]
 800d1a2:	681b      	ldr	r3, [r3, #0]
 800d1a4:	4ac1      	ldr	r2, [pc, #772]	; (800d4ac <UART_SetConfig+0x674>)
 800d1a6:	4293      	cmp	r3, r2
 800d1a8:	d143      	bne.n	800d232 <UART_SetConfig+0x3fa>
 800d1aa:	4bc1      	ldr	r3, [pc, #772]	; (800d4b0 <UART_SetConfig+0x678>)
 800d1ac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800d1ae:	23c0      	movs	r3, #192	; 0xc0
 800d1b0:	011b      	lsls	r3, r3, #4
 800d1b2:	4013      	ands	r3, r2
 800d1b4:	22c0      	movs	r2, #192	; 0xc0
 800d1b6:	0112      	lsls	r2, r2, #4
 800d1b8:	4293      	cmp	r3, r2
 800d1ba:	d02a      	beq.n	800d212 <UART_SetConfig+0x3da>
 800d1bc:	22c0      	movs	r2, #192	; 0xc0
 800d1be:	0112      	lsls	r2, r2, #4
 800d1c0:	4293      	cmp	r3, r2
 800d1c2:	d82e      	bhi.n	800d222 <UART_SetConfig+0x3ea>
 800d1c4:	2280      	movs	r2, #128	; 0x80
 800d1c6:	0112      	lsls	r2, r2, #4
 800d1c8:	4293      	cmp	r3, r2
 800d1ca:	d012      	beq.n	800d1f2 <UART_SetConfig+0x3ba>
 800d1cc:	2280      	movs	r2, #128	; 0x80
 800d1ce:	0112      	lsls	r2, r2, #4
 800d1d0:	4293      	cmp	r3, r2
 800d1d2:	d826      	bhi.n	800d222 <UART_SetConfig+0x3ea>
 800d1d4:	2b00      	cmp	r3, #0
 800d1d6:	d004      	beq.n	800d1e2 <UART_SetConfig+0x3aa>
 800d1d8:	2280      	movs	r2, #128	; 0x80
 800d1da:	00d2      	lsls	r2, r2, #3
 800d1dc:	4293      	cmp	r3, r2
 800d1de:	d010      	beq.n	800d202 <UART_SetConfig+0x3ca>
 800d1e0:	e01f      	b.n	800d222 <UART_SetConfig+0x3ea>
 800d1e2:	231b      	movs	r3, #27
 800d1e4:	2218      	movs	r2, #24
 800d1e6:	4694      	mov	ip, r2
 800d1e8:	44bc      	add	ip, r7
 800d1ea:	4463      	add	r3, ip
 800d1ec:	2200      	movs	r2, #0
 800d1ee:	701a      	strb	r2, [r3, #0]
 800d1f0:	e026      	b.n	800d240 <UART_SetConfig+0x408>
 800d1f2:	231b      	movs	r3, #27
 800d1f4:	2218      	movs	r2, #24
 800d1f6:	4694      	mov	ip, r2
 800d1f8:	44bc      	add	ip, r7
 800d1fa:	4463      	add	r3, ip
 800d1fc:	2202      	movs	r2, #2
 800d1fe:	701a      	strb	r2, [r3, #0]
 800d200:	e01e      	b.n	800d240 <UART_SetConfig+0x408>
 800d202:	231b      	movs	r3, #27
 800d204:	2218      	movs	r2, #24
 800d206:	4694      	mov	ip, r2
 800d208:	44bc      	add	ip, r7
 800d20a:	4463      	add	r3, ip
 800d20c:	2204      	movs	r2, #4
 800d20e:	701a      	strb	r2, [r3, #0]
 800d210:	e016      	b.n	800d240 <UART_SetConfig+0x408>
 800d212:	231b      	movs	r3, #27
 800d214:	2218      	movs	r2, #24
 800d216:	4694      	mov	ip, r2
 800d218:	44bc      	add	ip, r7
 800d21a:	4463      	add	r3, ip
 800d21c:	2208      	movs	r2, #8
 800d21e:	701a      	strb	r2, [r3, #0]
 800d220:	e00e      	b.n	800d240 <UART_SetConfig+0x408>
 800d222:	231b      	movs	r3, #27
 800d224:	2218      	movs	r2, #24
 800d226:	4694      	mov	ip, r2
 800d228:	44bc      	add	ip, r7
 800d22a:	4463      	add	r3, ip
 800d22c:	2210      	movs	r2, #16
 800d22e:	701a      	strb	r2, [r3, #0]
 800d230:	e006      	b.n	800d240 <UART_SetConfig+0x408>
 800d232:	231b      	movs	r3, #27
 800d234:	2218      	movs	r2, #24
 800d236:	4694      	mov	ip, r2
 800d238:	44bc      	add	ip, r7
 800d23a:	4463      	add	r3, ip
 800d23c:	2210      	movs	r2, #16
 800d23e:	701a      	strb	r2, [r3, #0]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 800d240:	69fb      	ldr	r3, [r7, #28]
 800d242:	681b      	ldr	r3, [r3, #0]
 800d244:	4a99      	ldr	r2, [pc, #612]	; (800d4ac <UART_SetConfig+0x674>)
 800d246:	4293      	cmp	r3, r2
 800d248:	d000      	beq.n	800d24c <UART_SetConfig+0x414>
 800d24a:	e088      	b.n	800d35e <UART_SetConfig+0x526>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 800d24c:	231b      	movs	r3, #27
 800d24e:	2218      	movs	r2, #24
 800d250:	4694      	mov	ip, r2
 800d252:	44bc      	add	ip, r7
 800d254:	4463      	add	r3, ip
 800d256:	781b      	ldrb	r3, [r3, #0]
 800d258:	2b08      	cmp	r3, #8
 800d25a:	d01d      	beq.n	800d298 <UART_SetConfig+0x460>
 800d25c:	dc20      	bgt.n	800d2a0 <UART_SetConfig+0x468>
 800d25e:	2b04      	cmp	r3, #4
 800d260:	d015      	beq.n	800d28e <UART_SetConfig+0x456>
 800d262:	dc1d      	bgt.n	800d2a0 <UART_SetConfig+0x468>
 800d264:	2b00      	cmp	r3, #0
 800d266:	d002      	beq.n	800d26e <UART_SetConfig+0x436>
 800d268:	2b02      	cmp	r3, #2
 800d26a:	d005      	beq.n	800d278 <UART_SetConfig+0x440>
 800d26c:	e018      	b.n	800d2a0 <UART_SetConfig+0x468>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800d26e:	f7fd fb97 	bl	800a9a0 <HAL_RCC_GetPCLK1Freq>
 800d272:	0003      	movs	r3, r0
 800d274:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d276:	e01d      	b.n	800d2b4 <UART_SetConfig+0x47c>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800d278:	4b8d      	ldr	r3, [pc, #564]	; (800d4b0 <UART_SetConfig+0x678>)
 800d27a:	681b      	ldr	r3, [r3, #0]
 800d27c:	2210      	movs	r2, #16
 800d27e:	4013      	ands	r3, r2
 800d280:	d002      	beq.n	800d288 <UART_SetConfig+0x450>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 800d282:	4b8c      	ldr	r3, [pc, #560]	; (800d4b4 <UART_SetConfig+0x67c>)
 800d284:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800d286:	e015      	b.n	800d2b4 <UART_SetConfig+0x47c>
          pclk = (uint32_t) HSI_VALUE;
 800d288:	4b8b      	ldr	r3, [pc, #556]	; (800d4b8 <UART_SetConfig+0x680>)
 800d28a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d28c:	e012      	b.n	800d2b4 <UART_SetConfig+0x47c>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800d28e:	f7fd fad7 	bl	800a840 <HAL_RCC_GetSysClockFreq>
 800d292:	0003      	movs	r3, r0
 800d294:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d296:	e00d      	b.n	800d2b4 <UART_SetConfig+0x47c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800d298:	2380      	movs	r3, #128	; 0x80
 800d29a:	021b      	lsls	r3, r3, #8
 800d29c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d29e:	e009      	b.n	800d2b4 <UART_SetConfig+0x47c>
      default:
        pclk = 0U;
 800d2a0:	2300      	movs	r3, #0
 800d2a2:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 800d2a4:	231a      	movs	r3, #26
 800d2a6:	2218      	movs	r2, #24
 800d2a8:	4694      	mov	ip, r2
 800d2aa:	44bc      	add	ip, r7
 800d2ac:	4463      	add	r3, ip
 800d2ae:	2201      	movs	r2, #1
 800d2b0:	701a      	strb	r2, [r3, #0]
        break;
 800d2b2:	46c0      	nop			; (mov r8, r8)
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 800d2b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d2b6:	2b00      	cmp	r3, #0
 800d2b8:	d100      	bne.n	800d2bc <UART_SetConfig+0x484>
 800d2ba:	e132      	b.n	800d522 <UART_SetConfig+0x6ea>
    {
      /* No Prescaler applicable */
      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 800d2bc:	69fb      	ldr	r3, [r7, #28]
 800d2be:	685a      	ldr	r2, [r3, #4]
 800d2c0:	0013      	movs	r3, r2
 800d2c2:	005b      	lsls	r3, r3, #1
 800d2c4:	189b      	adds	r3, r3, r2
 800d2c6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d2c8:	429a      	cmp	r2, r3
 800d2ca:	d305      	bcc.n	800d2d8 <UART_SetConfig+0x4a0>
          (pclk > (4096U * huart->Init.BaudRate)))
 800d2cc:	69fb      	ldr	r3, [r7, #28]
 800d2ce:	685b      	ldr	r3, [r3, #4]
 800d2d0:	031b      	lsls	r3, r3, #12
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 800d2d2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d2d4:	429a      	cmp	r2, r3
 800d2d6:	d907      	bls.n	800d2e8 <UART_SetConfig+0x4b0>
      {
        ret = HAL_ERROR;
 800d2d8:	231a      	movs	r3, #26
 800d2da:	2218      	movs	r2, #24
 800d2dc:	4694      	mov	ip, r2
 800d2de:	44bc      	add	ip, r7
 800d2e0:	4463      	add	r3, ip
 800d2e2:	2201      	movs	r2, #1
 800d2e4:	701a      	strb	r2, [r3, #0]
 800d2e6:	e11c      	b.n	800d522 <UART_SetConfig+0x6ea>
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate));
 800d2e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d2ea:	613b      	str	r3, [r7, #16]
 800d2ec:	2300      	movs	r3, #0
 800d2ee:	617b      	str	r3, [r7, #20]
 800d2f0:	6939      	ldr	r1, [r7, #16]
 800d2f2:	697a      	ldr	r2, [r7, #20]
 800d2f4:	000b      	movs	r3, r1
 800d2f6:	0e1b      	lsrs	r3, r3, #24
 800d2f8:	0010      	movs	r0, r2
 800d2fa:	0205      	lsls	r5, r0, #8
 800d2fc:	431d      	orrs	r5, r3
 800d2fe:	000b      	movs	r3, r1
 800d300:	021c      	lsls	r4, r3, #8
 800d302:	69fb      	ldr	r3, [r7, #28]
 800d304:	685b      	ldr	r3, [r3, #4]
 800d306:	085b      	lsrs	r3, r3, #1
 800d308:	60bb      	str	r3, [r7, #8]
 800d30a:	2300      	movs	r3, #0
 800d30c:	60fb      	str	r3, [r7, #12]
 800d30e:	68b8      	ldr	r0, [r7, #8]
 800d310:	68f9      	ldr	r1, [r7, #12]
 800d312:	1900      	adds	r0, r0, r4
 800d314:	4169      	adcs	r1, r5
 800d316:	69fb      	ldr	r3, [r7, #28]
 800d318:	685b      	ldr	r3, [r3, #4]
 800d31a:	603b      	str	r3, [r7, #0]
 800d31c:	2300      	movs	r3, #0
 800d31e:	607b      	str	r3, [r7, #4]
 800d320:	683a      	ldr	r2, [r7, #0]
 800d322:	687b      	ldr	r3, [r7, #4]
 800d324:	f7f3 f88a 	bl	800043c <__aeabi_uldivmod>
 800d328:	0002      	movs	r2, r0
 800d32a:	000b      	movs	r3, r1
 800d32c:	0013      	movs	r3, r2
 800d32e:	62bb      	str	r3, [r7, #40]	; 0x28
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800d330:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d332:	23c0      	movs	r3, #192	; 0xc0
 800d334:	009b      	lsls	r3, r3, #2
 800d336:	429a      	cmp	r2, r3
 800d338:	d309      	bcc.n	800d34e <UART_SetConfig+0x516>
 800d33a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d33c:	2380      	movs	r3, #128	; 0x80
 800d33e:	035b      	lsls	r3, r3, #13
 800d340:	429a      	cmp	r2, r3
 800d342:	d204      	bcs.n	800d34e <UART_SetConfig+0x516>
        {
          huart->Instance->BRR = usartdiv;
 800d344:	69fb      	ldr	r3, [r7, #28]
 800d346:	681b      	ldr	r3, [r3, #0]
 800d348:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d34a:	60da      	str	r2, [r3, #12]
 800d34c:	e0e9      	b.n	800d522 <UART_SetConfig+0x6ea>
        }
        else
        {
          ret = HAL_ERROR;
 800d34e:	231a      	movs	r3, #26
 800d350:	2218      	movs	r2, #24
 800d352:	4694      	mov	ip, r2
 800d354:	44bc      	add	ip, r7
 800d356:	4463      	add	r3, ip
 800d358:	2201      	movs	r2, #1
 800d35a:	701a      	strb	r2, [r3, #0]
 800d35c:	e0e1      	b.n	800d522 <UART_SetConfig+0x6ea>
        }
      } /* if ( (pclk < (3 * huart->Init.BaudRate) ) || (pclk > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800d35e:	69fb      	ldr	r3, [r7, #28]
 800d360:	69da      	ldr	r2, [r3, #28]
 800d362:	2380      	movs	r3, #128	; 0x80
 800d364:	021b      	lsls	r3, r3, #8
 800d366:	429a      	cmp	r2, r3
 800d368:	d000      	beq.n	800d36c <UART_SetConfig+0x534>
 800d36a:	e074      	b.n	800d456 <UART_SetConfig+0x61e>
  {
    switch (clocksource)
 800d36c:	231b      	movs	r3, #27
 800d36e:	2218      	movs	r2, #24
 800d370:	4694      	mov	ip, r2
 800d372:	44bc      	add	ip, r7
 800d374:	4463      	add	r3, ip
 800d376:	781b      	ldrb	r3, [r3, #0]
 800d378:	2b08      	cmp	r3, #8
 800d37a:	d822      	bhi.n	800d3c2 <UART_SetConfig+0x58a>
 800d37c:	009a      	lsls	r2, r3, #2
 800d37e:	4b4f      	ldr	r3, [pc, #316]	; (800d4bc <UART_SetConfig+0x684>)
 800d380:	18d3      	adds	r3, r2, r3
 800d382:	681b      	ldr	r3, [r3, #0]
 800d384:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800d386:	f7fd fb0b 	bl	800a9a0 <HAL_RCC_GetPCLK1Freq>
 800d38a:	0003      	movs	r3, r0
 800d38c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d38e:	e022      	b.n	800d3d6 <UART_SetConfig+0x59e>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800d390:	f7fd fb1c 	bl	800a9cc <HAL_RCC_GetPCLK2Freq>
 800d394:	0003      	movs	r3, r0
 800d396:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d398:	e01d      	b.n	800d3d6 <UART_SetConfig+0x59e>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800d39a:	4b45      	ldr	r3, [pc, #276]	; (800d4b0 <UART_SetConfig+0x678>)
 800d39c:	681b      	ldr	r3, [r3, #0]
 800d39e:	2210      	movs	r2, #16
 800d3a0:	4013      	ands	r3, r2
 800d3a2:	d002      	beq.n	800d3aa <UART_SetConfig+0x572>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 800d3a4:	4b43      	ldr	r3, [pc, #268]	; (800d4b4 <UART_SetConfig+0x67c>)
 800d3a6:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800d3a8:	e015      	b.n	800d3d6 <UART_SetConfig+0x59e>
          pclk = (uint32_t) HSI_VALUE;
 800d3aa:	4b43      	ldr	r3, [pc, #268]	; (800d4b8 <UART_SetConfig+0x680>)
 800d3ac:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d3ae:	e012      	b.n	800d3d6 <UART_SetConfig+0x59e>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800d3b0:	f7fd fa46 	bl	800a840 <HAL_RCC_GetSysClockFreq>
 800d3b4:	0003      	movs	r3, r0
 800d3b6:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d3b8:	e00d      	b.n	800d3d6 <UART_SetConfig+0x59e>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800d3ba:	2380      	movs	r3, #128	; 0x80
 800d3bc:	021b      	lsls	r3, r3, #8
 800d3be:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d3c0:	e009      	b.n	800d3d6 <UART_SetConfig+0x59e>
      default:
        pclk = 0U;
 800d3c2:	2300      	movs	r3, #0
 800d3c4:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 800d3c6:	231a      	movs	r3, #26
 800d3c8:	2218      	movs	r2, #24
 800d3ca:	4694      	mov	ip, r2
 800d3cc:	44bc      	add	ip, r7
 800d3ce:	4463      	add	r3, ip
 800d3d0:	2201      	movs	r2, #1
 800d3d2:	701a      	strb	r2, [r3, #0]
        break;
 800d3d4:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 800d3d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d3d8:	2b00      	cmp	r3, #0
 800d3da:	d100      	bne.n	800d3de <UART_SetConfig+0x5a6>
 800d3dc:	e0a1      	b.n	800d522 <UART_SetConfig+0x6ea>
    {
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800d3de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d3e0:	005a      	lsls	r2, r3, #1
 800d3e2:	69fb      	ldr	r3, [r7, #28]
 800d3e4:	685b      	ldr	r3, [r3, #4]
 800d3e6:	085b      	lsrs	r3, r3, #1
 800d3e8:	18d2      	adds	r2, r2, r3
 800d3ea:	69fb      	ldr	r3, [r7, #28]
 800d3ec:	685b      	ldr	r3, [r3, #4]
 800d3ee:	0019      	movs	r1, r3
 800d3f0:	0010      	movs	r0, r2
 800d3f2:	f7f2 fe89 	bl	8000108 <__udivsi3>
 800d3f6:	0003      	movs	r3, r0
 800d3f8:	b29b      	uxth	r3, r3
 800d3fa:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800d3fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d3fe:	2b0f      	cmp	r3, #15
 800d400:	d921      	bls.n	800d446 <UART_SetConfig+0x60e>
 800d402:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d404:	2380      	movs	r3, #128	; 0x80
 800d406:	025b      	lsls	r3, r3, #9
 800d408:	429a      	cmp	r2, r3
 800d40a:	d21c      	bcs.n	800d446 <UART_SetConfig+0x60e>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800d40c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d40e:	b29a      	uxth	r2, r3
 800d410:	200e      	movs	r0, #14
 800d412:	2418      	movs	r4, #24
 800d414:	193b      	adds	r3, r7, r4
 800d416:	181b      	adds	r3, r3, r0
 800d418:	210f      	movs	r1, #15
 800d41a:	438a      	bics	r2, r1
 800d41c:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800d41e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d420:	085b      	lsrs	r3, r3, #1
 800d422:	b29b      	uxth	r3, r3
 800d424:	2207      	movs	r2, #7
 800d426:	4013      	ands	r3, r2
 800d428:	b299      	uxth	r1, r3
 800d42a:	193b      	adds	r3, r7, r4
 800d42c:	181b      	adds	r3, r3, r0
 800d42e:	193a      	adds	r2, r7, r4
 800d430:	1812      	adds	r2, r2, r0
 800d432:	8812      	ldrh	r2, [r2, #0]
 800d434:	430a      	orrs	r2, r1
 800d436:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
 800d438:	69fb      	ldr	r3, [r7, #28]
 800d43a:	681b      	ldr	r3, [r3, #0]
 800d43c:	193a      	adds	r2, r7, r4
 800d43e:	1812      	adds	r2, r2, r0
 800d440:	8812      	ldrh	r2, [r2, #0]
 800d442:	60da      	str	r2, [r3, #12]
 800d444:	e06d      	b.n	800d522 <UART_SetConfig+0x6ea>
      }
      else
      {
        ret = HAL_ERROR;
 800d446:	231a      	movs	r3, #26
 800d448:	2218      	movs	r2, #24
 800d44a:	4694      	mov	ip, r2
 800d44c:	44bc      	add	ip, r7
 800d44e:	4463      	add	r3, ip
 800d450:	2201      	movs	r2, #1
 800d452:	701a      	strb	r2, [r3, #0]
 800d454:	e065      	b.n	800d522 <UART_SetConfig+0x6ea>
      }
    }
  }
  else
  {
    switch (clocksource)
 800d456:	231b      	movs	r3, #27
 800d458:	2218      	movs	r2, #24
 800d45a:	4694      	mov	ip, r2
 800d45c:	44bc      	add	ip, r7
 800d45e:	4463      	add	r3, ip
 800d460:	781b      	ldrb	r3, [r3, #0]
 800d462:	2b08      	cmp	r3, #8
 800d464:	d82e      	bhi.n	800d4c4 <UART_SetConfig+0x68c>
 800d466:	009a      	lsls	r2, r3, #2
 800d468:	4b15      	ldr	r3, [pc, #84]	; (800d4c0 <UART_SetConfig+0x688>)
 800d46a:	18d3      	adds	r3, r2, r3
 800d46c:	681b      	ldr	r3, [r3, #0]
 800d46e:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800d470:	f7fd fa96 	bl	800a9a0 <HAL_RCC_GetPCLK1Freq>
 800d474:	0003      	movs	r3, r0
 800d476:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d478:	e02e      	b.n	800d4d8 <UART_SetConfig+0x6a0>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800d47a:	f7fd faa7 	bl	800a9cc <HAL_RCC_GetPCLK2Freq>
 800d47e:	0003      	movs	r3, r0
 800d480:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d482:	e029      	b.n	800d4d8 <UART_SetConfig+0x6a0>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800d484:	4b0a      	ldr	r3, [pc, #40]	; (800d4b0 <UART_SetConfig+0x678>)
 800d486:	681b      	ldr	r3, [r3, #0]
 800d488:	2210      	movs	r2, #16
 800d48a:	4013      	ands	r3, r2
 800d48c:	d002      	beq.n	800d494 <UART_SetConfig+0x65c>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 800d48e:	4b09      	ldr	r3, [pc, #36]	; (800d4b4 <UART_SetConfig+0x67c>)
 800d490:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800d492:	e021      	b.n	800d4d8 <UART_SetConfig+0x6a0>
          pclk = (uint32_t) HSI_VALUE;
 800d494:	4b08      	ldr	r3, [pc, #32]	; (800d4b8 <UART_SetConfig+0x680>)
 800d496:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d498:	e01e      	b.n	800d4d8 <UART_SetConfig+0x6a0>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800d49a:	f7fd f9d1 	bl	800a840 <HAL_RCC_GetSysClockFreq>
 800d49e:	0003      	movs	r3, r0
 800d4a0:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d4a2:	e019      	b.n	800d4d8 <UART_SetConfig+0x6a0>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800d4a4:	2380      	movs	r3, #128	; 0x80
 800d4a6:	021b      	lsls	r3, r3, #8
 800d4a8:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d4aa:	e015      	b.n	800d4d8 <UART_SetConfig+0x6a0>
 800d4ac:	40004800 	.word	0x40004800
 800d4b0:	40021000 	.word	0x40021000
 800d4b4:	003d0900 	.word	0x003d0900
 800d4b8:	00f42400 	.word	0x00f42400
 800d4bc:	0800f258 	.word	0x0800f258
 800d4c0:	0800f27c 	.word	0x0800f27c
      default:
        pclk = 0U;
 800d4c4:	2300      	movs	r3, #0
 800d4c6:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 800d4c8:	231a      	movs	r3, #26
 800d4ca:	2218      	movs	r2, #24
 800d4cc:	4694      	mov	ip, r2
 800d4ce:	44bc      	add	ip, r7
 800d4d0:	4463      	add	r3, ip
 800d4d2:	2201      	movs	r2, #1
 800d4d4:	701a      	strb	r2, [r3, #0]
        break;
 800d4d6:	46c0      	nop			; (mov r8, r8)
    }

    if (pclk != 0U)
 800d4d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d4da:	2b00      	cmp	r3, #0
 800d4dc:	d021      	beq.n	800d522 <UART_SetConfig+0x6ea>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800d4de:	69fb      	ldr	r3, [r7, #28]
 800d4e0:	685b      	ldr	r3, [r3, #4]
 800d4e2:	085a      	lsrs	r2, r3, #1
 800d4e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d4e6:	18d2      	adds	r2, r2, r3
 800d4e8:	69fb      	ldr	r3, [r7, #28]
 800d4ea:	685b      	ldr	r3, [r3, #4]
 800d4ec:	0019      	movs	r1, r3
 800d4ee:	0010      	movs	r0, r2
 800d4f0:	f7f2 fe0a 	bl	8000108 <__udivsi3>
 800d4f4:	0003      	movs	r3, r0
 800d4f6:	b29b      	uxth	r3, r3
 800d4f8:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800d4fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d4fc:	2b0f      	cmp	r3, #15
 800d4fe:	d909      	bls.n	800d514 <UART_SetConfig+0x6dc>
 800d500:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d502:	2380      	movs	r3, #128	; 0x80
 800d504:	025b      	lsls	r3, r3, #9
 800d506:	429a      	cmp	r2, r3
 800d508:	d204      	bcs.n	800d514 <UART_SetConfig+0x6dc>
      {
        huart->Instance->BRR = usartdiv;
 800d50a:	69fb      	ldr	r3, [r7, #28]
 800d50c:	681b      	ldr	r3, [r3, #0]
 800d50e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d510:	60da      	str	r2, [r3, #12]
 800d512:	e006      	b.n	800d522 <UART_SetConfig+0x6ea>
      }
      else
      {
        ret = HAL_ERROR;
 800d514:	231a      	movs	r3, #26
 800d516:	2218      	movs	r2, #24
 800d518:	4694      	mov	ip, r2
 800d51a:	44bc      	add	ip, r7
 800d51c:	4463      	add	r3, ip
 800d51e:	2201      	movs	r2, #1
 800d520:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800d522:	69fb      	ldr	r3, [r7, #28]
 800d524:	2200      	movs	r2, #0
 800d526:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 800d528:	69fb      	ldr	r3, [r7, #28]
 800d52a:	2200      	movs	r2, #0
 800d52c:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 800d52e:	231a      	movs	r3, #26
 800d530:	2218      	movs	r2, #24
 800d532:	4694      	mov	ip, r2
 800d534:	44bc      	add	ip, r7
 800d536:	4463      	add	r3, ip
 800d538:	781b      	ldrb	r3, [r3, #0]
}
 800d53a:	0018      	movs	r0, r3
 800d53c:	46bd      	mov	sp, r7
 800d53e:	b00e      	add	sp, #56	; 0x38
 800d540:	bdb0      	pop	{r4, r5, r7, pc}
 800d542:	46c0      	nop			; (mov r8, r8)

0800d544 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800d544:	b580      	push	{r7, lr}
 800d546:	b082      	sub	sp, #8
 800d548:	af00      	add	r7, sp, #0
 800d54a:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
 800d54c:	687b      	ldr	r3, [r7, #4]
 800d54e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d550:	2bff      	cmp	r3, #255	; 0xff
 800d552:	d905      	bls.n	800d560 <UART_AdvFeatureConfig+0x1c>
 800d554:	4aa8      	ldr	r2, [pc, #672]	; (800d7f8 <UART_AdvFeatureConfig+0x2b4>)
 800d556:	4ba9      	ldr	r3, [pc, #676]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d558:	0011      	movs	r1, r2
 800d55a:	0018      	movs	r0, r3
 800d55c:	f7f8 fe9b 	bl	8006296 <assert_failed>

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800d560:	687b      	ldr	r3, [r7, #4]
 800d562:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d564:	2201      	movs	r2, #1
 800d566:	4013      	ands	r3, r2
 800d568:	d01b      	beq.n	800d5a2 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
 800d56a:	687b      	ldr	r3, [r7, #4]
 800d56c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d56e:	2b00      	cmp	r3, #0
 800d570:	d00b      	beq.n	800d58a <UART_AdvFeatureConfig+0x46>
 800d572:	687b      	ldr	r3, [r7, #4]
 800d574:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d576:	2380      	movs	r3, #128	; 0x80
 800d578:	029b      	lsls	r3, r3, #10
 800d57a:	429a      	cmp	r2, r3
 800d57c:	d005      	beq.n	800d58a <UART_AdvFeatureConfig+0x46>
 800d57e:	4aa0      	ldr	r2, [pc, #640]	; (800d800 <UART_AdvFeatureConfig+0x2bc>)
 800d580:	4b9e      	ldr	r3, [pc, #632]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d582:	0011      	movs	r1, r2
 800d584:	0018      	movs	r0, r3
 800d586:	f7f8 fe86 	bl	8006296 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800d58a:	687b      	ldr	r3, [r7, #4]
 800d58c:	681b      	ldr	r3, [r3, #0]
 800d58e:	685b      	ldr	r3, [r3, #4]
 800d590:	4a9c      	ldr	r2, [pc, #624]	; (800d804 <UART_AdvFeatureConfig+0x2c0>)
 800d592:	4013      	ands	r3, r2
 800d594:	0019      	movs	r1, r3
 800d596:	687b      	ldr	r3, [r7, #4]
 800d598:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d59a:	687b      	ldr	r3, [r7, #4]
 800d59c:	681b      	ldr	r3, [r3, #0]
 800d59e:	430a      	orrs	r2, r1
 800d5a0:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800d5a2:	687b      	ldr	r3, [r7, #4]
 800d5a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d5a6:	2202      	movs	r2, #2
 800d5a8:	4013      	ands	r3, r2
 800d5aa:	d01b      	beq.n	800d5e4 <UART_AdvFeatureConfig+0xa0>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
 800d5ac:	687b      	ldr	r3, [r7, #4]
 800d5ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d5b0:	2b00      	cmp	r3, #0
 800d5b2:	d00b      	beq.n	800d5cc <UART_AdvFeatureConfig+0x88>
 800d5b4:	687b      	ldr	r3, [r7, #4]
 800d5b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d5b8:	2380      	movs	r3, #128	; 0x80
 800d5ba:	025b      	lsls	r3, r3, #9
 800d5bc:	429a      	cmp	r2, r3
 800d5be:	d005      	beq.n	800d5cc <UART_AdvFeatureConfig+0x88>
 800d5c0:	4a91      	ldr	r2, [pc, #580]	; (800d808 <UART_AdvFeatureConfig+0x2c4>)
 800d5c2:	4b8e      	ldr	r3, [pc, #568]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d5c4:	0011      	movs	r1, r2
 800d5c6:	0018      	movs	r0, r3
 800d5c8:	f7f8 fe65 	bl	8006296 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800d5cc:	687b      	ldr	r3, [r7, #4]
 800d5ce:	681b      	ldr	r3, [r3, #0]
 800d5d0:	685b      	ldr	r3, [r3, #4]
 800d5d2:	4a8e      	ldr	r2, [pc, #568]	; (800d80c <UART_AdvFeatureConfig+0x2c8>)
 800d5d4:	4013      	ands	r3, r2
 800d5d6:	0019      	movs	r1, r3
 800d5d8:	687b      	ldr	r3, [r7, #4]
 800d5da:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d5dc:	687b      	ldr	r3, [r7, #4]
 800d5de:	681b      	ldr	r3, [r3, #0]
 800d5e0:	430a      	orrs	r2, r1
 800d5e2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800d5e4:	687b      	ldr	r3, [r7, #4]
 800d5e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d5e8:	2204      	movs	r2, #4
 800d5ea:	4013      	ands	r3, r2
 800d5ec:	d01b      	beq.n	800d626 <UART_AdvFeatureConfig+0xe2>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
 800d5ee:	687b      	ldr	r3, [r7, #4]
 800d5f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d5f2:	2b00      	cmp	r3, #0
 800d5f4:	d00b      	beq.n	800d60e <UART_AdvFeatureConfig+0xca>
 800d5f6:	687b      	ldr	r3, [r7, #4]
 800d5f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d5fa:	2380      	movs	r3, #128	; 0x80
 800d5fc:	02db      	lsls	r3, r3, #11
 800d5fe:	429a      	cmp	r2, r3
 800d600:	d005      	beq.n	800d60e <UART_AdvFeatureConfig+0xca>
 800d602:	4a83      	ldr	r2, [pc, #524]	; (800d810 <UART_AdvFeatureConfig+0x2cc>)
 800d604:	4b7d      	ldr	r3, [pc, #500]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d606:	0011      	movs	r1, r2
 800d608:	0018      	movs	r0, r3
 800d60a:	f7f8 fe44 	bl	8006296 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800d60e:	687b      	ldr	r3, [r7, #4]
 800d610:	681b      	ldr	r3, [r3, #0]
 800d612:	685b      	ldr	r3, [r3, #4]
 800d614:	4a7f      	ldr	r2, [pc, #508]	; (800d814 <UART_AdvFeatureConfig+0x2d0>)
 800d616:	4013      	ands	r3, r2
 800d618:	0019      	movs	r1, r3
 800d61a:	687b      	ldr	r3, [r7, #4]
 800d61c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d61e:	687b      	ldr	r3, [r7, #4]
 800d620:	681b      	ldr	r3, [r3, #0]
 800d622:	430a      	orrs	r2, r1
 800d624:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800d626:	687b      	ldr	r3, [r7, #4]
 800d628:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d62a:	2208      	movs	r2, #8
 800d62c:	4013      	ands	r3, r2
 800d62e:	d01b      	beq.n	800d668 <UART_AdvFeatureConfig+0x124>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
 800d630:	687b      	ldr	r3, [r7, #4]
 800d632:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d634:	2b00      	cmp	r3, #0
 800d636:	d00b      	beq.n	800d650 <UART_AdvFeatureConfig+0x10c>
 800d638:	687b      	ldr	r3, [r7, #4]
 800d63a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d63c:	2380      	movs	r3, #128	; 0x80
 800d63e:	021b      	lsls	r3, r3, #8
 800d640:	429a      	cmp	r2, r3
 800d642:	d005      	beq.n	800d650 <UART_AdvFeatureConfig+0x10c>
 800d644:	4a74      	ldr	r2, [pc, #464]	; (800d818 <UART_AdvFeatureConfig+0x2d4>)
 800d646:	4b6d      	ldr	r3, [pc, #436]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d648:	0011      	movs	r1, r2
 800d64a:	0018      	movs	r0, r3
 800d64c:	f7f8 fe23 	bl	8006296 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800d650:	687b      	ldr	r3, [r7, #4]
 800d652:	681b      	ldr	r3, [r3, #0]
 800d654:	685b      	ldr	r3, [r3, #4]
 800d656:	4a71      	ldr	r2, [pc, #452]	; (800d81c <UART_AdvFeatureConfig+0x2d8>)
 800d658:	4013      	ands	r3, r2
 800d65a:	0019      	movs	r1, r3
 800d65c:	687b      	ldr	r3, [r7, #4]
 800d65e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d660:	687b      	ldr	r3, [r7, #4]
 800d662:	681b      	ldr	r3, [r3, #0]
 800d664:	430a      	orrs	r2, r1
 800d666:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800d668:	687b      	ldr	r3, [r7, #4]
 800d66a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d66c:	2210      	movs	r2, #16
 800d66e:	4013      	ands	r3, r2
 800d670:	d01c      	beq.n	800d6ac <UART_AdvFeatureConfig+0x168>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
 800d672:	687b      	ldr	r3, [r7, #4]
 800d674:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d676:	2b00      	cmp	r3, #0
 800d678:	d00c      	beq.n	800d694 <UART_AdvFeatureConfig+0x150>
 800d67a:	687b      	ldr	r3, [r7, #4]
 800d67c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d67e:	2380      	movs	r3, #128	; 0x80
 800d680:	015b      	lsls	r3, r3, #5
 800d682:	429a      	cmp	r2, r3
 800d684:	d006      	beq.n	800d694 <UART_AdvFeatureConfig+0x150>
 800d686:	23cb      	movs	r3, #203	; 0xcb
 800d688:	011a      	lsls	r2, r3, #4
 800d68a:	4b5c      	ldr	r3, [pc, #368]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d68c:	0011      	movs	r1, r2
 800d68e:	0018      	movs	r0, r3
 800d690:	f7f8 fe01 	bl	8006296 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800d694:	687b      	ldr	r3, [r7, #4]
 800d696:	681b      	ldr	r3, [r3, #0]
 800d698:	689b      	ldr	r3, [r3, #8]
 800d69a:	4a61      	ldr	r2, [pc, #388]	; (800d820 <UART_AdvFeatureConfig+0x2dc>)
 800d69c:	4013      	ands	r3, r2
 800d69e:	0019      	movs	r1, r3
 800d6a0:	687b      	ldr	r3, [r7, #4]
 800d6a2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d6a4:	687b      	ldr	r3, [r7, #4]
 800d6a6:	681b      	ldr	r3, [r3, #0]
 800d6a8:	430a      	orrs	r2, r1
 800d6aa:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800d6ac:	687b      	ldr	r3, [r7, #4]
 800d6ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d6b0:	2220      	movs	r2, #32
 800d6b2:	4013      	ands	r3, r2
 800d6b4:	d01b      	beq.n	800d6ee <UART_AdvFeatureConfig+0x1aa>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
 800d6b6:	687b      	ldr	r3, [r7, #4]
 800d6b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d6ba:	2b00      	cmp	r3, #0
 800d6bc:	d00b      	beq.n	800d6d6 <UART_AdvFeatureConfig+0x192>
 800d6be:	687b      	ldr	r3, [r7, #4]
 800d6c0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800d6c2:	2380      	movs	r3, #128	; 0x80
 800d6c4:	019b      	lsls	r3, r3, #6
 800d6c6:	429a      	cmp	r2, r3
 800d6c8:	d005      	beq.n	800d6d6 <UART_AdvFeatureConfig+0x192>
 800d6ca:	4a56      	ldr	r2, [pc, #344]	; (800d824 <UART_AdvFeatureConfig+0x2e0>)
 800d6cc:	4b4b      	ldr	r3, [pc, #300]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d6ce:	0011      	movs	r1, r2
 800d6d0:	0018      	movs	r0, r3
 800d6d2:	f7f8 fde0 	bl	8006296 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800d6d6:	687b      	ldr	r3, [r7, #4]
 800d6d8:	681b      	ldr	r3, [r3, #0]
 800d6da:	689b      	ldr	r3, [r3, #8]
 800d6dc:	4a52      	ldr	r2, [pc, #328]	; (800d828 <UART_AdvFeatureConfig+0x2e4>)
 800d6de:	4013      	ands	r3, r2
 800d6e0:	0019      	movs	r1, r3
 800d6e2:	687b      	ldr	r3, [r7, #4]
 800d6e4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800d6e6:	687b      	ldr	r3, [r7, #4]
 800d6e8:	681b      	ldr	r3, [r3, #0]
 800d6ea:	430a      	orrs	r2, r1
 800d6ec:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800d6ee:	687b      	ldr	r3, [r7, #4]
 800d6f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d6f2:	2240      	movs	r2, #64	; 0x40
 800d6f4:	4013      	ands	r3, r2
 800d6f6:	d059      	beq.n	800d7ac <UART_AdvFeatureConfig+0x268>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
 800d6f8:	687b      	ldr	r3, [r7, #4]
 800d6fa:	681b      	ldr	r3, [r3, #0]
 800d6fc:	4a4b      	ldr	r2, [pc, #300]	; (800d82c <UART_AdvFeatureConfig+0x2e8>)
 800d6fe:	4293      	cmp	r3, r2
 800d700:	d00a      	beq.n	800d718 <UART_AdvFeatureConfig+0x1d4>
 800d702:	687b      	ldr	r3, [r7, #4]
 800d704:	681b      	ldr	r3, [r3, #0]
 800d706:	4a4a      	ldr	r2, [pc, #296]	; (800d830 <UART_AdvFeatureConfig+0x2ec>)
 800d708:	4293      	cmp	r3, r2
 800d70a:	d005      	beq.n	800d718 <UART_AdvFeatureConfig+0x1d4>
 800d70c:	4a49      	ldr	r2, [pc, #292]	; (800d834 <UART_AdvFeatureConfig+0x2f0>)
 800d70e:	4b3b      	ldr	r3, [pc, #236]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d710:	0011      	movs	r1, r2
 800d712:	0018      	movs	r0, r3
 800d714:	f7f8 fdbf 	bl	8006296 <assert_failed>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
 800d718:	687b      	ldr	r3, [r7, #4]
 800d71a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d71c:	2b00      	cmp	r3, #0
 800d71e:	d00b      	beq.n	800d738 <UART_AdvFeatureConfig+0x1f4>
 800d720:	687b      	ldr	r3, [r7, #4]
 800d722:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800d724:	2380      	movs	r3, #128	; 0x80
 800d726:	035b      	lsls	r3, r3, #13
 800d728:	429a      	cmp	r2, r3
 800d72a:	d005      	beq.n	800d738 <UART_AdvFeatureConfig+0x1f4>
 800d72c:	4a42      	ldr	r2, [pc, #264]	; (800d838 <UART_AdvFeatureConfig+0x2f4>)
 800d72e:	4b33      	ldr	r3, [pc, #204]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d730:	0011      	movs	r1, r2
 800d732:	0018      	movs	r0, r3
 800d734:	f7f8 fdaf 	bl	8006296 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800d738:	687b      	ldr	r3, [r7, #4]
 800d73a:	681b      	ldr	r3, [r3, #0]
 800d73c:	685b      	ldr	r3, [r3, #4]
 800d73e:	4a3f      	ldr	r2, [pc, #252]	; (800d83c <UART_AdvFeatureConfig+0x2f8>)
 800d740:	4013      	ands	r3, r2
 800d742:	0019      	movs	r1, r3
 800d744:	687b      	ldr	r3, [r7, #4]
 800d746:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800d748:	687b      	ldr	r3, [r7, #4]
 800d74a:	681b      	ldr	r3, [r3, #0]
 800d74c:	430a      	orrs	r2, r1
 800d74e:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800d750:	687b      	ldr	r3, [r7, #4]
 800d752:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800d754:	2380      	movs	r3, #128	; 0x80
 800d756:	035b      	lsls	r3, r3, #13
 800d758:	429a      	cmp	r2, r3
 800d75a:	d127      	bne.n	800d7ac <UART_AdvFeatureConfig+0x268>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
 800d75c:	687b      	ldr	r3, [r7, #4]
 800d75e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d760:	2b00      	cmp	r3, #0
 800d762:	d017      	beq.n	800d794 <UART_AdvFeatureConfig+0x250>
 800d764:	687b      	ldr	r3, [r7, #4]
 800d766:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800d768:	2380      	movs	r3, #128	; 0x80
 800d76a:	039b      	lsls	r3, r3, #14
 800d76c:	429a      	cmp	r2, r3
 800d76e:	d011      	beq.n	800d794 <UART_AdvFeatureConfig+0x250>
 800d770:	687b      	ldr	r3, [r7, #4]
 800d772:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800d774:	2380      	movs	r3, #128	; 0x80
 800d776:	03db      	lsls	r3, r3, #15
 800d778:	429a      	cmp	r2, r3
 800d77a:	d00b      	beq.n	800d794 <UART_AdvFeatureConfig+0x250>
 800d77c:	687b      	ldr	r3, [r7, #4]
 800d77e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800d780:	23c0      	movs	r3, #192	; 0xc0
 800d782:	03db      	lsls	r3, r3, #15
 800d784:	429a      	cmp	r2, r3
 800d786:	d005      	beq.n	800d794 <UART_AdvFeatureConfig+0x250>
 800d788:	4a2d      	ldr	r2, [pc, #180]	; (800d840 <UART_AdvFeatureConfig+0x2fc>)
 800d78a:	4b1c      	ldr	r3, [pc, #112]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d78c:	0011      	movs	r1, r2
 800d78e:	0018      	movs	r0, r3
 800d790:	f7f8 fd81 	bl	8006296 <assert_failed>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800d794:	687b      	ldr	r3, [r7, #4]
 800d796:	681b      	ldr	r3, [r3, #0]
 800d798:	685b      	ldr	r3, [r3, #4]
 800d79a:	4a2a      	ldr	r2, [pc, #168]	; (800d844 <UART_AdvFeatureConfig+0x300>)
 800d79c:	4013      	ands	r3, r2
 800d79e:	0019      	movs	r1, r3
 800d7a0:	687b      	ldr	r3, [r7, #4]
 800d7a2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800d7a4:	687b      	ldr	r3, [r7, #4]
 800d7a6:	681b      	ldr	r3, [r3, #0]
 800d7a8:	430a      	orrs	r2, r1
 800d7aa:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800d7ac:	687b      	ldr	r3, [r7, #4]
 800d7ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d7b0:	2280      	movs	r2, #128	; 0x80
 800d7b2:	4013      	ands	r3, r2
 800d7b4:	d01b      	beq.n	800d7ee <UART_AdvFeatureConfig+0x2aa>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
 800d7b6:	687b      	ldr	r3, [r7, #4]
 800d7b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d7ba:	2b00      	cmp	r3, #0
 800d7bc:	d00b      	beq.n	800d7d6 <UART_AdvFeatureConfig+0x292>
 800d7be:	687b      	ldr	r3, [r7, #4]
 800d7c0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800d7c2:	2380      	movs	r3, #128	; 0x80
 800d7c4:	031b      	lsls	r3, r3, #12
 800d7c6:	429a      	cmp	r2, r3
 800d7c8:	d005      	beq.n	800d7d6 <UART_AdvFeatureConfig+0x292>
 800d7ca:	4a1f      	ldr	r2, [pc, #124]	; (800d848 <UART_AdvFeatureConfig+0x304>)
 800d7cc:	4b0b      	ldr	r3, [pc, #44]	; (800d7fc <UART_AdvFeatureConfig+0x2b8>)
 800d7ce:	0011      	movs	r1, r2
 800d7d0:	0018      	movs	r0, r3
 800d7d2:	f7f8 fd60 	bl	8006296 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800d7d6:	687b      	ldr	r3, [r7, #4]
 800d7d8:	681b      	ldr	r3, [r3, #0]
 800d7da:	685b      	ldr	r3, [r3, #4]
 800d7dc:	4a1b      	ldr	r2, [pc, #108]	; (800d84c <UART_AdvFeatureConfig+0x308>)
 800d7de:	4013      	ands	r3, r2
 800d7e0:	0019      	movs	r1, r3
 800d7e2:	687b      	ldr	r3, [r7, #4]
 800d7e4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800d7e6:	687b      	ldr	r3, [r7, #4]
 800d7e8:	681b      	ldr	r3, [r3, #0]
 800d7ea:	430a      	orrs	r2, r1
 800d7ec:	605a      	str	r2, [r3, #4]
  }
}
 800d7ee:	46c0      	nop			; (mov r8, r8)
 800d7f0:	46bd      	mov	sp, r7
 800d7f2:	b002      	add	sp, #8
 800d7f4:	bd80      	pop	{r7, pc}
 800d7f6:	46c0      	nop			; (mov r8, r8)
 800d7f8:	00000c8f 	.word	0x00000c8f
 800d7fc:	0800df80 	.word	0x0800df80
 800d800:	00000c94 	.word	0x00000c94
 800d804:	fffdffff 	.word	0xfffdffff
 800d808:	00000c9b 	.word	0x00000c9b
 800d80c:	fffeffff 	.word	0xfffeffff
 800d810:	00000ca2 	.word	0x00000ca2
 800d814:	fffbffff 	.word	0xfffbffff
 800d818:	00000ca9 	.word	0x00000ca9
 800d81c:	ffff7fff 	.word	0xffff7fff
 800d820:	ffffefff 	.word	0xffffefff
 800d824:	00000cb7 	.word	0x00000cb7
 800d828:	ffffdfff 	.word	0xffffdfff
 800d82c:	40013800 	.word	0x40013800
 800d830:	40004400 	.word	0x40004400
 800d834:	00000cbe 	.word	0x00000cbe
 800d838:	00000cbf 	.word	0x00000cbf
 800d83c:	ffefffff 	.word	0xffefffff
 800d840:	00000cc4 	.word	0x00000cc4
 800d844:	ff9fffff 	.word	0xff9fffff
 800d848:	00000ccc 	.word	0x00000ccc
 800d84c:	fff7ffff 	.word	0xfff7ffff

0800d850 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800d850:	b580      	push	{r7, lr}
 800d852:	b086      	sub	sp, #24
 800d854:	af02      	add	r7, sp, #8
 800d856:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d858:	687b      	ldr	r3, [r7, #4]
 800d85a:	2280      	movs	r2, #128	; 0x80
 800d85c:	2100      	movs	r1, #0
 800d85e:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 800d860:	f7f9 fe40 	bl	80074e4 <HAL_GetTick>
 800d864:	0003      	movs	r3, r0
 800d866:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800d868:	687b      	ldr	r3, [r7, #4]
 800d86a:	681b      	ldr	r3, [r3, #0]
 800d86c:	681b      	ldr	r3, [r3, #0]
 800d86e:	2208      	movs	r2, #8
 800d870:	4013      	ands	r3, r2
 800d872:	2b08      	cmp	r3, #8
 800d874:	d10c      	bne.n	800d890 <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d876:	68fb      	ldr	r3, [r7, #12]
 800d878:	2280      	movs	r2, #128	; 0x80
 800d87a:	0391      	lsls	r1, r2, #14
 800d87c:	6878      	ldr	r0, [r7, #4]
 800d87e:	4a17      	ldr	r2, [pc, #92]	; (800d8dc <UART_CheckIdleState+0x8c>)
 800d880:	9200      	str	r2, [sp, #0]
 800d882:	2200      	movs	r2, #0
 800d884:	f000 f82c 	bl	800d8e0 <UART_WaitOnFlagUntilTimeout>
 800d888:	1e03      	subs	r3, r0, #0
 800d88a:	d001      	beq.n	800d890 <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800d88c:	2303      	movs	r3, #3
 800d88e:	e021      	b.n	800d8d4 <UART_CheckIdleState+0x84>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800d890:	687b      	ldr	r3, [r7, #4]
 800d892:	681b      	ldr	r3, [r3, #0]
 800d894:	681b      	ldr	r3, [r3, #0]
 800d896:	2204      	movs	r2, #4
 800d898:	4013      	ands	r3, r2
 800d89a:	2b04      	cmp	r3, #4
 800d89c:	d10c      	bne.n	800d8b8 <UART_CheckIdleState+0x68>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d89e:	68fb      	ldr	r3, [r7, #12]
 800d8a0:	2280      	movs	r2, #128	; 0x80
 800d8a2:	03d1      	lsls	r1, r2, #15
 800d8a4:	6878      	ldr	r0, [r7, #4]
 800d8a6:	4a0d      	ldr	r2, [pc, #52]	; (800d8dc <UART_CheckIdleState+0x8c>)
 800d8a8:	9200      	str	r2, [sp, #0]
 800d8aa:	2200      	movs	r2, #0
 800d8ac:	f000 f818 	bl	800d8e0 <UART_WaitOnFlagUntilTimeout>
 800d8b0:	1e03      	subs	r3, r0, #0
 800d8b2:	d001      	beq.n	800d8b8 <UART_CheckIdleState+0x68>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800d8b4:	2303      	movs	r3, #3
 800d8b6:	e00d      	b.n	800d8d4 <UART_CheckIdleState+0x84>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800d8b8:	687b      	ldr	r3, [r7, #4]
 800d8ba:	2220      	movs	r2, #32
 800d8bc:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 800d8be:	687b      	ldr	r3, [r7, #4]
 800d8c0:	2220      	movs	r2, #32
 800d8c2:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d8c4:	687b      	ldr	r3, [r7, #4]
 800d8c6:	2200      	movs	r2, #0
 800d8c8:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 800d8ca:	687b      	ldr	r3, [r7, #4]
 800d8cc:	2274      	movs	r2, #116	; 0x74
 800d8ce:	2100      	movs	r1, #0
 800d8d0:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800d8d2:	2300      	movs	r3, #0
}
 800d8d4:	0018      	movs	r0, r3
 800d8d6:	46bd      	mov	sp, r7
 800d8d8:	b004      	add	sp, #16
 800d8da:	bd80      	pop	{r7, pc}
 800d8dc:	01ffffff 	.word	0x01ffffff

0800d8e0 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800d8e0:	b580      	push	{r7, lr}
 800d8e2:	b084      	sub	sp, #16
 800d8e4:	af00      	add	r7, sp, #0
 800d8e6:	60f8      	str	r0, [r7, #12]
 800d8e8:	60b9      	str	r1, [r7, #8]
 800d8ea:	603b      	str	r3, [r7, #0]
 800d8ec:	1dfb      	adds	r3, r7, #7
 800d8ee:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800d8f0:	e05e      	b.n	800d9b0 <UART_WaitOnFlagUntilTimeout+0xd0>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800d8f2:	69bb      	ldr	r3, [r7, #24]
 800d8f4:	3301      	adds	r3, #1
 800d8f6:	d05b      	beq.n	800d9b0 <UART_WaitOnFlagUntilTimeout+0xd0>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800d8f8:	f7f9 fdf4 	bl	80074e4 <HAL_GetTick>
 800d8fc:	0002      	movs	r2, r0
 800d8fe:	683b      	ldr	r3, [r7, #0]
 800d900:	1ad3      	subs	r3, r2, r3
 800d902:	69ba      	ldr	r2, [r7, #24]
 800d904:	429a      	cmp	r2, r3
 800d906:	d302      	bcc.n	800d90e <UART_WaitOnFlagUntilTimeout+0x2e>
 800d908:	69bb      	ldr	r3, [r7, #24]
 800d90a:	2b00      	cmp	r3, #0
 800d90c:	d11b      	bne.n	800d946 <UART_WaitOnFlagUntilTimeout+0x66>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800d90e:	68fb      	ldr	r3, [r7, #12]
 800d910:	681b      	ldr	r3, [r3, #0]
 800d912:	681a      	ldr	r2, [r3, #0]
 800d914:	68fb      	ldr	r3, [r7, #12]
 800d916:	681b      	ldr	r3, [r3, #0]
 800d918:	492f      	ldr	r1, [pc, #188]	; (800d9d8 <UART_WaitOnFlagUntilTimeout+0xf8>)
 800d91a:	400a      	ands	r2, r1
 800d91c:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d91e:	68fb      	ldr	r3, [r7, #12]
 800d920:	681b      	ldr	r3, [r3, #0]
 800d922:	689a      	ldr	r2, [r3, #8]
 800d924:	68fb      	ldr	r3, [r7, #12]
 800d926:	681b      	ldr	r3, [r3, #0]
 800d928:	2101      	movs	r1, #1
 800d92a:	438a      	bics	r2, r1
 800d92c:	609a      	str	r2, [r3, #8]

        huart->gState = HAL_UART_STATE_READY;
 800d92e:	68fb      	ldr	r3, [r7, #12]
 800d930:	2220      	movs	r2, #32
 800d932:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 800d934:	68fb      	ldr	r3, [r7, #12]
 800d936:	2220      	movs	r2, #32
 800d938:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 800d93a:	68fb      	ldr	r3, [r7, #12]
 800d93c:	2274      	movs	r2, #116	; 0x74
 800d93e:	2100      	movs	r1, #0
 800d940:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800d942:	2303      	movs	r3, #3
 800d944:	e044      	b.n	800d9d0 <UART_WaitOnFlagUntilTimeout+0xf0>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800d946:	68fb      	ldr	r3, [r7, #12]
 800d948:	681b      	ldr	r3, [r3, #0]
 800d94a:	681b      	ldr	r3, [r3, #0]
 800d94c:	2204      	movs	r2, #4
 800d94e:	4013      	ands	r3, r2
 800d950:	d02e      	beq.n	800d9b0 <UART_WaitOnFlagUntilTimeout+0xd0>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800d952:	68fb      	ldr	r3, [r7, #12]
 800d954:	681b      	ldr	r3, [r3, #0]
 800d956:	69da      	ldr	r2, [r3, #28]
 800d958:	2380      	movs	r3, #128	; 0x80
 800d95a:	011b      	lsls	r3, r3, #4
 800d95c:	401a      	ands	r2, r3
 800d95e:	2380      	movs	r3, #128	; 0x80
 800d960:	011b      	lsls	r3, r3, #4
 800d962:	429a      	cmp	r2, r3
 800d964:	d124      	bne.n	800d9b0 <UART_WaitOnFlagUntilTimeout+0xd0>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800d966:	68fb      	ldr	r3, [r7, #12]
 800d968:	681b      	ldr	r3, [r3, #0]
 800d96a:	2280      	movs	r2, #128	; 0x80
 800d96c:	0112      	lsls	r2, r2, #4
 800d96e:	621a      	str	r2, [r3, #32]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800d970:	68fb      	ldr	r3, [r7, #12]
 800d972:	681b      	ldr	r3, [r3, #0]
 800d974:	681a      	ldr	r2, [r3, #0]
 800d976:	68fb      	ldr	r3, [r7, #12]
 800d978:	681b      	ldr	r3, [r3, #0]
 800d97a:	4917      	ldr	r1, [pc, #92]	; (800d9d8 <UART_WaitOnFlagUntilTimeout+0xf8>)
 800d97c:	400a      	ands	r2, r1
 800d97e:	601a      	str	r2, [r3, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d980:	68fb      	ldr	r3, [r7, #12]
 800d982:	681b      	ldr	r3, [r3, #0]
 800d984:	689a      	ldr	r2, [r3, #8]
 800d986:	68fb      	ldr	r3, [r7, #12]
 800d988:	681b      	ldr	r3, [r3, #0]
 800d98a:	2101      	movs	r1, #1
 800d98c:	438a      	bics	r2, r1
 800d98e:	609a      	str	r2, [r3, #8]

          huart->gState = HAL_UART_STATE_READY;
 800d990:	68fb      	ldr	r3, [r7, #12]
 800d992:	2220      	movs	r2, #32
 800d994:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 800d996:	68fb      	ldr	r3, [r7, #12]
 800d998:	2220      	movs	r2, #32
 800d99a:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800d99c:	68fb      	ldr	r3, [r7, #12]
 800d99e:	2280      	movs	r2, #128	; 0x80
 800d9a0:	2120      	movs	r1, #32
 800d9a2:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800d9a4:	68fb      	ldr	r3, [r7, #12]
 800d9a6:	2274      	movs	r2, #116	; 0x74
 800d9a8:	2100      	movs	r1, #0
 800d9aa:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
 800d9ac:	2303      	movs	r3, #3
 800d9ae:	e00f      	b.n	800d9d0 <UART_WaitOnFlagUntilTimeout+0xf0>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800d9b0:	68fb      	ldr	r3, [r7, #12]
 800d9b2:	681b      	ldr	r3, [r3, #0]
 800d9b4:	69db      	ldr	r3, [r3, #28]
 800d9b6:	68ba      	ldr	r2, [r7, #8]
 800d9b8:	4013      	ands	r3, r2
 800d9ba:	68ba      	ldr	r2, [r7, #8]
 800d9bc:	1ad3      	subs	r3, r2, r3
 800d9be:	425a      	negs	r2, r3
 800d9c0:	4153      	adcs	r3, r2
 800d9c2:	b2db      	uxtb	r3, r3
 800d9c4:	001a      	movs	r2, r3
 800d9c6:	1dfb      	adds	r3, r7, #7
 800d9c8:	781b      	ldrb	r3, [r3, #0]
 800d9ca:	429a      	cmp	r2, r3
 800d9cc:	d091      	beq.n	800d8f2 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 800d9ce:	2300      	movs	r3, #0
}
 800d9d0:	0018      	movs	r0, r3
 800d9d2:	46bd      	mov	sp, r7
 800d9d4:	b004      	add	sp, #16
 800d9d6:	bd80      	pop	{r7, pc}
 800d9d8:	fffffe5f 	.word	0xfffffe5f

0800d9dc <__libc_init_array>:
 800d9dc:	b570      	push	{r4, r5, r6, lr}
 800d9de:	2600      	movs	r6, #0
 800d9e0:	4d0c      	ldr	r5, [pc, #48]	; (800da14 <__libc_init_array+0x38>)
 800d9e2:	4c0d      	ldr	r4, [pc, #52]	; (800da18 <__libc_init_array+0x3c>)
 800d9e4:	1b64      	subs	r4, r4, r5
 800d9e6:	10a4      	asrs	r4, r4, #2
 800d9e8:	42a6      	cmp	r6, r4
 800d9ea:	d109      	bne.n	800da00 <__libc_init_array+0x24>
 800d9ec:	2600      	movs	r6, #0
 800d9ee:	f000 f82b 	bl	800da48 <_init>
 800d9f2:	4d0a      	ldr	r5, [pc, #40]	; (800da1c <__libc_init_array+0x40>)
 800d9f4:	4c0a      	ldr	r4, [pc, #40]	; (800da20 <__libc_init_array+0x44>)
 800d9f6:	1b64      	subs	r4, r4, r5
 800d9f8:	10a4      	asrs	r4, r4, #2
 800d9fa:	42a6      	cmp	r6, r4
 800d9fc:	d105      	bne.n	800da0a <__libc_init_array+0x2e>
 800d9fe:	bd70      	pop	{r4, r5, r6, pc}
 800da00:	00b3      	lsls	r3, r6, #2
 800da02:	58eb      	ldr	r3, [r5, r3]
 800da04:	4798      	blx	r3
 800da06:	3601      	adds	r6, #1
 800da08:	e7ee      	b.n	800d9e8 <__libc_init_array+0xc>
 800da0a:	00b3      	lsls	r3, r6, #2
 800da0c:	58eb      	ldr	r3, [r5, r3]
 800da0e:	4798      	blx	r3
 800da10:	3601      	adds	r6, #1
 800da12:	e7f2      	b.n	800d9fa <__libc_init_array+0x1e>
 800da14:	0800f2a8 	.word	0x0800f2a8
 800da18:	0800f2a8 	.word	0x0800f2a8
 800da1c:	0800f2a8 	.word	0x0800f2a8
 800da20:	0800f2ac 	.word	0x0800f2ac

0800da24 <memcpy>:
 800da24:	2300      	movs	r3, #0
 800da26:	b510      	push	{r4, lr}
 800da28:	429a      	cmp	r2, r3
 800da2a:	d100      	bne.n	800da2e <memcpy+0xa>
 800da2c:	bd10      	pop	{r4, pc}
 800da2e:	5ccc      	ldrb	r4, [r1, r3]
 800da30:	54c4      	strb	r4, [r0, r3]
 800da32:	3301      	adds	r3, #1
 800da34:	e7f8      	b.n	800da28 <memcpy+0x4>

0800da36 <memset>:
 800da36:	0003      	movs	r3, r0
 800da38:	1882      	adds	r2, r0, r2
 800da3a:	4293      	cmp	r3, r2
 800da3c:	d100      	bne.n	800da40 <memset+0xa>
 800da3e:	4770      	bx	lr
 800da40:	7019      	strb	r1, [r3, #0]
 800da42:	3301      	adds	r3, #1
 800da44:	e7f9      	b.n	800da3a <memset+0x4>
	...

0800da48 <_init>:
 800da48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800da4a:	46c0      	nop			; (mov r8, r8)
 800da4c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800da4e:	bc08      	pop	{r3}
 800da50:	469e      	mov	lr, r3
 800da52:	4770      	bx	lr

0800da54 <_fini>:
 800da54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800da56:	46c0      	nop			; (mov r8, r8)
 800da58:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800da5a:	bc08      	pop	{r3}
 800da5c:	469e      	mov	lr, r3
 800da5e:	4770      	bx	lr
